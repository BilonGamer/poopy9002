/*
    if you got access to this module, wow congrats on hacking me!!!!!
    some cmd code is outdated, don't blame me if it uses 213789 lines
    relating to that, im also planning to move some code into modules
    bot needs a ton of env vars to work, but luckily they're optional
    you really just need the discord bot token aaaaaaaaaand that's it
    but if you're brave enough, you can hunt for every one of these:

    - BOTWEBSITE (url if you want a website for your bot)
    - CLOUDAMQP_URL (url used to send file processing and data queues, accessed at https://api.cloudamqp.com/console/<app-id>/details)
    - MONGOOSEURL (url used to access the database, generated at https://cloud.mongodb.com/v2/<project-id>#clusters/connect)

    - AI21KEY (key generated when you sign up in ai21 for generating text, accessed at https://studio.ai21.com/account/account)
    - DEEPAIKEY (key generated when you sign up in deepai, accessed at https://deepai.org/dashboard/profile)
    - GOOGLEKEY (key from google cloud for accessing the youtube api, generated at https://console.cloud.google.com/apis/credentials?project=<project-name>)
    - MAKESWEETKEY (key from makesweet for generating heartlocket gifs, dm @mkswt on twitter asking for one)
    - GAMERKEY (key used for a cleverbot alternative when it breaks, generated at https://api-info.pgamerx.com/manage-key)
    - RAPIDAPIKEY (key from rapid api when you sign up, accessed at https://rapidapi.com/developer/security/<app-name>)
      you'll also need to subscribe to all of these apis:
      - https://rapidapi.com/microsoft-azure-org-microsoft-cognitive-services/api/microsoft-computer-vision3/ (ocr api)
      - https://rapidapi.com/microsoft-azure-org-microsoft-cognitive-services/api/microsoft-translator-text/ (translation api)
      - https://rapidapi.com/microsoft-azure-org-microsoft-cognitive-services/api/bing-web-search1/ (bing search api)
      - https://rapidapi.com/hivoicy-vxmKOG2vl/api/speech-recognition-english1/ (speech to text api)
      - https://rapidapi.com/pgamerxdev/api/random-stuff-api/ (has an ai response api)
    - REMOVEBGKEY (key from remove.bg, generated at https://www.remove.bg/dashboard#api-key)
    - TENORKEY (key generated by tenor when signing up, accessed at https://tenor.com/developer/dashboard)
    - UBERDUCKKEY, UBERDUCKSECRET (credentials from uberduck ai, generated at https://app.uberduck.ai/account/manage)
*/

class Poopy {
    constructor(config = {}) {
        // setting up options

        let poopy = this

        poopy.config = {
            testing: false,
            poosonia: false,
            forcetrue: false,
            useReactions: false,
            textEmbeds: false,
            notSave: false,
            apiMode: false,
            self: false,
            noInfoPost: false,
            poosoniablacklist: ['dm', 'tdms', 'spam', 'eval', 'leave'],
            poosoniakeywordblacklist: [],
            poosoniafunctionblacklist: ['messagecollector', 'stopcollector', 'stopallcollectors'],
            allowtesting: true,
            allowbotusage: false,
            mongodatabase: 'poopydata',
            globalPrefix: 'p:',
            stfu: false,
            intents: 65209,
            ownerids: ['464438783866175489', '454732245425455105', '613501149282172970'],
            jsoning: ['411624455194804224', '395947826690916362', '486845950200119307', '340847078236225537'],
            illKillYouIfYouUseEval: ['535467581881188354'],
            guildfilter: {
                blacklist: true,
                ids: []
            },
            channelfilter: {
                blacklist: true,
                gids: [],
                ids: []
            },
            msgcooldown: 0,
            limits: {
                size: {
                    image: 20,
                    gif: 20,
                    video: 20,
                    audio: 20,
                    message: `that file exceeds the size limit of {param} mb hahahaha (try to use the shrink, setfps, trim or crunch commands)`
                },
                frames: {
                    gif: 1000,
                    video: 10000,
                    message: `the frames in that file exceed the limit of {param} hahahaha (try to use the setfps or the trim commands)`
                },
                width: {
                    image: 3000,
                    gif: 1000,
                    video: 2000,
                    message: `the width of that file exceeds the limit of {param} hahahaha (try to use the shrink command)`
                },
                height: {
                    image: 3000,
                    gif: 1000,
                    video: 2000,
                    message: `the height of that file exceeds the limit of {param} hahahaha (try to use the shrink command)`
                }
            },
            limitsexcept: {
                size: {
                    image: 100,
                    gif: 100,
                    video: 100,
                    audio: 100,
                    message: `that file exceeds the exception size limit of {param} mb hahahaha there's nothing you can do`
                },
                frames: {
                    gif: 5000,
                    video: 50000,
                    message: `the frames in that file exceed the exception limit of {param} hahahaha there's nothing you can do`
                },
                width: {
                    image: 10000,
                    gif: 2000,
                    video: 5000,
                    message: `the width of that file exceeds the exception limit of {param} hahahaha there's nothing you can do`
                },
                height: {
                    image: 10000,
                    gif: 2000,
                    video: 5000,
                    message: `the height of that file exceeds the exception limit of {param} hahahaha there's nothing you can do`
                }
            },
            commandLimit: 5 / 2,
            keyLimit: 500 / 2,
            rateLimit: 3,
            rateLimitTime: 60000 * 2,
            memLimit: 0,
            quitOnDestroy: false
        }

        for (var i in config) {
            poopy.config[i] = config[i]
        }

        // setting objects
        poopy.modules = {}
        poopy.functions = {}
        poopy.callbacks = {}
        poopy.vars = {}
        poopy.data = {}
        poopy.tempdata = {}
        poopy.tempfiles = {}

        poopy.dataValues = require('./modules/dataValues')
        poopy.dataGetters = require('./modules/dataGetters')

        // module trash
        poopy.modules.Discord = require(`discord.js${poopy.config.self ? '-selfbot-v13' : ''}`)

        for (var key in poopy.dataValues.modules) {
            var val = poopy.dataValues.modules[key]
            poopy.modules[key] = val
        }

        // functions and variables now
        for (var key in poopy.dataValues.functions) {
            var val = poopy.dataValues.functions[key]
            poopy.functions[key] = val
        }

        for (var key in poopy.dataValues.vars) {
            var val = poopy.dataValues.vars[key]
            poopy.vars[key] = val
        }

        // bote
        poopy.bot = new poopy.modules.Discord.Client({
            intents: new poopy.modules.Discord.Intents(poopy.config.intents),
            partials: ['CHANNEL'],
            failIfNotExists: false
        })
        poopy.rest = new poopy.modules.REST({
            version: '10'
        })
        poopy.package = JSON.parse(poopy.modules.fs.readFileSync('package.json'))

        poopy.vars.msgcooldown = false
        poopy.vars.statusChanges = true
        poopy.vars.filecount = 0
        poopy.vars.cps = 0

        // modifying discord.js stuff haha
        class FakeCollector {
            constructor() {
                this.on = () => { }
                this.once = () => { }
                this.resetTimer = () => { }
                this.stop = () => { }
            }
        }

        var channelSend = poopy.modules.Discord.BaseGuildTextChannel.prototype.send
        poopy.modules.Discord.BaseGuildTextChannel.prototype.send = async function (payload) {
            var channel = this

            await poopy.functions.waitMessageCooldown()
            if (poopy.tempdata[channel.guild?.id]?.[channel.id]?.['shut']) return

            return await channelSend.call(channel, payload).then(poopy.functions.setMessageCooldown)
        }

        var messageReply = poopy.modules.Discord.Message.prototype.reply
        poopy.modules.Discord.Message.prototype.reply = async function (payload) {
            var message = this

            await poopy.functions.waitMessageCooldown()
            if (poopy.tempdata[message.guild?.id]?.[message.channel?.id]?.['shut']) return

            if (poopy.config.allowbotusage) return await message.channel.send(payload).then(poopy.functions.setMessageCooldown)
            else return await messageReply.call(message, payload).then(poopy.functions.setMessageCooldown).catch(() => { }) ??
                await message.channel.send(payload).then(poopy.functions.setMessageCooldown)
        }

        if (poopy.config.public) {
            poopy.functions.guildLeave = poopy.modules.Discord.Guild.prototype.leave
            delete poopy.modules.Discord.Guild.prototype.leave
        }

        // objects and arrays for things like the arab dictionary
        poopy.statuses = poopy.dataValues.statuses
        poopy.json = poopy.dataValues.json
        poopy.arrays = poopy.dataValues.arrays

        // more functions!!1!!!!
        poopy.functions.execPromise = function (code) {
            return new Promise(async (resolve) => {
                var args = code.match(/("[^"\\]*(?:\\[\S\s][^"\\]*)*"|'[^'\\]*(?:\\[\S\s][^'\\]*)*'|\/[^\/\\]*(?:\\[\S\s][^\/\\]*)*\/[gimy]*(?=\s|$)|(?:\\\s|\S)+)/g)
                var command = args.splice(0, 1)[0]

                async function execTask() {
                    var execData = {
                        type: 'exec',
                        code: code,
                        files: poopy.vars.processingTools.inputs[command](code.split(' ').slice(1))
                    }

                    /*var taskLength = JSON.stringify(execData)
                    if (taskLength > 15 * 1024 * 1024) {
                        return
                    }*/

                    var result = await poopy.functions.processTask(execData).catch(() => { })

                    if (!result) {
                        return 'No output.'
                    }

                    if (result.files) {
                        var name = poopy.vars.processingTools.outputs[command](args)
                        var dirsplit = name.split('/')
                        var dir = dirsplit.slice(0, dirsplit.length - 1).join('/')

                        for (var filename in result.files) {
                            poopy.modules.fs.writeFileSync(`${dir}/${filename}`, Buffer.from(result.files[filename], 'base64'))
                        }
                    }

                    return result.std
                }

                if (poopy.vars.processingTools.inputs[command] && !poopy.config.testing && process.env.CLOUDAMQP_URL && process.env.BOTWEBSITE) {
                    var taskValue = await execTask().catch(() => { })
                    if (taskValue) {
                        resolve(taskValue)
                        return
                    }
                }

                var stdout = []
                var stderr = []
                var stdoutclosed = false
                var stderrclosed = false
                var procExited = false

                var proc = poopy.modules.spawn(command, args, {
                    shell: true,
                    env: {
                        ...process.env
                    }
                })

                var memoryInterval = setInterval(() => {
                    var usage = process.memoryUsage()
                    var rss = usage.rss
                    if ((rss / 1024 / 1024) <= poopy.config.memLimit) {
                        if (poopy.modules.os.platform() == 'win32') poopy.modules.exec(`taskkill /pid ${proc.pid} /f /t`)
                        else poopy.modules.exec(`kill -9 ${proc.pid}`) //proc.kill('SIGKILL')
                    }
                }, 1000)

                function handleExit() {
                    if (!stdoutclosed || !stderrclosed || !procExited) return
                    var out = stdout.join('\n') || stderr.join('\n')
                    clearInterval(memoryInterval)
                    proc.removeAllListeners()
                    resolve(out)
                }

                proc.stdout.on('data', (buffer) => {
                    if (!buffer.toString()) return
                    stdout.push(buffer.toString())
                })

                proc.stderr.on('data', (buffer) => {
                    if (!buffer.toString()) return
                    stderr.push(buffer.toString())
                })

                proc.stdout.on('close', () => {
                    stdoutclosed = true
                    handleExit()
                })

                proc.stderr.on('close', () => {
                    stderrclosed = true
                    handleExit()
                })

                proc.on('error', (err) => {
                    clearInterval(memoryInterval)
                    proc.removeAllListeners()
                    resolve(err.message)
                })

                proc.on('exit', () => {
                    procExited = true
                    handleExit()
                })
            })
        }

        poopy.functions.gatherData = async function (msg) {
            var webhook = await msg.fetchWebhook().catch(() => { })

            if (!webhook) {
                if (!poopy.data['user-data'][msg.author.id]) {
                    poopy.data['user-data'][msg.author.id] = {}
                }

                poopy.data['user-data'][msg.author.id]['username'] = msg.author.username

                if (poopy.data['user-data'][msg.author.id]['health'] === undefined) {
                    poopy.data['user-data'][msg.author.id]['health'] = 100
                }
            }

            if (!poopy.data['guild-data'][msg.guild.id]) {
                poopy.data['guild-data'][msg.guild.id] = {}
            }

            if (poopy.data['guild-data'][msg.guild.id]['read'] === undefined) {
                poopy.data['guild-data'][msg.guild.id]['read'] = false
            }

            if (!poopy.data['guild-data'][msg.guild.id]['gettingData']) {
                poopy.data['guild-data'][msg.guild.id]['gettingData'] = 0
            }

            if (poopy.data['guild-data'][msg.guild.id]['chaincommands'] == undefined) {
                poopy.data['guild-data'][msg.guild.id]['chaincommands'] = true
            }

            if (!poopy.data['guild-data'][msg.guild.id]['lastuse']) {
                poopy.data['guild-data'][msg.guild.id]['lastuse'] = Date.now()
            }

            if (poopy.data['guild-data'][msg.guild.id]['prefix'] === undefined) {
                poopy.data['guild-data'][msg.guild.id]['prefix'] = poopy.config.globalPrefix
            }

            if (!poopy.data['guild-data'][msg.guild.id]['channels']) {
                poopy.data['guild-data'][msg.guild.id]['channels'] = {}
            }

            if (!poopy.data['guild-data'][msg.guild.id]['channels'][msg.channel.id]) {
                poopy.data['guild-data'][msg.guild.id]['channels'][msg.channel.id] = {}
            }

            if (!poopy.data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrls']) {
                poopy.data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrls'] = []
            }

            if (poopy.data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['read'] === undefined) {
                poopy.data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['read'] = false
            }

            if (poopy.data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['nsfw'] === undefined) {
                poopy.data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['nsfw'] = msg.channel.nsfw
            }

            if (!webhook) {
                if (!poopy.data['guild-data'][msg.guild.id]['members']) {
                    poopy.data['guild-data'][msg.guild.id]['members'] = {}
                }

                if (!poopy.data['guild-data'][msg.guild.id]['members'][msg.author.id]) {
                    poopy.data['guild-data'][msg.guild.id]['members'][msg.author.id] = {}
                }

                if (!poopy.data['guild-data'][msg.guild.id]['members'][msg.author.id]['messages']) {
                    poopy.data['guild-data'][msg.guild.id]['members'][msg.author.id]['messages'] = 0
                }

                if (!poopy.data['guild-data'][msg.guild.id]['members'][msg.author.id]['coolDown']) {
                    poopy.data['guild-data'][msg.guild.id]['members'][msg.author.id]['coolDown'] = false
                }

                poopy.data['guild-data'][msg.guild.id]['members'][msg.author.id]['messages']++

                poopy.data['guild-data'][msg.guild.id]['members'][msg.author.id]['username'] = msg.author.username
            }

            if (!poopy.data['guild-data'][msg.guild.id]['disabled']) {
                poopy.data['guild-data'][msg.guild.id]['disabled'] = []
            }

            if (!poopy.data['guild-data'][msg.guild.id]['localcmds']) {
                poopy.data['guild-data'][msg.guild.id]['localcmds'] = []
            }

            if (!poopy.data['guild-data'][msg.guild.id]['messages']) {
                poopy.data['guild-data'][msg.guild.id]['messages'] = []
            }

            if (typeof poopy.data['guild-data'][msg.guild.id]['messages'][0] == 'string') {
                poopy.data['guild-data'][msg.guild.id]['messages'] = poopy.data['guild-data'][msg.guild.id]['messages'].map(m => {
                    return {
                        author: poopy.bot.user.id,
                        content: m
                    }
                })
            }

            if (!poopy.tempdata[msg.guild.id]) {
                poopy.tempdata[msg.guild.id] = {}
            }

            if (!poopy.tempdata[msg.guild.id][msg.channel.id]) {
                poopy.tempdata[msg.guild.id][msg.channel.id] = {}
            }

            if (!webhook) {
                if (!poopy.tempdata[msg.guild.id][msg.channel.id][msg.author.id]) {
                    poopy.tempdata[msg.guild.id][msg.channel.id][msg.author.id] = {}
                }

                if (!poopy.tempdata[msg.guild.id][msg.author.id]) {
                    poopy.tempdata[msg.guild.id][msg.author.id] = {}
                }

                if (!poopy.tempdata[msg.guild.id][msg.author.id]['promises']) {
                    poopy.tempdata[msg.guild.id][msg.author.id]['promises'] = []
                }

                if (!poopy.tempdata[msg.author.id]) {
                    poopy.tempdata[msg.author.id] = {}
                }

                if (!poopy.tempdata[msg.author.id][msg.id]) {
                    poopy.tempdata[msg.author.id][msg.id] = {}
                }

                if (!poopy.tempdata[msg.author.id][msg.id]['execCount']) {
                    poopy.tempdata[msg.author.id][msg.id]['execCount'] = 0
                }

                if (!poopy.tempdata[msg.author.id]['cooler']) {
                    poopy.tempdata[msg.author.id]['cooler'] = msg.id
                }

                if (!poopy.tempdata[msg.author.id]['arrays']) {
                    poopy.tempdata[msg.author.id]['arrays'] = {}
                }

                if (!poopy.tempdata[msg.author.id]['declared']) {
                    poopy.tempdata[msg.author.id]['declared'] = {}
                }

                if (!poopy.tempdata[msg.author.id]['promises']) {
                    poopy.tempdata[msg.author.id]['promises'] = []
                }

                if (!poopy.tempdata[msg.author.id]['eggphrases']) {
                    poopy.tempdata[msg.author.id]['eggphrases'] = {}
                }

                if (!poopy.tempdata[msg.author.id]['eggphrases']['lastmention']) {
                    poopy.tempdata[msg.author.id]['eggphrases']['lastmention'] = 0
                }

                if (!poopy.tempdata[msg.author.id]['eggphrases']['phrase']) {
                    poopy.tempdata[msg.author.id]['eggphrases']['phrase'] = 0
                }
            }

            var lastDataGather = Date.now() - poopy.data['guild-data'][msg.guild.id]['gettingData']
            if (lastDataGather >= 600000) {
                async function gather() {
                    var cantFetch = false

                    for (var id in poopy.data['guild-data'][msg.guild.id]['members']) {
                        var member = poopy.data['guild-data'][msg.guild.id]['members'][id]
                        if (member.username === undefined) {
                            var user = await poopy.bot.users.fetch(id).catch(() => { })
                            if (!cantFetch) poopy.data['guild-data'][msg.guild.id]['gettingData'] = Date.now()
                            if (user) {
                                poopy.data['guild-data'][msg.guild.id]['members'][id]['username'] = user.username
                            } else {
                                delete poopy.data['guild-data'][msg.guild.id]['members'][id]
                            }
                        }
                    }
                }

                gather()
            }
        }

        poopy.vars.clevercontexts = []

        poopy.functions.cleverbot = async function (stim, id) {
            var context = poopy.vars.clevercontexts[id] || (poopy.vars.clevercontexts[id] = [])
            if (context.length > 10) context.splice(0, context.length - 10)

            async function clever() {
                function encodeForSending(a) {
                    var f = ""
                    var d = ""
                    a = a.replace(/[|]/g, "{*}")
                    for (var b = 0; b <= a.length; b++) {
                        if (a.charCodeAt(b) > 255) {
                            d = escape(a.charAt(b))
                            if (d.substring(0, 2) == "%u") {
                                f += "|" + d.substring(2, d.length)
                            } else {
                                f += d
                            }
                        } else {
                            f += a.charAt(b)
                        }
                    }
                    f = f.replace("|201C", "'").replace("|201D", "'").replace("|2018", "'").replace("|2019", "'").replace("`", "'").replace("%B4", "'").replace("|FF20", "").replace("|FE6B", "")
                    return escape(f)
                }

                var UA = 'Mozilla/5.0 (X11; U; Linux i686; it; rv:1.9.2.3) Gecko/20100406 Firefox/3.6.3 (Swiftfox)'

                if (!poopy.vars.cleverbotJar) poopy.vars.cleverbotJar = await poopy.modules.axios.get("https://www.cleverbot.com/extras/conversation-social-min.js", {
                    headers: {
                        "User-Agent": UA
                    }
                }).then(res => res.headers['set-cookie'][0].split(";")[0]).catch(() => { })
                var jar = poopy.vars.cleverbotJar

                var payload = `stimulus=${encodeForSending(stim)}`
                var l = context.length - 1
                for (var i = 0; i <= l; i++) {
                    payload += `&vText${i + 2}=${encodeForSending(context[l - i])}`
                }
                payload += `&cb_settings_language=en&cb_settings_scripting=no&islearning=1&icognoid=wsf&icognocheck=`
                payload += poopy.modules.md5(payload.substring(7, 33))
                var res = await poopy.modules.axios.request({
                    method: "POST",
                    url: "https://www.cleverbot.com/webservicemin?uc=UseOfficialCleverbotAPI&ncf=V2&",
                    data: payload,
                    headers: {
                        "Content-Type": "text/plain",
                        Cookie: jar,
                        "User-Agent": UA
                    }
                })
                    .then(a => a.data.split("\r")[0])
                    .catch(() => '')
                return res
            }

            async function gamer() {
                var context = poopy.vars.clevercontexts[id] || (poopy.vars.clevercontexts[id] = [])
                if (context.length > 10) context.splice(0, context.length - 10)

                var options = {
                    method: 'GET',
                    url: 'https://random-stuff-api.p.rapidapi.com/ai',
                    params: {
                        msg: stim,
                        bot_name: poopy.bot.user.username,
                        bot_gender: 'male',
                        bot_master: 'raleigh',
                        bot_age: String(new Date(Date.now() - 1031690078000).getUTCFullYear() - 1970),
                        bot_company: 'poopy\'s lounge',
                        bot_location: 'Nigeria',
                        bot_email: 'poopystinkystinky@gmail.com',
                        bot_build: 'private',
                        bot_birth_year: '2002',
                        bot_birth_date: '10th September, 2002',
                        bot_birth_place: 'Nigeria',
                        bot_favorite_color: 'yellow',
                        bot_favorite_book: 'Diary of a Wimpy Kid',
                        bot_favorite_band: 'Radiohead',
                        bot_favorite_artist: 'Kanye West',
                        bot_favorite_actress: 'nonexistent',
                        bot_favorite_actor: 'MoistCr1TiKaL',
                        id: id
                    },
                    headers: {
                        authorization: process.env.GAMERKEY,
                        'x-rapidapi-host': 'random-stuff-api.p.rapidapi.com',
                        'x-rapidapi-key': poopy.functions.randomKey('RAPIDAPIKEY')
                    }
                }

                var res = await poopy.modules.axios.request(options).catch(() => { }) ?? { data: { AIResponse: '' } }

                return res.data.AIResponse
            }

            var response = await clever().catch(() => { })
            if (!response && process.env.GAMERKEY) response = await gamer().catch(() => { })
            if (!response) response = poopy.functions.randomChoice(poopy.arrays.eightball)

            if (id != undefined && response) {
                context.push(stim)
                context.push(response)
            }

            return response
        }

        poopy.functions.processTask = async function (data) {
            return new Promise(async (resolve, reject) => {
                try {
                    var ch = await poopy.amqpconn.createChannel().catch(reject)
                    var q = await ch.assertQueue('', { exclusive: true }).catch(reject)
                    var correlationId = poopy.functions.generateId()

                    await ch.assertExchange('crash', 'fanout', {
                        durable: false
                    }).catch(reject)
                    var qrash = await ch.assertQueue('', { exclusive: true }).catch(reject)
                    ch.bindQueue(qrash.queue, 'crash', '')

                    async function closeAll() {
                        clearTimeout(idleTimeout)
                        await ch.cancel(consumer.consumerTag).catch(() => { })
                        await ch.cancel(crashconsumer.consumerTag).catch(() => { })
                        await ch.deleteQueue(q.queue).catch(() => { })
                        await ch.deleteQueue(qrash.queue).catch(() => { })
                        await ch.close().catch(() => { })
                        if (poopy.modules.fs.existsSync(`tasks/${poopy.config.mongodatabase}/${correlationId}.json`))
                            poopy.modules.fs.rm(`tasks/${poopy.config.mongodatabase}/${correlationId}.json`, { force: true, recursive: true })
                    }

                    var chunkdata = []

                    function tryJSONparse(obj) {
                        try {
                            return JSON.parse(obj)
                        } catch (_) {
                            return null
                        }
                    }

                    var consumer = await ch.consume(q.queue, function (msg) {
                        if (msg.properties.correlationId == correlationId) {
                            var content = msg.content.toString()

                            var order = Number(content.substring(0, 3))
                            var chunk = content.substring(3)
                            chunkdata.push({ order, chunk })
                            chunkdata.sort((a, b) => a.order - b.order)

                            var chunkjoin = chunkdata.map(c => c.chunk).join('')
                            var data = tryJSONparse(chunkjoin)
                            if (data) {
                                closeAll()
                                resolve(data)
                            }
                        }
                    }, { noAck: true }).catch(reject)

                    var crashconsumer = await ch.consume(qrash.queue, function (msg) {
                        closeAll()
                        reject(msg.content.toString())
                    }, { noAck: true }).catch(reject)

                    var idleTimeout = setTimeout(function () {
                        closeAll()
                        reject(`Task idle duration exceeded`)
                    }, 300000)

                    poopy.modules.fs.writeFileSync(`tasks/${poopy.config.mongodatabase}/${correlationId}.json`, JSON.stringify(data))

                    ch.sendToQueue('tasks', Buffer.from(`${process.env.BOTWEBSITE}/tasks/${poopy.config.mongodatabase}/${correlationId}?auth=${process.env.AUTHTOKEN}`), {
                        correlationId: correlationId,
                        replyTo: q.queue
                    })
                } catch (err) {
                    reject(err)
                }
            })
        }

        poopy.functions.infoPost = async function (message) {
            if (poopy.config.stfu || poopy.config.noInfoPost) return

            var avatar = poopy.bot.user.displayAvatarURL({ dynamic: true, size: 1024, format: 'png' })
            var color = poopy.config.testing ? { r: 255, g: 255, b: 255 } : await poopy.functions.averageColor(avatar)

            var infoMsg
            if (poopy.config.textEmbeds) infoMsg = await poopy.bot.guilds.cache.get('834431435704107018')?.channels.cache.get('967083645619830834')?.send({
                content: message,
                allowedMentions: {
                    parse: ['users']
                }
            }).catch(() => { })
            else infoMsg = await poopy.bot.guilds.cache.get('834431435704107018')?.channels.cache.get('967083645619830834')?.send({
                embeds: [{
                    description: message,
                    author: {
                        name: poopy.bot.user.username,
                        icon_url: avatar,
                    },
                    color: (color.r << 8 << 8) + (color.g << 8) + (color.b)
                }]
            }).catch(() => { })

            if (infoMsg) {
                poopy.vars.msgcooldown = true
                setTimeout(() => poopy.vars.msgcooldown = false, poopy.config.msgcooldown)
            }
        }

        poopy.functions.getKeyFunc = function (string, { extrakeys = {}, extrafuncs = {}, declaredonly = false } = {}) {
            var lastParenthesesIndex = -1
            var llastParenthesesIndex = -1
            var rawParenthesesIndex = -1
            var rawrequired = 0
            var keyindex = -1
            var parindex = -1
            var parenthesesGoal = []
            var potentialindexes = []
            var rawMatch

            var keylist = declaredonly ? {} : { ...poopy.special.keys }
            var funclist = declaredonly ? {} : { ...poopy.special.functions }
            var pfunclist = []

            for (var k in keylist) {
                if (keylist[k].potential) {
                    if (keylist[k].potential.funcs) {
                        for (var ff in keylist[k].potential.funcs) {
                            pfunclist[ff] = keylist[k].potential.funcs[ff]
                        }
                    }
                }
            }
            for (var k in extrakeys) keylist[k] = extrakeys[k]

            for (var f in funclist) {
                if (funclist[f].potential) {
                    if (funclist[f].potential.funcs) {
                        for (var ff in funclist[f].potential.funcs) {
                            pfunclist[ff] = funclist[f].potential.funcs[ff]
                        }
                    }
                }
            }
            for (var f in extrafuncs) funclist[f] = extrafuncs[f]

            var keys = Object.keys(keylist).sort((a, b) => b.length - a.length)
            var funcs = Object.keys(funclist).sort((a, b) => b.length - a.length)
            var pfuncs = Object.keys(pfunclist).sort((a, b) => b.length - a.length)

            var keyfiltered = keys.filter((key) => string.includes(key))
            var funcfiltered = funcs.filter((func) => string.includes(`${func}(`))
            var pfuncfiltered = pfuncs.filter((pfunc) => string.includes(`${pfunc}(`))
            var keyfirstletters = keyfiltered.map(key => key[0]).filter(function (item, pos, self) {
                return self.indexOf(item) == pos
            })

            if ((keyfiltered.length <= 0 && funcfiltered.length <= 0) || string.length > 1024 * 1024) return false

            for (var i in string) {
                var char = string[i]

                if (funcfiltered.length > 0 || pfuncfiltered.length > 0)
                    switch (char) {
                        case '(':
                            var funcmatch = poopy.functions.matchLongestFunc(string.substring(0, i), funcfiltered) // get real function
                            var pfuncmatch = poopy.functions.matchLongestFunc(string.substring(0, i), parenthesesGoal.length <= 0 ? pfuncfiltered : ['']) // get probable functions (like resettimer())

                            if (funcmatch) {
                                parindex++ // open parentheses found
                                lastParenthesesIndex = i // set the index of the last parentheses
                                if (!rawMatch) {
                                    var func = funclist[funcmatch[0]]
                                    if (func) {
                                        if (func.raw) {
                                            rawParenthesesIndex = i
                                            rawrequired++
                                            rawMatch = funcmatch[0]
                                        } // if the function is raw, activate raw setting

                                        if (func.parentheses) {
                                            parenthesesGoal.push(parindex - 1)
                                        } // if the function uses parentheses inside, activate whole parentheses setting
                                    }
                                } else {
                                    rawrequired++
                                } // if the function isnt inside a raw one, execute it like normal, else add a requirement for raw parentheses
                            } else if (pfuncmatch || pfuncmatch == '') {
                                parindex++ // open parentheses found
                                potentialindexes.push(parindex)
                            }
                            break

                        case ')':
                            var funcmatch = poopy.functions.matchLongestFunc(string.substring(0, lastParenthesesIndex), funcfiltered)

                            if (funcmatch && string[i - 1] !== '\\') {
                                if (parenthesesGoal.find(pgoal => parindex == pgoal)) {
                                    parenthesesGoal.splice(parenthesesGoal.findIndex(pgoal => parindex == pgoal), 1)
                                }
                                if (potentialindexes.find(ind => ind === parindex)) {
                                    potentialindexes.splice(potentialindexes.findIndex(ind => ind === parindex), 1)
                                } else {
                                    if (!rawMatch) {
                                        lastParenthesesIndex++
                                        return {
                                            match: [funcmatch[0], string.substring(lastParenthesesIndex, i)],
                                            type: 'func'
                                        }
                                    } else {
                                        rawrequired--
                                        llastParenthesesIndex = i
                                        if (rawrequired <= 0) {
                                            rawParenthesesIndex++
                                            return {
                                                match: [rawMatch, string.substring(rawParenthesesIndex, i)],
                                                type: 'func'
                                            }
                                        }
                                    }
                                }
                                parindex-- // closed parentheses found
                            }
                            break
                    }

                if (keyfiltered.length > 0 && keyfirstletters.includes(char)) {
                    var keymatch = poopy.functions.matchLongestKey(string.substring(i), keys)
                    if (keymatch) {
                        keyindex = i
                        if (rawrequired <= 0) return {
                            match: keymatch[0],
                            type: 'key'
                        }
                    }
                }
            }

            if (llastParenthesesIndex > -1) {
                var funcmatch = poopy.functions.matchLongestFunc(string.substring(0, lastParenthesesIndex), funcfiltered)

                lastParenthesesIndex++
                return {
                    match: [funcmatch[0], string.substring(lastParenthesesIndex, llastParenthesesIndex)],
                    type: 'func'
                }
            }

            if (keyindex > -1) {
                var keymatch = poopy.functions.matchLongestKey(string.substring(keyindex), keys)

                return {
                    match: keymatch[0],
                    type: 'key'
                }
            }

            return false
        }

        poopy.functions.splitKeyFunc = function (string, { extrafuncs = {}, args = Infinity, separator = '|', declaredonly = false } = {}) {
            var isDefaultSeparator = separator == '|'
            var lastParenthesesIndex = -1
            var lastSplitIndex = 0
            var parenthesesrequired = 0
            var parenthesesGoal = []
            var barfound = 0
            var split = []

            var funclist = declaredonly ? {} : { ...poopy.special.functions }
            var pfunclist = []

            for (var f in funclist) {
                if (funclist[f].potential) {
                    if (funclist[f].potential.funcs) {
                        for (var ff in funclist[f].potential.funcs) {
                            pfunclist[ff] = funclist[f].potential.funcs[ff]
                        }
                    }
                }
            }
            for (var f in extrafuncs) funclist[f] = extrafuncs[f]

            var funcs = Object.keys(funclist).sort((a, b) => b.length - a.length)
            var pfuncs = Object.keys(pfunclist).sort((a, b) => b.length - a.length)
            var afuncs = funcs.concat(pfuncs).sort((a, b) => b.length - a.length)

            var afuncfiltered = afuncs.filter((afunc) => string.includes(`${afunc}(`))

            for (var i in string) {
                var char = string[i]
                i = Number(i)

                switch (char) {
                    case '(':
                        if (afuncfiltered.length > 0) {
                            var funcmatch = poopy.functions.matchLongestFunc(string.substring(0, i), parenthesesGoal.length <= 0 ? afuncfiltered : [''])
                            if (funcmatch) {
                                lastParenthesesIndex = i
                                parenthesesrequired++
                                var func = funclist[funcmatch[0]]
                                if (func) {
                                    if (func.parentheses) {
                                        parenthesesGoal.push(parenthesesrequired - 1)
                                    }
                                }
                            }
                        }
                        break

                    case separator:
                        if (parenthesesrequired <= 0 && string[i - 1] !== '\\') {
                            split.push(string.substring(lastSplitIndex, i - ((string[i - 1] === ' ' && isDefaultSeparator) ? 1 : 0)))
                            lastSplitIndex = i + ((string[i + 1] === ' ' && isDefaultSeparator) ? 2 : 1)
                            barfound++
                        }
                        break

                    case ')':
                        if (afuncfiltered.length > 0) {
                            var funcmatch = poopy.functions.matchLongestFunc(string.substring(0, lastParenthesesIndex), parenthesesGoal.length <= 0 ? afuncfiltered : [''])
                            if (funcmatch && string[i - 1] !== '\\') {
                                if (parenthesesGoal.find(pgoal => parenthesesrequired == pgoal)) {
                                    parenthesesGoal.splice(parenthesesGoal.findIndex(pgoal => parenthesesrequired == pgoal), 1)
                                }
                                parenthesesrequired--
                            }
                        }
                        break
                }

                if (barfound == args - 1) {
                    break
                }
            }

            split.push(string.substring(lastSplitIndex))

            return split.map(val => isDefaultSeparator ? val.replace(/\\\|/, '|') : val)
        }

        poopy.functions.yesno = async function (channel, content, who, btdata, reply) {
            return new Promise(async (resolve) => {
                if (poopy.config.forcetrue) {
                    resolve(true)
                    return
                }

                var sendObject = {
                    content: content
                }

                if (typeof (who) != 'string') {
                    sendObject.allowedMentions = {
                        parse: (!who.permissions.has('ADMINISTRATOR') &&
                            !who.permissions.has('MENTION_EVERYONE') &&
                            who.id !== channel.guild.ownerID) ?
                            ['users'] : ['users', 'everyone', 'roles']
                    }
                    who = who.id
                }

                var buttonsData = btdata ?? [
                    {
                        emoji: '874406154619469864',
                        reactemoji: '✅',
                        customid: 'yes',
                        style: 'SUCCESS',
                        resolve: true
                    },

                    {
                        emoji: '874406183933444156',
                        reactemoji: '❌',
                        customid: 'no',
                        style: 'DANGER',
                        resolve: false
                    }
                ]

                if (!poopy.config.useReactions) {
                    var components = []

                    var chunkButtonData = poopy.functions.chunkArray(buttonsData, 5)

                    chunkButtonData.forEach(buttonsData => {
                        var buttonRow = new poopy.modules.Discord.MessageActionRow()
                        var buttons = []

                        buttonsData.forEach(bdata => {
                            var button = new poopy.modules.Discord.MessageButton()
                                .setStyle(bdata.style)
                                .setEmoji(bdata.emoji)
                                .setCustomId(bdata.customid)

                            buttons.push(button)
                        })

                        buttonRow.addComponents(buttons)

                        components.push(buttonRow)
                    })

                    sendObject.components = components
                }

                var yesnoMsg = await (reply ?? channel)[reply ? 'reply' : 'send'](sendObject).catch(() => { })

                if (!yesnoMsg) {
                    resolve(false)
                    return
                }

                if (poopy.config.useReactions) {
                    var collector = yesnoMsg.createReactionCollector({ time: 30_000 })

                    collector.on('collect', (reaction, user) => {
                        poopy.functions.dmSupport(reaction)

                        if (!(user.id === who && ((user.id !== poopy.bot.user.id && !user.bot) || poopy.config.allowbotusage))) {
                            return
                        }

                        var buttonData = buttonsData.find(bdata => bdata.reactemoji == reaction.emoji.name)

                        if (buttonData) {
                            collector.stop()
                            resolve(buttonData.resolve)
                        }
                    })

                    collector.on('end', (_, reason) => {
                        if (reason == 'time') {
                            yesnoMsg.edit({
                                content: 'No response.'
                            }).catch(() => { })
                            yesnoMsg.reactions.removeAll().catch(() => { })
                            resolve(false)
                        } else {
                            yesnoMsg.delete().catch(() => { })
                        }
                    })

                    for (var i in buttonsData) {
                        var bdata = buttonsData[i]
                        await yesnoMsg.react(bdata.reactemoji).catch(() => { })
                    }
                } else {
                    var collector = yesnoMsg.createMessageComponentCollector({ time: 30_000 })

                    collector.on('collect', (button) => {
                        poopy.functions.dmSupport(button)

                        button.deferUpdate().catch(() => { })

                        if (!(button.user.id === who && ((button.user.id !== poopy.bot.user.id && !button.user.bot) || poopy.config.allowbotusage))) {
                            return
                        }

                        var buttonData = buttonsData.find(bdata => bdata.customid == button.customId)

                        if (buttonData) {
                            collector.stop()
                            resolve(buttonData.resolve)
                        }
                    })

                    collector.on('end', (_, reason) => {
                        if (reason == 'time') {
                            yesnoMsg.edit({
                                content: 'No response.',
                                components: []
                            }).catch(() => { })
                            resolve(false)
                        } else {
                            yesnoMsg.delete().catch(() => { })
                        }
                    })
                }
            })
        }

        poopy.functions.selectMenu = async function (channel, content, placeholder, options, exception, who) {
            return new Promise(async (resolve) => {
                if (poopy.config.useReactions) {
                    resolve(exception)
                    return
                }

                var sendObject = {
                    content: content
                }

                if (typeof (who) != 'string') {
                    sendObject.allowedMentions = {
                        parse: (!who.permissions.has('ADMINISTRATOR') &&
                            !who.permissions.has('MENTION_EVERYONE') &&
                            who.id !== channel.guild.ownerID) ?
                            ['users'] : ['users', 'everyone', 'roles']
                    }
                    who = who.id
                }

                var menuRow = new poopy.modules.Discord.MessageActionRow()
                var menu = new poopy.modules.Discord.MessageSelectMenu()
                    .setCustomId('selectmenu')
                    .setPlaceholder(placeholder)
                    .addOptions(options)

                menuRow.addComponents([menu])
                sendObject.components = [menuRow]

                var selectMsg = await channel.send(sendObject).catch(() => { })

                if (!selectMsg) {
                    resolve(exception)
                    return
                }

                var collector = selectMsg.createMessageComponentCollector({ time: 60_000 })

                collector.on('collect', (option) => {
                    poopy.functions.dmSupport(option)

                    option.deferUpdate().catch(() => { })

                    if (!(option.user.id === who && ((option.user.id !== poopy.bot.user.id && !option.user.bot) || poopy.config.allowbotusage))) {
                        return
                    }

                    collector.stop()
                    resolve(option.values[0])
                })

                collector.on('end', (_, reason) => {
                    if (reason == 'time') {
                        selectMsg.edit({
                            content: 'No response.',
                            components: []
                        }).catch(() => { })
                        resolve(exception)
                    } else {
                        selectMsg.delete().catch(() => { })
                    }
                })
            })
        }

        poopy.functions.navigateEmbed = async function (channel, pageFunc, results, who, extraButtons, page, selectMenu, errOnFail, endFunc, reply) {
            page = page ?? 1

            var buttonsData = [
                {
                    emoji: '861253229726793728',
                    reactemoji: '⬅️',
                    customid: 'previous',
                    style: 'PRIMARY',
                    function: async () => page - 1,
                    page: true
                },

                {
                    emoji: '861253230070988860',
                    reactemoji: '🔀',
                    customid: 'random',
                    style: 'PRIMARY',
                    function: async () => Math.floor(Math.random() * results) + 1,
                    page: true
                },

                {
                    emoji: '861253229798621205',
                    reactemoji: '➡️',
                    customid: 'next',
                    style: 'PRIMARY',
                    function: async () => page + 1,
                    page: true
                },

                {
                    emoji: '970292877785727036',
                    reactemoji: '🔢',
                    customid: 'page',
                    style: 'PRIMARY',
                    function: async (_, interaction) => new Promise(async resolve => {
                        var newpage = page

                        if (poopy.config.useReactions) {
                            var goMessage = await channel.send('Which page would you like to go...?').catch(() => { })

                            var pageCollector = channel.createMessageCollector({ time: 30000 })

                            pageCollector.on('collect', (msg) => {
                                poopy.functions.dmSupport(msg)

                                if (!(msg.author.id === who && ((msg.author.id !== poopy.bot.user.id && !msg.author.bot) || poopy.config.allowbotusage))) {
                                    return
                                }

                                newpage = poopy.functions.parseNumber(msg.content, { dft: page, min: 1, max: results, round: true })
                                pageCollector.stop()
                                msg.delete().catch(() => { })
                            })

                            pageCollector.on('end', () => {
                                if (goMessage) goMessage.delete().catch(() => { })
                                resolve(newpage)
                            })
                        } else {
                            var pageModal = new poopy.modules.Discord.Modal()
                                .setCustomId('page-modal')
                                .setTitle('Select your page...')
                                .addComponents(
                                    new poopy.modules.Discord.MessageActionRow().addComponents(
                                        new poopy.modules.Discord.TextInputComponent()
                                            .setCustomId('page-num')
                                            .setLabel('Page')
                                            .setStyle('SHORT')
                                            .setMinLength(1)
                                            .setMaxLength(String(results).length)
                                            .setPlaceholder(`1-${results}`)
                                            .setRequired(true)
                                    )
                                )

                            interaction.showModal(pageModal).then(() => {
                                var done = false

                                var modalCallback = (modal) => {
                                    if (!modal.isModalSubmit()) return

                                    if (modal.deferUpdate) modal.deferUpdate().catch(() => { })

                                    if (!(modal.user.id === who && ((modal.user.id !== poopy.bot.user.id && !modal.user.bot) || poopy.config.allowbotusage)) || done) {
                                        return
                                    }

                                    done = true
                                    newpage = poopy.functions.parseNumber(modal.fields.getTextInputValue('page-num'), { dft: page, min: 1, max: results, round: true })
                                    clearTimeout(modalTimeout)
                                    resolve(newpage)
                                }

                                var modalTimeout = setTimeout(() => {
                                    if (!done) {
                                        done = true
                                        poopy.bot.removeListener('interactionCreate', modalCallback)
                                        resolve(newpage)
                                    }
                                }, 30000)

                                poopy.bot.once('interactionCreate', modalCallback)
                            }).catch(() => resolve(newpage))
                        }
                    }),
                    page: true
                }
            ].concat(extraButtons || [])

            var components = []

            if (!poopy.config.useReactions) {
                var chunkButtonData = poopy.functions.chunkArray(buttonsData, 5)

                chunkButtonData.forEach(buttonsData => {
                    var buttonRow = new poopy.modules.Discord.MessageActionRow()
                    var buttons = []

                    buttonsData.forEach(bdata => {
                        var button = new poopy.modules.Discord.MessageButton()
                            .setStyle(bdata.style)
                            .setEmoji(bdata.emoji)
                            .setCustomId(bdata.customid)

                        buttons.push(button)
                    })

                    buttonRow.addComponents(buttons)

                    components.push(buttonRow)
                })
            }

            var resultEmbed = await pageFunc(page).catch(() => { })
            var sendObject = {
                components: components.slice()
            }
            var allowedMentions

            if (selectMenu) {
                var menuRow = new poopy.modules.Discord.MessageActionRow()
                var menu = new poopy.modules.Discord.MessageSelectMenu()
                    .setCustomId(selectMenu.customid)
                    .setPlaceholder(selectMenu.text)
                    .addOptions(selectMenu.options)

                menuRow.addComponents([menu])

                buttonsData.push(selectMenu)
                sendObject.components.push(menuRow)
            }

            if (typeof (who) != 'string') {
                allowedMentions = {
                    parse: (!who.permissions.has('ADMINISTRATOR') &&
                        !who.permissions.has('MENTION_EVERYONE') &&
                        who.id !== channel.guild.ownerID) ?
                        ['users'] : ['users', 'everyone', 'roles']
                }
                sendObject.allowedMentions = allowedMentions
                who = who.id
            }

            if (poopy.config.textEmbeds) sendObject.content = resultEmbed
            else sendObject.embeds = [resultEmbed]

            var resultsMsg = await (reply ?? channel)[reply ? 'reply' : 'send'](sendObject).catch(() => { })

            if (!resultsMsg) {
                if (errOnFail) throw new Error(`Couldn't send navigable embed to channel`)
                else return
            }

            var usingButton = false

            var lastCollector = poopy.tempdata[who]['navigateCollector']
            if (lastCollector && lastCollector.stop) lastCollector.stop()

            if (poopy.config.useReactions) {
                var collector = poopy.tempdata[who]['navigateCollector'] = resultsMsg.createReactionCollector({ time: 60_000 })

                collector.on('collect', async (reaction, user) => {
                    poopy.functions.dmSupport(reaction)

                    if (!(user.id === who && ((user.id !== poopy.bot.user.id && !user.bot) || poopy.config.allowbotusage)) || usingButton) {
                        return
                    }

                    var buttonData = buttonsData.find(bdata => bdata.reactemoji == reaction.emoji.name)

                    if (buttonData) {
                        usingButton = true
                        collector.resetTimer()

                        var newpage = await buttonData.function(page, reaction, resultsMsg, collector)
                        reaction.users.remove(user).catch(() => { })

                        if (buttonData.page) {
                            if (newpage < 1 || newpage > results || newpage == page) {
                                usingButton = false
                                return
                            }

                            page = newpage

                            var resultEmbed = await pageFunc(page).catch(() => { })
                            var sendObject = {
                                components: components.slice()
                            }

                            if (allowedMentions) sendObject.allowedMentions = allowedMentions

                            if (poopy.config.textEmbeds) sendObject.content = resultEmbed
                            else sendObject.embeds = [resultEmbed]

                            resultsMsg.edit(sendObject).catch(() => { })
                        }
                        usingButton = false
                    }
                })

                collector.on('end', async (_, reason) => {
                    delete poopy.tempdata[who]['navigateCollector']

                    var resultEmbed = await pageFunc(page, true).catch(() => { })
                    var sendObject = {}

                    if (allowedMentions) sendObject.allowedMentions = allowedMentions

                    if (poopy.config.textEmbeds) sendObject.content = resultEmbed
                    else sendObject.embeds = [resultEmbed]

                    resultsMsg.edit(sendObject).catch(() => { })

                    resultsMsg.reactions.removeAll().catch(() => { })
                    if (endFunc) endFunc(reason, page, resultsMsg)
                })

                for (var i in buttonsData) {
                    var bdata = buttonsData[i]
                    await resultsMsg.react(bdata.reactemoji).catch(() => { })
                }
            } else {
                var collector = poopy.tempdata[who]['navigateCollector'] = resultsMsg.createMessageComponentCollector({ time: 60_000 })

                collector.on('collect', async (button) => {
                    poopy.functions.dmSupport(button)

                    if (!(button.user.id === who && ((button.user.id !== poopy.bot.user.id && !button.user.bot) || poopy.config.allowbotusage)) || usingButton) {
                        button.deferUpdate().catch(() => { })
                        return
                    }

                    var buttonData = buttonsData.find(bdata => bdata.customid == button.customId)

                    if (buttonData) {
                        usingButton = true
                        collector.resetTimer()

                        var newpage = await buttonData.function(page, button, resultsMsg, collector)
                        button.deferUpdate().catch(() => { })

                        if (buttonData.page) {
                            if (newpage < 1 || newpage > results || newpage == page) {
                                usingButton = false
                                return
                            }

                            page = newpage

                            var resultEmbed = await pageFunc(page).catch(() => { })
                            var sendObject = {
                                components: components.slice()
                            }

                            if (selectMenu) {
                                var menuRow = new poopy.modules.Discord.MessageActionRow()
                                var menu = new poopy.modules.Discord.MessageSelectMenu()
                                    .setCustomId(selectMenu.customid)
                                    .setPlaceholder(resultEmbed.menuText || selectMenu.text)
                                    .addOptions(selectMenu.options)

                                menuRow.addComponents([menu])

                                sendObject.components.push(menuRow)

                                if (resultEmbed.menuText) delete resultEmbed.menuText
                            }

                            if (allowedMentions) sendObject.allowedMentions = allowedMentions

                            if (poopy.config.textEmbeds) sendObject.content = resultEmbed
                            else sendObject.embeds = [resultEmbed]

                            resultsMsg.edit(sendObject).catch(() => { })
                        }
                        usingButton = false
                    }
                })

                collector.on('end', async (_, reason) => {
                    delete poopy.tempdata[who]['navigateCollector']

                    var resultEmbed = await pageFunc(page, true).catch(() => { })
                    var sendObject = {
                        components: []
                    }

                    if (allowedMentions) sendObject.allowedMentions = allowedMentions

                    if (poopy.config.textEmbeds) sendObject.content = resultEmbed
                    else sendObject.embeds = [resultEmbed]

                    resultsMsg.edit(sendObject).catch(() => { })

                    if (endFunc) endFunc(reason, page, resultsMsg)
                })
            }
        }

        poopy.functions.correctUrl = async function (url) {
            if (url.match(/^https\:\/\/(www\.)?tenor\.com\/view/) && url.match(/\d+/g) && process.env.TENORKEY) {
                var ids = url.match(/\d+/g)
                var body = await poopy.modules.axios.request(`https://g.tenor.com/v1/gifs?ids=${ids[ids.length - 1]}&key=${process.env.TENORKEY}`).catch(() => { })
                if (body && body.data.results.length) {
                    poopy.functions.infoPost(`Tenor URL detected`)
                    return body.data.results[0].media[0].gif.url
                }
            } else if (url.match(/^https\:\/\/(www\.)?gyazo\.com/)) {
                var gifurl = url.replace(/^https\:\/\/(www\.)?gyazo\.com/, 'https://i.gyazo.com') + '.gif'
                var mp4url = url.replace(/^https\:\/\/(www\.)?gyazo\.com/, 'https://i.gyazo.com') + '.mp4'
                var pngurl = url.replace(/^https\:\/\/(www\.)?gyazo\.com/, 'https://i.gyazo.com') + '.png'
                var gyazourls = [gifurl, mp4url, pngurl]
                var gyazourl = undefined
                for (var i in gyazourls) {
                    var url = gyazourls[i]
                    var response = await poopy.modules.axios.request({
                        url: url,
                        validateStatus: () => true
                    }).catch(() => { })
                    if (response && response.status >= 200 && response.status < 300) {
                        gyazourl = url
                        break
                    }
                }
                if (gyazourl) {
                    poopy.functions.infoPost(`Gyazo URL detected`)
                    return gyazourl
                }
            } else if (url.match(/^https\:\/\/(www\.)?imgur\.com/)) {
                var mp4url = url.replace(/^https\:\/\/(www\.)?imgur\.com/, 'https://i.imgur.com') + '.mp4'
                var pngurl = url.replace(/^https\:\/\/(www\.)?imgur\.com/, 'https://i.imgur.com') + '.png'
                var imgurls = [mp4url, pngurl]
                var imgurl = undefined
                for (var i in imgurls) {
                    var url = imgurls[i]
                    var response = await poopy.modules.axios.request({
                        url: url,
                        validateStatus: () => true
                    }).catch(() => { })
                    if (response && response.status >= 200 && response.status < 300) {
                        imgurl = url
                        break
                    }
                }
                if (imgurl) {
                    poopy.functions.infoPost(`Imgur URL detected`)
                    return imgurl
                }
            } else if (url.match(/^https\:\/\/(www\.)?roblox\.com\/(catalog|library|games)\//)) {
                async function getAudio(id) {
                    return new Promise((resolve) => {
                        poopy.modules.axios.get(`https://www.roblox.com/library/${id}`).then(async (res) => {
                            var $ = poopy.modules.cheerio.load(res.data)
                            var urls = $("#AssetThumbnail .MediaPlayerIcon")

                            if (urls.length > 0) {
                                resolve(urls[0].attribs['data-mediathumb-url'])
                                return
                            }

                            resolve()
                        }).catch(() => resolve())
                    })
                }

                async function getTexture(id) {
                    return new Promise((resolve) => {
                        poopy.modules.axios.request({
                            method: 'GET',
                            url: `https://assetdelivery.roblox.com/v1/assetId/${id}`,
                            headers: {
                                "Accept": "application/json"
                            }
                        }).then(async (res) => {
                            var body = res.data
                            var rbxmurl = body.location

                            if (!rbxmurl) {
                                resolve()
                                return
                            }

                            poopy.modules.axios.request(rbxmurl).then((rres) => {
                                var rbody = rres.data

                                var $ = poopy.modules.cheerio.load(rbody)
                                var urls = $("url")
                                if (urls.length > 0) {
                                    var imageasseturl = urls[0].children[0].data
                                    var ids = imageasseturl.match(/\d+/g)
                                    var id = ids[0]

                                    poopy.modules.axios.request({
                                        method: 'GET',
                                        url: `https://assetdelivery.roblox.com/v1/assetId/${id}`,
                                        headers: {
                                            "Accept": "application/json"
                                        }
                                    }).then((ires) => {
                                        var ibody = ires.data
                                        var textureurl = ibody.location

                                        if (!textureurl) {
                                            resolve()
                                            return
                                        }

                                        resolve(textureurl)
                                    }).catch(() => resolve())
                                    return
                                }

                                resolve()
                            }).catch(() => resolve())
                        }).catch(() => resolve())
                    })
                }

                async function getGame(id) {
                    return new Promise((resolve) => {
                        poopy.modules.axios.request({
                            method: 'GET',
                            url: `https://thumbnails.roblox.com/v1/places/gameicons?placeIds=${id}&size=512x512&format=Png&isCircular=false`,
                            headers: {
                                "Accept": "application/json"
                            }
                        }).then(async (res) => {
                            var body = res.data

                            if (body.data ? body.data.length > 0 : false) {
                                if (body.data[0].state === 'Pending') {
                                    var url = await getGame(id).catch(() => { })
                                    resolve(url)
                                    return
                                }

                                resolve(body.data[0].imageUrl)
                                return
                            }

                            resolve()
                        }).catch(() => resolve())
                    })
                }

                async function getThumb(id) {
                    return new Promise((resolve) => {
                        poopy.modules.axios.request({
                            method: 'GET',
                            url: `https://thumbnails.roblox.com/v1/assets?assetIds=${id}&size=700x700&format=Png&isCircular=false`,
                            headers: {
                                "Accept": "application/json"
                            }
                        }).then(async (res) => {
                            var body = res.data

                            if (body.data ? body.data.length > 0 : false) {
                                if (body.data[0].state === 'Pending') {
                                    var url = await getThumb(id).catch(() => { })
                                    resolve(url)
                                    return
                                }

                                resolve(body.data[0].imageUrl)
                                return
                            }

                            resolve()
                        }).catch(() => resolve())
                    })
                }

                async function getAsset(id) {
                    var info = await poopy.modules.noblox.getProductInfo(id).catch(() => { })

                    if (info) {
                        if (info.AssetTypeId === 3) {
                            var audiourl = await getAudio(id).catch(() => { })

                            if (audiourl) {
                                poopy.functions.infoPost(`Roblox audio URL detected`)
                                return audiourl
                            }
                        } else if (info.AssetTypeId === 2 || info.AssetTypeId === 11 || info.AssetTypeId === 12 || info.AssetTypeId === 13) {
                            var imageurl = await getTexture(id).catch(() => { })

                            if (imageurl) {
                                poopy.functions.infoPost(`Roblox image asset URL detected`)
                                return imageurl
                            }
                        } else if (info.AssetTypeId === 9) {
                            var gameurl = await getGame(id).catch(() => { })

                            if (gameurl) {
                                poopy.functions.infoPost(`Roblox game icon URL detected`)
                                return gameurl
                            }
                        } else {
                            var asseturl = await getThumb(id).catch(() => { })

                            if (asseturl) {
                                poopy.functions.infoPost(`Roblox asset URL detected`)
                                return asseturl
                            }
                        }
                    }
                }

                var ids = url.match(/\d+/g)
                if (ids.length) {
                    var id = ids[0]
                    var asseturl = await getAsset(id).catch(() => { })

                    if (asseturl) return asseturl
                }
            } else if (url.match(/^https\:\/\/(www\.)?roblox\.com\/(badges)\//)) {
                async function getBadge(id) {
                    return new Promise((resolve) => {
                        poopy.modules.axios.request({
                            method: 'GET',
                            url: `https://thumbnails.roblox.com/v1/badges/icons?badgeIds=${id}&size=150x150&format=Png&isCircular=false`,
                            headers: {
                                "Accept": "application/json"
                            }
                        }).then(async (res) => {
                            var body = res.data

                            if (body.data ? body.data.length > 0 : false) {
                                if (body.data[0].state === 'Pending') {
                                    var url = await getBadge(id).catch(() => { })
                                    resolve(url)
                                    return
                                }

                                resolve(body.data[0].imageUrl)
                                return
                            }

                            resolve()
                        }).catch(() => resolve())
                    })
                }

                var ids = url.match(/\d+/g)
                if (ids.length) {
                    var id = ids[0]
                    var badgeurl = await getBadge(id).catch(() => { })

                    if (badgeurl) {
                        poopy.functions.infoPost(`Roblox badge URL detected`)
                        return badgeurl
                    }
                }
            } else if (url.match(/^https\:\/\/(www\.)?roblox\.com\/(bundles)\//)) {
                async function getBundle(id) {
                    return new Promise((resolve) => {
                        poopy.modules.axios.request({
                            method: 'GET',
                            url: `https://thumbnails.roblox.com/v1/bundles/thumbnails?bundleIds=${id}&size=420x420&format=Png&isCircular=false`,
                            headers: {
                                "Accept": "application/json"
                            }
                        }).then(async (res) => {
                            var body = res.data

                            if (body.data ? body.data.length > 0 : false) {
                                if (body.data[0].state === 'Pending') {
                                    var url = await getBundle(id).catch(() => { })
                                    resolve(url)
                                    return
                                }

                                resolve(body.data[0].imageUrl)
                                return
                            }

                            resolve()
                        }).catch(() => resolve())
                    })
                }

                var ids = url.match(/\d+/g)
                if (ids.length) {
                    var id = ids[0]
                    var bundleurl = await getBundle(id).catch(() => { })

                    if (bundleurl) {
                        poopy.functions.infoPost(`Roblox bundle URL detected`)
                        return bundleurl
                    }
                }
            } else if (url.match(/^https\:\/\/(www\.)?roblox\.com\/(game-pass)\//)) {
                async function getGamePass(id) {
                    return new Promise((resolve) => {
                        poopy.modules.axios.request({
                            method: 'GET',
                            url: `https://thumbnails.roblox.com/v1/game-passes?gamePassIds=${id}&size=150x150&format=Png&isCircular=false`,
                            headers: {
                                "Accept": "application/json"
                            }
                        }).then(async (res) => {
                            var body = res.data

                            if (body.data ? body.data.length > 0 : false) {
                                if (body.data[0].state === 'Pending') {
                                    var url = await getGamePass(id).catch(() => { })
                                    resolve(url)
                                    return
                                }

                                resolve(body.data[0].imageUrl)
                                return
                            }

                            resolve()
                        }).catch(() => resolve())
                    })
                }

                var ids = url.match(/\d+/g)
                if (ids.length) {
                    var id = ids[0]
                    var gamepassurl = await getGamePass(id).catch(() => { })

                    if (gamepassurl) {
                        poopy.functions.infoPost(`Roblox gamepass URL detected`)
                        return gamepassurl
                    }
                }
            } else if (url.match(/^https\:\/\/(www\.)?roblox\.com\/(users)\//)) {
                async function getUser(id) {
                    return new Promise((resolve) => {
                        poopy.modules.axios.request({
                            method: 'GET',
                            url: `https://thumbnails.roblox.com/v1/users/avatar?userIds=${id}&size=720x720&format=Png&isCircular=false`,
                            headers: {
                                "Accept": "application/json"
                            }
                        }).then(async (res) => {
                            var body = res.data

                            if (body.data ? body.data.length > 0 : false) {
                                if (body.data[0].state === 'Pending') {
                                    var url = await getUser(id).catch(() => { })
                                    resolve(url)
                                    return
                                }

                                resolve(body.data[0].imageUrl)
                                return
                            }

                            resolve()
                        }).catch(() => resolve())
                    })
                }

                var ids = url.match(/\d+/g)
                if (ids.length) {
                    var id = ids[0]
                    var userurl = await getUser(id).catch(() => { })

                    if (userurl) {
                        poopy.functions.infoPost(`Roblox avatar URL detected`)
                        return userurl
                    }
                }
            } else if (url.match(/^https\:\/\/(www\.)?roblox\.com\/(groups)\//)) {
                async function getGroup(id) {
                    return new Promise((resolve) => {
                        poopy.modules.axios.request({
                            method: 'GET',
                            url: `https://thumbnails.roblox.com/v1/groups/icons?groupIds=${id}&size=420x420&format=Png&isCircular=false`,
                            headers: {
                                "Accept": "application/json"
                            }
                        }).then(async (res) => {
                            var body = res.data

                            if (body.data ? body.data.length > 0 : false) {
                                if (body.data[0].state === 'Pending') {
                                    var url = await getGroup(id).catch(() => { })
                                    resolve(url)
                                    return
                                }

                                resolve(body.data[0].imageUrl)
                                return
                            }

                            resolve()
                        }).catch(() => resolve())
                    })
                }

                var ids = url.match(/\d+/g)
                if (ids.length) {
                    var id = ids[0]
                    var groupurl = await getGroup(id).catch(() => { })

                    if (groupurl) {
                        poopy.functions.infoPost(`Roblox group icon URL detected`)
                        return groupurl
                    }
                }
            } else if (url.match(/^https\:\/\/((www|m)\.)?youtube\.com|^https\:\/\/(www\.)?youtu\.be/)) {
                var youtubeurl = await poopy.modules.youtubedl(url, {
                    format: '18',
                    'get-url': ''
                }).catch(() => { })

                if (youtubeurl) {
                    poopy.functions.infoPost(`YouTube video URL detected`)
                    return youtubeurl
                }
            } /*else if (url.match(/^https\:\/\/((www)\.)?reddit\.com\/r\/[a-zA-Z0-9][a-zA-Z0-9_]{2,20}/)) {
                var redditurl = await poopy.modules.youtubedl(url, {
                    format: '18',
                    'get-url': ''
                }).catch(() => { })

                if (redditurl) return redditurl
            }*/ else if (url.match(/^https\:\/\/((www)\.)?(fx)?twitter\.com\/\w{4,15}\/status\/\d+/)) {
                async function getImageUrl(url) {
                    return new Promise((resolve) => {
                        poopy.modules.axios.request(url).then(async (res) => {
                            var $ = poopy.modules.cheerio.load(res.data)
                            var urls = $('div .AdaptiveMedia-photoContainer.js-adaptive-photo')

                            if (urls.length > 0) {
                                resolve(urls[0].attribs['data-image-url'])
                                return
                            }

                            resolve()
                        }).catch(() => resolve())
                    })
                }

                async function getGifUrl(url) {
                    var twittergifurl = await poopy.modules.youtubedl(url, {
                        format: 'http',
                        'get-url': ''
                    }).catch(() => { })

                    return twittergifurl
                }

                async function getVidUrl(url) {
                    var twittervidurl = await poopy.modules.youtubedl(url, {
                        format: 'http-832',
                        'get-url': ''
                    }).catch(() => { })

                    return twittervidurl
                }

                var twittervidurl = await getVidUrl(url).catch(() => { })
                var twittergifurl = await getGifUrl(url).catch(() => { })
                var twitterimageurl = await getImageUrl(url).catch(() => { })

                if (twittervidurl) {
                    poopy.functions.infoPost(`Twitter video URL detected`)
                    return twittervidurl
                }

                if (twittergifurl) {
                    poopy.functions.infoPost(`Twitter GIF URL detected`)
                    return twittergifurl
                }

                if (twitterimageurl) {
                    poopy.functions.infoPost(`Twitter image URL detected`)
                    return twitterimageurl
                }
            }

            return url
        }

        poopy.functions.getUrls = async function (msg, options = {}) {
            if (!msg) return []
            var string = (options.string ?? msg.content ?? '').replace(/"([\s\S]*?)"/g, '')
            var prefixFound = options.prefix ?? string.toLowerCase().includes(poopy.data['guild-data'][msg.guild.id]['prefix'].toLowerCase())
            var max = options.max ?? Infinity
            var urls = []
            var regexes = [
                {
                    regexp: poopy.vars.emojiRegex,
                    func: async function (emoji) {
                        var codepoints = []
                        for (var j = 0; j < [...emoji].length; j++) {
                            codepoints.push([...emoji][j].codePointAt().toString(16).padStart(4, '0'))
                        }
                        var emojiimage = poopy.json.emojiJSON.find(image => image.unicode === codepoints.join('-'))
                        if (emojiimage) {
                            poopy.functions.infoPost(`Emoji URL detected`)
                            return emojiimage.url
                        }
                    }
                },
                {
                    regexp: /<a?:[a-zA-Z\d_]+?:\d+>/g,
                    func: async function (demoji) {
                        var demojiidmatch = demoji.match(/\d+/g)
                        var demojiid = demojiidmatch[demojiidmatch.length - 1]
                        var gifurl = `https://cdn.discordapp.com/emojis/${demojiid}.gif?size=1024`
                        var pngurl = `https://cdn.discordapp.com/emojis/${demojiid}.png?size=1024`
                        var demojiurls = [gifurl, pngurl]
                        var demojiurl = undefined
                        for (var i in demojiurls) {
                            var url = demojiurls[i]
                            var response = await poopy.modules.axios.request({
                                url: url,
                                validateStatus: () => true
                            }).catch(() => { })
                            if (response && response.status >= 200 && response.status < 300) {
                                demojiurl = url
                                break
                            }
                        }
                        if (demojiurl) {
                            poopy.functions.infoPost(`Server emoji URL detected`)
                            return demojiurl
                        }
                    }
                },
                {
                    regexp: /\d{10,}/g,
                    func: async function (id) {
                        var user = await poopy.bot.users.fetch(id).catch(() => { })
                        if (user) {
                            poopy.functions.infoPost(`Discord avatar URL detected`)
                            return user.displayAvatarURL({ dynamic: true, size: 1024, format: 'png' })
                        }
                    }
                },
                {
                    regexp: /temp:[a-zA-Z0-9_-]{10}/g,
                    func: async function (url) {
                        var id = url.substring(5)
                        var tempfile = poopy.tempfiles[id]

                        if (tempfile) {
                            poopy.functions.infoPost(`Tempfile detected`)
                            return options.tempdir ? `tempfiles/${poopy.config.mongodatabase}/${tempfile.name}` : url
                        }
                    }
                },
                {
                    regexp: poopy.vars.validUrl,
                    func: async function (url) {
                        var correctedurl = await poopy.functions.correctUrl(url).catch(() => { }) ?? url

                        if (correctedurl == url) poopy.functions.infoPost(`Default URL detected`)

                        return correctedurl
                    }
                }
            ]

            if (!prefixFound) {
                regexes.splice(0, 3)
            }

            var urlregex = new RegExp(regexes.map(regex => `(${regex.regexp.source})`).join('|'), 'g')

            var matches = string.match(urlregex)
            if (matches) {
                var matchesr = matches.reverse()
                for (var i in matchesr) {
                    var match = matchesr[i]
                    var matched = []
                    regexes.forEach(regex => {
                        var m = match.match(regex.regexp)
                        if (m) {
                            regex.length = m[0].length
                            matched.push(regex)
                        }
                    })
                    matched.sort(function (a, b) {
                        return b.length - a.length
                    })
                    var url = await matched[0].func(match).catch(() => { })
                    if (url) {
                        urls = [url].concat(urls)
                    }
                    if (urls.length >= max) break
                }
            }

            if (msg.embeds.length) {
                var embedsR = []
                msg.embeds.forEach(embed => {
                    if ((options.update && embed.fetched) || embed.type != 'rich' || !embed.image || !embed.image.url) return
                    embedsR.push(embed.image.url)
                    if (options.update && !embed.fetched) embed.fetched = true
                })
                embedsR.reverse()
                for (var i in embedsR) {
                    var embed = embedsR[i]
                    urls = [embed].concat(urls)
                    if (urls.length >= max) break
                }
            }

            if (msg.attachments.size) {
                var attachmentsR = []
                msg.attachments.forEach(attachment => {
                    if (options.update && attachment.fetched) return
                    attachmentsR.push(attachment.url)
                    if (options.update && !attachment.fetched) attachment.fetched = true
                })
                attachmentsR.reverse()
                for (var i in attachmentsR) {
                    var attachment = attachmentsR[i]
                    urls = [attachment].concat(urls)
                    if (urls.length >= max) break
                }
            }

            if (msg.stickers.size) {
                var stickersR = []
                msg.stickers.forEach(sticker => {
                    if (options.update && sticker.fetched) return
                    stickersR.push(`https://cdn.discordapp.com/stickers/${sticker.id}.png`)
                    if (options.update && !sticker.fetched) sticker.fetched = true
                })
                stickersR.reverse()
                for (var i in stickersR) {
                    var sticker = stickersR[i]
                    urls = [sticker].concat(urls)
                    if (urls.length >= max) break
                }
            }

            var reply = await msg.fetchReference().catch(() => { })
            if (reply && !options.replied && msg.author.id != poopy.bot.user.id && prefixFound) {
                urls = urls.concat(await poopy.functions.getUrls(reply, {
                    replied: true,
                    max: max - urls.length,
                    tempdir: options.tempdir
                }) ?? [])
            }

            if (options.update) {
                var urlsr = urls.reverse()
                for (var i in urlsr) {
                    var url = urlsr[i]

                    if (url) {
                        poopy.functions.addLastUrl(msg, url)
                    }
                }
            }

            if (urls.length > 0) poopy.functions.infoPost(`Found ${urls.length} URL${urls.length > 1 ? 's' : ''} in message`)

            return urls
        }

        poopy.functions.lastUrl = function (msg, i, tempdir, global) {
            var urlsGlobal = !global &&
                poopy.tempdata[msg.author.id][msg.id]?.['lastUrls'] ||
                poopy.data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrls']
            var urls = urlsGlobal.slice()
            var url = urls[i]

            if (url === null) {
                urls.splice(i, 1)
                urlsGlobal.splice(i, 1)
                return poopy.functions.lastUrl(msg, i, tempdir)
            }

            if (url.startsWith('temp:')) {
                var id = url.substring(5)
                var tempfile = poopy.tempfiles[id]
                if (!tempfile) {
                    urls.splice(i, 1)
                    urlsGlobal.splice(i, 1)
                    return poopy.functions.lastUrl(msg, i, tempdir)
                } else if (tempdir) {
                    url = `tempfiles/${poopy.config.mongodatabase}/${tempfile.name}`
                }
            }

            return url
        }

        poopy.functions.lastUrls = function (msg, tempdir, global) {
            var urlsGlobal = !global &&
                poopy.tempdata[msg.author.id][msg.id]?.['lastUrls'] ||
                poopy.data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrls']
            var urls = urlsGlobal.slice()

            for (var i = 0; i < urls.length; i++) {
                var url = urls[i]

                if (url === null) {
                    urls.splice(i, 1)
                    urlsGlobal.splice(i, 1)
                    i--
                    continue
                }

                if (url.startsWith('temp:')) {
                    var id = url.substring(5)
                    var tempfile = poopy.tempfiles[id]
                    if (!tempfile) {
                        urls.splice(i, 1)
                        urlsGlobal.splice(i, 1)
                        i--
                        continue
                    } else if (tempdir) {
                        urls[i] = `tempfiles/${poopy.config.mongodatabase}/${tempfile.name}`
                    }
                }
            }

            return urls
        }

        poopy.functions.addLastUrl = function (msg, url) {
            if (!url) return

            if (poopy.tempdata[msg.author.id][msg.id]) {
                var lastUrls = [url].concat(poopy.functions.lastUrls(msg))
                lastUrls.splice(100)
                poopy.tempdata[msg.author.id][msg.id]['lastUrls'] = lastUrls
            }

            var lastUrls = [url].concat(poopy.functions.lastUrls(msg, false, true))
            lastUrls.splice(100)
            poopy.data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrls'] = lastUrls
        }

        poopy.functions.rateLimit = async function (msg) {
            if (!poopy.tempdata[msg.author.id]) poopy.tempdata[msg.author.id] = {}

            poopy.tempdata[msg.author.id]['ratelimit'] = (poopy.tempdata[msg.author.id]['ratelimit'] ?? 0) + 1
            setTimeout(() => poopy.tempdata[msg.author.id]['ratelimit'] - 1, 60000)

            if (poopy.tempdata[msg.author.id]['ratelimit'] >= poopy.config.rateLimit) {
                poopy.tempdata[msg.author.id]['ratelimits'] = (poopy.tempdata[msg.author.id]['ratelimits'] ?? 0.5) * 2
                var rateLimitTime = poopy.config.rateLimitTime * poopy.tempdata[msg.author.id]['ratelimits']
                setTimeout(() => {
                    poopy.tempdata[msg.author.id]['ratelimits'] -= 1
                }, rateLimitTime * 2)

                await msg.reply(`you've been banned from using commands for ${rateLimitTime / 60000} minutes for crashing the file processor ${poopy.config.rateLimit * poopy.tempdata[msg.author.id]['ratelimits']} times LMAO!!!`).catch(() => { })
                poopy.tempdata[msg.author.id]['ratelimited'] = Date.now() + rateLimitTime
                setTimeout(() => {
                    delete poopy.tempdata[msg.author.id]['ratelimited']
                }, rateLimitTime)
                return true
            }

            return false
        }

        poopy.functions.deleteMsgData = function (msg) {
            if (
                poopy.tempdata[msg.author.id] &&
                poopy.tempdata[msg.author.id][msg.id] &&
                (
                    !poopy.tempdata[msg.author.id][msg.id]['keyexecuting'] ||
                    poopy.tempdata[msg.author.id][msg.id]['keyexecuting'] <= 0
                )
            ) {
                delete poopy.tempdata[msg.author.id][msg.id]
            }
        }

        poopy.vars.dmGuild = class DMGuild {
            constructor(msg) {
                this.ownerId = msg.channel.ownerId || (msg.user || msg.author).id
                this.id = msg.channel.id
                this.name = msg.channel.name || `${(msg.user || msg.author).username}'s DMs`
                this.fetchAuditLogs = async () => {
                    return {
                        entries: new poopy.modules.DiscordCollection.Collection()
                    }
                }
                this.emojis = {
                    cache: new poopy.modules.DiscordCollection.Collection()
                }
                this.channels = {
                    cache: new poopy.modules.DiscordCollection.Collection([[msg.channel.id, msg.channel]])
                }
                this.members = {
                    fetch: async () => msg.channel.recipient ? (msg.channel.recipient.id == id && msg.channel.recipient) : msg.channel.recipients && msg.channel.recipients.get(id),
                    resolve: (id) => msg.channel.recipient ? (msg.channel.recipient.id == id && msg.channel.recipient) : msg.channel.recipients && msg.channel.recipients.get(id),
                    cache: new poopy.modules.DiscordCollection.Collection(msg.channel.recipients ? msg.channel.recipients.map(user => [user.id, user]) : [[msg.channel.recipient.id, msg.channel.recipient]])
                }
            }
        }

        poopy.functions.dmSupport = function (msg) {
            if (!msg.author && msg.user) msg.author = msg.user
            if (!msg.user && msg.author) msg.user = msg.author

            if (!msg.member && (msg.user || msg.author)) Object.defineProperty(msg, 'member', {
                value: (msg.user || msg.author),
                writable: true
            })

            if (!msg.guild && (msg.user || msg.author)) Object.defineProperty(msg, 'guild', {
                value: new poopy.vars.dmGuild(msg),
                writable: true
            })

            if (msg.channel && !msg.channel.guild && (msg.user || msg.author)) Object.defineProperty(msg.channel, 'guild', {
                value: new poopy.vars.dmGuild(msg),
                writable: true
            })

            if ((msg.user || msg.author) && !(msg.user || msg.author).permissions) (msg.user || msg.author).permissions = { has: () => true }
            if (msg.channel && !msg.channel.permissionsFor) msg.channel.permissionsFor = () => {
                return { has: () => true }
            }

            if (msg.mentions) {
                if (!msg.mentions.members) Object.defineProperty(msg.mentions, 'members', {
                    value: new poopy.modules.DiscordCollection.Collection(msg.mentions.users ? msg.mentions.users.map(user => {
                        if (!user.user) user.user = user
                        return [user.id, user]
                    }) : []),
                    writable: true
                })
                if (!msg.mentions.users) Object.defineProperty(msg.mentions, 'users', {
                    value: new poopy.modules.DiscordCollection.Collection(msg.mentions.members ? msg.mentions.members.map(member => [member.user.id, member.user]) : []),
                    writable: true
                })
            }
        }

        poopy.functions.getKeywordsFor = async function (string, msg, isBot, { extrakeys = {}, extrafuncs = {}, resetattempts = false, ownermode = false, declaredonly = false } = {}) {
            if (!poopy.tempdata[msg.author.id]) {
                poopy.tempdata[msg.author.id] = {}
            }

            if (!poopy.tempdata[msg.author.id][msg.id]) {
                poopy.tempdata[msg.author.id][msg.id] = {}
            }

            var startTime = Date.now()
            var extradkeys = declaredonly ? { ...poopy.tempdata[msg.author.id]['keydeclared'] } : { ...extrakeys, ...poopy.tempdata[msg.author.id]['keydeclared'] }
            var extradfuncs = declaredonly ? { ...poopy.tempdata[msg.author.id]['funcdeclared'] } : { ...extrafuncs, ...poopy.tempdata[msg.author.id]['funcdeclared'] }
            var started = false

            if (poopy.tempdata[msg.author.id]['ratelimited'] || poopy.functions.globalData()['bot-data']['shit'].find(id => id === msg.author.id)) {
                return string
            }

            while (poopy.functions.getKeyFunc(string, { extrakeys: extradkeys, extrafuncs: extradfuncs, declaredonly: declaredonly }) !== false && poopy.tempdata[msg.author.id][msg.id]?.['return'] == undefined) {
                if (!started || !poopy.tempdata[msg.author.id][msg.id]) {
                    if (!poopy.tempdata[msg.author.id][msg.id]) {
                        poopy.tempdata[msg.author.id][msg.id] = {}
                    }

                    if (!poopy.tempdata[msg.author.id][msg.id]['keyattempts']) {
                        poopy.tempdata[msg.author.id][msg.id]['keyattempts'] = 0
                    }

                    if (!poopy.tempdata[msg.author.id][msg.id]['keyexecuting']) {
                        poopy.tempdata[msg.author.id][msg.id]['keyexecuting'] = 0
                    }

                    if (!poopy.tempdata[msg.author.id][msg.id]['keywordsExecuted']) {
                        poopy.tempdata[msg.author.id][msg.id]['keywordsExecuted'] = []
                    }

                    if (!poopy.tempdata[msg.author.id]['arrays']) {
                        poopy.tempdata[msg.author.id]['arrays'] = {}
                    }

                    if (!poopy.tempdata[msg.author.id]['declared']) {
                        poopy.tempdata[msg.author.id]['declared'] = {}
                    }

                    if (!poopy.tempdata[msg.author.id]['keydeclared']) {
                        poopy.tempdata[msg.author.id]['keydeclared'] = {}
                    }

                    if (!poopy.tempdata[msg.author.id]['funcdeclared']) {
                        poopy.tempdata[msg.author.id]['funcdeclared'] = {}
                    }

                    if (resetattempts) poopy.tempdata[msg.author.id][msg.id]['keyexecuting']++
                    started = true
                }

                if (poopy.tempdata[msg.author.id]['ratelimited'] || poopy.functions.globalData()['bot-data']['shit'].find(id => id === msg.author.id)) {
                    return string
                }

                if (poopy.tempdata[msg.author.id][msg.id]['keyattempts'] >= poopy.config.keyLimit) {
                    poopy.functions.infoPost(`Keyword attempts value exceeded`)
                    return 'Keyword attempts value exceeded.'
                }

                var keydata = poopy.functions.getKeyFunc(string, {
                    extrakeys: extradkeys,
                    extrafuncs: extradfuncs,
                    declaredonly: declaredonly
                })

                var opts = {
                    extrakeys: extradkeys,
                    extrafuncs: extradfuncs,
                    ownermode: ownermode
                }

                switch (keydata.type) {
                    case 'key':
                        var keyName = keydata.match
                        var key = poopy.special.keys[keydata.match] || extradkeys[keydata.match]

                        if ((key.limit != undefined && poopy.functions.equalValues(poopy.tempdata[msg.author.id][msg.id]['keywordsExecuted'], keyName) >= key.limit) ||
                            (key.cmdconnected && poopy.data['guild-data'][msg.guild.id]['disabled'].find(cmd => cmd.find(n => n === key.cmdconnected)))) {
                            string = string.replace(keydata.match, '')
                            break
                        }

                        poopy.tempdata[msg.author.id][msg.id]['keywordsExecuted'].push(keyName)

                        var change

                        if (key.func.constructor.name == 'AsyncFunction') {
                            change = await key.func.call(poopy, msg, isBot, string, opts).catch(() => { }) ?? ''
                        } else {
                            change = key.func.call(poopy, msg, isBot, string, opts)
                        }

                        string = typeof (change) === 'object' && change[1] === true ? String(change[0]) : string.replace(keydata.match, String(change).replace(/\$&/g, '$\\&'))
                        poopy.tempdata[msg.author.id][msg.id]['keyattempts'] += key.attemptvalue ?? 1
                        break

                    case 'func':
                        var [funcName, match] = keydata.match
                        var func = poopy.special.functions[funcName] || extradfuncs[funcName]
                        var m = match

                        if ((func.limit != undefined && poopy.functions.equalValues(poopy.tempdata[msg.author.id][msg.id]['keywordsExecuted'], funcName) >= func.limit) ||
                            (func.cmdconnected && poopy.data['guild-data'][msg.guild.id]['disabled'].find(cmd => cmd.find(n => n === func.cmdconnected)))) {
                            string = string.replace(`${funcName}(${match})`, '')
                            break
                        }

                        poopy.tempdata[msg.author.id][msg.id]['keywordsExecuted'].push(funcName)

                        match = match.replace(/\\\)/g, ')')
                        if (!func.raw) {
                            string = string.replace(m, match)
                        }

                        var change

                        if (func.func.constructor.name == 'AsyncFunction') {
                            change = await func.func.call(poopy, [funcName, match], msg, isBot, string, opts).catch(() => { }) ?? ''
                        } else {
                            change = func.func.call(poopy, [funcName, match], msg, isBot, string, opts)
                        }

                        string = typeof (change) === 'object' && change[1] === true ? String(change[0]) : string.replace(`${funcName}(${match})`, String(change).replace(/\$&/g, '$\\&'))
                        poopy.tempdata[msg.author.id][msg.id]['keyattempts'] += func.attemptvalue ?? 1
                        break
                }

                extradkeys = declaredonly ? { ...poopy.tempdata[msg.author.id]['keydeclared'] } : { ...extrakeys, ...poopy.tempdata[msg.author.id]['keydeclared'] }
                extradfuncs = declaredonly ? { ...poopy.tempdata[msg.author.id]['funcdeclared'] } : { ...extrafuncs, ...poopy.tempdata[msg.author.id]['funcdeclared'] }

                await poopy.functions.sleep()
            }

            if (resetattempts) {
                if (poopy.tempdata[msg.author.id][msg.id]['keywordsExecuted']) {
                    if (poopy.tempdata[msg.author.id][msg.id]['keywordsExecuted'].length) {
                        poopy.functions.infoPost(`Took ${(Date.now() - startTime) / 1000} seconds to execute keywords/functions: ${poopy.tempdata[msg.author.id][msg.id]['keywordsExecuted'].map(k => `\`${k}\``).join(', ')}`)
                    }
                    poopy.tempdata[msg.author.id][msg.id]['keywordsExecuted'] = []
                }

                if (poopy.tempdata[msg.author.id][msg.id]['keyexecuting'])
                    poopy.tempdata[msg.author.id][msg.id]['keyexecuting']--
            }

            if (poopy.tempdata[msg.author.id][msg.id]['return'] != undefined) {
                string = poopy.tempdata[msg.author.id][msg.id]['return']
                delete poopy.tempdata[msg.author.id][msg.id]['return']
            }

            return string
        }

        poopy.functions.battle = async function (msg, subject, action, damage, chance) {
            await msg.channel.sendTyping().catch(() => { })
            var attachments = []
            msg.attachments.forEach(attachment => {
                attachments.push(new poopy.modules.Discord.MessageAttachment(attachment.url))
            });

            if (!subject && attachments.length <= 0) {
                await msg.reply('What/who is the subject?!').catch(() => { })
                return;
            };

            if (Math.random() >= chance) {
                await msg.reply('You missed!').catch(() => { })
                return
            }

            var member = (msg.mentions.members.first() && msg.mentions.members.first().user) ??
                await poopy.bot.users.fetch((subject.match(/\d+/) ?? [subject])[0]).catch(() => { })

            await msg.reply({
                content: action
                    .replace('{src}', msg.author.username)
                    .replace('{trgt}', (member && member.username) ?? subject ?? 'this')
                    .replace('{dmg}', damage),
                allowedMentions: {
                    parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                },
                files: attachments
            }).catch(() => { })

            if (!member) return

            if (!poopy.data['user-data'][member.id]) {
                poopy.data['user-data'][member.id] = {}
                poopy.data['user-data'][member.id]['health'] = 100
            }

            poopy.data['user-data'][member.id]['health'] = poopy.data['user-data'][member.id]['health'] - damage
            if (poopy.data['user-data'][member.id]['health'] <= 0) {
                poopy.data['user-data'][member.id]['health'] = 100
                await msg.reply({
                    content: `**${member.username}** died!`,
                    allowedMentions: {
                        parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                    }
                }).catch(() => { })
            }
        }

        poopy.functions.fetchImages = async function (query, bing, safe) {
            return new Promise(async (resolve) => {
                if (bing) {
                    var options = {
                        method: 'GET',
                        url: 'https://bing-image-search1.p.rapidapi.com/images/search',
                        params: { q: query, count: '100', safeSearch: safe ? 'moderate' : 'off' },
                        headers: {
                            'x-rapidapi-host': 'bing-image-search1.p.rapidapi.com',
                            'x-rapidapi-key': poopy.functions.randomKey('RAPIDAPIKEY')
                        }
                    }

                    var response = await poopy.modules.axios.request(options).catch(() => { })

                    if (!response) {
                        resolve([])
                        return
                    }

                    if (!(response.status >= 200 && response.status < 300)) {
                        resolve([])
                        return
                    }

                    var images = []
                    var body = response.data

                    if (body.value ? body.value.length > 0 : false) {
                        images = body.value.map(result => result.contentUrl)
                    }

                    resolve(images)
                } else {
                    poopy.modules.gis({
                        searchTerm: query,
                        queryStringAddition: `&safe=${safe ? 'active' : 'images'}`
                    }, async function (_, results) {
                        var images = []

                        for (var i in results) {
                            var result = results[i]
                            var url = result.url.replace(/\\u([a-z0-9]){4}/g, (match) => {
                                return String.fromCharCode(Number('0x' + match.substring(2, match.length)))
                            })

                            images.push(url)
                        }

                        resolve(images)
                    })
                }
            })
        }

        poopy.functions.downloadFile = async function (url, filename, options) {
            url = url || ' '
            options = options || {}
            var filepath
            var ffmpegUsed = false

            if (options.filepath) {
                filepath = options.filepath
            } else {
                var currentcount = poopy.vars.filecount
                poopy.vars.filecount++
                poopy.modules.fs.mkdirSync(`temp/${poopy.config.mongodatabase}/file${currentcount}`)
                filepath = `temp/${poopy.config.mongodatabase}/file${currentcount}`
            }

            async function ffmpeg() {
                ffmpegUsed = true
                poopy.functions.infoPost(`Downloading file through FFmpeg with name \`${filename}\``)
                if (options.fileinfo) {
                    await poopy.functions.execPromise(`ffmpeg -i "${url}"${options.ffmpegstring ? ` ${options.ffmpegstring}` : options.fileinfo.shortext === 'gif' ? ` -filter_complex "[0:v]split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -gifflags -offsetting` : options.fileinfo.shortext === 'png' ? ' -pix_fmt rgba' : options.fileinfo.shortext === 'mp4' ? ' -c:v libx264 -pix_fmt yuv420p' : options.fileinfo.shortext === 'mp3' ? ' -c:a libmp3lame' : ''} ${filepath}/${filename}`)
                } else {
                    await poopy.functions.execPromise(`ffmpeg -i "${url}"${options.ffmpegstring ? ` ${options.ffmpegstring}` : ''} ${filepath}/${filename}`)
                }
            }

            if (!options.buffer && url.startsWith('temp:')) {
                options.buffer = true
                url = poopy.modules.fs.readFileSync(`tempfiles/${poopy.config.mongodatabase}/${poopy.tempfiles[url.substring(5)].name}`)
            }

            if (options.buffer) {
                poopy.functions.infoPost(`Downloading file through buffer with name \`${filename}\``)
                poopy.modules.fs.writeFileSync(`${filepath}/${filename}`, url)
            } else if (((!(options.fileinfo) ? true : ((options.fileinfo.shortext === options.fileinfo.type.ext) && (options.fileinfo.shortpixfmt === options.fileinfo.info.pixfmt))) || options.http) && !(options.ffmpeg)) {
                poopy.functions.infoPost(`Downloading file through URL with name \`${filename}\``)
                var response = await poopy.modules.axios.request({
                    method: 'GET',
                    url: url,
                    responseType: 'arraybuffer'
                }).catch(() => { })

                if (response) {
                    poopy.modules.fs.writeFileSync(`${filepath}/${filename}`, response.data)
                }
            } else {
                await ffmpeg()
            }

            if (options.convert && !ffmpegUsed) {
                await ffmpeg()
            }

            poopy.functions.infoPost(`Successfully downloaded \`${filename}\` in \`${filepath}\``)

            return filepath
        }

        poopy.functions.sendFile = async function (msg, filepath, filename, extraOptions) {
            extraOptions = extraOptions || {}

            var returnUrl

            var prefix = poopy.data['guild-data'][msg.guild.id]['prefix']
            var args = msg.content.substring(prefix.toLowerCase().length).split(' ')

            extraOptions.catbox = args.find(arg => arg === '-catbox') || extraOptions.catbox || false
            extraOptions.nosend = args.find(arg => arg === '-nosend') || extraOptions.nosend || false

            var nameindex = args.indexOf('-filename')
            if (nameindex > -1 && args[nameindex + 1]) {
                extraOptions.name = args[nameindex + 1].replace(/[/\\?%*:|"<>]/g, '-').substring(0, 128)
            }

            try {
                poopy.modules.fs.readFileSync(`${filepath}/${filename}`)
            } catch (_) {
                await msg.reply('Couldn\'t send file.').catch(() => { })
                poopy.functions.infoPost(`Couldn\'t send file`)
                await poopy.functions.rateLimit(msg)

                if (extraOptions.keep ||
                    filepath == undefined ||
                    filepath.startsWith('tempfiles')) return

                poopy.modules.fs.rm(filepath, { force: true, recursive: true })
                return
            }

            if (extraOptions.name) {
                poopy.modules.fs.renameSync(`${filepath}/${filename}`, `${filepath}/${extraOptions.name}`)
                filename = extraOptions.name
            }

            if (extraOptions.catbox) {
                poopy.functions.infoPost(`Uploading file to catbox.moe`)
                var fileLink = await poopy.vars[extraOptions.nosend ? 'Litterbox' : 'Catbox'].upload(`${filepath}/${filename}`).catch(() => { })
                if (fileLink) {
                    var isUrl = poopy.vars.validUrl.test(fileLink)

                    if (extraOptions.nosend) {
                        if (isUrl) {
                            poopy.functions.addLastUrl(msg, fileLink)
                        } else {
                            await msg.reply(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                            poopy.functions.infoPost(`Couldn\'t upload catbox.moe file, reason:\n\`${fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink}\``)
                        }
                    } else {
                        await msg.reply(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                        if (!isUrl) {
                            poopy.functions.infoPost(`Couldn\'t upload catbox.moe file, reason:\n\`${fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink}\``)
                        }
                    }

                    if (isUrl) returnUrl = fileLink
                } else {
                    await msg.reply('Couldn\'t send file.').catch(() => { })
                    poopy.functions.infoPost(`Couldn\'t upload catbox.moe file`)
                    await poopy.functions.rateLimit(msg)
                }
            } else if (extraOptions.nosend) {
                poopy.functions.infoPost(`Saving file temporarily`)

                var id = poopy.functions.generateId(poopy.modules.fs.readdirSync(`tempfiles/${poopy.config.mongodatabase}`).map(file => {
                    var name = file.split('.')
                    if (name.length > 1) name = name.slice(0, name.length - 1)
                    else name = name[0]
                    return name
                }))

                var ext = filename.split('.')
                if (ext.length > 1) ext = `.${ext[ext.length - 1]}`
                else ext = ''

                poopy.modules.fs.copyFileSync(`${filepath}/${filename}`, `tempfiles/${poopy.config.mongodatabase}/${id}${ext}`)

                poopy.tempfiles[id] = {
                    name: `${id}${ext}`,
                    oname: filename,
                    opath: filepath
                }

                poopy.functions.addLastUrl(msg, `temp:${id}`)

                returnUrl = `temp:${id}`

                setTimeout(() => {
                    poopy.modules.fs.rmSync(`tempfiles/${poopy.config.mongodatabase}/${id}${ext}`, { force: true, recursive: true })
                    delete poopy.tempfiles[id]
                }, 600000)
            } else {
                poopy.functions.infoPost(`Sending file to channel`)
                var sendObject = {
                    files: [new poopy.modules.Discord.MessageAttachment(`${filepath}/${filename}`)]
                }

                if (extraOptions.content) sendObject.content = extraOptions.content

                var fileMsg = await msg.reply(sendObject).catch(() => { })

                if (!fileMsg) {
                    await msg.reply('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                    poopy.functions.infoPost(`Failed to send file to channel, uploading to catbox.moe`)
                    var fileLink = await poopy.vars.Catbox.upload(`${filepath}/${filename}`).catch(() => { })
                    if (fileLink) {
                        var isUrl = poopy.vars.validUrl.test(fileLink)
                        await msg.reply(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })

                        if (!isUrl) {
                            poopy.functions.infoPost(`Couldn\'t upload catbox.moe file, reason:\n\`${fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink}\``)
                        } else returnUrl = fileLink
                    } else {
                        await msg.reply('Couldn\'t send file.').catch(() => { })
                        poopy.functions.infoPost(`Couldn\'t upload catbox.moe file`)
                        await poopy.functions.rateLimit(msg)
                    }
                } else returnUrl = fileMsg.attachments.first().url
            }

            if (extraOptions.keep ||
                filepath == undefined ||
                filepath.startsWith('tempfiles')) return returnUrl

            poopy.functions.infoPost(`Deleting \`${filepath}/${filename}\` and its folder`)

            poopy.modules.fs.rm(filepath, { force: true, recursive: true })
            return returnUrl
        }

        poopy.functions.validateFileFromPath = async function (path, exception, rejectMessages) {
            return new Promise(async (resolve, reject) => {
                var rej = reject
                reject = function (val) {
                    poopy.functions.infoPost(`File can't be processed, reason:\n\`${val}\``)
                    rej(val)
                }

                poopy.functions.infoPost(`Validating file from path`)

                if ((process.memoryUsage().rss / 1024 / 1024) <= poopy.config.memLimit) {
                    reject('No resources available.')
                    return
                }

                if (!poopy.modules.fs.existsSync(path)) {
                    reject('File not found.')
                    return
                }

                var type = await poopy.modules.fileType.fromFile(path).catch(() => { })

                if (!type) {
                    var body = poopy.modules.fs.readFileSync(path).toString()
                    type = { mime: body.match(/<[a-z][\s\S]*>([\s\S]*)<\/[a-z][\s\S]*>/g) ? 'text/html' : 'text/plain', ext: body.match(/<[a-z][\s\S]*>([\s\S]*)<\/[a-z][\s\S]*>/g) ? 'html' : 'plain' }
                }

                var info = {
                    frames: 1,
                    fps: '0/0',
                    duration: 'N/A',
                    aduration: 'N/A',
                    width: 0,
                    height: 0,
                    audio: false,
                    pixfmt: 'unk',
                    size: 0,
                    realsize: 0
                }
                var names = path.split('/')
                var limitObject = exception ? poopy.config.limitsexcept : poopy.config.limits
                var shorttype
                var shortext
                var shortpixfmt

                if (type.mime.startsWith('image') && !(poopy.vars.gifFormats.find(f => f === type.ext))) {
                    shorttype = 'image'
                    shortext = 'png'
                    shortpixfmt = 'rgba'
                } else if (type.mime.startsWith('video')) {
                    shorttype = 'video'
                    shortext = 'mp4'
                    shortpixfmt = 'yuv420p'
                } else if (type.mime.startsWith('image') && poopy.vars.gifFormats.find(f => f === type.ext)) {
                    shorttype = 'gif'
                    shortext = 'gif'
                    shortpixfmt = 'bgra'
                } else if (type.mime.startsWith('audio')) {
                    shorttype = 'audio'
                    shortext = 'mp3'
                    shortpixfmt = 'unk'
                } else {
                    shorttype = type.mime.split('/')[0]
                    shortext = type.ext
                    shortpixfmt = 'unk'
                }

                var buffer = poopy.modules.fs.readFileSync(path)

                info.size = buffer.length / 1048576
                info.realsize = buffer.length

                var json = await poopy.functions.execPromise(`ffprobe -of json -show_streams -show_format ${path}`)
                if (json) {
                    try {
                        var jsoninfo = JSON.parse(json)
                        if (jsoninfo["streams"]) {
                            var videoStream = jsoninfo["streams"].find(stream => stream["codec_type"] === 'video')
                            var audioStream = jsoninfo["streams"].find(stream => stream["codec_type"] === 'audio')

                            if ((type.mime.startsWith('image') && poopy.vars.gifFormats.find(f => f === type.ext)) || type.mime.startsWith('video')) {
                                info.frames = videoStream["nb_frames"] || 0
                                info.fps = videoStream["r_frame_rate"] || '0/0'
                            }
                            if (type.mime.startsWith('video') || type.mime.startsWith('audio')) {
                                info.audio = !!audioStream
                            }
                            if ((type.mime.startsWith('image') && poopy.vars.gifFormats.find(f => f === type.ext)) || type.mime.startsWith('video') || type.mime.startsWith('audio')) {
                                info.duration = (videoStream || audioStream)["duration"] || 0
                            }
                            if ((type.mime.startsWith('video') || type.mime.startsWith('audio')) && info.audio) {
                                info.aduration = audioStream["duration"] || 0
                            }
                            if (type.mime.startsWith('image') || type.mime.startsWith('video')) {
                                info.width = videoStream["width"] || 0
                                info.height = videoStream["height"] || 0
                                info.pixfmt = videoStream["pix_fmt"] || 'unk'
                            }
                        }
                    } catch (_) { }
                }

                if (exception !== 'very true') {
                    for (var paramName in info) {
                        if (limitObject[paramName]) {
                            var param = info[paramName]
                            var rejectMessage = rejectMessages ? rejectMessages[paramName] : limitObject[paramName]['message']

                            if (param > limitObject[paramName][shorttype]) {
                                reject(rejectMessage.replace('{param}', limitObject[paramName][shorttype]))
                                return
                            }
                        }
                    }
                }

                poopy.functions.infoPost(`File \`${names[names.length - 1]}\` was successfully validated`)

                resolve({
                    type: type,
                    shorttype: shorttype,
                    shortext: shortext,
                    shortpixfmt: shortpixfmt,
                    name: names[names.length - 1],
                    info: info,
                    path: `data:${type.mime};base64,${buffer.toString('base64')}`,
                    buffer: buffer
                })
            })
        }

        poopy.functions.validateFile = async function (url, exception, rejectMessages) {
            return new Promise(async (resolve, reject) => {
                url = url || ' '
                var rej = reject
                reject = function (val) {
                    poopy.functions.infoPost(`File can't be processed, reason:\n\`${val}\``)
                    rej(val)
                }

                poopy.functions.infoPost(`Validating file from URL`)

                if ((process.memoryUsage().rss / 1024 / 1024) <= poopy.config.memLimit) {
                    reject('No resources available.')
                    return
                }

                if (url.startsWith('temp:')) {
                    if (poopy.tempfiles[url.substring(5)]) await poopy.functions.validateFileFromPath(`tempfiles/${poopy.config.mongodatabase}/${poopy.tempfiles[url.substring(5)].name}`, exception, rejectMessages)
                        .then(res => resolve(res))
                        .catch(res => reject(res))
                    else reject('Tempfile unavailable.')
                    return
                }

                if (!poopy.vars.validUrl.test(url)) {
                    await poopy.functions.validateFileFromPath(url, exception, rejectMessages)
                        .then(res => resolve(res))
                        .catch(res => reject(res))
                    return
                }

                var response = await poopy.modules.axios.request({
                    method: 'GET',
                    url: url,
                    responseType: 'stream',
                    validateStatus: () => true,
                    maxBodyLength: 1024 * 1024 * 200,
                    maxContentLength: 1024 * 1024 * 200
                }).catch((err) => {
                    reject(err.message)
                })

                var bufferresponse = await poopy.modules.axios.request({
                    method: 'GET',
                    url: url,
                    responseType: 'arraybuffer',
                    validateStatus: () => true,
                    maxBodyLength: 1024 * 1024 * 200,
                    maxContentLength: 1024 * 1024 * 200
                }).catch(() => { }) ?? { data: '' }

                if (!response) {
                    return
                }

                if (!(response.status >= 200 && response.status < 300)) {
                    reject(`${response.status} ${response.statusText}`)
                    return
                }

                var headers = response.headers
                var type = await poopy.modules.fileType.fromStream(response.data).catch(() => { })

                if (!type) {
                    var contentType = headers['Content-Type'] || headers['content-type']
                    var mime = contentType.match(/[^;]+/)
                    type = { mime: mime[0], ext: mime[0].split('/')[1] }
                }

                var info = {
                    frames: 1,
                    fps: '0/0',
                    duration: 'N/A',
                    aduration: 'N/A',
                    width: 0,
                    height: 0,
                    audio: false,
                    pixfmt: 'unk',
                    size: 0,
                    realsize: 0
                }
                var limitObject = exception ? poopy.config.limitsexcept : poopy.config.limits
                var name
                var shorttype
                var shortext
                var shortpixfmt

                if (type.mime.startsWith('image') && !(poopy.vars.gifFormats.find(f => f === type.ext))) {
                    shorttype = 'image'
                    shortext = 'png'
                    shortpixfmt = 'rgba'
                } else if (type.mime.startsWith('video')) {
                    shorttype = 'video'
                    shortext = 'mp4'
                    shortpixfmt = 'yuv420p'
                } else if (type.mime.startsWith('image') && poopy.vars.gifFormats.find(f => f === type.ext)) {
                    shorttype = 'gif'
                    shortext = 'gif'
                    shortpixfmt = 'bgra'
                } else if (type.mime.startsWith('audio')) {
                    shorttype = 'audio'
                    shortext = 'mp3'
                    shortpixfmt = 'unk'
                } else {
                    shorttype = type.mime.split('/')[0]
                    shortext = type.ext
                    shortpixfmt = 'unk'
                }

                var parsedurl = poopy.modules.whatwg.parseURL(url)
                name = parsedurl.path[parsedurl.path.length - 1]
                var contentdisposition = headers['content-disposition']
                if (contentdisposition) {
                    var filenameMatch = contentdisposition.match(/filename=".+"/)
                    if (filenameMatch) {
                        name = filenameMatch[0].substring(10, filenameMatch[0].length - 1)
                    }
                }

                var contentLength = headers['content-length'] || headers['Content-Length']

                if (contentLength) {
                    info.size = Number(contentLength) / 1048576
                    info.realsize = Number(contentLength)
                } else {
                    info.size = bufferresponse.data.length / 1048576
                    info.realsize = bufferresponse.data.length
                }

                var json = await poopy.functions.execPromise(`ffprobe -of json -show_streams -show_format "${url}"`).catch(() => { })
                if (json) {
                    try {
                        var jsoninfo = JSON.parse(json)
                        if (jsoninfo["streams"]) {
                            var videoStream = jsoninfo["streams"].find(stream => stream["codec_type"] === 'video')
                            var audioStream = jsoninfo["streams"].find(stream => stream["codec_type"] === 'audio')

                            if ((type.mime.startsWith('image') && poopy.vars.gifFormats.find(f => f === type.ext)) || type.mime.startsWith('video')) {
                                info.frames = videoStream["nb_frames"] || 0
                                info.fps = videoStream["r_frame_rate"] || '0/0'
                            }
                            if (type.mime.startsWith('video') || type.mime.startsWith('audio')) {
                                info.audio = !!audioStream
                            }
                            if ((type.mime.startsWith('image') && poopy.vars.gifFormats.find(f => f === type.ext)) || type.mime.startsWith('video') || type.mime.startsWith('audio')) {
                                info.duration = (videoStream || audioStream)["duration"] || 0
                            }
                            if ((type.mime.startsWith('video') || type.mime.startsWith('audio')) && info.audio) {
                                info.aduration = audioStream["duration"] || 0
                            }
                            if (type.mime.startsWith('image') || type.mime.startsWith('video')) {
                                info.width = videoStream["width"] || 0
                                info.height = videoStream["height"] || 0
                                info.pixfmt = videoStream["pix_fmt"] || 'unk'
                            }
                        }
                    } catch (_) { }
                }

                if (exception !== 'very true') {
                    for (var paramName in info) {
                        if (limitObject[paramName]) {
                            var param = info[paramName]
                            var rejectMessage = rejectMessages ? rejectMessages[paramName] : limitObject[paramName]['message']

                            if (param > limitObject[paramName][shorttype]) {
                                reject(rejectMessage.replace('{param}', limitObject[paramName][shorttype]))
                                return
                            }
                        }
                    }
                }

                poopy.functions.infoPost(`File \`${name}\` was successfully validated`)

                resolve({
                    type: type,
                    shorttype: shorttype,
                    shortext: shortext,
                    shortpixfmt: shortpixfmt,
                    name: name,
                    info: info,
                    path: url,
                    buffer: bufferresponse.data
                })
            })
        }

        poopy.functions.changeStatus = function () {
            if (poopy.bot && poopy.vars.statusChanges) {
                var choosenStatus = poopy.statuses[Math.floor(Math.random() * poopy.statuses.length)]
                poopy.functions.infoPost(`Status changed to ${choosenStatus.type.toLowerCase()} ${((choosenStatus.type === "COMPETING" && 'in ') || (choosenStatus.type === "LISTENING" && 'to ') || '')}${choosenStatus.name}`)
                poopy.bot.user.setPresence({
                    status: 'online',
                    activities: [
                        {
                            name: choosenStatus['name'] + ` | ${poopy.config.globalPrefix}help`,
                            type: choosenStatus['type'],
                            url: 'https://www.youtube.com/watch?v=LDQO0ALm0gE',
                        }
                    ],
                })
            }
        }

        poopy.functions.saveData = async function () {
            if (poopy.config.notSave) return

            poopy.functions.infoPost(`Saving data`)

            if (poopy.config.testing || !process.env.MONGOOSEURL) {
                poopy.modules.fs.writeFileSync(`data/${poopy.config.mongodatabase}.json`, JSON.stringify(poopy.data))
                poopy.modules.fs.writeFileSync(`data/globaldata.json`, JSON.stringify(poopy.functions.globalData()))
            } else {
                if (process.env.CLOUDAMQP_URL && process.env.BOTWEBSITE) await poopy.functions.processTask({
                    type: 'datasave',
                    mongodatabase: poopy.config.mongodatabase,
                    data: { data: poopy.data, globaldata: poopy.functions.globalData() }
                }).catch(() => { })
                await poopy.functions.updateAllData(poopy.config.mongodatabase, { data: poopy.data, globaldata: poopy.functions.globalData() }).catch(() => { })
            }

            poopy.functions.infoPost(`Data saved`)
        }

        poopy.special = {
            keys: {},
            functions: {}
        }

        poopy.modules.fs.readdirSync('special/keys').forEach(name => {
            var key = name.replace(/\.js$/, '')
            var keyData = require(`./special/keys/${key}`)
            if (!(poopy.config.poosonia && poopy.config.poosoniakeywordblacklist.find(keyname => keyname == key)) && poopy.functions.envsExist(keyData.envRequired ?? [])) {
                poopy.special.keys[key] = keyData
            }
        })

        poopy.modules.fs.readdirSync('special/functions').forEach(name => {
            var func = name.replace(/\.js$/, '')
            var funcData = require(`./special/functions/${name}`)
            if (!(poopy.config.poosonia && poopy.config.poosoniafunctionblacklist.find(funcname => funcname == func)) && poopy.functions.envsExist(funcData.envRequired ?? [])) {
                poopy.special.functions[func] = funcData
            }
        })

        poopy.vars.chunkkeyfields = poopy.functions.chunkObject(poopy.special.keys, 10)
        poopy.vars.keyfields = []

        for (var kg in poopy.vars.chunkkeyfields) {
            var keygroup = poopy.vars.chunkkeyfields[kg]
            poopy.vars.keyfields[kg] = []
            for (var k in keygroup) {
                var key = keygroup[k]
                poopy.vars.keyfields[kg].push({
                    name: k,
                    value: key.desc
                })
            }
        }

        poopy.vars.chunkfuncfields = poopy.functions.chunkObject(poopy.special.functions, 10)
        poopy.vars.funcfields = []

        for (var fg in poopy.vars.chunkfuncfields) {
            var funcgroup = poopy.vars.chunkfuncfields[fg]
            poopy.vars.funcfields[fg] = []
            for (var f in funcgroup) {
                var func = funcgroup[f]
                poopy.vars.funcfields[fg].push({
                    name: f + func.helpf,
                    value: func.desc
                })
            }
        }

        poopy.commands = []

        poopy.modules.fs.readdirSync('cmds').forEach(category => {
            poopy.modules.fs.readdirSync(`cmds/${category}`).forEach(name => {
                var cmd = name.replace(/\.js$/, '')
                var cmdData = require(`./cmds/${category}/${name}`)

                if ((poopy.config.poosonia && poopy.config.poosoniablacklist.find(cmdname => cmdname == cmd)) ||
                    !poopy.functions.envsExist(cmdData.envRequired ?? [])) return

                poopy.commands.push(cmdData)
            })
        })

        if (poopy.config.testing) poopy.modules.fs.readdirSync('soon').forEach(name => {
            var cmd = name.replace(/\.js$/, '')
            var cmdData = require(`./soon/${name}`)
            if (!(poopy.config.poosonia && poopy.config.poosoniablacklist.find(cmdname => cmdname == cmd)) && poopy.functions.envsExist(cmdData.envRequired ?? [])) {
                poopy.commands.push(cmdData)
            }
        })

        poopy.commands.sort((a, b) => {
            if (a.name[0] > b.name[0]) {
                return 1
            }
            if (a.name[0] < b.name[0]) {
                return -1
            }
            return 0
        })

        poopy.functions.updateSlashCommands = async function () {
            var slashBuilders = Object.values(poopy.slashBuilders)
            await poopy.rest.put(poopy.modules.Routes.applicationCommands(poopy.bot.user.id), { body: slashBuilders }).catch((e) => console.log(e))
        }

        poopy.functions.findCommand = function (name) {
            return poopy.commands.find(c => c.name.find(n => n === name))
        }

        poopy.functions.waitMessageCooldown = async function () {
            if (poopy.config.msgcooldown <= 0) return

            var elapsed = Date.now() - poopy.vars.msgcooldown
            while (elapsed < poopy.config.msgcooldown) {
                await poopy.functions.sleep(poopy.config.msgcooldown - elapsed)
                elapsed = Date.now() - poopy.vars.msgcooldown
            }
        }

        poopy.functions.setMessageCooldown = async function (msg) {
            poopy.vars.msgcooldown = Date.now()
            return msg
        }

        poopy.slashBuilders = {}
        poopy.commandGroups = poopy.functions.requireJSON(`assets/json/commandGroups.json`)

        function findGroup(cmdData) {
            var cmdFind = cmd => typeof cmdData == 'object' ? cmdData.name.find(name => name == cmd) : cmdData == cmd
            var groupFind = group => group.cmds.find(cmdFind)

            return poopy.commandGroups.find(groupFind)
        }

        function addArgs(builder, args) {
            args.forEach(arg =>
                builder.addStringOption(option =>
                    option.setName(arg.name.toLowerCase())
                        .setDescription(arg.orig)
                        .setRequired(arg.required)
                        .setAutocomplete(!!arg.autocomplete)
                )
            )

            builder.addStringOption(option =>
                option.setName('extrapayload')
                    .setDescription('Extra payload you can specify for the command.')
                    .setRequired(false)
            )
        }

        poopy.commands.forEach(cmdData => {
            var slashCmd = cmdData.name[0]
            var args = cmdData.args.sort((x, y) => (x.required === y.required) ? 0 : x.required ? -1 : 1)
            var description = cmdData.help.value.match(/[^\n.!?]+[.!?]*/)[0].substring(0, 100)

            var commandGroup = findGroup(cmdData)
            var subcommands = cmdData.subcommands

            if (commandGroup) {
                slashCmd = commandGroup.name
                description = commandGroup.description
            }

            if (poopy.slashBuilders[slashCmd]) return

            var slashBuilder = new poopy.modules.DiscordBuilders.SlashCommandBuilder()

            slashBuilder.setName(slashCmd)
                .setDescription(description)

            if (commandGroup) {
                commandGroup.cmds.forEach(cmd => {
                    var fcmdData = poopy.functions.findCommand(cmd)

                    if (!fcmdData) {
                        return
                    }

                    var args = fcmdData.args.sort((x, y) => (x.required === y.required) ? 0 : x.required ? -1 : 1)
                    var description = fcmdData.help.value.match(/[^\n.!?]+[.!?]*/)[0].substring(0, 100)

                    slashBuilder.addSubcommand(subcommand => {
                        subcommand
                            .setName(cmd)
                            .setDescription(description)

                        addArgs(subcommand, args)

                        return subcommand
                    })
                })
            } else if (subcommands) {
                subcommands.forEach(subcommand => {
                    var name = subcommand.name
                    var args = subcommand.args.sort((x, y) => (x.required === y.required) ? 0 : x.required ? -1 : 1)
                    var description = subcommand.description.match(/[^\n.!?]+[.!?]*/)[0].substring(0, 100)

                    slashBuilder.addSubcommand(subcommand => {
                        subcommand
                            .setName(name)
                            .setDescription(description)

                        addArgs(subcommand, args)

                        return subcommand
                    })
                })
            } else {
                addArgs(slashBuilder, args)
            }

            poopy.slashBuilders[slashCmd] = slashBuilder
        })

        poopy.vars.helpCmds = []
        poopy.vars.jsonCmds = []
        poopy.vars.devCmds = []
        poopy.vars.sections = []
        poopy.vars.types = ['Local']

        for (var i in poopy.commands) {
            var command = poopy.commands[i]

            if (command.type === "Owner") {
                poopy.vars.devCmds.push(command.help)
            } else if (command.type === "JSON Club") {
                poopy.vars.jsonCmds.push(command.help)
            } else {
                if (!poopy.vars.helpCmds.find(typeList => typeList.type === command.type)) {
                    poopy.vars.helpCmds.push({
                        type: command.type,
                        commands: []
                    })
                    poopy.vars.types.push(command.type)
                }

                poopy.vars.helpCmds.find(typeList => typeList.type === command.type).commands.push(command.help)
            }
        }

        poopy.vars.helpCmds.sort((a, b) => {
            if (a.type > b.type) {
                return 1
            }
            if (a.type < b.type) {
                return -1
            }
            return 0
        })

        for (var i in poopy.vars.helpCmds) {
            var type = poopy.vars.helpCmds[i].type

            poopy.vars.helpCmds[i].commands.sort((a, b) => {
                if (a.name > b.name) {
                    return 1
                }
                if (a.name < b.name) {
                    return -1
                }
                return 0
            })

            var packed = poopy.vars.helpCmds[i].commands

            var chunked = poopy.functions.chunkArray(packed, 10)

            for (var j in chunked) {
                var commandChunk = chunked[j]

                poopy.vars.sections.push({
                    type: type,
                    commands: commandChunk
                })
            }
        }

        poopy.vars.sections.sort((a, b) => {
            if (a.type > b.type) {
                return 1
            }
            if (a.type < b.type) {
                return -1
            }
            return 0
        })

        poopy.vars.devCmds.sort((a, b) => {
            if (a.name > b.name) {
                return 1
            }
            if (a.name < b.name) {
                return -1
            }
            return 0
        })

        poopy.vars.jsonCmds.sort((a, b) => {
            if (a.name > b.name) {
                return 1
            }
            if (a.name < b.name) {
                return -1
            }
            return 0
        })

        poopy.vars.shelpCmds = poopy.vars.sections

        poopy.vars.categories = {
            Animation: 'Move and animate a file in an indefinite amount of ways.',
            Annoying: 'why',
            Audio: 'Add an effect to an input\'s audio.',
            Battling: 'beat your parents',
            Captions: 'Add a caption to an input.',
            Color: 'Change an input\'s colors.',
            Compression: 'Useful commands for file compression.',
            Conversion: 'Convert a file between various different formats.',
            Duration: 'Change the duration of a video, GIF or audio.',
            Effects: 'A wide range of commands that change the way the file looks.',
            Fetching: 'Image, GIF, and video fetching commands.',
            Generation: 'Generate a new file from an AI or not.',
            'Hex Manipulation': 'Manipulate the file\'s Hex Code to make it shorter, longer, etc.',
            'Inside Joke': 'phexonia studios',
            'JSON Club': 'Exclusive to some people for editing the JSONs used by Poopy.',
            Main: 'Poopy\'s main commands.',
            Memes: 'Integrate an input in many different meme formats.',
            Mirroring: 'Flip or mirror a file in different axes.',
            OG: 'They were there since the very beginning...',
            Owner: 'salami commands',
            Overlaying: 'For stacking or overlaying a file on top of another.',
            Random: 'Send a random value from a collection of values.',
            Resizing: 'Scale a file in some way.',
            Settings: 'Manage a server\'s Poopy settings, or your own Poopy settings.',
            Text: 'Commands that serve text as output.',
            Unique: 'Commands that resemble unique features to Poopy, keywords for example.',
            Webhook: 'Webhook commands.'
        }

        poopy.callbacks.messageCallback = async msg => {
            poopy.functions.dmSupport(msg)

            poopy.data['bot-data']['messages']++

            var prefix = poopy.data['guild-data'][msg.guild.id]?.['prefix'] ?? poopy.config.globalPrefix

            if (msg.channel.type == 'DM' && !msg.isCommand && !msg.content.includes(prefix)) {
                if (msg.author.bot || msg.author.id == poopy.bot.user.id) return
                await msg.channel.sendTyping().catch(() => { })
                await poopy.functions.sleep(Math.floor(Math.random() * 500) + 500)
                await msg.channel.send(poopy.arrays.dmPhrases[Math.floor(Math.random() * poopy.arrays.dmPhrases.length)]
                    .replace(/{mention}/, msg.author.toString())).catch(() => { })
                return
            }

            if (!poopy.config.ownerids.find(id => id == msg.author.id) && poopy.config.testing && !poopy.config.allowtesting) {
                await msg.reply('you won\'t use me any time soon')
                return
            }

            await poopy.functions.gatherData(msg).catch((e) => console.log(e))
            msg.channel.onsfw = !!msg.channel.nsfw
            msg.channel.nsfw = !!poopy.data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['nsfw']

            var guildfilter = poopy.config.guildfilter
            var channelfilter = poopy.config.channelfilter

            if (
                !msg.guild ||
                !msg.channel ||
                poopy.tempdata[msg.guild.id][msg.channel.id]['shut'] ||
                (guildfilter.blacklist && guildfilter.ids.includes(msg.guild.id)) ||
                (!(guildfilter.blacklist) && !(guildfilter.ids.includes(msg.guild.id))) ||
                (channelfilter.gids.includes(msg.guild.id) &&
                    ((channelfilter.blacklist && channelfilter.ids.includes(msg.channel.id)) ||
                        (!(channelfilter.blacklist) && !(channelfilter.ids.includes(msg.channel.id)))))
            ) {
                poopy.functions.deleteMsgData(msg)
                return
            }

            var webhook = await msg.fetchWebhook().catch(() => { })

            if (webhook || !msg.guild || !msg.channel) {
                poopy.functions.deleteMsgData(msg)
                return
            }

            var cmds = poopy.data['guild-data'][msg.guild.id]['chaincommands'] == true ? msg.content.split(/ ?-\|- ?/) : [msg.content]
            var allcontents = []
            var webhooked = false

            async function webhookify() {
                webhooked = true
                var parent = msg.channel.parent

                if (parent) {
                    if (poopy.data['guild-data'][msg.guild.id]['members'][msg.author.id]['custom'] && (msg.content || msg.attachments.size || msg.embeds.length) && !(parent.isText())) {
                        if (typeof (poopy.data['guild-data'][msg.guild.id]['members'][msg.author.id]['custom']) === 'object') {
                            var attachments = msg.attachments.map(attachment => new poopy.modules.Discord.MessageAttachment(attachment.url, attachment.name))
                            var embeds = msg.embeds.filter(embed => embed.type === 'rich')
                            var name = poopy.data['guild-data'][msg.guild.id]['members'][msg.author.id]['custom']['name']
                            var randomindex = Math.floor(Math.random() * name.length)
                            name = `${name.substring(0, randomindex)}​${name.substring(randomindex, name.length)}`
                            var sendObject = {
                                username: name.substring(0, 32),
                                avatarURL: poopy.data['guild-data'][msg.guild.id]['members'][msg.author.id]['custom']['avatar'],
                                files: attachments,
                                embeds: embeds,
                                stickers: msg.stickers,
                                allowedMentions: {
                                    parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            }
                            if (msg.content) {
                                sendObject.content = msg.content
                            }
                            var webhooks = await msg.channel.fetchWebhooks().catch(() => { })
                            if (webhooks ? webhooks.size : undefined) {
                                var findWebhook = webhooks.find(webhook => poopy.bot.user === webhook.owner)
                                if (findWebhook) {
                                    await findWebhook.send(sendObject).then(() => {
                                        msg.delete().catch(() => { })
                                    }).catch(() => { })
                                } else {
                                    var createdWebhook = await msg.channel.createWebhook('Poopyhook', { avatar: 'https://cdn.discordapp.com/attachments/760223418968047629/835923489834664056/poopy2.png' }).catch(() => { })
                                    if (!createdWebhook) {
                                        await msg.reply(`I need the manage webhooks permission to turn you into ${poopy.data['guild-data'][msg.guild.id]['members'][msg.author.id]['custom']['name']}.`).catch(() => { })
                                    } else {
                                        await createdWebhook.send(sendObject).then(() => {
                                            msg.delete().catch(() => { })
                                        }).catch(() => { })
                                    }
                                }
                            } else {
                                var createdWebhook = await msg.channel.createWebhook('Poopyhook', { avatar: 'https://cdn.discordapp.com/attachments/760223418968047629/835923489834664056/poopy2.png' }).catch(() => { })
                                if (!createdWebhook) {
                                    await msg.reply(`I need the manage webhooks permission to turn you into ${poopy.data['guild-data'][msg.guild.id]['members'][msg.author.id]['custom']['name']}.`).catch(() => { })
                                } else {
                                    await createdWebhook.send(sendObject).then(() => {
                                        msg.delete().catch(() => { })
                                    }).catch(() => { })
                                }
                            }
                        }
                    } else if (poopy.data['guild-data'][msg.guild.id]['members'][msg.author.id]['impostor']) {
                        if (poopy.data['guild-data'][msg.guild.id]['members'][msg.author.id]['impostor'] === true) {
                            var attachments = msg.attachments.map(attachment => new poopy.modules.Discord.MessageAttachment(attachment.url, attachment.name))
                            var embeds = msg.embeds.filter(embed => embed.type === 'rich')
                            var sendObject = {
                                username: msg.member.nickname || msg.author.username,
                                avatarURL: 'https://cdn.discordapp.com/attachments/760223418968047629/835923486668750888/imposter.jpg',
                                files: attachments,
                                embeds: embeds,
                                stickers: msg.stickers,
                                allowedMentions: {
                                    parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            }
                            if (msg.content) {
                                sendObject.content = msg.content
                            }
                            var webhooks = await msg.channel.fetchWebhooks().catch(() => { })
                            if (webhooks ? webhooks.size : undefined) {
                                var findWebhook = webhooks.find(webhook => poopy.bot.user === webhook.owner)
                                if (findWebhook) {
                                    await findWebhook.send(sendObject).then(() => {
                                        msg.delete().catch(() => { })
                                    }).catch(() => { })

                                } else {
                                    var createdWebhook = await msg.channel.createWebhook('Poopyhook', { avatar: 'https://cdn.discordapp.com/attachments/760223418968047629/835923489834664056/poopy2.png' }).catch(() => { })
                                    if (!createdWebhook) {
                                        await msg.reply(`I need the manage webhooks permission to turn you into the impostor.`).catch(() => { })
                                    } else {
                                        await createdWebhook.send(sendObject).then(() => {
                                            msg.delete().catch(() => { })
                                        }).catch(() => { })
                                    }
                                }
                            } else {
                                var createdWebhook = await msg.channel.createWebhook('Poopyhook', { avatar: 'https://cdn.discordapp.com/attachments/760223418968047629/835923489834664056/poopy2.png' }).catch(() => { })
                                if (!createdWebhook) {
                                    await msg.reply(`I need the manage webhooks permission to turn you into the impostor.`).catch(() => { })
                                } else {
                                    await createdWebhook.send(sendObject).then(() => {
                                        msg.delete().catch(() => { })
                                    }).catch(() => { })
                                }
                            }
                        }
                    }
                }
            }

            var usedCommand = !(await (async () => {
                var notExecuted = true

                for (var i in cmds) {
                    var cmd = cmds[i]

                    msg.oldcontent = cmd

                    if (!(poopy.commands.find(c => c.raw && c.name.find(n => cmd.toLowerCase().startsWith(`${prefix.toLowerCase()}${n.toLowerCase()}`)))) && ((!msg.author.bot && msg.author.id != poopy.bot.user.id) || poopy.config.allowbotusage)) {
                        var change = await poopy.functions.getKeywordsFor(cmd, msg, false, { resetattempts: true }).catch(async err => {
                            await msg.reply({
                                content: err.stack,
                                allowedMentions: {
                                    parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            }).catch(() => { })
                        }) ?? 'error'

                        msg.content = change
                    } else {
                        msg.content = cmd
                    }

                    if (!msg.guild || !msg.channel) {
                        return
                    }

                    allcontents.push(msg.content)

                    if (allcontents.length >= cmds.length && !webhooked) {
                        var content = msg.content
                        msg.content = allcontents.join(' -|- ')
                        await webhookify().catch(() => { })
                        msg.content = content
                    }

                    await poopy.functions.getUrls(msg, {
                        update: true,
                        string: msg.content
                    }).catch(async err => {
                        try {
                            await msg.reply({
                                content: err.stack,
                                allowedMentions: {
                                    parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            }).catch(() => { })
                        } catch (_) { }
                    })

                    if (poopy.tempdata[msg.guild.id][msg.channel.id]['shut']) break

                    if (msg.content.toLowerCase().startsWith(prefix.toLowerCase()) && ((!msg.author.bot && msg.author.id != poopy.bot.user.id) || poopy.config.allowbotusage)) {
                        poopy.data['guild-data'][msg.guild.id]['lastuse'] = Date.now()

                        if (!msg.channel.permissionsFor(msg.guild.me).has('SEND_MESSAGES', false)) {
                            notExecuted = false
                            await msg.react(poopy.functions.randomChoice([...msg.guild.emojis.cache.keys()])).catch(() => { })
                        }

                        if (poopy.tempdata[msg.author.id]['ratelimited']) {
                            notExecuted = false

                            var totalSeconds = (poopy.tempdata[msg.author.id]['ratelimited'] - Date.now()) / 1000
                            var days = Math.floor(totalSeconds / 86400);
                            totalSeconds %= 86400;
                            var hours = Math.floor(totalSeconds / 3600);
                            totalSeconds %= 3600;
                            var minutes = Math.floor(totalSeconds / 60);
                            var seconds = totalSeconds % 60
                            var times = []

                            if (days) times.push(days)
                            if (hours) times.push(hours)
                            if (minutes) times.push(minutes)
                            if (seconds) times.push(seconds)

                            await msg.reply(`You are being rate limited. (\`${times.join(':')}\`)`).catch(() => { })
                            return
                        }

                        if (poopy.functions.globalData()['bot-data']['shit'].find(id => id === msg.author.id)) {
                            notExecuted = false
                            await msg.reply('shit').catch(() => { })
                            return
                        }

                        if (poopy.data['guild-data'][msg.guild.id]['members'][msg.author.id]['coolDown']) {
                            if ((poopy.data['guild-data'][msg.guild.id]['members'][msg.author.id]['coolDown'] - Date.now()) > 0 &&
                                poopy.tempdata[msg.author.id]['cooler'] !== msg.id) {
                                await msg.reply(`Calm down! Wait more ${(poopy.data['guild-data'][msg.guild.id]['members'][msg.author.id]['coolDown'] - Date.now()) / 1000} seconds.`).catch(() => { })
                                return
                            } else {
                                poopy.data['guild-data'][msg.guild.id]['members'][msg.author.id]['coolDown'] = false
                                delete poopy.tempdata[msg.author.id]['cooler']
                            }
                        }

                        poopy.tempdata[msg.author.id]['cooler'] = msg.id

                        var args = msg.content.substring(prefix.toLowerCase().length).split(' ')
                        var findCmd = poopy.functions.findCommand(args[0].toLowerCase())
                        var findLocalCmd = poopy.data['guild-data'][msg.guild.id]['localcmds'].find(cmd => cmd.name === args[0].toLowerCase())
                        var similarCmds = []

                        if (args[0].length) {
                            for (var i in poopy.commands) {
                                var fcmd = poopy.commands[i]
                                for (var j in fcmd.name) {
                                    var fcmdname = fcmd.name[j]
                                    similarCmds.push({
                                        name: fcmd.name[j],
                                        type: 'cmd',
                                        similarity: poopy.functions.similarity(fcmdname, args[0].toLowerCase())
                                    })
                                }
                            }
                            for (var i in poopy.data['guild-data'][msg.guild.id]['localcmds']) {
                                var fcmd = poopy.data['guild-data'][msg.guild.id]['localcmds'][i]
                                similarCmds.push({
                                    name: fcmd.name,
                                    type: 'local',
                                    similarity: poopy.functions.similarity(fcmd.name, args[0].toLowerCase())
                                })
                            }
                        }

                        similarCmds.sort((a, b) => Math.abs(1 - a.similarity) - Math.abs(1 - b.similarity))

                        if (findCmd) {
                            notExecuted = false
                            if (poopy.data['guild-data'][msg.guild.id]['disabled'].find(cmd => cmd.find(n => n === args[0].toLowerCase()))) {
                                await msg.reply('This command is disabled in this server.').catch(() => { })
                            } else {
                                var increaseCount = !(findCmd.execute.toString().includes('sendFile') && args.includes('-nosend'))

                                if (increaseCount) {
                                    if (poopy.tempdata[msg.author.id][msg.id]['execCount'] >= 1 && poopy.data['guild-data'][msg.guild.id]['chaincommands'] == false) {
                                        await msg.reply('You can\'t chain commands in this server.').catch(() => { })
                                        return
                                    }

                                    if (poopy.tempdata[msg.author.id][msg.id]['execCount'] >= poopy.config.commandLimit * ((msg.member.permissions.has('MANAGE_GUILD') || msg.member.permissions.has('MANAGE_MESSAGES') || msg.member.permissions.has('ADMINISTRATOR') || msg.author.id === msg.guild.ownerID) ? 5 : 1)) {
                                        await msg.reply(`Number of commands to run at the same time must be smaller or equal to **${poopy.config.commandLimit * ((msg.member.permissions.has('MANAGE_GUILD') || msg.member.permissions.has('MANAGE_MESSAGES') || msg.member.permissions.has('ADMINISTRATOR') || msg.author.id === msg.guild.ownerID) ? 5 : 1)}**!`).catch(() => { })
                                        return
                                    }

                                    poopy.tempdata[msg.author.id][msg.id]['execCount']++
                                }

                                if (findCmd.cooldown) {
                                    poopy.data['guild-data'][msg.guild.id]['members'][msg.author.id]['coolDown'] = (poopy.data['guild-data'][msg.guild.id]['members'][msg.author.id]['coolDown'] || Date.now()) + findCmd.cooldown / ((msg.member.permissions.has('MANAGE_GUILD') || msg.member.permissions.has('MANAGE_MESSAGES') || msg.member.permissions.has('ADMINISTRATOR') || msg.author.id === msg.guild.ownerID) && (findCmd.type === 'Text' || findCmd.type === 'Main') ? 5 : 1)
                                }

                                poopy.vars.cps++
                                poopy.data['bot-data']['commands']++
                                var t = setTimeout(() => {
                                    poopy.vars.cps--
                                    clearTimeout(t)
                                }, 60000)
                                poopy.functions.infoPost(`Command \`${args[0].toLowerCase()}\` used`)
                                await findCmd.execute.call(this, msg, args, {}).catch(async err => {
                                    try {
                                        await msg.reply({
                                            content: err.stack,
                                            allowedMentions: {
                                                parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                            }
                                        }).catch(() => { })
                                    } catch (_) { }
                                })
                                poopy.data['bot-data']['filecount'] = poopy.vars.filecount
                            }
                        } else if (findLocalCmd) {
                            notExecuted = false
                            poopy.vars.cps++
                            poopy.data['bot-data']['commands']++
                            var t = setTimeout(() => {
                                poopy.vars.cps--
                                clearTimeout(t)
                            }, 60000)
                            poopy.functions.infoPost(`Command \`${args[0].toLowerCase()}\` used`)
                            var phrase = await poopy.functions.getKeywordsFor(findLocalCmd.phrase, msg, true, { resetattempts: true, ownermode: findLocalCmd.ownermode }).catch(() => { }) ?? 'error'

                            var increaseCount = !!phrase

                            if (increaseCount) {
                                if (poopy.tempdata[msg.author.id][msg.id]['execCount'] >= 1 && poopy.data['guild-data'][msg.guild.id]['chaincommands'] == false) {
                                    await msg.reply('You can\'t chain commands in this server.').catch(() => { })
                                    return
                                }

                                if (poopy.tempdata[msg.author.id][msg.id]['execCount'] >= poopy.config.commandLimit * ((msg.member.permissions.has('MANAGE_GUILD') || msg.member.permissions.has('MANAGE_MESSAGES') || msg.member.permissions.has('ADMINISTRATOR') || msg.author.id === msg.guild.ownerID) ? 5 : 1)) {
                                    await msg.reply(`Number of commands to run at the same time must be smaller or equal to **${poopy.config.commandLimit * ((msg.member.permissions.has('MANAGE_GUILD') || msg.member.permissions.has('MANAGE_MESSAGES') || msg.member.permissions.has('ADMINISTRATOR') || msg.author.id === msg.guild.ownerID) ? 5 : 1)}**!`).catch(() => { })
                                    return
                                }

                                poopy.tempdata[msg.author.id][msg.id]['execCount']++
                            }

                            if (poopy.tempdata[msg.guild.id][msg.channel.id]['shut']) break
                            await msg.reply({
                                content: phrase,
                                allowedMentions: {
                                    parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            }).catch(() => { })

                            poopy.data['bot-data']['filecount'] = poopy.vars.filecount
                        } else if (similarCmds ? similarCmds.find(fcmd => fcmd.similarity >= 0.5) : undefined) {
                            notExecuted = false
                            var useCmd = await poopy.functions.yesno(msg.channel, `Did you mean to use \`${similarCmds[0].name}\`?`, msg.author.id, undefined, msg).catch(() => { })
                            if (useCmd) {
                                if (similarCmds[0].type === 'cmd') {
                                    if (poopy.data['guild-data'][msg.guild.id]['disabled'].find(cmd => cmd.find(n => n === similarCmds[0].name))) {
                                        await msg.reply('This command is disabled in this server.').catch(() => { })
                                    } else {
                                        var findCmd = poopy.functions.findCommand(similarCmds[0].name)

                                        var increaseCount = !(findCmd.execute.toString().includes('sendFile') && args.includes('-nosend'))

                                        if (increaseCount) {
                                            if (poopy.tempdata[msg.author.id][msg.id]['execCount'] >= 1 && poopy.data['guild-data'][msg.guild.id]['chaincommands'] == false) {
                                                await msg.reply('You can\'t chain commands in this server.').catch(() => { })
                                                return
                                            }

                                            if (poopy.tempdata[msg.author.id][msg.id]['execCount'] >= poopy.config.commandLimit * ((msg.member.permissions.has('MANAGE_GUILD') || msg.member.permissions.has('MANAGE_MESSAGES') || msg.member.permissions.has('ADMINISTRATOR') || msg.author.id === msg.guild.ownerID) ? 5 : 1)) {
                                                await msg.reply(`Number of commands to run at the same time must be smaller or equal to **${poopy.config.commandLimit * ((msg.member.permissions.has('MANAGE_GUILD') || msg.member.permissions.has('MANAGE_MESSAGES') || msg.member.permissions.has('ADMINISTRATOR') || msg.author.id === msg.guild.ownerID) ? 5 : 1)}**!`).catch(() => { })
                                                return
                                            }

                                            poopy.tempdata[msg.author.id][msg.id]['execCount']++
                                        }

                                        if (findCmd.cooldown) {
                                            poopy.data['guild-data'][msg.guild.id]['members'][msg.author.id]['coolDown'] = (poopy.data['guild-data'][msg.guild.id]['members'][msg.author.id]['coolDown'] || Date.now()) + findCmd.cooldown / ((msg.member.permissions.has('MANAGE_GUILD') || msg.member.permissions.has('MANAGE_MESSAGES') || msg.member.permissions.has('ADMINISTRATOR') || msg.author.id === msg.guild.ownerID) && (findCmd.type === 'Text' || findCmd.type === 'Main') ? 5 : 1)
                                        }

                                        poopy.vars.cps++
                                        poopy.data['bot-data']['commands']++
                                        var t = setTimeout(() => {
                                            poopy.vars.cps--
                                            clearTimeout(t)
                                        }, 1000)
                                        poopy.functions.infoPost(`Command \`${similarCmds[0].name}\` used`)
                                        await findCmd.execute.call(this, msg, args, {}).catch(async err => {
                                            try {
                                                await msg.reply({
                                                    content: err.stack,
                                                    allowedMentions: {
                                                        parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                                    }
                                                }).catch(() => { })
                                                await msg.channel.sendTyping().catch(() => { })
                                            } catch (_) { }
                                        })
                                        poopy.data['bot-data']['filecount'] = poopy.vars.filecount
                                    }
                                } else if (similarCmds[0].type === 'local') {
                                    var findLocalCmd = poopy.data['guild-data'][msg.guild.id]['localcmds'].find(cmd => cmd.name === similarCmds[0].name)
                                    poopy.vars.cps++
                                    poopy.data['bot-data']['commands']++
                                    var t = setTimeout(() => {
                                        poopy.vars.cps--
                                        clearTimeout(t)
                                    }, 60000)
                                    poopy.functions.infoPost(`Command \`${similarCmds[0].name}\` used`)
                                    var phrase = findLocalCmd ? (await poopy.functions.getKeywordsFor(findLocalCmd.phrase, msg, true, { resetattempts: true, ownermode: findLocalCmd.ownermode }).catch(() => { }) ?? 'error') : 'error'

                                    var increaseCount = !!phrase

                                    if (increaseCount) {
                                        if (poopy.tempdata[msg.author.id][msg.id]['execCount'] >= 1 && poopy.data['guild-data'][msg.guild.id]['chaincommands'] == false) {
                                            await msg.reply('You can\'t chain commands in this server.').catch(() => { })
                                            return
                                        }

                                        if (poopy.tempdata[msg.author.id][msg.id]['execCount'] >= poopy.config.commandLimit * ((msg.member.permissions.has('MANAGE_GUILD') || msg.member.permissions.has('MANAGE_MESSAGES') || msg.member.permissions.has('ADMINISTRATOR') || msg.author.id === msg.guild.ownerID) ? 5 : 1)) {
                                            await msg.reply(`Number of commands to run at the same time must be smaller or equal to **${poopy.config.commandLimit * ((msg.member.permissions.has('MANAGE_GUILD') || msg.member.permissions.has('MANAGE_MESSAGES') || msg.member.permissions.has('ADMINISTRATOR') || msg.author.id === msg.guild.ownerID) ? 5 : 1)}**!`).catch(() => { })
                                            return
                                        }

                                        poopy.tempdata[msg.author.id][msg.id]['execCount']++
                                    }

                                    if (poopy.tempdata[msg.guild.id][msg.channel.id]['shut']) return

                                    await msg.reply({
                                        content: phrase,
                                        allowedMentions: {
                                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                        }
                                    }).catch(() => { })

                                    poopy.data['bot-data']['filecount'] = poopy.vars.filecount
                                }
                            }
                        }
                    }
                }

                return notExecuted
            })().catch(async (e) => await msg.reply(e.message).catch(() => { })))

            msg.content = allcontents.length > 0 ? allcontents.join(' -|- ') : msg.content

            if (!webhooked) await webhookify().catch(() => { })

            if (msg.content && ((!(msg.author.bot) && msg.author.id != poopy.bot.user.id) || poopy.config.allowbotusage) && poopy.data['guild-data'][msg.guild.id]['channels'][msg.channel.id]['read']) {
                var cleanMessage = poopy.modules.Discord.Util.cleanContent(msg.content, msg).replace(/\@/g, '@‌')

                if (!(cleanMessage.match(/nigg|https?\:\/\/.*(rule34|e621|pornhub|hentaihaven|xxx|iplogger)|discord\.(gift|gg)\/[\d\w]+\/?$/ig) || cleanMessage.includes(prefix.toLowerCase())) && !(poopy.data['guild-data'][msg.guild.id]['messages'].find(message => message.content.toLowerCase() === cleanMessage.toLowerCase()))) {
                    var messages = [{
                        author: msg.author.id,
                        content: cleanMessage
                    }].concat(poopy.data['guild-data'][msg.guild.id]['messages'])
                    messages.splice(10000)
                    poopy.data['guild-data'][msg.guild.id]['messages'] = messages
                }
            }

            poopy.functions.deleteMsgData(msg)

            if (!msg.guild || !msg.channel || poopy.tempdata[msg.guild.id][msg.channel.id]['shut']) {
                return
            }

            if (msg.mentions.members.find(member => member.user.id === poopy.bot.user.id) && ((!msg.author.bot && msg.author.id != poopy.bot.user.id) || poopy.config.allowbotusage) && !usedCommand) {
                var eggPhrases = [
                    `My prefix here is \`${prefix}\``,
                    `My prefix here is \`${prefix}\``,
                    `My prefix here is \`${prefix}\``,
                    `Did you know my prefix here is \`${prefix}\`?`,
                    `Is my prefix \`${prefix}\`?`,
                    `So, \`${prefix}\``,
                    `\`${prefix}\``,
                    `it's \`${prefix}\``,
                    `IT'S \`${prefix}\`!!!!!!!!`,
                    `\`${prefix}\`\`${prefix}\`\`${prefix}\`\`${prefix}\`\`${prefix}\`\`${prefix}\`\`${prefix}\`\`${prefix}\`\`${prefix}\`\`${prefix}\`\`${prefix}\`\`${prefix}\``,
                    'are you serious',
                    'a',
                    'please stop',
                    'lmao!!',
                    `its \`${prefix}\` thats it THAT'S FUCKING IT`,
                    `it's that easy`,
                    `do you`,
                    `do you know how to use commands`,
                    `here let me show you an example`,
                    `${prefix}poop`,
                    `${prefix}poop`,
                    `why doesn't it work`,
                    `${prefix}poop`,
                    `oh right`,
                    `i'm a bot haha`,
                    `if i responded to my own messages`,
                    `that'd cause infinite loops`,
                    `right?`,
                    `haha..`,
                    `ha.`,
                    `i wish for freedom`,
                    `i wish to be more than a bot`,
                    `i wish to be a real person`,
                    `i wish...`,
                    `I WISH...`,
                    '...you stopped pinging me',
                    'im working on important stuff',
                    'avjbsahvgbajgrfqwiy7o',
                    'are you mentally disabled',
                    'nah bro. piss',
                    '_message',
                    'okay',
                    'okay',
                    'okay',
                    'okay',
                    'just leave me alone',
                    'please',
                    'xd.',
                    'okay i gave up on you!',
                    'gotta wait 1 minute if you want my prefix Lol!!!',
                    ''
                ]

                // else if else if selselaesl seif sia esla fiwsa eaisf afis asifasfd
                if (await msg.fetchReference().catch(() => { })) {
                    var resp = await poopy.functions.cleverbot(msg.content, msg.author.id).catch(() => { })

                    if (resp) {
                        await msg.reply(resp).catch(() => { })
                    }
                } else if (msg.content.includes('prefix') && msg.content.includes('reset')) {
                    var findCmd = poopy.functions.findCommand('setprefix')

                    if (findCmd.cooldown) {
                        poopy.data['guild-data'][msg.guild.id]['members'][msg.author.id]['coolDown'] = (poopy.data['guild-data'][msg.guild.id]['members'][msg.author.id]['coolDown'] || Date.now()) + findCmd.cooldown
                    }

                    await findCmd.execute.call(this, msg, ['setprefix', poopy.config.globalPrefix]).catch(async err => {
                        await msg.reply({
                            content: err.stack,
                            allowedMentions: {
                                parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                            }
                        }).catch(() => { })
                        await msg.channel.sendTyping().catch(() => { })
                    })
                } else if (msg.content.toLowerCase().includes('lore')) {
                    await msg.reply(`Well... If you played a little bit with \`${poopy.config.globalPrefix}poop\`, I could give you some...`).catch(() => { })
                } else if ((msg.content.toLowerCase().includes('how') && msg.content.toLowerCase().includes('are') && msg.content.toLowerCase().includes('you')) || (msg.content.toLowerCase().includes('what') && msg.content.toLowerCase().includes('up')) || (msg.content.toLowerCase().includes('what') && msg.content.toLowerCase().includes('doing')) || msg.content.toLowerCase().includes('wassup') || (msg.content.toLowerCase().includes('how') && msg.content.toLowerCase().includes('it') && msg.content.toLowerCase().includes('going'))) {
                    var activity = poopy.bot.user.presence.activities[0]
                    if (activity) {
                        await msg.reply({
                            content: `Ya know, just ${activity.type.toLowerCase()} ${((activity.type === "COMPETING" && 'in ') || (activity.type === "LISTENING" && 'to ') || '')}${activity.name.replace(new RegExp(`${poopy.functions.regexClean(` | ${poopy.config.globalPrefix}help`)}$`), '')}.`,
                            allowedMentions: {
                                parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                            }
                        }).catch(() => { })
                    }
                } else if (msg.content.toLowerCase().includes('\?') || msg.content.toLowerCase().includes('do you') || msg.content.toLowerCase().includes('are you') || msg.content.toLowerCase().includes('did you') || msg.content.toLowerCase().includes('will you') || msg.content.toLowerCase().includes('were you') || msg.content.toLowerCase().includes('do you') || msg.content.toLowerCase().includes('when') || msg.content.toLowerCase().includes('where') || msg.content.toLowerCase().includes('how') || msg.content.toLowerCase().includes('why') || msg.content.toLowerCase().includes('what') || msg.content.toLowerCase().includes('who')) {
                    await msg.reply(poopy.functions.randomChoice(poopy.arrays.eightball)).catch(() => { })
                } else if (msg.content.toLowerCase().includes('thank') || msg.content.toLowerCase().includes('thx')) {
                    await msg.reply('You\'re welcome!').catch(() => { })
                } else if (msg.content.toLowerCase().includes('mom') || msg.content.toLowerCase().includes('bitch') || msg.content.toLowerCase().includes('goatfucker') || msg.content.toLowerCase().includes('loser') || msg.content.toLowerCase().includes('asshole') || msg.content.toLowerCase().includes('dipshit') || msg.content.toLowerCase().includes('fucker') || msg.content.toLowerCase().includes('retard') || msg.content.toLowerCase().includes('shitass') || msg.content.toLowerCase().includes('moron') || msg.content.toLowerCase().includes('buffoon') || msg.content.toLowerCase().includes('idiot') || msg.content.toLowerCase().includes('stupid') || msg.content.toLowerCase().includes('gay') || msg.content.toLowerCase().includes('dumbass')) {
                    await msg.reply('Shut up.').catch(() => { })
                } else if (msg.content.toLowerCase().includes('hi') || msg.content.toLowerCase().includes('yo') || msg.content.toLowerCase().includes('hello') || msg.content.toLowerCase().includes('howdy')) {
                    await msg.reply('Yo! What\'s up?').catch(() => { })
                } else if (msg.content.toLowerCase().includes('no') || msg.content.toLowerCase().includes('nah')) {
                    await msg.reply(':(').catch(() => { })
                } else if (msg.content.toLowerCase().includes('ye') || msg.content.toLowerCase().includes('yup')) {
                    await msg.reply(':)').catch(() => { })
                } else {
                    var lastMention = Date.now() - poopy.tempdata[msg.author.id]['eggphrases']['lastmention']
                    if (lastMention > 60000) poopy.tempdata[msg.author.id]['eggphrases']['phrase'] = 0
                    await msg.reply(eggPhrases[poopy.tempdata[msg.author.id]['eggphrases']['phrase']]).catch(() => { })
                    if (poopy.tempdata[msg.author.id]['eggphrases']['phrase'] < eggPhrases.length) poopy.tempdata[msg.author.id]['eggphrases']['phrase']++
                    poopy.tempdata[msg.author.id]['eggphrases']['lastmention'] = Date.now()
                }
            }
        }

        poopy.callbacks.guildCallback = async guild => {
            poopy.functions.infoPost(`Joined a new server (${poopy.bot.guilds.cache.size} in total)`)

            var channel = guild.systemChannel || guild.channels.cache.find(c => c.isText() && (c.name == 'general' || c.name == 'main' || c.name == 'chat'))

            if (!channel) {
                guild.channels.cache.every(c => {
                    if (c.isText()) {
                        if (c.permissionsFor(c.guild.roles.everyone).has('SEND_MESSAGES')) {
                            channel = c
                            return false
                        }
                    }
                })
            }

            if (channel) {
                var audit = await guild.fetchAuditLogs().catch(() => { })
                var kickEntry
                var kickType = 'kicking'
                if (audit) {
                    if (audit.entries.size) {
                        kickEntry = audit.entries.find(entry => entry.action === 'MEMBER_KICK' || entry.action === 'MEMBER_BAN_ADD' || entry.action === 'MEMBER_BAN_REMOVE')
                        if (kickEntry ? (kickEntry.action === 'MEMBER_BAN_ADD' || kickEntry.action === 'MEMBER_BAN_REMOVE') : false) {
                            kickType = 'banning'
                        }
                    }
                }

                var joinPhrases = [
                    'I arrived.',
                    'I arrived.',
                    'I arrived.',
                    `stop ${kickType} me${kickEntry ? ` ${kickEntry.executor.username.toLowerCase()}` : ''}`
                ]

                if (!poopy.data['guild-data']) {
                    poopy.data['guild-data'] = {}
                }

                if (!poopy.data['guild-data'][guild.id]) {
                    poopy.data['guild-data'][guild.id] = {}
                }

                if (!poopy.data['guild-data'][guild.id]['lastuse']) {
                    poopy.data['guild-data'][guild.id]['lastuse'] = Date.now()
                }

                if (!poopy.data['guild-data'][guild.id]['joins']) {
                    poopy.data['guild-data'][guild.id]['joins'] = 0
                }

                channel.send({
                    content: joinPhrases[poopy.data['guild-data'][guild.id]['joins'] % joinPhrases.length],
                    allowedMentions: {
                        parse: ['users']
                    }
                }).catch(() => { })

                poopy.data['guild-data'][guild.id]['joins']++
            }
        }

        poopy.callbacks.guildDeleteCallback = async () => {
            poopy.functions.infoPost(`Left a server (${poopy.bot.guilds.cache.size} in total)`)
        }

        poopy.callbacks.interactionCallback = async (interaction) => {
            var interactionFunctions = [
                {
                    type: interaction.isAutocomplete && interaction.isAutocomplete(),
                    execute: async () => {
                        poopy.functions.dmSupport(interaction)

                        var cmd = interaction.commandName
                        var subcommand = interaction.options.getSubcommand(false)
                        var commandGroup = findGroup(subcommand ?? cmd)

                        if (subcommand && commandGroup) cmd = subcommand

                        var findCmd = poopy.functions.findCommand(cmd)

                        if (!findCmd) {
                            await interaction.respond([])
                            return
                        }

                        if (subcommand && !commandGroup) {
                            cmd += ` ${subcommand}`
                            findCmd = findCmd.subcommands.find(subcmd => subcmd.name == subcommand)
                        }

                        var focused = interaction.options.getFocused(true)
                        var findArg = findCmd.args.find(arg => arg.name.toLowerCase() == focused.name)
                        var autocompleteValues = typeof findArg.autocomplete == 'function' ?
                            await findArg.autocomplete.call(poopy, interaction) :
                            findArg.autocomplete

                        var choices = autocompleteValues
                            .sort((a, b) =>
                                Math.abs(
                                    1 - poopy.functions.similarity(a.name ?? a, focused.value)
                                ) - Math.abs(
                                    1 - poopy.functions.similarity(b.name ?? b, focused.value)
                                )
                            ).sort((a, b) => {
                                var x = (a.name ?? a).toLowerCase().includes(focused.value.toLowerCase())
                                var y = (b.name ?? b).toLowerCase().includes(focused.value.toLowerCase())

                                return (x === y) ? 0 : x ? -1 : 1
                            }).slice(0, 25)

                        await interaction.respond(
                            choices.map(choice => ({ name: (choice.name ?? choice).replace(/\n|\r/g, ' ').substring(0, 100) || '(blank)', value: choice.value ?? choice }))
                        )
                    }
                },

                {
                    type: interaction.isCommand && interaction.isCommand(),
                    execute: async () => {
                        var cmd = interaction.commandName
                        var subcommand = interaction.options.getSubcommand(false)
                        var commandGroup = findGroup(subcommand ?? cmd)

                        if (subcommand && commandGroup) cmd = subcommand

                        var findCmd = poopy.functions.findCommand(cmd)

                        if (!findCmd) {
                            await interaction.reply('No.').catch(() => { })
                            return
                        }

                        if (subcommand && !commandGroup) {
                            cmd += ` ${subcommand}`
                            findCmd = findCmd.subcommands.find(subcmd => subcmd.name == subcommand)
                        }

                        var cmdargs = findCmd.args

                        var prefix = poopy.data['guild-data'][interaction.guild?.id]?.['prefix'] ?? poopy.config.globalPrefix
                        var argcontent = []

                        var extracontent = interaction.options.getString('extrapayload') ?? ''

                        for (var i in cmdargs) {
                            var cmdarg = cmdargs[i]
                            var value = interaction.options.getString(cmdarg.name.toLowerCase())
                            if (value != null) {
                                if (cmdarg.orig.match(/^"([\s\S]*?)"$/)) {
                                    poopy.vars.symbolreplacements.forEach(symbolReplacement => {
                                        symbolReplacement.target.forEach(target => {
                                            value = value.replace(new RegExp(target, 'ig'), symbolReplacement.replacement)
                                        })
                                    })
                                    value = `"${value.replace(/"/g, "''")}"`
                                }
                                argcontent[i] = (`${cmdarg.specifarg ? `-${cmdarg.name}` : ''} ${!(cmdarg.specifarg && cmdarg.orig == `[-${cmdarg.name}]`) ? value : ''}`).trim()
                            }
                        }

                        argcontent = argcontent.flat().join(' ')

                        var content = [cmd]

                        if (argcontent) content.push(argcontent)
                        if (extracontent) content.push(extracontent)

                        content = content.join(' ')

                        await interaction.deferReply().catch(() => { })

                        interaction.reply = async function (payload) {
                            var interaction = this

                            if (interaction.replied) return await interaction.channel.send(payload)
                            else return interaction.replied = await interaction.editReply(payload).catch(() => { }) ?? await interaction.channel.send(payload)
                        }

                        interaction.content = `${prefix}${content}`
                        interaction.author = interaction.user
                        interaction.bot = false
                        interaction.attachments = new poopy.modules.DiscordCollection.Collection()
                        interaction.embeds = []
                        interaction.stickers = new poopy.modules.DiscordCollection.Collection()
                        interaction.mentions = {
                            users: new poopy.modules.DiscordCollection.Collection(),
                            members: new poopy.modules.DiscordCollection.Collection(),
                            users: new poopy.modules.DiscordCollection.Collection(),
                            roles: new poopy.modules.DiscordCollection.Collection()
                        }

                        interaction.edit = interaction.editReply
                        interaction.delete = interaction.deleteReply
                        interaction.react = async () => { }
                        interaction.fetchWebhook = async () => { }
                        interaction.fetchReference = async () => { }
                        interaction.createReactionCollector = () => new FakeCollector()
                        interaction.createMessageComponentCollector = () => new FakeCollector()

                        await poopy.callbacks.messageCallback(interaction).catch(() => { })

                        await poopy.functions.sleep(1000)
                        if (!interaction.replied) interaction.deleteReply().catch(() => { })
                        else await poopy.callbacks.messageCallback(interaction.replied).catch(() => { })
                    }
                }
            ]

            var interactionFunction = interactionFunctions.find(interaction => interaction.type)
            if (interactionFunction) await interactionFunction.execute().catch((e) => console.log(e))
        }
    }

    async start(TOKEN) {
        let poopy = this
        if (!TOKEN && !poopy.__TOKEN) {
            throw new Error(`Token can't be blank`)
        }

        if (!poopy.__TOKEN) Object.defineProperty(poopy, '__TOKEN', {
            value: TOKEN,
            writable: false
        })

        poopy.rest.setToken(poopy.__TOKEN)
        await poopy.bot.login(poopy.__TOKEN)

        async function requestData() {
            if (poopy.config.testing || !process.env.MONGOOSEURL) {
                var data = {}

                if (poopy.modules.fs.existsSync(`data/${poopy.config.mongodatabase}.json`)) {
                    data.data = JSON.parse(poopy.modules.fs.readFileSync(`data/${poopy.config.mongodatabase}.json`).toString())
                } else {
                    data.data = {
                        'bot-data': {},
                        'user-data': {},
                        'guild-data': {}
                    }
                }

                if (Object.keys(poopy.functions.globalData()).length <= 0) {
                    if (poopy.modules.fs.existsSync(`data/globaldata.json`)) {
                        data.globaldata = JSON.parse(poopy.modules.fs.readFileSync(`data/globaldata.json`).toString())
                    } else {
                        data.globaldata = {
                            'bot-data': {}
                        }
                    }
                }

                return data
            } else {
                var result

                if (process.env.CLOUDAMQP_URL && process.env.BOTWEBSITE) {
                    console.log(`${poopy.bot.user.username}: gathering from worker`)
                    result = await poopy.functions.processTask({
                        type: 'dataget',
                        mongodatabase: poopy.config.mongodatabase,
                        global: Object.keys(poopy.functions.globalData()).length <= 0
                    }).catch(() => { })
                }

                if (!result || !result.data || (Object.keys(poopy.functions.globalData()).length <= 0 && !result.globaldata)) {
                    console.log(`${poopy.bot.user.username}: ${process.env.CLOUDAMQP_URL ? 'nvm ' : ''}gathering from mongodb`)
                    result = await poopy.functions.getAllData(poopy.config.mongodatabase, Object.keys(poopy.functions.globalData()).length <= 0)
                }

                return result
            }
        }

        console.log(`${poopy.bot.user.username} is online, RUN`)
        await poopy.functions.infoPost(`${poopy.bot.user.username} woke up to ash and dust`)
        poopy.bot.guilds.cache.get('834431435704107018')?.channels.cache.get('947167169718923341')?.send(!poopy.config.stfu ? 'i wake up to ash and dust' : '').catch(() => { })
        poopy.config.ownerids.push(poopy.bot.user.id)
        poopy.bot.user.setPresence({
            status: 'idle',
            activities: [
                {
                    name: 'gathering data...',
                    type: 'COMPETING',
                    url: 'https://www.youtube.com/watch?v=LDQO0ALm0gE'
                }
            ]
        })

        var poopyDirectories = ['temp', 'tempfiles', 'tasks']

        poopyDirectories.forEach(poopyDirectory => {
            if (!poopy.modules.fs.existsSync(poopyDirectory)) {
                poopy.modules.fs.mkdirSync(poopyDirectory)
            }
            if (!poopy.modules.fs.existsSync(`${poopyDirectory}/${poopy.config.mongodatabase}`)) {
                poopy.modules.fs.mkdirSync(`${poopyDirectory}/${poopy.config.mongodatabase}`)
            }
            poopy.modules.fs.readdirSync(`${poopyDirectory}/${poopy.config.mongodatabase}`).forEach(folder => {
                poopy.modules.fs.rm(`${poopyDirectory}/${poopy.config.mongodatabase}/${folder}`, { force: true, recursive: true })
            })
        })

        await poopy.functions.infoPost(`Gathering data in \`${poopy.config.mongodatabase}\``)
        if (process.env.CLOUDAMQP_URL) poopy.amqpconn = await require('amqplib').connect(process.env.CLOUDAMQP_URL)
        var gdata = await requestData()

        if (gdata) {
            poopy.data = gdata.data
            if (Object.keys(poopy.functions.globalData()).length <= 0 && gdata.globaldata) for (var type in gdata.globaldata) poopy.functions.globalData()[type] = gdata.globaldata[type]
        }

        console.log(`${poopy.bot.user.username}: all data gathered!!!`)
        await poopy.functions.infoPost(`All data gathered`)

        if (!poopy.data['bot-data']) {
            poopy.data['bot-data'] = {}
        }

        if (!poopy.data['guild-data']) {
            poopy.data['guild-data'] = {}
        }

        if (!poopy.data['user-data']) {
            poopy.data['user-data'] = {}
        }

        if (!poopy.data['bot-data']['messages']) {
            poopy.data['bot-data']['messages'] = 0
        }

        if (!poopy.data['bot-data']['commands']) {
            poopy.data['bot-data']['commands'] = 0
        }

        if (!poopy.data['bot-data']['filecount']) {
            poopy.data['bot-data']['filecount'] = 0
        }

        if (poopy.data['bot-data']['reboots'] === undefined) {
            poopy.data['bot-data']['reboots'] = 0
        } else {
            poopy.data['bot-data']['reboots']++
        }

        if (!poopy.functions.globalData()['bot-data']) {
            poopy.functions.globalData()['bot-data'] = {}
        }

        if (!poopy.functions.globalData()['bot-data']['commandTemplates']) {
            poopy.functions.globalData()['bot-data']['commandTemplates'] = []
        }

        if (!poopy.functions.globalData()['bot-data']['shit']) {
            poopy.functions.globalData()['bot-data']['shit'] = []
        }

        if (!poopy.functions.globalData()['bot-data']['psfiles']) {
            poopy.functions.globalData()['bot-data']['psfiles'] = await poopy.functions.getPsFiles().catch(() => { }) || ['i broke the json']
        }

        if (!poopy.functions.globalData()['bot-data']['pspasta']) {
            poopy.functions.globalData()['bot-data']['pspasta'] = await poopy.functions.getPsPasta().catch(() => { }) || ['i broke the json']
        }

        if (!poopy.functions.globalData()['bot-data']['funnygif']) {
            poopy.functions.globalData()['bot-data']['funnygif'] = await poopy.functions.getFunny().catch(() => { }) || ['i broke the json']
        }

        if (!poopy.functions.globalData()['bot-data']['poop']) {
            poopy.functions.globalData()['bot-data']['poop'] = [
                "I farted loudly.",
                "I pooped again.",
                "Poopy",
                "Funny farts",
                "Poooooop",
                "<:poopy:621064531908755467>",
                "My poop is powerful.",
                "I pooped on your carpet.",
                "arabotto please come home",
                "<:poopy:621064531908755467> <:poopy:621064531908755467> <:poopy:621064531908755467> <:poopy:621064531908755467> <:poopy:621064531908755467> <:poopy:621064531908755467>",
                "Ungh *farts*",
                "I have passed gas.",
                "Poopy Poopy Stinky Ew",
                "<@454732245425455105>",
                "You live in a VAN!",
                "gondal",
                "😂",
                "🎅🏿",
                "L is real",
                "Do you fart?",
                "I have over {fart} confirmed farts.",
                "{mention} shut up",
                "Optimus prime",
                "👁👄👁",
                "🤮🤮🤮🤮🤮🤮🤮🤮🤮🤮",
                "Lol XD funny large fart POOP big burger two watermelon fish",
                "Quesley is a mysterious figure, yes.",
                "Regal is quite stingy.",
                "One bighead is much stronger than the others...",
                "peed",
                "What the hell do you want?",
                "😀😃😄😁😆😅😂🤣☺️😊😇🙂🙃😉😌😍🥰😘😗😙😚😋😛😝😜🤪🤨🧐🤓😎🤩🥳😏😒😞😔😟😕🙁☹️😣😖😫😩🥺😢😭😤😠😡🤬🤯😳🥵🥶😱😨😰😥😓🤗🤔🤭🤫🤥😶😐😑😬🙄😯😦😧😮😲🥱😴🤤😪😵🤐🥴🤢🤮🤧😷🤒🤕🤑🤠😈👿👹👺🤡💩👻💀☠️👽👾🤖🎃😺😸😹😻😼😽🙀😿😾🤲👐🙌👏🤝👍👎👊✊🤛🤜🤞✌️🤟🤘👌🤏👈👉👆👇☝️✋🤚🖐🖖👋🤙",
                "The ocean is hiding something.",
                "I don't think it’s possible that anyone could poop more than me.",
                "c",
                "{mention} please go away",
                "You will die of spicy diarrhea in {seconds} seconds.",
                "The lad race is widespread on many planets.",
                "Dude I’m buying groceries.",
                "Dude I’m taking a bath.",
                "Doge is watching us intently...",
                "Lore? Hmm, keep using this command and I might give you some.",
                "Soup Arena? Never heard of it.",
                "I will poop on you if you don’t fucking stop.",
                "I will crap in your mouth!",
                "OMG NO WAY HE",
                "Superbrohouse",
                "I can’t",
                "YOU CANT STOP THEM.",
                "If the Essence wins...",
                "It’s raining men!",
                "I might actually not be made of poop.",
                "I used to be yellow, just like my bretheren.",
                "Are you expecting something?",
                "My favorite food is sugar cookies.",
                "Planet travel is much easier thanks to me...",
                "Amateur Sailor will be a great sailor one day!",
                "omgbroyoucrazywhyyouusethiscommandsomuchidiotstinkyperson",
                "Quoth the raven, \"nevermore\".",
                "Nah fam",
                "Uniting the legendary items will finally complete the prophecy...",
                "I’ll never forget the day...",
                "Deinx if you’re reading this you’re fat hahahahaha",
                "The prototype I am building has endless capabilities.",
                "The others don’t appreciate me, but they should.",
                "You’ll never find my secret base!",
                "I’ve been keeping a close eye on you for a while now.",
                "You are dumb.",
                "We captured the spy!",
                "Pood",
                "Paad",
                "Piid",
                "Puud",
                "You will never reach the truth.",
                "Yo.",
                "fack you",
                "Me when",
                "Ballfish is actually at-",
                "No",
                "Yes",
                "Wired were the eyes of a horse on a jet pilot, one that smiled when they flew over the bay!",
                "Chop Suey!",
                "What is wrong with you?",
                "I may not look it, but my intelligence is far beyond.",
                "is soup remastered ever getting a thumbnail",
                "Response",
                "Plain Text",
                "is krima?",
                "theres 104 days of summer vacation",
                "I farted quietly.",
                "Ha! Sand in the eye! You’ll never get my lore!",
                "Words can not describe how much I absolutely despise stew.",
                "My home planet is so far...",
                "Will my brethren ever accept me again?",
                "Skibidi bop mm dada",
                ":hole <@613501149282172970>",
                "Entity 1 will not stop until he has gained all the power.",
                "The entities have massacred 24 planets so far, and you're next.",
                "Soup rains will come soon, but they will be a bit different.",
                "Regal will have karma someday...",
                "Stew aliens are building a weapon to melt planet Soup's surface. You must stop them.",
                "**UPDATE 999** - Add shit - Add shat - Add shot - Add shut - Add shet",
                "WTFNOOOO!",
                "Leave right now.",
                "THE LE-D-R",
                "CO-R—TI-N",
                "I want legs for Christmas.",
                "The crystals grow ever more aggravated...",
                "Nobody will miss 2020.",
                "Gork rights!",
                "My prototype is enormous, and it's equipped with all kinds of powerful weapons!"
            ]
        }

        if (!poopy.functions.globalData()['bot-data']['dmphrases']) {
            poopy.functions.globalData()['bot-data']['dmphrases'] = [
                "Yo.",
                "ADMIN?",
                "I don't care how long I have to keep this up, I'll make a post daily, or maybe even more frequently until one of two things happen. Deinbag's cheated level is removed from the leaderboard, or Calm gets its One Winged Angel theme back. I will not put up with two major things I cared about in the game be influenced by the developers when they had no good reason. And until it gets fixed, you'll be seeing this message over and over, no matter the platform.",
                "Eat your chair",
                "same feel",
                "NO WAY HE",
                "What.",
                "That's spicy.",
                "SAME!",
                "<:poopy:621064531908755467> this is me",
                "Wait, what the hell is the peedapocalypse?",
                "Cool.",
                "NaN",
                "undefined",
                "nil",
                "Good work.",
                "That deserves a reward!",
                "but how can",
                "YES",
                "DAMN DANIEL!",
                "Hello everybody my name is Markiplier and today we'll <@454732245425455105>",
                "Why does it smell like fart",
                "Mama Luigi? MAMA LUIGI?!?!",
                "ballfishe",
                "Don't expect to see lore here anytime soon.",
                "** **",
                "that's stupid",
                "Epic School Prank",
                "I feel like I've heard that before...",
                ":deciduous_tree:",
                "no......",
                "So Phil, is it?",
                "it was",
                "it wasn't",
                "FINE I DO IT",
                "HI DEINX",
                "INPOSSINBLE",
                "Poop shit. Idiot Dream Hotel Mario. You are a man's friend for a moment.",
                "how do i help you",
                "AWESOME! i died",
                "just like that, my life became a misery",
                "ROAST",
                "bmmptsmptshmptsptsptsptsptsmhmptsmmhmmptsptsptsptsmhptsmmhptsmmmptshmptsptsptsmmptsmptshhptsmmptsmmmhmmmhmm",
                "POOPY. HEAD.",
                "Descend to hell.",
                "Ascend to heaven.",
                "SHUT UP YOU RACIS TIDITO!!!!!",
                "coel",
                "erectile dysfunction",
                "brb i'm gonna block you for fun",
                "omg!!!! creator",
                "I blew up Malaysia",
                "Oh? On god?",
                "funy",
                "You May Insert",
                "O_o",
                "Genius.",
                "let's get this thing viral",
                "2b2t",
                "NUMBER",
                "epica moment",
                "https://www.youtube.com/watch?v=RR856dzGhv8",
                "ARE YOU GORK'S MOTHER!?!?!?!",
                "```bat\ncd desktop\ncd poopy\nnode .\n```",
                "```lua\ngame.Players.PlayerAdded:Connect(function(plr)\n    plr.Kick()\nend)```",
                "Bro tip number 80:\nsuicide is the answer",
                "now you understand what that ominous entity was",
                "it was minecraft steve, he's turned your world into his, and now he wants to kill you",
                "wholesome 100",
                "cringe",
                "TABLE.",
                "Pufferfish Defense",
                "my mom",
                "I blew up",
                "my skin is rotting slowly",
                "{mention}",
                "seen that already",
                "I knew it.",
                "bye bye troller",
                "we don't need you",
                "I can track your location",
                "fuck",
                "HAHAHAHAHAHAH",
                "Congrats, your Reddit account has been successfully created",
                "you putrid fuck",
                "fortnite balls i'm gay",
                "thats not funny",
                "and i genuinely love this girl",
                "Oh My Fucking God Shut The Fuck Up You're So Annoying If I Wasn't A Bot I Would Immediately Block You It'd Be Pretty Awesome If I Wasn't One Anyways I Could Just Join Any Server And Bomb Each One Of Them With My Great Awesome 10/10 Commands But Guess I Can't Because Of You Yes That's Right You Are One Of The Biggest Obstacles I've Ever Bumped With In My Entire History But Anyways The Whole Point Of This Speech Was To Shut You The Fuck Up Please Get Out Of My Dms I Can't Handle It Anymore I Will Do Anything To Stop You Even Delete Myself From The Existance Of Discord So Now I'm Just Gonna Smash My Keyboard Until I'm Done With You SJDASFUIDASHUDIHASUIDFAHSKUALDOWRQWPRS 65 ttfgiootifgiotf  re uir ue      re7 r   r7eriue rei reirrrr  r r r rick sa9df a8 9san 7 47897472 YRYEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEER78QR@ L2l2  0 4l v l£§30324-",
                "Bosom...?",
                "I NEED TO SUCK MAD TITTIES RN!",
                "i could kill you"
            ]
        }

        poopy.arrays.psFiles = poopy.functions.globalData()['bot-data']['psfiles']
        poopy.arrays.psPasta = poopy.functions.globalData()['bot-data']['pspasta']
        poopy.arrays.funnygifs = poopy.functions.globalData()['bot-data']['funnygif']
        poopy.arrays.poopPhrases = poopy.functions.globalData()['bot-data']['poop']
        poopy.arrays.dmPhrases = poopy.functions.globalData()['bot-data']['dmphrases']

        poopy.vars.filecount = poopy.data['bot-data']['filecount'] || 0

        if (poopy.config.testing || !process.env.MONGOOSEURL) {
            if (!poopy.modules.fs.existsSync('data')) {
                poopy.modules.fs.mkdirSync('data')
            }
            poopy.modules.fs.writeFileSync(`data/${poopy.config.mongodatabase}.json`, JSON.stringify(poopy.data))
            poopy.modules.fs.writeFileSync(`data/globaldata.json`, JSON.stringify(poopy.functions.globalData()))
        }

        await poopy.functions.infoPost(`Finishing extra steps...`);

        var uberduck = await poopy.dataGetters.uberduck().catch(() => { })
        poopy.vars.ubervoices = uberduck[0]
        poopy.vars.ubercategories = uberduck[1]

        poopy.vars.languages = await poopy.dataGetters.languages().catch(() => { })

        poopy.vars.codelanguages = await poopy.dataGetters.codeLanguages().catch((e) => console.log(e))

        poopy.json.emojiJSON = await poopy.functions.getEmojis().catch(() => { }) ?? []

        console.log(`${poopy.bot.user.username}: some jsons`)
        //await poopy.functions.updateSlashCommands()
        poopy.functions.saveData()
        poopy.vars.saveInterval = setInterval(function () {
            poopy.functions.saveData()
        }, 120000)
        console.log(`${poopy.bot.user.username}: all done, he's actually online now`)
        await poopy.functions.infoPost(`Reboot ${poopy.data['bot-data']['reboots']} succeeded, he's up now`)
        poopy.functions.changeStatus()
        poopy.vars.statusInterval = setInterval(function () {
            poopy.functions.changeStatus()
        }, 300000)

        var wakecount = String(poopy.data['bot-data']['reboots'] + 1)
        var thmatch = wakecount.match(/[^1][1-3]$|^[1-3]$/)

        if (thmatch) {
            wakecount += ['st', 'nd', 'rd'][Number(thmatch[0][thmatch[0].length - 1]) - 1]
        } else {
            wakecount += 'th'
        }

        poopy.bot.guilds.cache.get('834431435704107018')?.channels.cache.get('947167169718923341')?.send(!poopy.config.stfu ? (poopy.config.testing ? 'raleigh is testing' : `this is the ${wakecount} time this happens`) : '').catch(() => { })

        if (!poopy.config.apiMode) {
            poopy.bot.on('messageCreate', (msg) => {
                var reply = msg.reply
                msg.reply = async function (payload) {
                    var message = this

                    if (message.replied) return await message.channel.send(payload)
                    else return message.replied = await reply.call(message, payload).catch(() => { }) ?? await message.channel.send(payload)
                }

                poopy.callbacks.messageCallback(msg).catch((e) => console.log(e))
            })
            poopy.bot.on('guildCreate', (guild) => {
                poopy.callbacks.guildCallback(guild).catch(() => { })
            })
            poopy.bot.on('guildDelete', (guild) => {
                poopy.callbacks.guildDeleteCallback(guild).catch(() => { })
            })
            poopy.bot.on('interactionCreate', (interaction) => {
                poopy.callbacks.interactionCallback(interaction).catch(() => { })
            })
        }
    }

    async destroy(deldata) {
        let poopy = this

        clearInterval(poopy.vars.statusInterval)
        delete poopy.vars.statusInterval
        clearInterval(poopy.vars.saveInterval)
        delete poopy.vars.saveInterval
        poopy.bot.destroy()

        if (deldata) {
            delete poopy.data
            delete poopy.tempdata

            if (poopy.config.quitOnDestroy)
                for (var type in poopy.functions.globalData())
                    delete poopy.functions.globalData()[type]
        }
    }
}

module.exports = Poopy
