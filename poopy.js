const Discord = require('discord.js')

module.exports = async function (TOKEN = process.env.POOPYTOKEN, { testing = false, poosonia = false, poosoniablacklist = ['dm', 'tdms', 'spam', 'eval', 'leave'], poosoniakeywordblacklist = [], poosoniafunctionblacklist = ['messagecollector', 'stopcollector', 'stopallcollectors'], allowtesting = true, allowbotusage = false, mongodatabase = 'poopydata', stfu = false, intents = Object.values(Discord.Intents.FLAGS) } = {}) {
    const { REST } = require('@discordjs/rest');
    const { Routes } = require('discord-api-types/v9');
    const { SlashCommandBuilder } = require('@discordjs/builders');
    const fs = require('fs-extra');
    const archiver = require('archiver')
    const { exec, spawn } = require('child_process')
    const fileType = require('file-type')
    const axios = require('axios').default
    const cheerio = require('cheerio')
    const util = require('util')
    const md5 = require('md5')
    if (fs.existsSync('node_modules/@jimp/plugin-print')) {
        fs.rmSync('node_modules/@jimp/plugin-print', { force: true, recursive: true })
    }
    fs.copySync('modules/plugin-print', 'node_modules/@jimp/plugin-print', { recursive: true })
    const Jimp = require('jimp');
    //const { Builder, By, Key, until } = require('selenium-webdriver')
    //const chrome = require('selenium-webdriver/chrome')
    const whatwg = require('whatwg-url');
    const deepai = require('deepai')
    deepai.setApiKey(process.env.DEEPAIKEY)
    const noblox = require('noblox.js')
    const youtubedl = require('youtube-dl-exec')
    const { google } = require('googleapis')
    const youtube = google.youtube({
        version: 'v3',
        auth: process.env.GOOGLEKEY
    })
    /*const Twitter = require('twitter')
    const twitterClient = new Twitter({
        consumer_key: process.env.TWITTERCONSUMERKEY,
        consumer_secret: process.env.TWITTERCONSUMERSECRET,
        access_token_key: process.env.TWITTERACCESSTOKENKEY,
        access_token_secret: process.env.TWITTERACCESSTOKENSECRET
    })*/
    const gis = require('g-i-s')
    const catbox = require('catbox.moe')
    const Catbox = new catbox.Catbox()
    const mathjs = require('mathjs')
    const prettyBytes = require('pretty-bytes')
    const os = require('os')
    const validUrl = /(http|https):\/\/[^\s`"]+/
    const emojiRegex = require('emoji-regex')()
    const getEmojis = require('@jimp/plugin-print/emojis')
    const braille = require('./modules/braille')
    const averageColor = require('./modules/averageColor')
    const spectrogram = require('./modules/spectrogram')
    const { getAllData, updateAllData } = require('./modules/dataGathering')
    const brainfuck = require('./modules/brainfuck')
    const tobrainfuck = require('./modules/tobrainfuck')
    const gibberish = require('./modules/gibberish')
    const { data } = require('./modules/data')
    var data2 = {};
    var procs = []
    const bot = new Discord.Client({
        intents: intents,
        partials: ['CHANNEL']
    })
    const rest = new REST({ version: '9' }).setToken(TOKEN);
    var ownerids = ['464438783866175489', '454732245425455105', '613501149282172970'];
    var jsoning = ['411624455194804224', '395947826690916362', '486845950200119307'];
    var shit = ['']
    var illKillYouIfYouUseEval = ['535467581881188354']
    var limits = {
        size: {
            image: 20,
            gif: 20,
            video: 20,
            audio: 20,
            message: `that file exceeds the size limit of {param} mb hahahaha (try to use the shrink, setfps, trim or crunch commands)`
        },
        frames: {
            gif: 1000,
            video: 10000,
            message: `the frames in that file exceed the limit of {param} hahahaha (try to use the setfps or the trim commands)`
        },
        width: {
            image: 3000,
            gif: 1000,
            video: 2000,
            message: `the width of that file exceeds the limit of {param} hahahaha (try to use the shrink command)`
        },
        height: {
            image: 3000,
            gif: 1000,
            video: 2000,
            message: `the height of that file exceeds the limit of {param} hahahaha (try to use the shrink command)`
        }
    }
    var limitsexcept = {
        size: {
            image: 100,
            gif: 100,
            video: 100,
            audio: 100,
            message: `that file exceeds the exception size limit of {param} mb hahahaha there's nothing you can do`
        },
        frames: {
            gif: 5000,
            video: 50000,
            message: `the frames in that file exceed the exception limit of {param} hahahaha there's nothing you can do`
        },
        width: {
            image: 10000,
            gif: 2000,
            video: 5000,
            message: `the width of that file exceeds the exception limit of {param} hahahaha there's nothing you can do`
        },
        height: {
            image: 10000,
            gif: 2000,
            video: 5000,
            message: `the height of that file exceeds the exception limit of {param} hahahaha there's nothing you can do`
        }
    }
    var commandLimit = 5
    var keyLimit = 500
    var memLimit = 0
    const gifFormats = ['gif', 'apng']
    const symbolreplacements = [
        {
            target: ['‚Äò', '‚Äô', '‚Äõ', '‚ùõ', '‚ùú'],
            replacement: '\''
        },
        {
            target: ['‚Äú', '‚Äù', '‚Äü'],
            replacement: '"'
        },
    ]

    var arabDictionary = ['4chan', 'the poopening', 'negro', 'feet', 'GIANT COCK', 'orgy', 'e621', 'cum', 'r34', 'mug', 'Talking Tom', 'Talking Ben', 'Talking Angela', 'IShowSpeed', 'deepwoken', 'pilgrammed', 'lean', 'ü§ì', 'punapea6', 'dream', 'soup land', 'phexonia studios', 'idfsgs', 'penis', 'sex', 'hentai', 'area', 'World', 'throat', 'Mongolian', 'finnish', 'Malagasy', 'Iraqi', 'polish', 'ethiopian', 'canadian', 'ukrainian', 'iranian', 'irish', 'swedish', 'danish', 'french', 'chips', 'spanish', 'racist', 'superbrohouse', 'deinx', 'bubbley', 'deinbag', 'another', 'crypyth', 'tordenask', 'lead', 'lumin', 'wovxzers', 'dootings', 'bartekoklol', 'tuca', 'ballfish', 'kleio', 'crazy', 'cinna', 'btn', 'tree', 'gritzy', 'ruki', 'henry', 'empsy', 'maks', 'henhen', 'phex', 'icre8', 'bilon', 'fnepp', 'zekkriel', 'tranzst', 'mance', 'luigistar', 'makos', 'spellbunny', 'scriptedsand', 'puppet', 'josh', 'spooky', 'catfishhotdog', 'robuk', 'pl0x7', 'lemoardo', 'dundeed', 'notsam', 'luigiluis', 'trongal', 'mysterymeatwad', 'carlito', 'azureblob', 'simpremove', 'gobby', 'sayori', 'concern', 'euth', 'dullminecraftsteve', 'gunk', 'betteruser', 'tix', 'charleh', 'jlol', 'Featured', 'Vesteria', 'Rogue Lineage', 'madness', 'tricky', 'zardy', 'madness combat', 'splatoon', 'babis', 'wiki', 'fandom', 'milk', 'carrot', 'vinegar', 'mushroom', 'stew', 'shroom', 'peashooter', 'eyed', 'pea', 'frank', 'carl', 'oil', 'sunflower', 'chomper', 'piranha', 'fishes', 'fishe', 'fish', 'salami', 'lid', '‚â•w‚â§', 'furry', 'nya', 'uwu', 'owo', '^w^', 'freedom', 'dick', 'flip', 'bottle', 'pork', 'demotion', 'promotion', 'Error', 'Scream', 'spoon', 'knife', 'all over', 'african', 'land', 'üòÇ', 'yup', 'pee', 'piss', 'stranger language', 'edition', 'version', 'turtle', 'language', 'stranger', 'persian', 'people', 'Freddy', 'FNAF', 'giraffe', 'hippopotamus', 'program', 'coding', 'ocean', 'treasure', 'egg', 'tool', 'lad', 'lad village', 'GPU', 'CPU', 'lag', 'imposter', 'Among Us', 'sus', 'homework', 'markov', 'moment', 'nervous', 'shy', 'CHICKEN', 'sosig', 'brogle', 'Dad', 'Grand', 'Windows 95', 'Windows XP', 'big fat', 'blender', 'group', 'Phexonia', 'venezuelan', 'tf2', 'Bastard', 'obby', 'david', 'WARIO', 'sandals', 'livestream', 'youtube', 'minimum', 'pickle', 'NSFW', 'hot', 'RALEIGH', 'PEED FAMILY', 'gif', 'nostalgia critic', 'Britain', 'America', 'United Kingdom', 'soup', 'United States of America', 'WOMEN', 'wife', 'cat', 'marselo', 'tech support', 'indian', 'australian', 'japanese', 'Plants vs Zombies', 'Joe Biden', 'chinese', 'Chinese Republic', 'french fries', 'german', 'SWITZERLAND', 'denmark', 'Donald Trump', 'portuguese', 'nigerian', 'russian', 'beach', 'alpha', 'beta', 'theaters', 'Movie', 'Trailer', 'Lego', 'chalk', 'Documentation', 'mcdrive', 'Boner', 'Big', 'Giant', 'Small', 'Awesome', 'STOLEN', 'no', 'yes', 'car', 'Rigby', 'Mordecai', 'BENSON', 'park', 'blaster', 'gaster', 'Undertale', 'phil', 'Anvil', 'halloween', 'pumpkin', 'shut up', 'platinum', 'cheats', 'farms', 'GOLD', 'cake day', 'pizza slice', 'lasagna', 'quesadilla', 'enchilada', 'Miner\'s Haven', 'berezaa', 'LEGENDARY', 'Bee Swarm Simulator', 'beta tester', 'member', 'creator', 'family', 'Empire', 'Warfare', 'upvotes', 'downvotes', 'redditor', 'reddit', 'reddit arguments', 'twitter', 'twitter arguments', 'amongla', 'virus', 'viruses', 'INSTALL NOW', 'FL Studio VST', 'Torrent', 'Github', 'the ESSENCE', 'soup satan', 'soup god', 'quesley', 'empsy', 'illegal', 'legal', 'regal', 'deflorestation', 'DONKEY KONG', 'piss shit come', 'gay chains', 'Tss crazed', 'ralsei', 'üë∂', '‚úÖ', 'PIG', 'cucumber', 'mark\'s pizzeria', 'dominus pizza', 'pizza hut', 'wendy\'s', 'hat', 'tool', 'burger king', 'mcdonalds', 'nugget', 'fat', 'WTF', 'ROFL', 'XD', 'LMAO', 'LOL', 'Lad', 'Piid', 'LOUD', 'griefed', 'Fitmc', '2b2t', 'POPBOB', 'mommy', 'Survival', 'Jeff', 'Slender', 'Piggy', 'üêñ', 'artistic', 'Burrito', 'fart channel', 'üíì', 'Banjo', 'guitarist', 'guitar', 'chords', 'instruments', 'bingus', 'sussy', 'Big ass', 'crewmate', 'Imposter', 'choccy milk', 'thwomp', 'üê°', 'brain rot', 'your mom', 'baby', 'baby farting', 'Admin', 'EMOTE GAME', 'Sega', 'Sega Genesis', 'Newgrounds', 'Gamejolt', 'Steam', 'Epic Games', 'basket', 'update released', 'Soup Land', 'ROCKET', 'clash of clans', 'clothes', 'lore', 'fart machine', 'mech', 'Angry Birds', 'Bad Piggies', 'vlog', 'Poopy', 'machine', 'Thanos', 'porn', 'New emote', 'bought', 'Sun', 'Moon', 'Friday Night Funkin', 'Mod', 'Minecraft', 'Terraria', 'Roblox', 'Shaders', '2012', '2016', 'peter', 'GTA 6', 'GTA', 'bananas', 'shanky', 'PEED', 'Hollow Knight', 'Burrito Bison', 'Taco', 'taxes', 'budget', 'dollars', 'british', 'fluffy', 'brocolli', 'brain', 'SHIT', 'HELL', 'naked', 'babis', 'kingdom', 'HAHAHA', 'arabic', 'Rocket League', 'Fortnite', 'mrflimflam', 'Flamingo', 'rap', 'bitch', 'Poop', 'MARIO', 'crAck', 'Harambe', 'hellish', 'crimes', 'cordy', 'Halal', 'HARAM', 'Chungus', 'president', 'santa', 'idiot', 'WOW', 'SANS', 'FART', 'Garfield', 'POG', 'DEINX', 'discord', 'Super', 'Market', 'Mark', 'EXPLOSIVE', 'combat', 'oyster', 'Epico', 'Grammar', 'SUS', 'fresh', 'matilda', 'sonic', 'corpses', 'Egyptian', 'White', 'BLACK', 'wacky', 'card', 'credit', 'Tycoon', 'tunas', 'Israelite', 'Saudi', 'brazilian', 'Luigi', 'shawty']
    var tenorDictionary = ['mug', 'Talking Tom', 'Talking Ben', 'Talking Angela', 'IShowSpeed', 'deepwoken', 'pilgrammed', 'lean', 'ü§ì', 'punapea6', 'dream', 'soup land', 'phexonia studios', 'idfsgs', 'chips', 'racist', 'superbrohouse', 'deinx', 'bubbley', 'deinbag', 'another', 'crypyth', 'tordenask', 'lead', 'lumin', 'wovxzers', 'dootings', 'bartekoklol', 'tuca', 'ballfish', 'kleio', 'crazy', 'cinna', 'btn', 'tree', 'gritzy', 'ruki', 'henry', 'empsy', 'maks', 'henhen', 'phex', 'icre8', 'bilon', 'fnepp', 'zekkriel', 'tranzst', 'mance', 'luigistar', 'makos', 'spellbunny', 'scriptedsand', 'puppet', 'josh', 'spooky', 'catfishhotdog', 'robuk', 'pl0x7', 'lemoardo', 'dundeed', 'notsam', 'luigiluis', 'trongal', 'mysterymeatwad', 'carlito', 'azureblob', 'simpremove', 'gobby', 'sayori', 'concern', 'euth', 'dullminecraftsteve', 'gunk', 'betteruser', 'tix', 'charleh', 'jlol', 'Vesteria', 'Rogue Lineage', 'tricky', 'zardy', 'madness combat', 'splatoon', 'babis', 'carrot', 'vinegar', 'mushroom', 'stew', 'shroom', 'peashooter', 'frank', 'carl', 'oil', 'sunflower', 'chomper', 'piranha', 'fishes', 'fishe', 'fish', 'salami', 'furry', 'uwu', 'owo', 'flip', 'bottle', 'pork', 'demotion', 'promotion', 'Error', 'spoon', 'knife', 'african', 'üòÇ', 'yup', 'turtle', 'persian', 'Freddy', 'FNAF', 'giraffe', 'hippopotamus', 'coding', 'ocean', 'egg', 'tool', 'lad', 'lad village', 'GPU', 'CPU', 'lag', 'imposter', 'Among Us', 'sus', 'homework', 'CHICKEN', 'sosig', 'brogle', 'Windows 95', 'Windows XP', 'blender', 'Phexonia', 'tf2', 'Bastard', 'obby', 'david', 'WARIO', 'sandals', 'livestream', 'youtube', 'pickle', 'hot', 'RALEIGH', 'PEED FAMILY', 'gif', 'nostalgia critic', 'Britain', 'America', 'United Kingdom', 'soup', 'United States of America', 'WOMEN', 'cat', 'marselo', 'tech support', 'indian', 'japanese', 'Plants vs Zombies', 'Joe Biden', 'chinese', 'Chinese Republic', 'french fries', 'german', 'SWITZERLAND', 'denmark', 'Donald Trump', 'portuguese', 'nigerian', 'russian', 'beach', 'Lego', 'Documentation', 'mcdrive', 'no', 'yes', 'Rigby', 'Mordecai', 'BENSON', 'park', 'phil', 'Anvil', 'halloween', 'pumpkin', 'shut up', 'platinum', 'cheats', 'GOLD', 'cake day', 'pizza slice', 'lasagna', 'quesadilla', 'enchilada', 'Miner\'s Haven', 'berezaa', 'LEGENDARY', 'Bee Swarm Simulator', 'beta tester', 'creator', 'upvotes', 'downvotes', 'redditor', 'reddit', 'reddit arguments', 'twitter', 'twitter arguments', 'amongla', 'virus', 'viruses', 'INSTALL NOW', 'Torrent', 'Github', 'the ESSENCE', 'soup satan', 'soup god', 'quesley', 'empsy', , 'regal', 'deflorestation', 'DONKEY KONG', 'gay chains', 'Tss crazed', 'ralsei', 'üë∂', '‚úÖ', 'PIG', 'cucumber', 'mark\'s pizzeria', 'dominus pizza', 'pizza hut', 'wendy\'s', 'burger king', 'mcdonalds', 'nugget', 'fat', 'WTF', 'ROFL', 'XD', 'LMAO', 'LOL', 'Lad', 'griefed', 'Fitmc', '2b2t', 'POPBOB', 'Jeff', 'Slender', 'Piggy', 'üêñ', 'Burrito', 'fart channel', 'üíì', 'Banjo', 'guitarist', 'guitar', 'instruments', 'bingus', 'sussy', 'crewmate', 'Imposter', 'choccy milk', 'thwomp', 'üê°', 'baby', 'Admin', 'EMOTE GAME', 'Sega', 'Sega Genesis', 'Newgrounds', 'Gamejolt', 'Steam', 'Epic Games', 'basket', 'update released', 'Soup Land', 'ROCKET', 'clash of clans', 'lore', 'mech', 'Angry Birds', 'Bad Piggies', 'machine', 'Thanos', 'Sun', 'Moon', 'Friday Night Funkin', 'Mod', 'Minecraft', 'Terraria', 'Roblox', 'Shaders', '2012', '2016', 'peter', 'GTA 6', 'GTA', 'bananas', 'Hollow Knight', 'Burrito Bison', 'Taco', 'taxes', 'budget', 'dollars', 'british', 'brocolli', 'HELL', 'babis', 'kingdom', 'HAHAHA', 'arabic', 'Rocket League', 'Fortnite', 'mrflimflam', 'Flamingo', 'rap', 'MARIO', 'crimes', 'cordy', 'Halal', 'HARAM', 'Chungus', 'president', 'santa', 'WOW', 'FART', 'Garfield', 'POG', 'DEINX', 'discord', 'Market', 'Mark', 'EXPLOSIVE', 'combat', 'oyster', 'Epico', 'Grammar', 'SUS', 'fresh', 'matilda', 'sonic', 'Egyptian', 'White', 'BLACK', 'Tycoon', 'tunas', 'brazilian', 'Luigi']
    var arabConnectors = ['basically', 'literally', 'unexpected', 'expected', 'lost', 'lost his shit', 'grinds', 'since', 'I\'m', 'he\'s', 'she\'s', 'le', 'now', 'says', 'shitted', 'promoted', 'demoted', 'buttered', 'lagging', 'praying', 'died', 'streaming', 'skydiving', 'trolled', 'goes viral', 'fight', 'gets fired', 'like', 'love', 'driving', 'could', 'can', 'that', 'this', 'these', 'those', 'who', 'WHEN', 'so', 'called out', 'on', 'sued', 'cancelled', 'installed', 'removed', 'muting', 'am', 'are', 'arrested', 'i', 'you', 'he', 'his', 'her', 'she', 'it', 'that', 'the', 'is', 'was', 'a', 'an', 'watch', 'play', 'gotta', 'get', 'gaming', 'balling', 'yours', 'mine', 'your', 'you\'re', 'we\'re', 'they\'re', 'our', 'we', 'they', 'them', 'their', 'wipe', 'born', 'pissing', 'taken off', 'holed', 'off', 'out', 'flood', 'spamming', 'buy', 'hacking', 'smelling', 'have', 'become', 'be', 'watching', 'Added']
    var punctuation = ['?', '.', '!', '...']
    var caseModifiers = [
        function (text) {
            return text.toUpperCase()
        },
        function (text) {
            return text.toLowerCase()
        },
        function (text) {
            return text.toUpperCase().substring(0, 1) + text.toLowerCase().substring(1)
        }
    ]
    var globalPrefix = 'p:';
    var psFiles = ['i broke the json']
    var psPasta = ['i broke the json']
    var funnygifs = ['i broke the json']
    var poopPhrases = ['i broke the json']
    var dmPhrases = ['i broke the json']
    var emojiImages = []
    var json = {
        wordJSON: JSON.parse(fs.readFileSync('./templates/json/words.json')),
        continentJSON: JSON.parse(fs.readFileSync('./templates/json/continents.json')),
        countryJSON: JSON.parse(fs.readFileSync('./templates/json/countries.json')),
        languageJSON: JSON.parse(fs.readFileSync('./templates/json/languages.json')),
        cityJSON: JSON.parse(fs.readFileSync('./templates/json/cities.json')),
        restaurantJSON: JSON.parse(fs.readFileSync('./templates/json/foods.json')),
        sentenceJSON: JSON.parse(fs.readFileSync('./templates/json/sentences.json')),
        nounJSON: JSON.parse(fs.readFileSync('./templates/json/nouns.json')),
        verbJSON: JSON.parse(fs.readFileSync('./templates/json/verbs.json')),
        adjJSON: JSON.parse(fs.readFileSync('./templates/json/adjectives.json')),
        imageJSON: JSON.parse(fs.readFileSync('./templates/json/images.json')),
        nameJSON: JSON.parse(fs.readFileSync('./templates/json/names.json'))
    }
    var statuses = [
        {
            name: "the cycle of poopy",
            type: "WATCHING"
        },
        {
            name: "berezaa",
            type: "WATCHING"
        },
        {
            name: "beans",
            type: "WATCHING"
        },
        {
            name: "Deinx abusing admin",
            type: "LISTENING"
        },
        {
            name: "Soup",
            type: "PLAYING"
        },
        {
            name: "Garfield Kart",
            type: "PLAYING"
        },
        {
            name: "Troll Boxing",
            type: "COMPETING"
        },
        {
            name: "the Annoying Orange",
            type: "STREAMING"
        },
        {
            name: "",
            type: "WATCHING"
        },
        {
            name: "nine",
            type: "STREAMING"
        },
        {
            name: "simple steps on how to make a chocolate generator",
            type: "STREAMING"
        },
        {
            name: "me doing arson",
            type: "STREAMING"
        },
        {
            name: "the quadrillionth 2 minute long video with dramatic music",
            type: "LISTENING"
        },
        {
            name: "edgar",
            type: "LISTENING"
        },
        {
            name: "the sky",
            type: "WATCHING"
        },
        {
            name: "sprikrjdbdondpipopiekprjtiet (luigi remix)",
            type: "LISTENING"
        },
        {
            name: "the brown note",
            type: "LISTENING"
        },
        {
            name: "you",
            type: "WATCHING"
        },
        {
            name: "the salami lid",
            type: "COMPETING"
        },
        {
            name: "deals",
            type: "WATCHING"
        },
        {
            name: "the server get filled with femboys",
            type: "WATCHING"
        },
        {
            name: "drama",
            type: "LISTENING"
        },
        {
            name: "HELL",
            type: "COMPETING"
        },
        {
            name: "tenor gif search",
            type: "WATCHING"
        },
        {
            name: "myself getting banned from Roblox for no reason for uploading multiple frames of a banana GIF",
            type: "WATCHING"
        },
        {
            name: "The Furry Community",
            type: "PLAYING"
        },
        {
            name: "the economy fall",
            type: "WATCHING"
        },
        {
            name: "O RALSEI GARCELLO √â UM MEME DOIDO! Mod Deltarune Friday Night Funkin",
            type: "WATCHING"
        },
        {
            name: "my funny video playlist",
            type: "WATCHING"
        },
        {
            name: "pilgrammed soundtrack",
            type: "LISTENING"
        },
        {
            name: "bagel timelapse",
            type: "STREAMING"
        },
        {
            name: "Intel(R) Xeon(R) Platinum 8259CL CPU @ 2.50GHz",
            type: "WATCHING"
        },
        {
            name: "t",
            type: "LISTENING"
        },
        {
            name: "bowsers big bean burrito",
            type: "WATCHING"
        },
        {
            name: "fnaf",
            type: "PLAYING"
        },
        {
            name: "New",
            type: "PLAYING"
        },
        {
            name: "_______.exe",
            type: "PLAYING"
        },
        {
            name: "rogue lineage",
            type: "PLAYING"
        },
        {
            name: "I only said the death threats because they angered me",
            type: "LISTENING"
        },
        {
            name: "squid games by mr nick",
            type: "WATCHING"
        },
        {
            name: "Emote Game 3",
            type: "STREAMING"
        },
        {
            name: "crjypptoland",
            type: "COMPETING"
        },
        {
            name: "le nft rouge",
            type: "WATCHING"
        },
        {
            name: "a blender",
            type: "STREAMING"
        },
        {
            name: "fl studio",
            type: "LISTENING"
        },
        {
            name: "... A D",
            type: "COMPETING"
        },
        {
            name: "sayorine",
            type: "WATCHING"
        },
        {
            name: "YOUR HOUSE LOL",
            type: "STREAMING"
        },
        {
            name: "as a robloxian studying with a pencil on the book",
            type: "PLAYING"
        },
        {
            name: "Roblox üèÖ",
            type: "COMPETING"
        },
        {
            name: "poopy crash count",
            type: "STREAMING"
        },
        {
            name: "with your files",
            type: "PLAYING"
        },
        {
            name: "node.js",
            type: "PLAYING"
        },
        {
            name: "UNDERTALE",
            type: "STREAMING"
        },
        {
            name: "evil js programmer be like i do not want to kill myself",
            type: "PLAYING"
        },
        {
            name: "terraria babis mod",
            type: "PLAYING"
        },
        {
            name: "tModLoader",
            type: "PLAYING"
        },
        {
            name: "PLANTS VS ZOMBIES GARDEN WARFARE –ë–û–°–° –ú–û–î NIG",
            type: "PLAYING"
        },
        {
            name: "What are the true capabilities of Nr N? What is his purpose?",
            type: "LISTENING"
        },
        {
            name: "https://media.discordapp.net/attachments/535469236802551811/932928601735692349/EXEHOTVIdle.gif",
            type: "STREAMING"
        },
        {
            name: "gurt",
            type: "WATCHING"
        }
    ]
    var statusChanges = 'true'
    var filecount = 0
    var cps = 0
    var chromeWindow = false
    var statusInterval

    Math.lerp = function (start, end, amt) {
        return (1 - amt) * start + amt * end
    }

    function sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }

    function execPromise(code) {
        return new Promise((resolve) => {
            var args = code.match(/("[^"\\]*(?:\\[\S\s][^"\\]*)*"|'[^'\\]*(?:\\[\S\s][^'\\]*)*'|\/[^\/\\]*(?:\\[\S\s][^\/\\]*)*\/[gimy]*(?=\s|$)|(?:\\\s|\S)+)/g)
            var command = args.splice(0, 1)[0]

            var stdout = []
            var stderr = []

            var proc = spawn(command, args, {
                shell: true,
                env: {
                    ...process.env
                }
            })

            var memoryInterval = setInterval(() => {
                var usage = process.memoryUsage()
                var rss = usage.rss
                if ((rss / 1024 / 1024) <= memLimit) proc.kill('SIGINT')
            }, 1000)

            proc.stdout.on('data', (buffer) => {
                if (!buffer.toString()) return
                stdout.push(buffer.toString())
            })

            proc.stderr.on('data', (buffer) => {
                if (!buffer.toString()) return
                stderr.push(buffer.toString())
            })

            proc.on('error', (err) => {
                resolve(err.message)
            })

            proc.on('close', () => {
                var fproc = procs.findIndex(p => p === proc)
                if (fproc > -1) procs.splice(fproc, 1)
                var out = stdout.join('\n') || stderr.join('\n')
                clearInterval(memoryInterval)
                resolve(out)
            })

            procs.push(proc)
        })
    }

    async function getPsFiles() {
        return new Promise((resolve, reject) => {
            axios.get('https://raw.githubusercontent.com/raIeigh/ps-media-json/main/psfiles.json').then((res) => {
                try {
                    resolve(res.data.data)
                } catch (err) {
                    reject(err)
                }
            })
        })
    }

    async function getPsPasta() {
        return new Promise((resolve, reject) => {
            axios.get('https://raw.githubusercontent.com/raIeigh/ps-media-json/main/pspasta.json').then((res) => {
                try {
                    resolve(res.data.data)
                } catch (err) {
                    reject(err)
                }
            })
        })
    }

    async function getFunny() {
        return new Promise((resolve, reject) => {
            axios.get('https://raw.githubusercontent.com/raIeigh/ps-media-json/main/funnygif.json').then((res) => {
                try {
                    resolve(res.data.data)
                } catch (err) {
                    reject(err)
                }
            })
        })
    }

    async function gatherData(msg) {
        var webhook = await msg.fetchWebhook().catch(() => { })

        if (!webhook) {
            if (!data()[mongodatabase]['user-data'][msg.author.id]) {
                data()[mongodatabase]['user-data'][msg.author.id] = {}
            }

            data()[mongodatabase]['user-data'][msg.author.id]['username'] = msg.author.username

            if (!data()[mongodatabase]['user-data'][msg.author.id]['health']) {
                data()[mongodatabase]['user-data'][msg.author.id]['health'] = 100
            }
        }

        if (!data()[mongodatabase]['guild-data'][msg.guild.id]) {
            data()[mongodatabase]['guild-data'][msg.guild.id] = {}
        }

        if (data()[mongodatabase]['guild-data'][msg.guild.id]['read'] === undefined) {
            data()[mongodatabase]['guild-data'][msg.guild.id]['read'] = false
        }

        if (!data()[mongodatabase]['guild-data'][msg.guild.id]['gettingData']) {
            data()[mongodatabase]['guild-data'][msg.guild.id]['gettingData'] = 0
        }

        if (data()[mongodatabase]['guild-data'][msg.guild.id]['chaincommands'] == undefined) {
            data()[mongodatabase]['guild-data'][msg.guild.id]['chaincommands'] = true
        }

        if (data()[mongodatabase]['guild-data'][msg.guild.id]['prefix'] === undefined) {
            data()[mongodatabase]['guild-data'][msg.guild.id]['prefix'] = globalPrefix
        }

        if (!data()[mongodatabase]['guild-data'][msg.guild.id]['channels']) {
            data()[mongodatabase]['guild-data'][msg.guild.id]['channels'] = {}
        }

        if (!data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]) {
            data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id] = {}
        }

        if (!data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl']) {
            data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] = undefined
        }

        if (!data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl2']) {
            data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl2'] = undefined
        }

        if (!data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrls']) {
            data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrls'] = []
        }

        if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['read'] === undefined) {
            data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['read'] = false
        }

        if (!webhook) {
            if (!data()[mongodatabase]['guild-data'][msg.guild.id]['members']) {
                data()[mongodatabase]['guild-data'][msg.guild.id]['members'] = {}
            }

            if (!data()[mongodatabase]['guild-data'][msg.guild.id]['members'][msg.author.id]) {
                data()[mongodatabase]['guild-data'][msg.guild.id]['members'][msg.author.id] = {}
            }

            if (!data()[mongodatabase]['guild-data'][msg.guild.id]['members'][msg.author.id]['coolDown']) {
                data()[mongodatabase]['guild-data'][msg.guild.id]['members'][msg.author.id]['coolDown'] = false
            }

            data()[mongodatabase]['guild-data'][msg.guild.id]['members'][msg.author.id]['username'] = msg.author.username
        }

        if (!data()[mongodatabase]['guild-data'][msg.guild.id]['disabled']) {
            data()[mongodatabase]['guild-data'][msg.guild.id]['disabled'] = []
        }

        if (!data()[mongodatabase]['guild-data'][msg.guild.id]['localcmds']) {
            data()[mongodatabase]['guild-data'][msg.guild.id]['localcmds'] = []
        }

        if (!data()[mongodatabase]['guild-data'][msg.guild.id]['messages']) {
            data()[mongodatabase]['guild-data'][msg.guild.id]['messages'] = []
        }

        if (!data2[msg.guild.id]) {
            data2[msg.guild.id] = {}
        }

        if (!data2[msg.guild.id][msg.channel.id]) {
            data2[msg.guild.id][msg.channel.id] = {}
        }

        if (!data2[msg.guild.id][msg.channel.id][msg.author.id]) {
            data2[msg.guild.id][msg.channel.id][msg.author.id] = {}
        }

        if (!data2[msg.guild.id][msg.author.id]) {
            data2[msg.guild.id][msg.author.id] = {}
        }

        if (!data2[msg.guild.id][msg.author.id]['promises']) {
            data2[msg.guild.id][msg.author.id]['promises'] = []
        }

        if (!data2[msg.author.id]) {
            data2[msg.author.id] = {}
        }

        if (!data2[msg.author.id]['keyattempts']) {
            data2[msg.author.id]['keyattempts'] = 0
        }

        if (!data2[msg.author.id]['arrays']) {
            data2[msg.author.id]['arrays'] = {}
        }

        if (!data2[msg.author.id]['declared']) {
            data2[msg.author.id]['declared'] = {}
        }

        if (!data2[msg.author.id]['promises']) {
            data2[msg.author.id]['promises'] = []
        }

        if (!data2[msg.author.id]['eggphrases']) {
            data2[msg.author.id]['eggphrases'] = {}
        }

        if (!data2[msg.author.id]['eggphrases']['lastmention']) {
            data2[msg.author.id]['eggphrases']['lastmention'] = 0
        }

        if (!data2[msg.author.id]['eggphrases']['phrase']) {
            data2[msg.author.id]['eggphrases']['phrase'] = 0
        }

        var lastDataGather = Date.now() - data()[mongodatabase]['guild-data'][msg.guild.id]['gettingData']
        if (lastDataGather >= 600000) {
            async function gather() {
                var cantFetch = false

                for (var id in data()[mongodatabase]['guild-data'][msg.guild.id]['members']) {
                    var member = data()[mongodatabase]['guild-data'][msg.guild.id]['members'][id]
                    if (member.username === undefined) {
                        var user = await bot.users.fetch(id).catch(() => { })
                        if (!cantFetch) data()[mongodatabase]['guild-data'][msg.guild.id]['gettingData'] = Date.now()
                        if (user) {
                            data()[mongodatabase]['guild-data'][msg.guild.id]['members'][id]['username'] = user.username
                        } else {
                            delete data()[mongodatabase]['guild-data'][msg.guild.id]['members'][id]
                        }
                    }
                }
            }

            gather()
        }
    }

    function adjustedEncodeURIComponent(str) {
        return encodeURIComponent(str).replace(/[!'()*]/g, function (c) {
            return '%' + c.charCodeAt(0).toString(16);
        });
    }

    async function cleverbot(stim, id) {
        /*function encodeForSending(a) {
            var f = "";
            var d = "";
            a = a.replace(/[|]/g, "{*}");
            for (var b = 0; b <= a.length; b++) {
                if (a.charCodeAt(b) > 255) {
                    d = escape(a.charAt(b));
                    if (d.substring(0, 2) == "%u") {
                        f += "|" + d.substring(2, d.length)
                    } else {
                        f += d
                    }
                } else {
                    f += a.charAt(b)
                }
            }
            f = f.replace("|201C", "'").replace("|201D", "'").replace("|2018", "'").replace("|2019", "'").replace("`", "'").replace("%B4", "'").replace("|FF20", "").replace("|FE6B", "");
            return escape(f)
        }

        var jar = process.env.CLEVERBOTCOOKIE
        var contexts = {}
        var UA = "Mozilla/5.0 (Linux; Android 7.0; Redmi Note 4X) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/100.0.4896.127 Mobile Safari/537.36";

        var context = id;
        if (!Array.isArray(id)) {
            context = contexts[id] || (contexts[id] = [])
        }

        //if (!jar) jar = await fetch("https://www.cleverbot.com/", { headers: { "User-Agent": UA } }).then(a => a.headers.raw()['set-cookie'][0].split(";")[0]);

        var payload = `stimulus=${encodeForSending(stim)}`;
        if (context.length > 10) context.splice(0, context.length - 10)
        var l = context.length - 1;
        for (var i = 0; i <= l; i++) {
            payload += `&vText${i + 2}=${encodeForSending(context[l - i])}`;
        }
        payload += `&cb_settings_language=en&cb_settings_scripting=no&islearning=1&icognoid=wsf&icognocheck=${md5(payload.substring(7, 33))}`
        var res = await axios.request({ method: "POST", url: "https://www.cleverbot.com/webservicemin?uc=UseOfficialCleverbotAPI&ncf=V2&", data: payload, headers: { "Content-Type": "text/plain", "User-Agent": UA, Cookie: jar } })
            .then(a => a.data.split("\r")[0])
            .catch(() => '')
        if (id != undefined) context.push(stim);
        if (id != undefined) context.push(res);
        return res;*/
        
        var options = {
            method: 'GET',
            url: 'https://random-stuff-api.p.rapidapi.com/ai',
            params: {
                msg: stim,
                bot_name: bot.user.username,
                bot_gender: 'male',
                bot_master: 'raleigh',
                bot_age: '19',
                bot_company: 'poopy\'s lounge',
                bot_location: 'Nigeria',
                bot_email: 'poopystinkystinky@gmail.com',
                bot_build: 'private',
                bot_birth_year: '2002',
                bot_birth_date: '10th September, 2002',
                bot_birth_place: 'Nigeria',
                bot_favorite_color: 'yellow',
                bot_favorite_book: 'Diary of a Wimpy Kid',
                bot_favorite_band: 'Radiohead',
                bot_favorite_artist: 'Kanye West',
                bot_favorite_actress: 'your mom',
                bot_favorite_actor: 'Joe Biden',
                id: id
            },
            headers: {
                authorization: process.env.GAMERKEY,
                'x-rapidapi-host': 'random-stuff-api.p.rapidapi.com',
                'x-rapidapi-key': randomKey('RAPIDAPIKEY')
            }
        }
        
        var res = await axios.request(options).catch(() => { }) ?? { data: { AIResponse: '' } }
        
        return res.data.AIResponse
    }

    async function infoPost(message) {
        var avatar = bot.user.displayAvatarURL({ dynamic: true, size: 1024, format: 'png' })
        var color = await averageColor(avatar)
        await bot.guilds.cache.get('834431435704107018')?.channels.cache.get('967083645619830834')?.send({
            embeds: [{
                description: message,
                author: {
                    name: bot.user.username,
                    icon_url: avatar,
                },
                color: (color.r << 8 << 8) + (color.g << 8) + (color.b)
            }]
        }).catch(() => { })
    }

    function regexClean(str) {
        return str.replace(/[\\^$.|?*+()[{]/g, (match) => `\\${match}`)
    }

    function getKeyMod(string, { extrakeys = {}, extrafuncs = {} } = {}) {
        var lastParenthesesIndex = -1
        var llastParenthesesIndex = -1
        var rawParenthesesIndex = -1
        var rawrequired = 0
        var keyindex = -1
        var parindex = -1
        var parenthesesGoal = []
        var potentialindexes = []
        var rawMatch

        var keylist = special.keys
        var funclist = special.functions
        var pfunclist = []

        for (var k in keylist) {
            if (keylist[k].potential) {
                if (keylist[k].potential.funcs) {
                    for (var ff in keylist[k].potential.funcs) {
                        pfunclist[ff] = keylist[k].potential.funcs[ff]
                    }
                }
            }
        }
        for (var k in extrakeys) keylist[k] = extrakeys[k]

        for (var f in funclist) {
            if (funclist[f].potential) {
                if (funclist[f].potential.funcs) {
                    for (var ff in funclist[f].potential.funcs) {
                        pfunclist[ff] = funclist[f].potential.funcs[ff]
                    }
                }
            }
        }
        for (var f in extrafuncs) funclist[f] = extrafuncs[f]

        var keys = Object.keys(keylist)
        var funcs = Object.keys(funclist)
        var pfuncs = Object.keys(pfunclist)

        for (var i in string) {
            var char = string[i]

            switch (char) {
                case '(':
                    var funcmatch = (string.substring(0, i)).match(new RegExp(`(${funcs.map(f => regexClean(f)).join('|')})$`, 'i'))
                    var pfuncmatch = (string.substring(0, i)).match(new RegExp(`(${parenthesesGoal.length <= 0 ? pfuncs.map(f => regexClean(f)).join('|') : ''})$`, 'i'))

                    if (funcmatch) {
                        parindex++
                        lastParenthesesIndex = i
                        if (!rawMatch) {
                            var func = funclist[funcmatch[0].toLowerCase()]
                            if (func) {
                                if (func.raw) {
                                    rawParenthesesIndex = i
                                    rawrequired++
                                    rawMatch = funcmatch[0].toLowerCase()
                                }
                                if (func.parentheses) {
                                    parenthesesGoal.push(parindex - 1)
                                }
                            }
                        } else {
                            rawrequired++
                        }
                    } else if (pfuncmatch) {
                        parindex++
                        potentialindexes.push(parindex)
                    }
                    break

                case ')':
                    var funcmatch = (string.substring(0, lastParenthesesIndex)).match(new RegExp(`(${funcs.map(f => regexClean(f)).join('|')})$`, 'i'))

                    if (funcmatch && string[i - 1] !== '\\') {
                        if (parenthesesGoal.find(pgoal => parindex == pgoal)) {
                            parenthesesGoal.splice(parenthesesGoal.findIndex(pgoal => parindex == pgoal), 1)
                        }
                        if (potentialindexes.find(ind => ind === parindex)) {
                            potentialindexes.splice(potentialindexes.findIndex(ind => ind === parindex), 1)
                        } else {
                            if (!rawMatch) {
                                lastParenthesesIndex++
                                return {
                                    match: [funcmatch[0].toLowerCase(), string.substring(lastParenthesesIndex, i)],
                                    type: 'func'
                                }
                            } else {
                                rawrequired--
                                llastParenthesesIndex = i
                                if (rawrequired <= 0) {
                                    rawParenthesesIndex++
                                    return {
                                        match: [rawMatch, string.substring(rawParenthesesIndex, i)],
                                        type: 'func'
                                    }
                                }
                            }
                        }
                        parindex--
                    }
                    break
            }

            var keymatch = string.substring(i).match(new RegExp(`^(${keys.map(k => regexClean(k)).join('|')})`, 'i'))
            if (keymatch) {
                keyindex = i
                if (rawrequired <= 0) return {
                    match: keymatch[0].toLowerCase(),
                    type: 'key'
                }
            }
        }

        if (llastParenthesesIndex > -1) {
            var funcmatch = string.substring(0, lastParenthesesIndex).match(new RegExp(`(${funcs.map(f => regexClean(f)).join('|')})$`, 'i'))

            lastParenthesesIndex++
            return {
                match: [funcmatch[0].toLowerCase(), string.substring(lastParenthesesIndex, llastParenthesesIndex)],
                type: 'func'
            }
        }

        if (keyindex > -1) {
            var keymatch = string.substring(keyindex).match(new RegExp(`^(${keys.map(k => regexClean(k)).join('|')})`, 'i'))

            return {
                match: keymatch[0].toLowerCase(),
                type: 'key'
            }
        }

        return false
    }

    function splitKeyMod(string, { extrafuncs = {}, args = Infinity, separator = '|' } = {}) {
        var isDefaultSeparator = separator == '|'
        var lastParenthesesIndex = -1
        var lastSplitIndex = 0
        var parenthesesrequired = 0
        var parenthesesGoal = []
        var barfound = 0
        var split = []

        var funclist = special.functions
        var pfunclist = []

        for (var f in funclist) {
            if (funclist[f].potential) {
                if (funclist[f].potential.funcs) {
                    for (var ff in funclist[f].potential.funcs) {
                        pfunclist[ff] = funclist[f].potential.funcs[ff]
                    }
                }
            }
        }
        for (var f in extrafuncs) funclist[f] = extrafuncs[f]

        var funcs = Object.keys(funclist)
        var pfuncs = Object.keys(pfunclist)
        var afuncs = funcs.concat(pfuncs)

        for (var i in string) {
            var char = string[i]
            i = Number(i)

            switch (char) {
                case '(':
                    var funcmatch = (string.substring(0, i)).match(new RegExp(`(${parenthesesGoal.length <= 0 ? afuncs.map(f => regexClean(f)).join('|') : ''})$`, 'i'))
                    if (funcmatch) {
                        lastParenthesesIndex = i
                        parenthesesrequired++
                        var func = funclist[funcmatch[0].toLowerCase()]
                        if (func) {
                            if (func.parentheses) {
                                parenthesesGoal.push(parenthesesrequired - 1)
                            }
                        }
                    }
                    break

                case separator:
                    if (parenthesesrequired <= 0 && string[i - 1] !== '\\') {
                        split.push(string.substring(lastSplitIndex, i - ((string[i - 1] === ' ' && isDefaultSeparator) ? 1 : 0)))
                        lastSplitIndex = i + ((string[i + 1] === ' ' && isDefaultSeparator) ? 2 : 1)
                        barfound++
                    }
                    break

                case ')':
                    var funcmatch = (string.substring(0, lastParenthesesIndex)).match(new RegExp(`(${!parenthesesGoal.length > 0 ? afuncs.map(f => regexClean(f)).join('|') : ''})$`, 'i'))
                    if (funcmatch && string[i - 1] !== '\\') {
                        if (parenthesesGoal.find(pgoal => parenthesesrequired == pgoal)) {
                            parenthesesGoal.splice(parenthesesGoal.findIndex(pgoal => parenthesesrequired == pgoal), 1)
                        }
                        parenthesesrequired--
                    }
                    break
            }

            if (barfound == args - 1) {
                break
            }
        }

        split.push(string.substring(lastSplitIndex))

        return split.map(val => isDefaultSeparator ? val.replace(/\\\|/, '|') : val)
    }

    function getIndexOption(args, i, { dft = undefined, n = 1 } = {}) {
        return args.slice(i, i + n) || dft
    }

    function getOption(args, name, { dft = undefined, n = 1 } = {}) {
        var option = dft
        var optionindex = args.indexOf(`-${name}`)
        if (optionindex > -1) {
            option = []
            for (var i = 1; i <= n; i++) {
                option.push(args[optionindex + i])
            }
            return option
        }
    }

    function parseNumber(str, { dft = undefined, min = -Infinity, max = Infinity, round = false } = {}) {
        if (str === undefined || str === '') return dft
        var number = Number(str)
        return isNaN(number) ? dft : (round ? Math.round(Math.max(Math.min(number, max), min)) : Math.max(Math.min(number, max), min)) ?? dft
    }

    function parseString(str, validList, { dft = undefined, lower = false, upper = false } = {}) {
        if (str == undefined || str === '') return dft
        var query = upper ? str.toUpperCase() : lower ? str.toLowerCase() : str
        return validList.find(q => q == query) || dft
    }

    async function yesno(channel, content, who) {
        var buttonRow = new Discord.MessageActionRow()
        var yesbutton = new Discord.MessageButton()
            .setStyle('SUCCESS')
            .setEmoji('874406154619469864')
            .setCustomId('874406154619469864')
        var nobutton = new Discord.MessageButton()
            .setStyle('DANGER')
            .setEmoji('874406183933444156')
            .setCustomId('874406183933444156')
        buttonRow.addComponents([yesbutton])
        buttonRow.addComponents([nobutton])
        var similarMsg = await channel.send({
            content: content,
            components: [buttonRow]
        }).catch(() => { })

        if (!similarMsg) return

        return new Promise((resolve) => {
            var filter = async (button) => {
                if (!(button.user.id === who && button.user.id !== bot.user.id && !button.user.bot)) {
                    button.deferUpdate().catch(() => { })
                    return
                }
                if (button.customId === '874406154619469864') {
                    similarMsg.delete().catch(() => { })
                    resolve(true)
                } else if (button.customId === '874406183933444156') {
                    similarMsg.delete().catch(() => { })
                    resolve(false)
                } else {
                    button.deferUpdate().catch(() => { })
                }
            }

            similarMsg.awaitMessageComponent({ componentType: 'BUTTON', time: 60000, filter }).catch((err) => {
                if (err.message.endsWith('reason: time')) {
                    similarMsg.edit({
                        content: 'No response.',
                        components: []
                    }).catch(() => { })
                }
                resolve()
            })
        })
    }

    async function waitForChromeSessionEnd(msg) {
        return new Promise(async resolve => {
            var waitMessage
            setTimeout(async () => {
                if (waitMessage) {
                    if (chromeWindow) {
                        await chromeWindow.quit().catch(() => { })
                    }
                    resolve()
                }
            }, 60000 * 3)
            while (chromeWindow) {
                if (!waitMessage) waitMessage = await msg.channel.send('A Chrome session is currently occurring, and I can\'t have more than one or I malfunction, so you\'ll have to wait for it to end. If it takes more than 3 minutes for a Chrome session to be available, I\'ll just close it.').catch(() => { })
                await sleep(1000)
            }
            if (waitMessage) await waitMessage.delete().catch(() => { })
            resolve()
        })
    }

    function editDistance(s1, s2) {
        s1 = s1.toLowerCase();
        s2 = s2.toLowerCase();

        var costs = new Array();
        for (var i = 0; i <= s1.length; i++) {
            var lastValue = i;
            for (var j = 0; j <= s2.length; j++) {
                if (i == 0)
                    costs[j] = j;
                else {
                    if (j > 0) {
                        var newValue = costs[j - 1];
                        if (s1.charAt(i - 1) != s2.charAt(j - 1))
                            newValue = Math.min(Math.min(newValue, lastValue),
                                costs[j]) + 1;
                        costs[j - 1] = lastValue;
                        lastValue = newValue;
                    }
                }
            }
            if (i > 0)
                costs[s2.length] = lastValue;
        }
        return costs[s2.length];
    }

    function similarity(s1, s2) {
        var longer = s1;
        var shorter = s2;
        if (s1.length < s2.length) {
            longer = s2;
            shorter = s1;
        }
        var longerLength = longer.length;
        if (longerLength == 0) {
            return 1.0;
        }
        return (longerLength - editDistance(longer, shorter)) / parseFloat(longerLength);
    }

    function chunkArray(myArray, chunk_size) {
        var index = 0;
        var arrayLength = myArray.length;
        var tempArray = [];

        for (index = 0; index < arrayLength; index += chunk_size) {
            var myChunk = myArray.slice(index, index + chunk_size);
            tempArray.push(myChunk);
        }

        return tempArray;
    }

    function chunkObject(object, chunk_size) {
        var values = Object.values(object);
        var final = [];
        var counter = 0;
        var portion = {};

        for (var key in object) {
            if (counter !== 0 && counter % chunk_size === 0) {
                final.push(portion);
                portion = {};
            }
            portion[key] = values[counter];
            counter++
        }
        final.push(portion);

        return final
    }

    function generateId(unique) {
        var charset = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ-_'
        var length = 10
        var id = ''

        for (var i = 0; i < length; i++) {
            id += charset[Math.floor(Math.random() * charset.length)]
        }

        if (unique) {
            var cmdTemplates = data()[mongodatabase]['bot-data']['bot']['commandTemplates']

            if (cmdTemplates.length ? cmdTemplates.find(cmd => cmd.id === id) : false) {
                return generateId(unique)
            }
        }

        return id
    }

    async function replaceAsync(str, regex, asyncFn) {
        var promises = [];
        str.replace(regex, (match, ...args) => {
            var promise = asyncFn(match, ...args);
            promises.push(promise);
        });
        var data = await Promise.all(promises);
        return str.replace(regex, () => data.shift());
    }

    async function findAsync(arr, asyncCallback) {
        var promises = arr.map(asyncCallback);
        var results = await Promise.all(promises);
        var index = results.findIndex(result => result);
        return arr[index];
    }

    async function findIndexAsync(arr, asyncCallback) {
        var promises = arr.map(asyncCallback);
        var results = await Promise.all(promises);
        var index = results.findIndex(result => result);
        return index;
    }

    function markovChainGenerator(text) {
        var textArr = text.split(' ')
        var markovChain = [];
        markovChain.findChain = function (w) {
            return this.find(chain => chain.word === w)
        }
        markovChain.random = function () {
            return this[Math.floor(Math.random() * this.length)]
        }
        for (var i = 0; i < textArr.length; i++) {
            var word = textArr[i]
            if (word) {
                if (!markovChain.findChain(word.toLowerCase())) {
                    markovChain.push({
                        word: word.toLowerCase(),
                        forms: [],
                        next: [],
                        repeated: 0
                    })
                }
                markovChain.findChain(word.toLowerCase()).forms.push(word)
                markovChain.findChain(word.toLowerCase()).repeated++
                if (textArr[i + 1]) {
                    markovChain.findChain(word.toLowerCase()).next.push(textArr[i + 1]);
                }
            }
        }
        markovChain.sort((a, b) => {
            return b.repeated - a.repeated
        })
        return markovChain
    }

    function markovMe(markovChain, text = '', options = {}) {
        var words = markovChain.map(chain => chain.word)

        if (words.length <= 0) return 'no markov data for guild, arabotto 2020'

        var wordNumber = options.wordNumber
        var nopunctuation = options.nopunctuation
        var keepcase = options.keepcase

        var result = text ? text.split(' ') : []
        var chain = markovChain.random()
        var word = result[result.length - 1] || chain.forms[Math.floor(Math.random() * chain.forms.length)]
        result.splice(result.length - 1)
        var maxrepeat = markovChain[0].repeated
        var randomchance = 0
        for (var i = 0; i < (wordNumber || Math.min(words.length, Math.floor(Math.random() * 20) + 1)); i++) {
            result.push(word);
            if (validUrl.test(word) && !wordNumber) break
            var markov = markovChain.findChain(word.toLowerCase())
            var newWord = markov.next[Math.floor(Math.random() * markov.next.length)]
            word = newWord;
            randomchance = Math.lerp(randomchance, maxrepeat, 0.4)
            if (!word || !markovChain.findChain(word.toLowerCase()) || Math.floor(Math.random() * randomchance) >= maxrepeat * 0.5) {
                randomchance = 0
                chain = markovChain.random()
                word = chain.forms[Math.floor(Math.random() * chain.forms.length)]
            }
        }
        result = result.join(' ')
        if (!punctuation.find(p => result.match(new RegExp(`[${p}]$`))) && Math.floor(Math.random() * 5) === 0 && !nopunctuation) {
            result += punctuation[Math.floor(Math.random() * punctuation.length)]
        }
        if (Math.floor(Math.random() * 5) === 0 && !keepcase) {
            result = caseModifiers[Math.floor(Math.random() * caseModifiers.length)](result)
        }
        return result
    }

    function findpreset(args) {
        var presets = [
            'ultrafast',
            'superfast',
            'veryfast',
            'faster',
            'fast',
            'medium',
            'slow',
            'slower',
            'veryslow'
        ]
        var preset = 'ultrafast'
        var presetindex = args.indexOf('-encodingpreset')
        if (presetindex > -1) {
            if (presets.find(preset => preset === args[presetindex + 1].toLowerCase())) {
                preset = args[presetindex + 1]
            }
        }
        return preset
    }

    function findext(args, dft) {
        var ext = dft
        var extindex = args.indexOf('-ext')
        if (extindex > -1) {
            ext = args[extindex + 1]
        }
        return ext
    }

    function randomKey(name) {
        var i = 1
        var keys = []
        while (process.env[name + (i != 1 ? i : '')]) {
            keys.push(process.env[name + (i != 1 ? i : '')])
            i++
        }
        return keys[Math.floor(Math.random() * keys.length)]
    }

    async function correctUrl(url) {
        if (url.match(/^https\:\/\/(www\.)?tenor\.com\/view/) && url.match(/\d+/g)) {
            var ids = url.match(/\d+/g)
            var body = await axios.request(`https://g.tenor.com/v1/gifs?ids=${ids[ids.length - 1]}&key=${process.env.TENORKEY}`).catch(() => { })
            if (body && body.data.results.length) {
                infoPost(`Tenor URL detected`)
                return body.data.results[0].media[0].gif.url
            }
        } else if (url.match(/^https\:\/\/(www\.)?gyazo\.com/)) {
            var gifurl = url.replace(/^https\:\/\/(www\.)?gyazo\.com/, 'https://i.gyazo.com') + '.gif'
            var mp4url = url.replace(/^https\:\/\/(www\.)?gyazo\.com/, 'https://i.gyazo.com') + '.mp4'
            var pngurl = url.replace(/^https\:\/\/(www\.)?gyazo\.com/, 'https://i.gyazo.com') + '.png'
            var gyazourls = [gifurl, mp4url, pngurl]
            var gyazourl = undefined
            for (var i in gyazourls) {
                var url = gyazourls[i]
                var response = await axios.request({
                    url: url,
                    validateStatus: () => true
                }).catch(() => { })
                if (response && response.status >= 200 && response.status < 300) {
                    gyazourl = url
                    break
                }
            }
            if (gyazourl) {
                infoPost(`Gyazo URL detected`)
                return gyazourl
            }
        } else if (url.match(/^https\:\/\/(www\.)?imgur\.com/)) {
            var mp4url = url.replace(/^https\:\/\/(www\.)?imgur\.com/, 'https://i.imgur.com') + '.mp4'
            var pngurl = url.replace(/^https\:\/\/(www\.)?imgur\.com/, 'https://i.imgur.com') + '.png'
            var imgurls = [mp4url, pngurl]
            var imgurl = undefined
            for (var i in imgurls) {
                var url = imgurls[i]
                var response = await axios.request({
                    url: url,
                    validateStatus: () => true
                }).catch(() => { })
                if (response && response.status >= 200 && response.status < 300) {
                    imgurl = url
                    break
                }
            }
            if (imgurl) {
                infoPost(`Imgur URL detected`)
                return imgurl
            }
        } else if (url.match(/^https\:\/\/(www\.)?roblox\.com\/(catalog|library|games)\//)) {
            async function getAudio(id) {
                return new Promise((resolve) => {
                    axios.get(`https://www.roblox.com/library/${id}`).then(async (res) => {
                        var $ = cheerio.load(res.data)
                        var urls = $("#AssetThumbnail .MediaPlayerIcon")

                        if (urls.length > 0) {
                            resolve(urls[0].attribs['data-mediathumb-url'])
                            return
                        }

                        resolve()
                    }).catch(() => resolve())
                })
            }

            async function getTexture(id) {
                return new Promise((resolve) => {
                    axios.request({
                        method: 'GET',
                        url: `https://assetdelivery.roblox.com/v1/assetId/${id}`,
                        headers: {
                            "Accept": "application/json"
                        }
                    }).then(async (res) => {
                        var body = res.data
                        var rbxmurl = body.location

                        if (!rbxmurl) {
                            resolve()
                            return
                        }

                        axios.request(rbxmurl).then((rres) => {
                            var rbody = rres.data

                            var $ = cheerio.load(rbody)
                            var urls = $("url")
                            if (urls.length > 0) {
                                var imageasseturl = urls[0].children[0].data
                                var ids = imageasseturl.match(/\d+/g)
                                var id = ids[0]

                                axios.request({
                                    method: 'GET',
                                    url: `https://assetdelivery.roblox.com/v1/assetId/${id}`,
                                    headers: {
                                        "Accept": "application/json"
                                    }
                                }).then((ires) => {
                                    var ibody = ires.data
                                    var textureurl = ibody.location

                                    if (!textureurl) {
                                        resolve()
                                        return
                                    }

                                    resolve(textureurl)
                                }).catch(() => resolve())
                                return
                            }

                            resolve()
                        }).catch(() => resolve())
                    }).catch(() => resolve())
                })
            }

            async function getGame(id) {
                return new Promise((resolve) => {
                    axios.request({
                        method: 'GET',
                        url: `https://thumbnails.roblox.com/v1/places/gameicons?placeIds=${id}&size=512x512&format=Png&isCircular=false`,
                        headers: {
                            "Accept": "application/json"
                        }
                    }).then(async (res) => {
                        var body = res.data

                        if (body.data ? body.data.length > 0 : false) {
                            if (body.data[0].state === 'Pending') {
                                var url = await getGame(id).catch(() => { })
                                resolve(url)
                                return
                            }

                            resolve(body.data[0].imageUrl)
                            return
                        }

                        resolve()
                    }).catch(() => resolve())
                })
            }

            async function getThumb(id) {
                return new Promise((resolve) => {
                    axios.request({
                        method: 'GET',
                        url: `https://thumbnails.roblox.com/v1/assets?assetIds=${id}&size=700x700&format=Png&isCircular=false`,
                        headers: {
                            "Accept": "application/json"
                        }
                    }).then(async (res) => {
                        var body = res.data

                        if (body.data ? body.data.length > 0 : false) {
                            if (body.data[0].state === 'Pending') {
                                var url = await getThumb(id).catch(() => { })
                                resolve(url)
                                return
                            }

                            resolve(body.data[0].imageUrl)
                            return
                        }

                        resolve()
                    }).catch(() => resolve())
                })
            }

            async function getAsset(id) {
                var info = await noblox.getProductInfo(id).catch(() => { })

                if (info) {
                    if (info.AssetTypeId === 3) {
                        var audiourl = await getAudio(id).catch(() => { })

                        if (audiourl) {
                            infoPost(`Roblox audio URL detected`)
                            return audiourl
                        }
                    } else if (info.AssetTypeId === 2 || info.AssetTypeId === 11 || info.AssetTypeId === 12 || info.AssetTypeId === 13) {
                        var imageurl = await getTexture(id).catch(() => { })

                        if (imageurl) {
                            infoPost(`Roblox image asset URL detected`)
                            return imageurl
                        }
                    } else if (info.AssetTypeId === 9) {
                        var gameurl = await getGame(id).catch(() => { })

                        if (gameurl) {
                            infoPost(`Roblox game icon URL detected`)
                            return gameurl
                        }
                    } else {
                        var asseturl = await getThumb(id).catch(() => { })

                        if (asseturl) {
                            infoPost(`Roblox asset URL detected`)
                            return asseturl
                        }
                    }
                }
            }

            var ids = url.match(/\d+/g)
            if (ids.length) {
                var id = ids[0]
                var asseturl = await getAsset(id).catch(() => { })

                if (asseturl) return asseturl
            }
        } else if (url.match(/^https\:\/\/(www\.)?roblox\.com\/(badges)\//)) {
            async function getBadge(id) {
                return new Promise((resolve) => {
                    axios.request({
                        method: 'GET',
                        url: `https://thumbnails.roblox.com/v1/badges/icons?badgeIds=${id}&size=150x150&format=Png&isCircular=false`,
                        headers: {
                            "Accept": "application/json"
                        }
                    }).then(async (res) => {
                        var body = res.data

                        if (body.data ? body.data.length > 0 : false) {
                            if (body.data[0].state === 'Pending') {
                                var url = await getBadge(id).catch(() => { })
                                resolve(url)
                                return
                            }

                            resolve(body.data[0].imageUrl)
                            return
                        }

                        resolve()
                    }).catch(() => resolve())
                })
            }

            var ids = url.match(/\d+/g)
            if (ids.length) {
                var id = ids[0]
                var badgeurl = await getBadge(id).catch(() => { })

                if (badgeurl) {
                    infoPost(`Roblox badge URL detected`)
                    return badgeurl
                }
            }
        } else if (url.match(/^https\:\/\/(www\.)?roblox\.com\/(bundles)\//)) {
            async function getBundle(id) {
                return new Promise((resolve) => {
                    axios.request({
                        method: 'GET',
                        url: `https://thumbnails.roblox.com/v1/bundles/thumbnails?bundleIds=${id}&size=420x420&format=Png&isCircular=false`,
                        headers: {
                            "Accept": "application/json"
                        }
                    }).then(async (res) => {
                        var body = res.data

                        if (body.data ? body.data.length > 0 : false) {
                            if (body.data[0].state === 'Pending') {
                                var url = await getBundle(id).catch(() => { })
                                resolve(url)
                                return
                            }

                            resolve(body.data[0].imageUrl)
                            return
                        }

                        resolve()
                    }).catch(() => resolve())
                })
            }

            var ids = url.match(/\d+/g)
            if (ids.length) {
                var id = ids[0]
                var bundleurl = await getBundle(id).catch(() => { })

                if (bundleurl) {
                    infoPost(`Roblox bundle URL detected`)
                    return bundleurl
                }
            }
        } else if (url.match(/^https\:\/\/(www\.)?roblox\.com\/(game-pass)\//)) {
            async function getGamePass(id) {
                return new Promise((resolve) => {
                    axios.request({
                        method: 'GET',
                        url: `https://thumbnails.roblox.com/v1/game-passes?gamePassIds=${id}&size=150x150&format=Png&isCircular=false`,
                        headers: {
                            "Accept": "application/json"
                        }
                    }).then(async (res) => {
                        var body = res.data

                        if (body.data ? body.data.length > 0 : false) {
                            if (body.data[0].state === 'Pending') {
                                var url = await getGamePass(id).catch(() => { })
                                resolve(url)
                                return
                            }

                            resolve(body.data[0].imageUrl)
                            return
                        }

                        resolve()
                    }).catch(() => resolve())
                })
            }

            var ids = url.match(/\d+/g)
            if (ids.length) {
                var id = ids[0]
                var gamepassurl = await getGamePass(id).catch(() => { })

                if (gamepassurl) {
                    infoPost(`Roblox gamepass URL detected`)
                    return gamepassurl
                }
            }
        } else if (url.match(/^https\:\/\/(www\.)?roblox\.com\/(users)\//)) {
            async function getUser(id) {
                return new Promise((resolve) => {
                    axios.request({
                        method: 'GET',
                        url: `https://thumbnails.roblox.com/v1/users/avatar?userIds=${id}&size=720x720&format=Png&isCircular=false`,
                        headers: {
                            "Accept": "application/json"
                        }
                    }).then(async (res) => {
                        var body = res.data

                        if (body.data ? body.data.length > 0 : false) {
                            if (body.data[0].state === 'Pending') {
                                var url = await getUser(id).catch(() => { })
                                resolve(url)
                                return
                            }

                            resolve(body.data[0].imageUrl)
                            return
                        }

                        resolve()
                    }).catch(() => resolve())
                })
            }

            var ids = url.match(/\d+/g)
            if (ids.length) {
                var id = ids[0]
                var userurl = await getUser(id).catch(() => { })

                if (userurl) {
                    infoPost(`Roblox avatar URL detected`)
                    return userurl
                }
            }
        } else if (url.match(/^https\:\/\/(www\.)?roblox\.com\/(groups)\//)) {
            async function getGroup(id) {
                return new Promise((resolve) => {
                    axios.request({
                        method: 'GET',
                        url: `https://thumbnails.roblox.com/v1/groups/icons?groupIds=${id}&size=420x420&format=Png&isCircular=false`,
                        headers: {
                            "Accept": "application/json"
                        }
                    }).then(async (res) => {
                        var body = res.data

                        if (body.data ? body.data.length > 0 : false) {
                            if (body.data[0].state === 'Pending') {
                                var url = await getGroup(id).catch(() => { })
                                resolve(url)
                                return
                            }

                            resolve(body.data[0].imageUrl)
                            return
                        }

                        resolve()
                    }).catch(() => resolve())
                })
            }

            var ids = url.match(/\d+/g)
            if (ids.length) {
                var id = ids[0]
                var groupurl = await getGroup(id).catch(() => { })

                if (groupurl) {
                    infoPost(`Roblox group icon URL detected`)
                    return groupurl
                }
            }
        } else if (url.match(/^https\:\/\/((www|m)\.)?youtube\.com|^https\:\/\/(www\.)?youtu\.be/)) {
            var youtubeurl = await youtubedl(url, {
                format: '18',
                'get-url': ''
            }).catch(() => { })

            if (youtubeurl) {
                infoPost(`YouTube video URL detected`)
                return youtubeurl
            }
        } /*else if (url.match(/^https\:\/\/((www)\.)?reddit\.com\/r\/[a-zA-Z0-9][a-zA-Z0-9_]{2,20}/)) {
            var redditurls = await youtubedl(url, {
                format: '18',
                'get-url': ''
            }).catch(() => { })

            if (youtubeurl) return youtubeurl
        }*/ else if (url.match(/^https\:\/\/((www)\.)?(fx)?twitter\.com\/\w{4,15}\/status\/\d+/)) {
            async function getImageUrl(url) {
                return new Promise((resolve) => {
                    axios.request(url).then(async (res) => {
                        var $ = cheerio.load(res.data)
                        var urls = $('div .AdaptiveMedia-photoContainer.js-adaptive-photo')

                        if (urls.length > 0) {
                            resolve(urls[0].attribs['data-image-url'])
                            return
                        }

                        resolve()
                    }).catch(() => resolve())
                })
            }

            async function getGifUrl(url) {
                var twittergifurl = await youtubedl(url, {
                    format: 'http',
                    'get-url': ''
                }).catch(() => { })

                return twittergifurl
            }

            async function getVidUrl(url) {
                var twittervidurl = await youtubedl(url, {
                    format: 'http-832',
                    'get-url': ''
                }).catch(() => { })

                return twittervidurl
            }

            var twittervidurl = await getVidUrl(url).catch(() => { })
            var twittergifurl = await getGifUrl(url).catch(() => { })
            var twitterimageurl = await getImageUrl(url).catch(() => { })

            if (twittervidurl) {
                infoPost(`Twitter video URL detected`)
                return twittervidurl
            }

            if (twittergifurl) {
                infoPost(`Twitter GIF URL detected`)
                return twittergifurl
            }

            if (twitterimageurl) {
                infoPost(`Twitter image URL detected`)
                return twitterimageurl
            }
        }
        
        return url
    }

    async function getUrls(msg, options = {}) {
        if (!msg) return []
        var string = (options.string ?? msg.content ?? '').replace(/"([\s\S]*?)"/g, '')
        var prefixFound = string.toLowerCase().includes(data()[mongodatabase]['guild-data'][msg.guild.id]['prefix'].toLowerCase())
        var urls = []
        var regexes = [
            {
                regexp: emojiRegex,
                func: async function (emoji) {
                    var codepoints = []
                    for (var j = 0; j < [...emoji].length; j++) {
                        codepoints.push([...emoji][j].codePointAt().toString(16).padStart(4, '0'))
                    }
                    var emojiimage = emojiImages.find(image => image.unicode === codepoints.join('-'))
                    if (emojiimage) {
                        infoPost(`Emoji URL detected`)
                        return emojiimage.url
                    }
                }
            },
            {
                regexp: /<a?:.+?:\d+>/g,
                func: async function (demoji) {
                    var demojiidmatch = demoji.match(/\d+/g)
                    var demojiid = demojiidmatch[demojiidmatch.length - 1]
                    var gifurl = `https://cdn.discordapp.com/emojis/${demojiid}.gif?size=1024`
                    var pngurl = `https://cdn.discordapp.com/emojis/${demojiid}.png?size=1024`
                    var demojiurls = [gifurl, pngurl]
                    var demojiurl = undefined
                    for (var i in demojiurls) {
                        var url = demojiurls[i]
                        var response = await axios.request({
                            url: url,
                            validateStatus: () => true
                        }).catch(() => { })
                        if (response && response.status >= 200 && response.status < 300) {
                            demojiurl = url
                            break
                        }
                    }
                    if (demojiurl) {
                        infoPost(`Server emoji URL detected`)
                        return demojiurl
                    }
                }
            },
            {
                regexp: /\d{10,}/g,
                func: async function (id) {
                    var user = await bot.users.fetch(id).catch(() => { })
                    if (user) {
                        infoPost(`Discord avatar URL detected`)
                        return user.displayAvatarURL({ dynamic: true, size: 1024, format: 'png' })
                    }
                }
            },
            {
                regexp: validUrl,
                func: async function (url) {
                    var correctedurl = await correctUrl(url).catch(() => { }) ?? url

                    if (correctedurl == url) infoPost(`Default URL detected`)

                    return correctedurl
                }
            }
        ]

        if (!prefixFound) {
            regexes.splice(0, 3)
        }

        var urlregex = new RegExp(regexes.map(regex => `(${regex.regexp.source})`).join('|'), 'g')

        /*if (prefixPresent) {
            var emojimatch = string.match(emojiRegex)
            if (emojimatch) {
                emojimatch = emojimatch.reverse()
                for (var i in emojimatch) {
                    var emoji = emojimatch[i]
                    var codepoints = []
                    for (var j = 0; j < [...emoji].length; j++) {
                        codepoints.push([...emoji][j].codePointAt().toString(16).padStart(4, '0'))
                    }
                    var emojiurl = emojiImages.find(url => url.match(new RegExp(`[\\d\\w\\-\\_]+_${codepoints.join('-')}(_${codepoints[codepoints.length - 1]})?\\.png`)))
                    if (emojiurl) {
                        urls = [emojiurl].concat(urls)
                    }
                }
            }
            var demojimatch = string.match(/<a?:.+?:\d+>/g)
            if (demojimatch) {
                demojimatch = demojimatch.reverse()
                for (var i in demojimatch) {
                    var demojiidmatch = demojimatch[i].match(/\d+/g)
                    var demojiid = demojiidmatch[demojiidmatch.length - 1]
                    var gifurl = `https://cdn.discordapp.com/emojis/${demojiid}.gif?size=1024`
                    var pngurl = `https://cdn.discordapp.com/emojis/${demojiid}.png?size=1024`
                    var demojiurls = [gifurl, pngurl]
                    var demojiurl = undefined
                    for (var i in demojiurls) {
                        var url = demojiurls[i]
                        var response = await fetch(url)
                        if (response.status >= 200 && response.status < 300) {
                            demojiurl = url
                            break
                        }
                    }
                    if (demojiurl) {
                        urls = [demojiurl].concat(urls)
                    }
                }
            }
            var useridmatch = string.match(/\d{10,}/g)
            if (useridmatch) {
                useridmatch = useridmatch.reverse()
                for (var i in useridmatch) {
                    var id = useridmatch[i]
                    var user = await bot.users.fetch(id).catch(() => { })
                    if (user) {
                        urls = [user.displayAvatarURL({ dynamic: true, size: 1024, format: 'png' })].concat(urls)
                    }
                }
            }
        }

        var words = string.split(/[\s]+| ?-\|- ?/)
        var wordsreverse = words.reverse()

        for (var i in wordsreverse) {
            var word = wordsreverse[i]
            if (validUrl.test(word)) {
                var correctedurl = await correctUrl(word).catch(() => { })
                if (correctedurl) {
                    urls = [correctedurl].concat(urls)
                } else {
                    urls = [word].concat(urls)
                }
            }
        }*/

        var matches = string.match(urlregex)
        if (matches) {
            var matchesr = matches.reverse()
            for (var i in matchesr) {
                var match = matchesr[i]
                var matched = []
                regexes.forEach(regex => {
                    var m = match.match(regex.regexp)
                    if (m) {
                        regex.length = m[0].length
                        matched.push(regex)
                    }
                })
                matched.sort(function (a, b) {
                    return b.length - a.length
                })
                var url = await matched[0].func(match).catch(() => { })
                if (url) {
                    urls = [url].concat(urls)
                }
            }
        }

        if (msg.attachments.size) {
            var attachmentsR = []
            msg.attachments.forEach(attachment => {
                attachmentsR.push(attachment.url)
            })
            attachmentsR.reverse()
            attachmentsR.forEach(attachment => {
                urls = [attachment].concat(urls)
            })
        }

        var reply = await msg.fetchReference().catch(() => { })
        if (reply && !options.replied) {
            if (reply.guild) {
                urls = urls.concat(await getUrls(reply, {
                    replied: true
                }) ?? [])
            }
        }

        if (options.update) {
            var urlsr = urls.reverse()
            for (var i in urlsr) {
                var url = urlsr[i]

                data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl2'] = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl']
                data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] = url
                var lastUrls = [url].concat(data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrls'])
                lastUrls.splice(100)
                data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrls'] = lastUrls
            }
        }

        if (urls.length > 0) infoPost(`Found ${urls.length} URL${urls.length > 1 ? 's' : ''} in message`)

        return urls
    }

    async function getKeywordsFor(string, msg, isBot, { extrakeys = {}, extrafuncs = {}, resetattempts = false } = {}) {
        if (!data2[msg.author.id]) {
            data2[msg.author.id] = {}
        }

        if (!data2[msg.author.id]['keyattempts']) {
            data2[msg.author.id]['keyattempts'] = 0
        }

        if (!data2[msg.author.id]['arrays']) {
            data2[msg.author.id]['arrays'] = {}
        }

        if (!data2[msg.author.id]['declared']) {
            data2[msg.author.id]['declared'] = {}
        }

        if (!data2[msg.author.id]['keywordsExecuted']) {
            data2[msg.author.id]['keywordsExecuted'] = []
        }

        while (getKeyMod(string, { extrakeys: extrakeys, extrafuncs: extrafuncs }) !== false) {
            if (data2[msg.author.id]['keyattempts'] >= keyLimit) {
                return 'Keyword attempts value exceeded.'
            }

            var keydata = getKeyMod(string, { extrakeys: extrakeys, extrafuncs: extrafuncs })

            data2[msg.author.id]['keywordsExecuted'].push(typeof (keydata.match) == 'object' ? keydata.match[0] : keydata.match)

            switch (keydata.type) {
                case 'key':
                    var key = special.keys[keydata.match] || extrakeys[keydata.match]
                    data2[msg.author.id]['keyattempts'] += key.attemptvalue ?? 1
                    var func = key.func
                    var change = await func(msg, isBot, string).catch(() => { }) ?? ''
                    string = typeof (change) === 'object' && change[1] === true ? change[0] : string.replace(new RegExp(regexClean(keydata.match), 'i'), change)
                    break

                case 'func':
                    var [funcName, match] = keydata.match
                    var mod = special.functions[funcName] || extrafuncs[funcName]
                    data2[msg.author.id]['keyattempts'] += mod.attemptvalue ?? 1
                    var func = mod.func
                    var m = match
                    if (!mod.raw) {
                        match = await getKeywordsFor(match, msg, isBot, { extrakeys: extrakeys, extrafuncs: extrafuncs }).catch(() => { }) ?? m
                    }
                    match = match.replace(/\\\)/g, ')')
                    if (!mod.raw) {
                        string = string.replace(m, match)
                    }
                    var change = await func([funcName, match], msg, isBot, string).catch(() => { }) ?? ''
                    string = typeof (change) === 'object' && change[1] === true ? change[0] : string.replace(new RegExp(regexClean(`${funcName}(${match})`), 'i'), change)
                    break
            }
        }

        if (resetattempts) {
            data2[msg.author.id]['keyattempts'] = 0
            if (data2[msg.author.id]['keywordsExecuted'].length) {
                infoPost(`Executed keywords/functions: ${data2[msg.author.id]['keywordsExecuted'].map(k => `\`${k}\``).join(', ')}`)
            }
            data2[msg.author.id]['keywordsExecuted'] = []
        }

        return string
    }

    async function fetchImages(query, bing) {
        return new Promise(async (resolve) => {
            if (bing) {
                var options = {
                    method: 'GET',
                    url: 'https://bing-image-search1.p.rapidapi.com/images/search',
                    params: { q: query, count: '100', safeSearch: 'moderate' },
                    headers: {
                        'x-rapidapi-host': 'bing-image-search1.p.rapidapi.com',
                        'x-rapidapi-key': randomKey('RAPIDAPIKEY')
                    }
                };

                var response = await axios.request(options).catch(() => { })

                if (!response) {
                    resolve([])
                    return
                }

                if (!(response.status >= 200 && response.status < 300)) {
                    resolve([])
                    return
                }

                var images = []
                var body = response.data

                if (body.value ? body.value.length > 0 : false) {
                    images = body.value.map(result => result.contentUrl)
                }

                resolve(images)
            } else {
                gis(query, async function (_, results) {
                    var images = []

                    for (var i in results) {
                        var result = results[i]
                        var url = result.url.replace(/\\u([a-z0-9]){4}/g, (match) => {
                            return String.fromCharCode(Number('0x' + match.substring(2, match.length)))
                        })

                        images.push(url)
                    }

                    resolve(images)
                })
            }
        })
    }

    async function downloadFile(url, filename, options) {
        url = url || ' '
        options = options || {}
        var filepath
        var ffmpegUsed = false

        if (options.filepath) {
            filepath = options.filepath
        } else {
            var currentcount = filecount
            filecount++
            fs.mkdirSync(`temp/file${currentcount}`)
            filepath = `temp/file${currentcount}`
        }

        async function ffmpeg() {
            ffmpegUsed = true
            infoPost(`Downloading file through FFmpeg with name \`${filename}\``)
            if (options.fileinfo) {
                await execPromise(`ffmpeg -i "${url}"${options.ffmpegstring ? ` ${options.ffmpegstring}` : options.fileinfo.shortext === 'gif' ? ` -filter_complex "[0:v]split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -gifflags -offsetting` : options.fileinfo.shortext === 'png' ? ' -pix_fmt rgba' : options.fileinfo.shortext === 'mp4' ? ' -c:v libx264 -pix_fmt yuv420p' : options.fileinfo.shortext === 'mp3' ? ' -c:a libmp3lame' : ''} ${filepath}/${filename}`)
            } else {
                await execPromise(`ffmpeg -i "${url}"${options.ffmpegstring ? ` ${options.ffmpegstring}` : ''} ${filepath}/${filename}`)
            }
        }

        if (options.buffer) {
            infoPost(`Downloading file through buffer with name \`${filename}\``)
            fs.writeFileSync(`${filepath}/${filename}`, url)
        } else if (((!(options.fileinfo) ? true : ((options.fileinfo.shortext === options.fileinfo.type.ext) && (options.fileinfo.shortpixfmt === options.fileinfo.info.pixfmt))) || options.http) && !(options.ffmpeg)) {
            infoPost(`Downloading file through URL with name \`${filename}\``)
            var response = await axios.request({
                method: 'GET',
                url: url,
                responseType: 'arraybuffer'
            }).catch(() => { })

            if (response) {
                fs.writeFileSync(`${filepath}/${filename}`, response.data)
            }
        } else {
            await ffmpeg()
        }

        if (options.convert && !ffmpegUsed) {
            await ffmpeg()
        }

        infoPost(`Successfully downloaded \`${filename}\` in \`${filepath}\``)

        return filepath
    }

    async function sendFile(msg, filepath, filename, extraOptions) {
        extraOptions = extraOptions || {}

        var prefix = testing ? `2${data()[mongodatabase]['guild-data'][msg.guild.id]['prefix']}` : data()[mongodatabase]['guild-data'][msg.guild.id]['prefix']
        var args = msg.content.substring(prefix.toLowerCase().length).split(' ');

        extraOptions.catbox = !!args.find(arg => arg === '-catbox')
        extraOptions.nosend = !!args.find(arg => arg === '-nosend')

        var nameindex = args.indexOf('-filename')
        if (nameindex > -1 && args[nameindex + 1]) {
            extraOptions.name = args[nameindex + 1].replace(/[/\\?%*:|"<>]/g, '-').substring(0, 128)
        }

        try {
            fs.readFileSync(`${filepath}/${filename}`)
        } catch (_) {
            await msg.channel.send('Couldn\'t send file.').catch(() => { })
            infoPost(`Couldn\'t send file`)
            msg.channel.sendTyping().catch(() => { })
            fs.rmSync(filepath, { force: true, recursive: true })
            return
        }

        if (extraOptions.name) {
            fs.renameSync(`${filepath}/${filename}`, `${filepath}/${extraOptions.name}`)
            filename = extraOptions.name
        }

        if (extraOptions.catbox || extraOptions.nosend) {
            infoPost(`Uploading file to catbox.moe`)
            var fileLink = await Catbox.upload(`${filepath}/${filename}`).catch(() => { })
            if (fileLink) {
                var isUrl = validUrl.test(fileLink)

                if (extraOptions.nosend) {
                    if (isUrl) {
                        data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl2'] = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl']
                        data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] = fileLink
                        var lastUrls = [fileLink].concat(data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrls'])
                        lastUrls.splice(100)
                        data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrls'] = lastUrls
                    } else {
                        var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                        infoPost(`Couldn\'t upload catbox.moe file, reason:\n\`${fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink}\``)
                    }
                } else {
                    var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                    if (!isUrl) {
                        infoPost(`Couldn\'t upload catbox.moe file, reason:\n\`${fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink}\``)
                    }
                }
            } else {
                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                infoPost(`Couldn\'t upload catbox.moe file`)
            }
        } else {
            infoPost(`Sending file to channel`)
            var sendObject = {
                files: [new Discord.MessageAttachment(`${filepath}/${filename}`)]
            }

            if (extraOptions.content) sendObject.content = extraOptions.content

            var fileMsg = await msg.channel.send(sendObject).catch(() => { })

            if (!fileMsg) {
                await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                infoPost(`Failed to send file to channel, uploading to catbox.moe`)
                var fileLink = await Catbox.upload(`${filepath}/${filename}`).catch(() => { })
                if (fileLink) {
                    var isUrl = validUrl.test(fileLink)
                    var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                    
                    if (!isUrl) {
                        infoPost(`Couldn\'t upload catbox.moe file, reason:\n\`${fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink}\``)
                    }
                } else {
                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                    infoPost(`Couldn\'t upload catbox.moe file`)
                }
            }
        }

        msg.channel.sendTyping().catch(() => { })

        if (!extraOptions.keep && filepath !== undefined) {
            infoPost(`Deleting \`${filepath}/${filename}\` and its folder`)
            fs.rmSync(filepath, { force: true, recursive: true })
        }
    }

    async function validateFileFromPath(path, exception, rejectMessages) {
        return new Promise(async (resolve, reject) => {
            infoPost(`Validating file from path`)

            var rej = reject
            reject = function(val) {
                infoPost(`File can't be processed, reason:\n\`${val}\``)
                rej(val)
            }

            if ((process.memoryUsage().rss / 1024 / 1024) <= memLimit) {
                reject('No resources available.')
                return
            }

            var type = await fileType.fromFile(path).catch(() => { })

            if (!type) {
                var body = fs.readFileSync(path).toString()
                type = { mime: body.match(/<[a-z]>(.*?)<\/[a-z]>/g) ? 'text/html' : 'text/plain', ext: body.match(/<[a-z]>(.*?)<\/[a-z]>/g) ? 'html' : 'plain' }
            }

            var info = {
                frames: 1,
                fps: '0/0',
                duration: 'N/A',
                aduration: 'N/A',
                width: 0,
                height: 0,
                audio: false,
                pixfmt: 'unk',
                size: 0,
                realsize: 0
            }
            var names = path.split('/')
            var limitObject = exception ? limitsexcept : limits
            var shorttype
            var shortext
            var shortpixfmt

            if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                shorttype = 'image'
                shortext = 'png'
                shortpixfmt = 'rgba'
            } else if (type.mime.startsWith('video')) {
                shorttype = 'video'
                shortext = 'mp4'
                shortpixfmt = 'yuv420p'
            } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                shorttype = 'gif'
                shortext = 'gif'
                shortpixfmt = 'bgra'
            } else if (type.mime.startsWith('audio')) {
                shorttype = 'audio'
                shortext = 'mp3'
                shortpixfmt = 'unk'
            } else {
                shorttype = type.mime.split('/')[0]
                shortext = type.ext
                shortpixfmt = 'unk'
            }

            info.size = fs.readFileSync(path).length / 1048576
            info.realsize = fs.readFileSync(path).length

            var json = await execPromise(`ffprobe -of json -show_streams -show_format ${path}`)
            if (json) {
                try {
                    var jsoninfo = JSON.parse(json)
                    if (jsoninfo["streams"]) {
                        var videoStream = jsoninfo["streams"].find(stream => stream["codec_type"] === 'video')
                        var audioStream = jsoninfo["streams"].find(stream => stream["codec_type"] === 'audio')

                        if ((type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) || type.mime.startsWith('video')) {
                            info.frames = videoStream["nb_frames"] || 0
                            info.fps = videoStream["r_frame_rate"] || '0/0'
                        }
                        if (type.mime.startsWith('video') || type.mime.startsWith('audio')) {
                            info.audio = !!audioStream
                        }
                        if ((type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) || type.mime.startsWith('video') || type.mime.startsWith('audio')) {
                            info.duration = (videoStream || audioStream)["duration"] || 0
                        }
                        if ((type.mime.startsWith('video') || type.mime.startsWith('audio')) && info.audio) {
                            info.aduration = audioStream["duration"] || 0
                        }
                        if (type.mime.startsWith('image') || type.mime.startsWith('video')) {
                            info.width = videoStream["width"] || 0
                            info.height = videoStream["height"] || 0
                            info.pixfmt = videoStream["pix_fmt"] || 'unk'
                        }
                    }
                } catch (_) { }
            }

            if (exception !== 'very true') {
                for (var paramName in info) {
                    if (limitObject[paramName]) {
                        var param = info[paramName]
                        var rejectMessage = rejectMessages ? rejectMessages[paramName] : limitObject[paramName]['message']

                        if (param >= limitObject[paramName][shorttype]) {
                            reject(rejectMessage.replace('{param}', limitObject[paramName][shorttype]))
                            return
                        }
                    }
                }
            }

            infoPost(`File \`${names[names.length - 1]}\` was successfully validated`)

            resolve({
                type: type,
                shorttype: shorttype,
                shortext: shortext,
                shortpixfmt: shortpixfmt,
                name: names[names.length - 1],
                info: info
            })
        })
    }

    async function validateFile(url, exception, rejectMessages) {
        return new Promise(async (resolve, reject) => {
            infoPost(`Validating file from URL`)

            var rej = reject
            reject = function(val) {
                infoPost(`File can't be processed, reason:\n\`${val}\``)
                rej(val)
            }

            url = url || ' '
            if ((process.memoryUsage().rss / 1024 / 1024) <= memLimit) {
                reject('No resources available.')
                return
            }

            var response = await axios.request({
                method: 'GET',
                url: url,
                responseType: 'stream',
                validateStatus: () => true
            }).catch((err) => {
                reject(err.message)
            })

            if (!response) {
                return
            }

            if (!(response.status >= 200 && response.status < 300)) {
                reject(`${response.status} ${response.statusText}`)
                return
            }

            var headers = response.headers
            var type = await fileType.fromStream(response.data).catch(() => { })

            if (!type) {
                var contentType = headers['Content-Type'] || headers['content-type']
                var mime = contentType.match(/[^;]+/)
                type = { mime: mime[0], ext: mime[0].split('/')[1] }
            }

            var info = {
                frames: 1,
                fps: '0/0',
                duration: 'N/A',
                aduration: 'N/A',
                width: 0,
                height: 0,
                audio: false,
                pixfmt: 'unk',
                size: 0,
                realsize: 0
            }
            var limitObject = exception ? limitsexcept : limits
            var name
            var shorttype
            var shortext
            var shortpixfmt

            if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                shorttype = 'image'
                shortext = 'png'
                shortpixfmt = 'rgba'
            } else if (type.mime.startsWith('video')) {
                shorttype = 'video'
                shortext = 'mp4'
                shortpixfmt = 'yuv420p'
            } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                shorttype = 'gif'
                shortext = 'gif'
                shortpixfmt = 'bgra'
            } else if (type.mime.startsWith('audio')) {
                shorttype = 'audio'
                shortext = 'mp3'
                shortpixfmt = 'unk'
            } else {
                shorttype = type.mime.split('/')[0]
                shortext = type.ext
                shortpixfmt = 'unk'
            }

            var nameurl = headers['Location'] || headers['location'] || url
            var parsedurl = whatwg.parseURL(nameurl)
            name = parsedurl.path[parsedurl.path.length - 1]
            var contentdisposition = headers['content-disposition']
            if (contentdisposition) {
                var filenameMatch = contentdisposition.match(/filename=".+"/)
                if (filenameMatch) {
                    name = filenameMatch[0].substring(10, filenameMatch[0].length - 1)
                }
            }

            var contentLength = headers['content-length'] || headers['Content-Length']

            if (contentLength) {
                info.size = Number(contentLength) / 1048576
                info.realsize = Number(contentLength)
            } else {
                var bufferresponse = await axios.request({
                    method: 'GET',
                    url: url,
                    responseType: 'arraybuffer'
                }).catch(() => { }) ?? { data: '' }

                info.size = bufferresponse.data.length / 1048576
                info.realsize = bufferresponse.data.length
            }

            var json = await execPromise(`ffprobe -of json -show_streams -show_format "${url}"`).catch(() => { })
            if (json) {
                try {
                    var jsoninfo = JSON.parse(json)
                    if (jsoninfo["streams"]) {
                        var videoStream = jsoninfo["streams"].find(stream => stream["codec_type"] === 'video')
                        var audioStream = jsoninfo["streams"].find(stream => stream["codec_type"] === 'audio')

                        if ((type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) || type.mime.startsWith('video')) {
                            info.frames = videoStream["nb_frames"] || 0
                            info.fps = videoStream["r_frame_rate"] || '0/0'
                        }
                        if (type.mime.startsWith('video') || type.mime.startsWith('audio')) {
                            info.audio = !!audioStream
                        }
                        if ((type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) || type.mime.startsWith('video') || type.mime.startsWith('audio')) {
                            info.duration = (videoStream || audioStream)["duration"] || 0
                        }
                        if ((type.mime.startsWith('video') || type.mime.startsWith('audio')) && info.audio) {
                            info.aduration = audioStream["duration"] || 0
                        }
                        if (type.mime.startsWith('image') || type.mime.startsWith('video')) {
                            info.width = videoStream["width"] || 0
                            info.height = videoStream["height"] || 0
                            info.pixfmt = videoStream["pix_fmt"] || 'unk'
                        }
                    }
                } catch (_) { }
            }

            if (exception !== 'very true') {
                for (var paramName in info) {
                    if (limitObject[paramName]) {
                        var param = info[paramName]
                        var rejectMessage = rejectMessages ? rejectMessages[paramName] : limitObject[paramName]['message']

                        if (param >= limitObject[paramName][shorttype]) {
                            reject(rejectMessage.replace('{param}', limitObject[paramName][shorttype]))
                            return
                        }
                    }
                }
            }

            infoPost(`File \`${name}\` was successfully validated`)

            resolve({
                type: type,
                shorttype: shorttype,
                shortext: shortext,
                shortpixfmt: shortpixfmt,
                name: name,
                info: info
            })
        })
    }

    function changeStatus() {
        if (bot && statusChanges === 'true') {
            var choosenStatus = statuses[Math.floor(Math.random() * statuses.length)]
            infoPost(`Status changed to ${choosenStatus.type.toLowerCase() + ' ' + ((choosenStatus.type === "COMPETING" && 'in ') || (choosenStatus.type === "LISTENING" && 'to ') || '') + choosenStatus.name.replace(/ \| 2?p\:help$/, '')}`)
            bot.user.setPresence({
                status: 'online',
                activities: [
                    {
                        name: choosenStatus['name'] + ` | ${testing ? '2' : ''}p:help`,
                        type: choosenStatus['type'],
                        url: 'https://www.youtube.com/watch?v=LDQO0ALm0gE',
                    }
                ],
            });
        }
    }

    async function save() {
        infoPost(`Saving data`)
        if (testing) {
            fs.writeFileSync('data.json', JSON.stringify(data()), () => { });
        } else {
            await updateAllData(mongodatabase, data()[mongodatabase]).catch(() => { })
        }
        infoPost(`Data saved`)
    }

    var special = {
        keys: {
            _rkeyword: {
                desc: "Returns a random keyword.",

                func: async (msg) => {
                    var keys = []
                    for (var k in special.keys) {
                        keys.push(k)
                    }
                    return special.keys[keys[Math.floor(Math.random() * keys.length)]].func(msg)
                },

                attemptvalue: 2
            },

            _puncmark: {
                desc: "Returns a random punctuation mark.",

                func: async () => {
                    return punctuation[Math.floor(Math.random() * punctuation.length)]
                },
            },

            _word: {
                desc: "Returns a random word.",

                func: async () => {
                    var wordJSON = json.wordJSON
                    return wordJSON.data[Math.floor(Math.random() * wordJSON.data.length)].word.value
                },
            },

            _continent: {
                desc: "Returns a random continent.",

                func: async () => {
                    var continentJSON = json.continentJSON
                    var continentCodes = Object.keys(continentJSON)
                    return continentJSON[continentCodes[Math.floor(Math.random() * continentCodes.length)]]
                },
            },

            _countrycode: {
                desc: "Returns a random country code.",

                func: async () => {
                    var countryJSON = json.countryJSON
                    var countryCodes = Object.keys(countryJSON)
                    return countryCodes[Math.floor(Math.random() * countryCodes.length)]
                },
            },

            _country: {
                desc: "Returns a random country.",

                func: async () => {
                    var countryJSON = json.countryJSON
                    var countryCodes = Object.keys(countryJSON)
                    return countryJSON[countryCodes[Math.floor(Math.random() * countryCodes.length)]].name
                },
            },

            _nationality: {
                desc: "Returns a random nationality.",

                func: async () => {
                    var languageJSON = json.languageJSON
                    var languageCodes = Object.keys(languageJSON)
                    return languageJSON[languageCodes[Math.floor(Math.random() * languageCodes.length)]].name
                },
            },

            _city: {
                desc: "Returns a random city.",

                func: async () => {
                    var cityJSON = json.cityJSON
                    return cityJSON[Math.floor(Math.random() * cityJSON.length)].name
                },
            },

            _restaurantfood: {
                desc: "Returns a random food from a restaurant.",

                func: async () => {
                    var restaurantJSON = json.restaurantJSON
                    var restaurant = restaurantJSON[Math.floor(Math.random() * restaurantJSON.length)]
                    return restaurant.foodItems[Math.floor(Math.random() * restaurant.foodItems.length)].foodName
                },
            },

            _restaurant: {
                desc: "Returns a random restaurant.",

                func: async () => {
                    var restaurantJSON = json.restaurantJSON
                    return restaurantJSON[Math.floor(Math.random() * restaurantJSON.length)].restaurant
                },
            },

            _food: {
                desc: "Returns a random food.",

                func: async () => {
                    var foods = ["apple", "apricot", "artichoke", "arugula", "avocado", "bacon", "bagel", "baked ziti", "bamboo shoot", "banana", "barbecue", "beef", "bell pepper", "berry", "biscuits and gravy", "bitter melon", "blackberry", "boiled peanuts", "boysenberry", "bread", "breakfast burrito", "breakfast cereal", "breakfast sandwich", "breakfast sausage", "broad bean", "broccoli", "brussels sprout", "buffalo burger", "buffalo wing", "butter", "cabbage", "calzone", "cantaloupe", "carambola", "carrot", "cauliflower", "celery", "cereal", "chard", "chayote", "cherimoya", "cherry", "chicken and waffles", "chicken divan", "chicken fingers", "chicken fried steak", "chicken meat", "chicken soup", "chicory", "chili con carne", "chili pepper", "chocolate chip cookie", "chocolate milk", "cinnamon roll", "clam chowder", "coconut", "coffee", "common fig", "condiment", "corn chowder", "cornbread", "corned beef", "cottage cheese", "crab cake", "cracker", "cranberry", "cream cheese", "croissant", "cucumber", "daikon", "date palm", "doughnut", "durian", "egg as food", "eggplant", "eggs benedict", "enchilada", "endive", "energy bar", "english muffin", "fajita", "fettuccine alfredo", "fortune cookie", "french toast", "fried chicken", "fried egg", "fried fish", "frito pie", "fruit", "frybread", "garden asparagus", "garden rhubarb", "garlic", "gooseberry", "grape", "grapefruit", "gravy", "green bean", "green bean casserole", "grits", "gumbo", "hamburger", "hash browns", "herb", "hoppin' john", "horned melon", "hot dog", "huevos rancheros", "jambalaya", "jell-o", "jerky", "juice", "jujube", "kale", "kiwifruit", "kohlrabi", "kumquat", "lasagne", "leek", "lemon", "lettuce", "lime", "lobster roll", "longan", "loquat", "lychee", "macaroni and cheese", "maize", "mango", "marrow-stem kale", "meat", "meatloaf", "milk", "mozzarella", "muffin", "muffuletta", "muskmelon", "mustard greens", "napa cabbage", "noodle", "oatmeal", "okra", "olive", "omelette", "onion", "orange", "orange juice", "pancake", "papaya", "parmigiana", "parsnip", "passion fruit", "pasta", "pea", "peach", "peanut butter", "pear", "persimmon", "pineapple", "pitaya", "pizza", "pomegranate", "pomelo", "popcorn", "pork", "potato", "prune", "purple mangosteen", "quiche", "quince", "radish", "rapini", "raspberry", "red cabbage", "rice", "roast chicken", "rutabaga", "salad", "sandwich", "sauce", "sausage", "scallion", "scrambled eggs", "seafood", "seasoning", "shallot", "sloppy joe", "smoothie", "soursop", "spaghetti", "spinach", "steak", "strawberry", "stuffing", "taco", "taco salad", "taco soup", "tangelo", "tangerine", "tea", "thanksgiving dinner", "tomato", "tortellini", "turnip", "turnip greens", "waffle", "watercress", "watermelon", "yogurt", "zucchini"]
                    return foods[Math.floor(Math.random() * foods.length)]
                },
            },

            _fruit: {
                desc: "Returns a random fruit.",

                func: async () => {
                    var fruits = ["apple", "apricot", "avocado", "banana", "berry", "blackberry", "boysenberry", "cantaloupe", "carambola", "cherimoya", "cherry", "coconut", "common fig", "cranberry", "date palm", "durian", "gooseberry", "grape", "grapefruit", "horned melon", "jujube", "kiwifruit", "kumquat", "lemon", "lime", "longan", "loquat", "lychee", "mango", "muskmelon", "olive", "orange", "papaya", "passion fruit", "peach", "pear", "persimmon", "pineapple", "pitaya", "pomegranate", "pomelo", "prune", "purple mangosteen", "quince", "raspberry", "soursop", "strawberry", "tangelo", "tangerine", "watermelon"]
                    return fruits[Math.floor(Math.random() * fruits.length)]
                },
            },

            _vegetable: {
                desc: "Returns a random vegetable.",

                func: async () => {
                    var vegetables = ["artichoke", "arugula", "bamboo shoot", "bell pepper", "bitter melon", "broad bean", "broccoli", "brussels sprout", "cabbage", "carrot", "cauliflower", "celery", "chard", "chayote", "chicory", "chili pepper", "cucumber", "daikon", "eggplant", "endive", "garden asparagus", "garden rhubarb", "garlic", "green bean", "herb", "kale", "kohlrabi", "leek", "lettuce", "maize", "marrow-stem kale", "mustard greens", "napa cabbage", "okra", "onion", "parsnip", "pea", "potato", "radish", "rapini", "red cabbage", "rutabaga", "scallion", "shallot", "spinach", "tomato", "turnip", "turnip greens", "watercress", "zucchini"]
                    return vegetables[Math.floor(Math.random() * vegetables.length)]
                },
            },

            _animal: {
                desc: "Returns a random animal.",

                func: async () => {
                    var animals = ["meerkat", "aardvark", "addax", "alligator", "alpaca", "anteater", "antelope", "aoudad", "ape", "argali", "armadillo", "baboon", "badger", "basilisk", "bat", "bear", "beaver", "bighorn", "bison", "boar", "budgerigar", "buffalo", "bull", "bunny", "burro", "camel", "canary", "capybara", "cat", "chameleon", "chamois", "cheetah", "chimpanzee", "chinchilla", "chipmunk", "civet", "coati", "colt", "cougar", "cow", "coyote", "crocodile", "crow", "deer", "dingo", "doe", "dung beetle", "dog", "donkey", "dormouse", "dromedary", "duckbill platypus", "dugong", "eland", "elephant", "elk", "ermine", "ewe", "fawn", "ferret", "finch", "fish", "fox", "frog", "gazelle", "gemsbok", "gila monster", "giraffe", "gnu", "goat", "gopher", "gorilla", "grizzly bear", "ground hog", "guanaco", "guinea pig", "hamster", "hare", "hartebeest", "hedgehog", "highland cow", "hippopotamus", "hog", "horse", "hyena", "ibex", "iguana", "impala", "jackal", "jaguar", "jerboa", "kangaroo", "kitten", "koala", "lamb", "lemur", "leopard", "lion", "lizard", "llama", "lovebird", "lynx", "mandrill", "mare", "marmoset", "marten", "mink", "mole", "mongoose", "monkey", "moose", "mountain goat", "mouse", "mule", "musk deer", "musk-ox", "muskrat", "mustang", "mynah bird", "newt", "ocelot", "okapi", "opossum", "orangutan", "oryx", "otter", "ox", "panda", "panther", "parakeet", "parrot", "peccary", "pig", "octopus", "thorny devil", "starfish", "blue crab", "snowy owl", "chicken", "rooster", "bumble bee", "eagle owl", "polar bear", "pony", "porcupine", "porpoise", "prairie dog", "pronghorn", "puma", "puppy", "quagga", "rabbit", "raccoon", "ram", "rat", "reindeer", "rhinoceros", "salamander", "seal", "sheep", "shrew", "silver fox", "skunk", "sloth", "snake", "springbok", "squirrel", "stallion", "steer", "tapir", "tiger", "toad", "turtle", "vicuna", "walrus", "warthog", "waterbuck", "weasel", "whale", "wildcat", "bald eagle", "wolf", "wolverine", "wombat", "woodchuck", "yak", "zebra", "zebu"]
                    return animals[Math.floor(Math.random() * animals.length)]
                },
            },

            _sentence: {
                desc: "Returns a random sentence.",

                func: async () => {
                    var sentenceJSON = json.sentenceJSON
                    return sentenceJSON.data[Math.floor(Math.random() * sentenceJSON.data.length)].sentence
                },
            },

            _name: {
                desc: "Returns a random name.",

                func: async () => {
                    var nameJSON = json.nameJSON
                    var surnames = nameJSON.surname
                    var names = nameJSON.male.concat(nameJSON.female)
                    return `${names[Math.floor(Math.random() * names.length)].name.value} ${surnames[Math.floor(Math.random() * surnames.length)].name.value}`
                },
            },

            _noun: {
                desc: "Returns a random noun.",

                func: async () => {
                    var nounJSON = json.nounJSON
                    return nounJSON.data[Math.floor(Math.random() * nounJSON.data.length)].noun
                },
            },

            _verb: {
                desc: "Returns a random verb.",

                func: async () => {
                    var verbJSON = json.verbJSON
                    return verbJSON.data[Math.floor(Math.random() * verbJSON.data.length)].verb
                },
            },

            _adj: {
                desc: "Returns a random adjective.",

                func: async () => {
                    var adjJSON = json.adjJSON
                    return adjJSON.data[Math.floor(Math.random() * adjJSON.data.length)].adjective
                },
            },

            _emoji: {
                desc: "Returns a random Unicode emoji.",

                func: async () => {
                    return emojiImages[Math.floor(Math.random() * emojiImages.length)].emoji
                },
            },

            _serveremoji: {
                desc: "Returns a random server emoji.",

                func: async (msg) => {
                    var emojis = msg.guild.emojis.cache;
                    var emojis2 = [];
                    emojis.forEach(emoji => emojis2.push({ animated: emoji.animated, id: emoji.id, name: emoji.name }))
                    var emoji = emojis2[Math.floor(Math.random() * emojis2.length)]
                    return emoji ? `<${emoji.animated ? 'a' : ''}:${emoji.name}:${emoji.id}>` : ''
                },
            },

            _nsfw: {
                desc: "Returns whether the channel is NSFW or not.",

                func: async (msg) => {
                    return msg.channel.nsfw || ''
                },
            },

            _arab: {
                desc: "Returns a random word from the arabottify command's dictionary.",

                func: async () => {
                    return arabDictionary[Math.floor(Math.random() * arabDictionary.length)]
                },
            },

            _arabfriendly: {
                desc: "Returns a random word from the arabottify command's dictionary, except it doesn't include words like \"sex\" or \"penis\".",

                func: async () => {
                    return tenorDictionary[Math.floor(Math.random() * tenorDictionary.length)]
                },
            },

            _arabconnector: {
                desc: "Returns a random connector from the arabottify command's connector dictionary.",

                func: async () => {
                    return arabConnectors[Math.floor(Math.random() * arabConnectors.length)]
                },
            },

            _arabw: {
                desc: "Returns a completely nonsensical word that doesn't even exist.",

                func: async () => {
                    var vowels = ['a', 'e', 'i', 'o', 'u']
                    var consonants = []
                    for (i = 97; i <= 122; i++) {
                        var char = String.fromCharCode(i)
                        if (!vowels.find(letter => letter == char)) {
                            consonants.push(char)
                        }
                    }
                    var word = ''
                    for (i = 0; i < Math.floor(Math.random() * 3) + 2; i++) {
                        word += consonants[Math.floor(Math.random() * consonants.length)] + vowels[Math.floor(Math.random() * vowels.length)]
                    }
                    return word
                },
            },

            _fnaf: {
                desc: "Returns a random phrase based on FNAF, like \"fred\" or \"Fred five nights\".",

                func: async () => {
                    var fnaf = [
                        'fred',
                        'FRED!',
                        'Fred five nights',
                        'fred five.',
                        'the night of freddy',
                        'FIVE FREDDY NIGHTS',
                        'Fred night at',
                        'Fred at night',
                        'Fred night',
                        'at the freddy night',
                        'five freddy nights',
                        'nig',
                        'Freddy\'s',
                        'At\'s fredyd',
                        'les fred de nuit',
                        'Five Night Freddy',
                        'five nights at freddys',
                        'five nights at freddy\'s',
                        'five night\'s at freddy\'s',
                        'fnaf',
                        'fnf',
                        'frede',
                        'feddy',
                        'FEDDY!',
                        '5',
                        'nights',
                        'Fiv\'esg \'ighes at fryed'
                    ]
                    return fnaf[Math.floor(Math.random() * fnaf.length)]
                },
            },

            _funnygif: {
                desc: "Returns a random funny meme GIF like Nostalgia Critic clapping or Walter White falling.",

                func: async () => {
                    return funnygifs[Math.floor(Math.random() * funnygifs.length)]
                },
            },

            _poop: {
                desc: "Returns a random Poopy funny.",

                func: async (msg) => {
                    return poopPhrases[Math.floor(Math.random() * poopPhrases.length)]
                        .replace(/{fart}/, Math.floor(Math.random() * 291) + 10)
                        .replace(/{seconds}/, Math.floor((Math.random() * 59) + 2))
                        .replace(/{mention}/, `<@${msg.author.id}>`)
                },
            },

            _dmphrase: {
                desc: "Returns a random DM phrase.",

                func: async (msg) => {
                    return dmPhrases[Math.floor(Math.random() * dmPhrases.length)]
                        .replace(/{mention}/, `<@${msg.author.id}>`)
                },
            },

            _ronald: {
                desc: "Returns a random Ronald McDonald GIF.",

                func: async () => {
                    var ronald = [
                        'https://tenor.com/view/ronald-gif-20323112',
                        'https://tenor.com/view/ronald-gif-20323104',
                        'https://tenor.com/view/mc-donalds-smile-thumbs-down-gif-15614678',
                        'https://tenor.com/view/mc-donalds-smile-wave-hi-hello-gif-15614675',
                        'https://tenor.com/view/shocked-surprised-what-huh-ronald-mcdonald-gif-17825301',
                        'https://tenor.com/view/mcdonalds-ronald-mcdonald-no-bad-gif-18753679',
                        'https://tenor.com/view/mcdonalds-oh-yeah-happy-dance-peace-gif-15790119',
                        'https://tenor.com/view/ronald-mcdonald-mcdonalds-excited-happy-yay-gif-16178752',
                        'https://tenor.com/view/clown-mcdonalds-good-thumbs-up-nice-gif-16704087',
                        'https://tenor.com/view/clown-mcdonald-ronald-mcdonald-laugh-lol-gif-18842655',
                        'https://tenor.com/view/mcdonalds-ronald-mcdonald-clown-makeup-costume-gif-15607172',
                        'https://tenor.com/view/mcdonalds-ronald-mcdonald-clown-makeup-costume-gif-15607167',
                        'https://tenor.com/view/mcdonalds-ronald-mcdonald-clown-makeup-costume-gif-15607170',
                        'https://tenor.com/view/clown-mcdonalds-wink-pointing-smile-gif-16021556',
                        'https://tenor.com/view/airsoftfatty-mcdonalds-dancing-deepfake-dance-gif-19807516',
                        'https://tenor.com/view/clown-mcdonalds-oh-wow-surprised-gif-16021560',
                        'https://tenor.com/view/ronald-gif-21619925',
                        'https://tenor.com/view/ronald-gif-21619963'
                    ]

                    return ronald[Math.floor(Math.random() * ronald.length)]
                },
            },

            _persontype: {
                desc: "Returns a random type of person. (i honestly don't know what to call it)",

                func: async () => {
                    var insults = [
                        'gay',
                        'lesbian',
                        'catboy',
                        'catboy maid',
                        'maid',
                        'trans',
                        'bisexual',
                        'pedophile',
                        'zoophile',
                        'degenerate',
                        'femboy',
                        'furry',
                        'tomboy',
                        'horny',
                        'racist',
                        'underaged',
                        'gamer',
                        'oder',
                        'gangster',
                        'male',
                        'female',
                        'homophobic',
                        'xenobic',
                        'transphobic'
                    ]

                    return insults[Math.floor(Math.random() * insults.length)]
                },
            },

            _compliment: {
                desc: "Returns a random compliment.",

                func: async () => {
                    var insults = [
                        'awesome',
                        'cool',
                        'fantastic',
                        'talented',
                        'swag',
                        'spectacular',
                        'good',
                        'nice',
                        'intelligent',
                        'lovely',
                        'cute',
                        'smart',
                        'strong',
                        'kind',
                        'brave',
                        'caring'
                    ]

                    return insults[Math.floor(Math.random() * insults.length)]
                },
            },

            _insult: {
                desc: "Returns a random insult.",

                func: async () => {
                    var insults = [
                        'stupid',
                        'bastard',
                        'retard',
                        'idiot',
                        'buffoon',
                        'moron',
                        'lazy',
                        'bad',
                        'weak',
                        'unkind',
                        'dumb',
                        'bitch',
                        'worthless',
                        'trash'
                    ]

                    return insults[Math.floor(Math.random() * insults.length)]
                },
            },

            _randomgif: {
                desc: "Returns a random Tenor gif.",

                func: async (msg) => {
                    return new Promise(resolve => {
                        function getWord() {
                            var word = tenorDictionary[Math.floor(Math.random() * tenorDictionary.length)]
                            if (!word) {
                                return getWord()
                            }
                            return word.toLowerCase()
                        }

                        axios.get(`https://g.tenor.com/v1/search?q=${encodeURIComponent(getWord())}&key=${process.env.TENORKEY}&limit=100&contentfilter=${msg.channel.nsfw ? 'off' : 'medium'}`).then((res) => {
                            var parsedBody = res.data
                            if (parsedBody.results) {
                                if (parsedBody.results[0]) {
                                    resolve(parsedBody.results[Math.floor(Math.random() * parsedBody.results.length)].itemurl)
                                } else {
                                    resolve('Error while fetching GIFs.')
                                }
                            } else {
                                resolve('Error while fetching GIFs.')
                            }
                        })
                    })
                },

                attemptvalue: 2
            },

            _psmember: {
                desc: "Returns a random Phexonia Studios related member.",

                func: async () => {
                    var members = [
                        "tenda",
                        "another",
                        "bubbley",
                        "avery",
                        "deinx",
                        "bilon",
                        "babis",
                        "empsy",
                        "gritzy",
                        "ballfish",
                        "meatwad",
                        "tuca",
                        "raleigh",
                        "jlol",
                        "makos",
                        "mance",
                        "henhen",
                        "tranzst",
                        "getmemed",
                        "spooky",
                        "alexandrfrol",
                        "spellbunny",
                        "diggle",
                        "fnepp",
                        "ilahiboykot",
                        "concern",
                        "rhanzier",
                        "bartekoklol",
                        "betteruser",
                        "lead",
                        "phexonia",
                        "deinbag",
                        "sander080",
                        "hiro",
                        "superbrohouse",
                        "sayori",
                        "tree",
                        "agnook",
                        "ennakon",
                        "gordano",
                        "lad",
                        "cease",
                        "tss_crazed",
                        "notsam",
                        "timprox",
                        "maks",
                        "eevbat",
                        "zekkriel",
                        "potion man",
                        "trongal",
                        "pl0x7",
                        "azureblob",
                        "wovxzers",
                        "wizord",
                        "zeezy",
                        "tyget",
                        "crypyth",
                        "luigiluis",
                        "dootings",
                        "keenan",
                        "henryguy",
                        "cinna",
                        "luigistar",
                        "scriptedsand",
                        "robuk",
                        "gobby",
                        "simpremove",
                        "richard",
                        "kleio",
                        "yarimkl",
                        "junoong",
                        "shwosho",
                        "sans",
                        "deltaz",
                        "figment",
                        "beeph",
                        "kurbee",
                        "cain",
                        "lumin",
                        "archerlolman",
                        "icre8",
                        "charleh",
                        "nitra_dev",
                        "rukifox",
                        "euth"
                    ]
                    return members[Math.floor(Math.random() * members.length)]
                },
            },

            _psknown: {
                desc: "Returns a random known Phexonia Studios member.",

                func: async () => {
                    var members = [
                        "tenda",
                        "another",
                        "bubbley",
                        "avery",
                        "deinx",
                        "bilon",
                        "babis",
                        "empsy",
                        "gritzy",
                        "ballfish",
                        "meatwad",
                        "tuca",
                        "raleigh",
                        "spooky",
                        "spellbunny",
                        "fnepp",
                        "concern",
                        "bartekoklol",
                        "betteruser",
                        "lead",
                        "phexonia",
                        "deinbag",
                        "hiro",
                        "superbrohouse",
                        "sayori",
                        "tree",
                        "agnook",
                        "ennakon",
                        "gordano",
                        "lad",
                        "charleh",
                        "maks",
                        "zekkriel",
                        "pl0x7",
                        "wovxzers",
                        "zeezy",
                        "henryguy",
                        "kleio",
                        "diep",
                        "welch",
                        "alexandrfrol",
                        "fizzy",
                        "kurbee"
                    ]
                    return members[Math.floor(Math.random() * members.length)]
                },
            },

            _pshit: {
                desc: "hate",

                func: async () => {
                    var members = [
                        "sayori",
                        "cain",
                        "tss_crazed",
                        "timprox",
                        "maks",
                        "lumin",
                        "archerlolman",
                        "icre8",
                        "charleh",
                        "nitra_dev",
                        "rukifox",
                        "euth"
                    ]
                    return members[Math.floor(Math.random() * members.length)]
                },
            },

            _pspasta: {
                desc: "Returns a random Phexonia Studios related copypasta or phrase.",

                func: async () => {
                    return psPasta[Math.floor(Math.random() * psPasta.length)]
                },
            },

            _psimage: {
                desc: "Returns a random Phexonia Studios related image.",

                func: async () => {
                    var psImages = []

                    for (var i in psFiles) {
                        var file = psFiles[i]
                        if (!(file.match(/\.(gif|mov|mp4|apng)/))) psImages.push(file)
                    }

                    return psImages[Math.floor(Math.random() * psImages.length)]
                },
            },

            _psvideo: {
                desc: "Returns a random Phexonia Studios related video.",

                func: async () => {
                    var psVideos = []

                    for (var i in psFiles) {
                        var file = psFiles[i]
                        if (file.match(/\.(mov|mp4)/)) psVideos.push(file)
                    }

                    return psVideos[Math.floor(Math.random() * psVideos.length)]
                },
            },

            _psgif: {
                desc: "Returns a random Phexonia Studios related GIF.",

                func: async () => {
                    var psGifs = []

                    for (var i in psFiles) {
                        var file = psFiles[i]
                        if (file.match(/\.(gif|apng)/)) psGifs.push(file)
                    }

                    return psGifs[Math.floor(Math.random() * psGifs.length)]
                },
            },

            _ps: {
                desc: "Returns a random Phexonia Studios related file.",

                func: async () => {
                    return psFiles[Math.floor(Math.random() * psFiles.length)]
                },
            },

            _unicode: {
                desc: "Returns a completely random unicode character.",

                func: async () => {
                    return String.fromCharCode(Math.floor(Math.random() * 15000))
                },
            },

            _id: {
                desc: "Returns your own id.",

                func: async (msg) => {
                    return msg.author.id
                },
            },

            _username: {
                desc: "Returns your own username.",

                func: async (msg) => {
                    return msg.author.username
                },
            },

            _nickname: {
                desc: "Returns your own nickname.",

                func: async (msg) => {
                    return msg.member ? (msg.member.nickname || msg.author.username) : msg.author.username
                },
            },

            _memberid: {
                desc: "Returns a random member's id from the server.",

                func: async (msg) => {
                    var datamembers = data()[mongodatabase]['guild-data'][msg.guild.id]['members'];
                    var keys = Object.keys(datamembers)
                    return keys[Math.floor(Math.random() * keys.length)]
                },
            },

            _member: {
                desc: "Returns a random member from the server.",

                func: async (msg) => {
                    var datamembers = data()[mongodatabase]['guild-data'][msg.guild.id]['members'];
                    var members = []
                    for (var id in datamembers) {
                        var datamember = datamembers[id]
                        if (datamember.username) members.push(datamember.username)
                    }
                    return members[Math.floor(Math.random() * members.length)].replace(/\@/g, '@‚Äå')
                },
            },

            _channelid: {
                desc: "Returns the channel's id.",

                func: async (msg) => {
                    return msg.channel.id
                },
            },

            _channelname: {
                desc: "Returns the channel's name.",

                func: async (msg) => {
                    return msg.channel.name
                },
            },

            _serverid: {
                desc: "Returns the server's id.",

                func: async (msg) => {
                    return msg.guild.id
                },
            },

            _servername: {
                desc: "Returns the server's name.",

                func: async (msg) => {
                    return msg.guild.name
                },
            },

            _message: {
                desc: "Returns a random message from the server.",

                func: async (msg) => {
                    var messages = data()[mongodatabase]['guild-data'][msg.guild.id]['messages']
                    return messages.length ? messages[Math.floor(Math.random() * messages.length)].replace(/\@/g, '@‚Äå') : ''
                },
            },

            _keyattempts: {
                desc: "Returns your current key attempts.",

                func: async (msg) => {
                    return data2[msg.author.id]['keyattempts']
                },
            },

            _sayori: {
                desc: "returns not sayori ai",

                func: async (msg) => {
                    var datamembers = data()[mongodatabase]['guild-data'][msg.guild.id]['members'];
                    var members = []
                    for (var id in datamembers) {
                        var datamember = datamembers[id]
                        if (datamember.username) members.push(datamember.username)
                    }
                    var year = new Date(Date.now()).getFullYear()
                    var sayoriAdjectives = ['HORNY', 'FARTING', 'RACIST', 'STUPID', 'FEMBOY', 'GAY', 'TRANS', 'UNDERAGED', 'RETARD', 'BITCH', 'ASSHOLE', 'MOTHERFUCKER']
                    var adjectives = ['is trans', 'the femboy', 'the futa', 'the idiot', 'the stalker', 'the impostor', 'now sus', 'the nutter', 'the shitter', 'the burger', 'is very annoying', 'big', 'fat', 'is thin', 'is small', 'what', 'is funny', 'noob', 'wtf', 'with pp', 'peed his pants', 'is amongla', 'looks at porn lolololol'];
                    var shipAdjectives = ['likes', 'you like', 'loves', 'you love', 'you are in love with', 'you should marry', 'with', 'hug', 'your game is now poopoo for'];
                    var fnf = ['dad', 'gf', 'pico', 'skid and pump', 'monster', 'mom', 'senpai', 'tankman', 'whitty', 'carol', 'hex', 'ruv', 'sarvente', 'miku', 'tricky', 'zardy', 'matt', 'garcello', 'shaggy', 'annie', 'cheeky', 'bob', 'tabi', 'agoti', 'kapi', 'neon', 'nene', 'monika', 'cg5', 'updike', 'selever', 'tord', 'impostor', 'trollge', 'tree']
                    var consoles = ['pc', 'mobile', 'tablet', 'xbox', 'nintendo switch', 'nintendo 3ds', 'nintendo 2ds', 'psp', 'ps1', 'ps2', 'gamecube', 'ps3', 'ps4', 'ps5', 'wii', 'xbox 360', 'xbox one', 'gameboy', 'nintendo 64', 'sega genesis', 'wii u']
                    var options = [
                        { pings: false, text: 'lol https://tenor.com/view/sus-suspect-among-us-gif-18663592' },
                        { pings: false, text: 'https://tenor.com/view/madness-hank-new-grounds-jump-gif-17044581' },
                        { pings: false, text: 'https://tenor.com/view/friday-night-funkin-hey-boyfriend-gif-21180248' },
                        { pings: true, text: 'SHUT UP' },
                        { pings: true, text: 'sussy' },
                        { pings: false, text: 'lol' },
                        { pings: false, text: 'among us impostor in madness tricky mod' },
                        { pings: false, text: 'ehat', edit: 'what' },
                        { pings: false, text: arabDictionary[Math.floor(Math.random() * arabDictionary.length)].toLowerCase() + ' is ' + arabDictionary[Math.floor(Math.random() * arabDictionary.length)].toLowerCase() },
                        { pings: false, text: arabDictionary[Math.floor(Math.random() * arabDictionary.length)].toLowerCase() + ' in ' + arabDictionary[Math.floor(Math.random() * arabDictionary.length)].toLowerCase() },
                        { pings: false, text: arabDictionary[Math.floor(Math.random() * arabDictionary.length)].toLowerCase() + ' ' + arabDictionary[Math.floor(Math.random() * arabDictionary.length)].toLowerCase() + ' is ' + arabDictionary[Math.floor(Math.random() * arabDictionary.length)].toLowerCase() + ' ' + arabDictionary[Math.floor(Math.random() * arabDictionary.length)].toLowerCase() },
                        { pings: false, text: 'not ' + arabDictionary[Math.floor(Math.random() * arabDictionary.length)].toLowerCase() },
                        { pings: false, text: arabDictionary[Math.floor(Math.random() * arabDictionary.length)].toLowerCase() },
                        { pings: false, text: arabDictionary[Math.floor(Math.random() * arabDictionary.length)].toLowerCase() + '.' },
                        { pings: false, text: 'the ' + arabDictionary[Math.floor(Math.random() * arabDictionary.length)].toLowerCase() + ' fandom is dying' },
                        { pings: false, text: 'THE VS ' + arabDictionary[Math.floor(Math.random() * arabDictionary.length)].toUpperCase() + ' MOD' },
                        { pings: false, text: 'WHAT A ' + arabDictionary[Math.floor(Math.random() * arabDictionary.length)].toUpperCase() },
                        { pings: false, text: 'they added the ' + arabDictionary[Math.floor(Math.random() * arabDictionary.length)].toLowerCase() + ' big ass' },
                        { pings: false, text: 'the ' + arabDictionary[Math.floor(Math.random() * arabDictionary.length)].toLowerCase() },
                        { pings: false, text: 'not ' + arabDictionary[Math.floor(Math.random() * arabDictionary.length)].toLowerCase() + ' fetish' },
                        { pings: false, text: 'finally a ' + arabDictionary[Math.floor(Math.random() * arabDictionary.length)].toLowerCase() + ' game to ' + consoles[Math.floor(Math.random() * consoles.length)] },
                        { pings: false, text: arabDictionary[Math.floor(Math.random() * arabDictionary.length)].toLowerCase() + ' was made in ' + (Math.floor(Math.random() * (year - 1980)) + 1980) + ' xd' },
                        { pings: false, text: 'this will be ' + arabDictionary[Math.floor(Math.random() * arabDictionary.length)].toLowerCase() + ' in ' + (Math.floor(Math.random() * (year - 2000)) + 2000) },
                        { pings: false, text: 'YOU DONT KILL ' + (arabDictionary[Math.floor(Math.random() * arabDictionary.length)].toUpperCase() + ' ').repeat(2) + 'KILLS YOU!!!!!!!!!!!!!!!!' },
                        { pings: false, text: arabDictionary[Math.floor(Math.random() * arabDictionary.length)].toLowerCase() + ' is in the ' + fnf[Math.floor(Math.random() * fnf.length)] + ' week' },
                        { pings: false, text: 'no not big ass ' + arabDictionary[Math.floor(Math.random() * arabDictionary.length)].toLowerCase() },
                        { pings: true, text: 'snat' },
                        { pings: false, text: 'STOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOPPPPPPPPPPPPPPPPPPPPPPP' },
                        { pings: false, text: 'WOOOOOOOOOOOOOOOOOOOOOOOOOOOOO' },
                        { pings: true, text: 'wjat', edit: 'what' },
                        { pings: false, text: 'NO' },
                        { pings: false, text: 'ü§£ ü§£ ü§£ ü§£ ü§£ ü§£' },
                        { pings: false, text: 'STOP' },
                        { pings: false, text: 'WHU', edit: 'WHY' },
                        { pings: true, text: 'WHY' },
                        { pings: false, text: 'GOD HELP ME' },
                        { pings: false, text: 'IM NOT' },
                        { pings: false, text: 'wtf' },
                        { pings: false, text: 'wow' },
                        { pings: false, text: 'no' },
                        { pings: false, text: 'not again' },
                        { pings: false, text: 'IM NOT ' + sayoriAdjectives[Math.floor(Math.random() * sayoriAdjectives.length)] },
                        { pings: false, text: 'im ' + sayoriAdjectives[Math.floor(Math.random() * sayoriAdjectives.length)].toLowerCase() },
                        { pings: false, text: 'nooooo' },
                        { pings: false, text: 'stol', edit: 'stop' },
                        { pings: false, text: 'Hope you realize that people can become not cringe. Maybe. Juuuust maybe. I have stopped doing shit with the "gay chains". If you tried not dwelling on the past maybe you could actually realize how annoying you are. Now let me guess youll respond with a short answer, not answer, respond with what I did, or completely change the topic.' },
                        { pings: true, text: 'no' },
                        { pings: false, text: 'gay' },
                        { pings: false, text: 'i dare someone to post porn on my dm\'s' },
                        { pings: false, text: '._.' },
                        { pings: true, text: '' },
                        { pings: false, text: msg.author.username.toUpperCase() + ' WHY' },
                        { pings: false, text: 'BRUH' },
                        { pings: false, text: 'SUS' },
                        { pings: false, text: 'im underaged' },
                        { pings: true, text: 'YOU SUSSY' },
                        { pings: false, text: 'AMOGUS' },
                        { pings: false, text: 'is that friday night porn' },
                        { pings: true, text: 'flop' },
                        { pings: false, text: 'i like porn ü•≤ ü•≤ ü•≤ ü•≤ ü•≤ ü•≤' },
                        { pings: true, text: 'stupid ' + msg.author.username.toLowerCase() },
                        { pings: false, text: 'not ' + msg.author.username.toLowerCase() },
                        { pings: false, text: 'wth ' + msg.author.username.toLowerCase() },
                        { pings: false, text: 'lol ' + msg.author.username.toLowerCase() },
                        { pings: false, text: msg.author.username.toLowerCase() + ' ' + adjectives[Math.floor(Math.random() * adjectives.length)] },
                        { pings: false, text: msg.author.username.toLowerCase() + ': ' + arabDictionary[Math.floor(Math.random() * arabDictionary.length)].toLowerCase() },
                        { pings: false, text: 'no not ' + msg.author.username.toLowerCase() + ' with ' + arabDictionary[Math.floor(Math.random() * arabDictionary.length)].toLowerCase() },
                        { pings: false, text: 'ahhhhhhhhhh' },
                        { pings: false, text: 'school suuucks' },
                        { pings: false, text: 'why am i a bot' },
                        { pings: false, text: msg.author.username.toLowerCase() + ' ' + shipAdjectives[Math.floor(Math.random() * shipAdjectives.length)] + ' ' + members[Math.floor(Math.random() * members.length)].toLowerCase() },
                        { pings: false, text: 'is ' + members[Math.floor(Math.random() * members.length)].toLowerCase() + ' hot' },
                        { pings: false, text: 'im not pinging ' + members[Math.floor(Math.random() * members.length)].toLowerCase() },
                        { pings: false, text: members[Math.floor(Math.random() * members.length)].toUpperCase() + ' IS ' + sayoriAdjectives[Math.floor(Math.random() * sayoriAdjectives.length)] + ' NOT ME' },
                        { pings: false, text: members[Math.floor(Math.random() * members.length)].toUpperCase() + ' IS THE ' + sayoriAdjectives[Math.floor(Math.random() * sayoriAdjectives.length)] + ' ' + sayoriAdjectives[Math.floor(Math.random() * sayoriAdjectives.length)] + ' ' + sayoriAdjectives[Math.floor(Math.random() * sayoriAdjectives.length)] + ' ' + sayoriAdjectives[Math.floor(Math.random() * sayoriAdjectives.length)] },
                        { pings: false, text: msg.author.username.toLowerCase() }
                    ];

                    return options[Math.floor(Math.random() * options.length)].text.replace(/\@/g, '@‚Äå')
                }
            }
        },

        functions: {
            rfunction: {
                helpf: "(phrase)",

                desc: "chooses A RANDOM fUNCTION to USE With The Text.",

                func: async (matches, msg, isBot, string) => {
                    var funcs = []
                    for (var ff in special.functions) {
                        funcs.push(ff)
                    }
                    var func = funcs[Math.floor(Math.random() * funcs.length)]
                    return special.functions[func].func(matches, msg, isBot, string)
                },

                attemptvalue: 10
            },

            lower: {
                helpf: "(phrase)",

                desc: "makes the phrase all lowercase.",

                func: async (matches) => {
                    var word = matches[1]
                    return word.toLowerCase()
                },
            },

            upper: {
                helpf: "(phrase)",

                desc: "MAKES THE PHRASE ALL UPPERCASE!",

                func: async (matches) => {
                    var word = matches[1]
                    return word.toUpperCase()
                },
            },

            cap: {
                helpf: "(phrase)",

                desc: "Makes the phrase inside the function start with a capital.",

                func: async (matches) => {
                    var word = matches[1]
                    return word.substring(0, 1).toUpperCase() + word.substring(1, word.length)
                }
            },

            capall: {
                helpf: "(phrase)",

                desc: "Makes Every Word In The Phrase Inside The Function Start With A Capital",

                func: async (matches) => {
                    var word = matches[1]
                    var words = word.split(' ')
                    for (var i in words) {
                        var w = words[i]
                        words[i] = w.substring(0, 1).toUpperCase() + w.substring(1, w.length)
                    }
                    return words.join(' ')
                }
            },

            swapcase: {
                helpf: "(phrase)",

                desc: "sWAPS ALL THE CASES IN THE PHRASE INSIDE THE FUNCTION!",

                func: async (matches) => {
                    var word = matches[1]
                    var swapword = ''
                    for (var i = 0; i < word.length; i++) {
                        if (word[i] === word[i].toLowerCase()) {
                            swapword += word[i].toUpperCase()
                        } else {
                            swapword += word[i].toLowerCase()
                        }
                    }
                    return swapword
                }
            },

            generate: {
                helpf: "(phrase)",

                desc: "Generates subsequent text from the phrase inside the function.",

                func: async (matches) => {
                    var word = matches[1]

                    var resp = await deepai.callStandardApi("text-generator", {
                        text: word,
                    }).catch(() => { })

                    if (resp) {
                        return resp.output
                    }

                    return word
                },

                attemptvalue: 10
            },

            reverse: {
                helpf: "(phrase)",

                desc: ".noitcnuf eht edisni esarhp eht sesreveR",

                func: async (matches) => {
                    var word = matches[1]
                    var letters = word.split('')
                    letters.reverse()
                    return letters.join('')
                }
            },

            scramble: {
                helpf: "(phrase)",

                desc: "the phrase Scrambles the function. inside",

                func: async (matches) => {
                    var word = matches[1]
                    var words = word.split(' ')
                    var scrambled = []
                    var scrambled2 = []
                    for (var i in words) {
                        var w = words[i]
                        scrambled.push({ word: w, randomness: Math.random() })
                    }
                    scrambled.sort(function (a, b) {
                        return a.randomness - b.randomness
                    })
                    for (var i in scrambled) {
                        var word = scrambled[i]
                        scrambled2.push(word.word)
                    }
                    return scrambled2.join(' ')
                }
            },

            shuffle: {
                helpf: "(phrase)",

                desc: "teh ltteres fo het parhse crSabmles hte cfuti.non siinde",

                func: async (matches) => {
                    var word = matches[1]
                    var letters = word.split('')
                    var shuffled = []
                    var shuffled2 = []
                    for (var i in letters) {
                        var l = letters[i]
                        shuffled.push({ letter: l, randomness: Math.random() })
                    }
                    shuffled.sort(function (a, b) {
                        return a.randomness - b.randomness
                    })
                    for (var i in shuffled) {
                        var letter = shuffled[i]
                        shuffled2.push(letter.letter)
                    }
                    return shuffled2.join('')
                }
            },

            stroke: {
                helpf: "(phrase)",

                desc: "ion into a stroke.  thnernn rhr rie tiaotsee pec",

                func: async (matches) => {
                    var word = matches[1]
                    return gibberish(word)
                }
            },

            arabottify: {
                helpf: "(phrase)",

                desc: "born the adds it. and WHEN inside function words he's phrase to the it. Scrambles extra to",

                func: async (matches, msg) => {
                    var word = matches[1]

                    if (!word) {
                        var arabArray = []
                        var dict = 1
                        var conn = 1
                        for (var i = 0; i < Math.floor(Math.random() * 40) + 1; i++) {
                            var randomFactor = Math.floor(Math.random() * 8)
                            if (randomFactor === 8) {
                                dict = 1
                                conn = 1
                                arabArray.push(msg.member.nickname || msg.author.username + ((Math.floor(Math.random() * 5) === 4 && punctuation[Math.floor(Math.random() * punctuation.length)]) || ''))
                            } else {
                                function chooseWord() {
                                    if (Math.floor(Math.random() * dict) + 1 === (dict === 3 ? 0 : 1)) {
                                        conn = 1
                                        dict++
                                        arabArray.push(arabDictionary[Math.floor(Math.random() * arabDictionary.length)] + ((Math.floor(Math.random() * 5) === 4 && punctuation[Math.floor(Math.random() * punctuation.length)]) || ''))
                                    } else if (Math.floor(Math.random() * conn) + 1 === (conn === 3 ? 0 : 1)) {
                                        dict = 1
                                        conn++
                                        arabArray.push(arabConnectors[Math.floor(Math.random() * arabConnectors.length)] + ((Math.floor(Math.random() * 5) === 4 && punctuation[Math.floor(Math.random() * punctuation.length)]) || ''))
                                    } else {
                                        chooseWord()
                                    }
                                }

                                chooseWord()
                            }
                        }

                        return arabArray.join(' ').replace(/\@/g, '@‚Äå')
                    }

                    var arabArray = word.split(' ')
                    var arabArray2 = []
                    arabArray.forEach(word => {
                        for (var i = 0; i < ((Math.floor(Math.random() * 5) === 1 && 2) || 1); i++) {
                            arabArray2.push({ word: word + ((Math.floor(Math.random() * 7) === 6 && punctuation[Math.floor(Math.random() * punctuation.length)]) || ''), randomness: Math.random() })
                        }
                        if (Math.floor(Math.random() * 4) === 3) {
                            var randomFactor = Math.floor(Math.random() * 8)
                            if (randomFactor === 7) {
                                arabArray2.push({ word: msg.member.nickname || msg.author.username + ((Math.floor(Math.random() * 7) === 4 && punctuation[Math.floor(Math.random() * punctuation.length)]) || ''), randomness: Math.random() })
                            } else if (randomFactor >= 0 && randomFactor <= 3) {
                                arabArray2.push({ word: arabDictionary[Math.floor(Math.random() * arabDictionary.length)] + ((Math.floor(Math.random() * 7) === 4 && punctuation[Math.floor(Math.random() * punctuation.length)]) || ''), randomness: Math.random() })
                            } else {
                                arabArray2.push({ word: arabConnectors[Math.floor(Math.random() * arabConnectors.length)] + ((Math.floor(Math.random() * 7) === 4 && punctuation[Math.floor(Math.random() * punctuation.length)]) || ''), randomness: Math.random() })
                            }
                        }
                    })
                    arabArray2.sort(function (a, b) {
                        return a.randomness - b.randomness
                    })
                    arabArray = []
                    arabArray2.forEach(word => {
                        arabArray.push(word.word)
                    })

                    return arabArray.join(' ').replace(/\@/g, '@‚Äå')
                }
            },

            markov: {
                helpf: "(phrase)",

                desc: "The markov chain generated AND THE Last Messages. turn on",

                func: async (matches, msg) => {
                    var word = matches[1]

                    var messages = data()[mongodatabase]['guild-data'][msg.guild.id]['messages'].slice()
                    if (messages.length <= 0) {
                        messages = json.sentenceJSON.data.map(s => s.sentence).concat(psPasta)
                    }
                    if (word) {
                        messages.push(word)
                    }
                    var markovChain = markovChainGenerator(messages.join('  '))
                    var markov = markovMe(markovChain, word)

                    return markov
                }
            },

            cleverbot: {
                helpf: "(phrase)",

                desc: "Generates a response to the phrase inside the function with Cleverbot AI.",

                func: async (matches, msg) => {
                    var word = matches[1]

                    var resp = await cleverbot(word, msg.channel.id).catch(() => { })

                    if (resp) {
                        return resp
                    }

                    return word
                },

                attemptvalue: 10
            },

            choice: {
                helpf: "(choice1 | choice2 | choice3 | etc...)",

                desc: "Chooses a random option out of the options inside the phrase. Each option should be separated by \"|\".",

                func: async (matches) => {
                    var word = matches[1]
                    var split = splitKeyMod(word)
                    return split[Math.floor(Math.random() * split.length)]
                },

                raw: true
            },

            length: {
                helpf: "(phrase)",

                desc: "Returns the length of the phrase.",

                func: async (matches) => {
                    var word = matches[1]
                    return word.length
                },
            },

            similarity: {
                helpf: "(phrase1 | phrase2)",

                desc: "Checks the similarity between the 2 phrases.",

                func: async (matches) => {
                    var word = matches[1]
                    var split = splitKeyMod(word, { args: 2 })
                    var phrase1 = split[0] ?? ''
                    var phrase2 = split[1] ?? ''

                    return similarity(phrase1, phrase2)
                },
            },

            substring: {
                helpf: "(phrase | start | end)",

                desc: "Substrings the phrase from the start point to the end point.",

                func: async (matches) => {
                    var word = matches[1]
                    var split = splitKeyMod(word)
                    var phrase = split[0] ?? ''
                    var start = (!(isNaN(Number(split[1]))) ? Math.round(Number(split[1])) : undefined) ?? 0
                    var end = split.slice(2).length ? (!(isNaN(Number(split.slice(2).join('|')))) ? Math.round(Number(split.slice(2).join('|'))) : undefined) : phrase.length
                    return phrase.substring(start, end)
                },
            },

            regexclean: {
                helpf: "(phrase)",

                desc: "Cleans the content in the phrase so it can be used in match functions without triggering anything from the cheatsheet.",

                func: async (matches) => {
                    var word = matches[1]
                    return regexClean(word)
                },
            },

            match: {
                helpf: "(phrase | regexp)",

                desc: "Matches the content in the phrase with the RegExp.",

                func: async (matches) => {
                    var word = matches[1]
                    var split = splitKeyMod(word)
                    var phrase = split[0] ?? ''
                    var reg = split.slice(1).length ? split.slice(1).join('|') : ''
                    var regexp = new RegExp(reg, 'i')
                    var match = phrase.match(regexp) ?? []
                    return match[1] ?? match[0] ?? ''
                },
            },

            replace: {
                helpf: "(phrase | replacement | regexp)",

                desc: "Replaces everything in the phrase that matches the RegExp with the new replacement.",

                func: async (matches) => {
                    var word = matches[1]
                    var split = splitKeyMod(word)
                    var phrase = split[0] ?? ''
                    var replacement = split[1] ?? ''
                    var reg = split.slice(2).length ? split.slice(2).join('|') : ''
                    var regexp = new RegExp(reg, 'ig')
                    return phrase.replace(regexp, replacement)
                },
            },

            indexof: {
                helpf: "(phrase | regexp)",

                desc: "Returns the first index in the phrase that matches the RegExp.",

                func: async (matches) => {
                    function regexIndexOf(string, regex, startpos) {
                        var indexOf = string.substring(startpos || 0).search(regex);
                        return (indexOf >= 0) ? (indexOf + (startpos || 0)) : indexOf;
                    }

                    var word = matches[1]
                    var split = splitKeyMod(word)
                    var phrase = split[0] ?? ''
                    var reg = split.slice(1).length ? split.slice(1).join('|') : ''
                    var regexp = new RegExp(reg, 'ig')
                    return regexIndexOf(phrase, regexp)
                },
            },

            lastindexof: {
                helpf: "(phrase | regexp)",

                desc: "Returns the last index in the phrase that matches the RegExp.",

                func: async (matches) => {
                    function regexLastIndexOf(string, regex, startpos) {
                        regex = (regex.global) ? regex : new RegExp(regex.source, "g" + (regex.ignoreCase ? "i" : "") + (regex.multiLine ? "m" : ""));
                        if (typeof (startpos) == "undefined") {
                            startpos = string.length;
                        } else if (startpos < 0) {
                            startpos = 0;
                        }
                        var stringToWorkWith = string.substring(0, startpos + 1);
                        var lastIndexOf = -1;
                        var nextStop = 0;
                        while ((result = regex.exec(stringToWorkWith)) != null) {
                            lastIndexOf = result.index;
                            regex.lastIndex = ++nextStop;
                        }
                        return lastIndexOf;
                    }

                    var word = matches[1]
                    var split = splitKeyMod(word)
                    var phrase = split[0] ?? ''
                    var reg = split.slice(1).length ? split.slice(1).join('|') : ''
                    var regexp = new RegExp(reg, 'ig')
                    return regexLastIndexOf(phrase, regexp)
                },
            },

            repeat: {
                helpf: "(phrase | times | separator)",

                desc: "Repeats the phrase by the times specified. If the separator is specified, it'll separate each repetition with the separator.",

                func: async (matches) => {
                    var word = matches[1]
                    var split = splitKeyMod(word)
                    var phrase = split[0] ?? ''
                    var times = Math.min(Number(split[1] ?? '', 2000))
                    var separator = split.slice(2).length ? split.slice(2).join('|') : ''
                    var repeat = []
                    for (var i = 0; i < times; i++) {
                        repeat.push(phrase)
                    }
                    return repeat.join(separator)
                },

                attemptvalue: 5
            },

            rawrepeat: {
                helpf: "(phrase | times | separator)",

                desc: "Repeats the phrase by the times specified, but keywords and functions don't execute automatically. If the separator is specified, it'll separate each repetition with the separator.",

                func: async (matches, msg, isBot) => {
                    var word = matches[1]
                    var split = splitKeyMod(word, { args: 3 })
                    var phrase = split[0] ?? ''
                    var times = Math.min(Number(await getKeywordsFor(split[1] ?? '', msg, isBot).catch(() => { })), 2000) ?? 1
                    var separator = await getKeywordsFor(split[2] ?? '', msg, isBot).catch(() => { }) ?? ''
                    var repeat = []
                    for (var i = 0; i < times; i++) {
                        repeat.push(phrase)
                    }
                    return repeat.join(separator)
                },

                raw: true,

                attemptvalue: 5
            },

            math: {
                helpf: "(expression)",

                desc: "Evaluates the specified math expression if it is valid.",

                func: async (matches) => {
                    var word = matches[1]
                    try {
                        return String(mathjs.evaluate(word))
                    } catch (err) {
                        return 'NaN'
                    }
                },

                parentheses: true
            },

            randomnumber: {
                helpf: "(min | max)",

                desc: "Returns a random number between min and max. They should be separated by \"|\".",

                func: async (matches) => {
                    var word = matches[1]
                    var split = splitKeyMod(word)
                    if (split.length <= 1 && split[0] === '') return Math.random()
                    var min = Math.round(Number(split[0])) || 0
                    var max = Math.round(Number(split[split.length - 1])) || 0
                    return Math.floor(Math.random() * (max + 1 - min)) + min
                },
            },

            if: {
                helpf: "(condition | phrase | elsePhrase)",

                desc: "Returns the phrase if the specified condition is not blank, or else it returns the elsePhrase, if it exists.",

                func: async (matches, msg, isBot) => {
                    var word = matches[1]
                    var split = splitKeyMod(word)
                    var condition = await getKeywordsFor(split[0] ?? '', msg, isBot).catch(() => { })
                    var phrase = split[1] ?? ''
                    var elsephrase = split.slice(2).length ? split.slice(2).join(' | ') : ''
                    return condition ? phrase : elsephrase
                },

                raw: true
            },

            not: {
                helpf: "(phrase)",

                desc: "Returns the opposite of the phrase.",

                func: async (matches) => {
                    var word = matches[1]
                    var split = splitKeyMod(word)
                    var phrase = split.slice(0).length ? split.slice(0).join(' | ') : ''
                    return !phrase ? 'true' : ''
                },
            },

            equal: {
                helpf: "(phrase1 | phrase2)",

                desc: "Returns true if phrase1 is equal to phrase2.",

                func: async (matches) => {
                    var word = matches[1]
                    var split = splitKeyMod(word)
                    var phrase1 = split[0] ?? ''
                    var phrase2 = split.slice(1).length ? split.slice(1).join(' | ') : ''
                    return phrase1 === phrase2 ? 'true' : ''
                },
            },

            notequal: {
                helpf: "(phrase1 | phrase2)",

                desc: "Returns true if phrase1 is not equal to phrase2.",

                func: async (matches) => {
                    var word = matches[1]
                    var split = splitKeyMod(word)
                    var phrase1 = split[0] ?? ''
                    var phrase2 = split.slice(1).length ? split.slice(1).join(' | ') : ''
                    return phrase1 !== phrase2 ? 'true' : ''
                },
            },

            bigger: {
                helpf: "(number1 | number2)",

                desc: "Returns true if number1 is bigger than number2.",

                func: async (matches) => {
                    var word = matches[1]
                    var split = splitKeyMod(word)
                    var number1 = Number(split[0])
                    var number2 = Number(split.slice(1).join('|'))
                    return number1 > number2 ? 'true' : ''
                },
            },

            biggerequal: {
                helpf: "(number1 | number2)",

                desc: "Returns true if number1 is bigger or equal to number2.",

                func: async (matches) => {
                    var word = matches[1]
                    var split = splitKeyMod(word)
                    var number1 = Number(split[0])
                    var number2 = Number(split.slice(1).join('|'))
                    return number1 >= number2 ? 'true' : ''
                },
            },

            smaller: {
                helpf: "(number1 | number2)",

                desc: "Returns true if number1 is smaller than number2.",

                func: async (matches) => {
                    var word = matches[1]
                    var split = splitKeyMod(word)
                    var number1 = Number(split[0])
                    var number2 = Number(split.slice(1).join('|'))
                    return number1 < number2 ? 'true' : ''
                },
            },

            smallerequal: {
                helpf: "(number1 | number2)",

                desc: "Returns true if number1 is smaller or equal to number2.",

                func: async (matches) => {
                    var word = matches[1]
                    var split = splitKeyMod(word)
                    var number1 = Number(split[0])
                    var number2 = Number(split.slice(1).join('|'))
                    return number1 <= number2 ? 'true' : ''
                },
            },

            and: {
                helpf: "(phrase1 | phrase2 | phrase3 | etc...)",

                desc: "Returns the last phrase if none are blank.",

                func: async (matches) => {
                    var word = matches[1]
                    var split = splitKeyMod(word)
                    var and = ''
                    for (var i in split) {
                        var phrase = split[i]
                        if (!phrase) return ''
                        else and = phrase
                    }
                    return and
                },
            },

            or: {
                helpf: "(phrase1 | phrase2 | phrase3 | etc...)",

                desc: "Returns the first phrase that isn't blank.",

                func: async (matches) => {
                    var word = matches[1]
                    var split = splitKeyMod(word)
                    var or = ''
                    for (var i in split) {
                        var phrase = split[i]
                        if (phrase) return phrase
                    }
                    return ''
                },
            },

            wait: {
                helpf: "(seconds)",

                desc: "Waits the specified seconds. Maximum is 60.",

                func: async (matches) => {
                    var word = matches[1]
                    var waitTime = Number(word)
                    await sleep((waitTime * 1000) > 60000 ? 60000 : waitTime * 1000)
                    return ''
                },

                attemptvalue: 10
            },

            waitcooldown: {
                helpf: "()",

                desc: "Waits your current cooldown value.",

                func: async (_, msg) => {
                    var cooldown = (data()[mongodatabase]['guild-data'][msg.guild.id]['members'][msg.author.id]['coolDown'] || 0) - Date.now()
                    await sleep(cooldown)
                    return ''
                },
            },

            sendid: {
                helpf: "(phrase)",

                desc: "Sends a message to the channel. After being sent, it returns its ID. Has the default cooldown of course.",

                func: async (matches, msg) => {
                    var word = matches[1]

                    if (data2[msg.guild.id][msg.channel.id]['shut']) return ''
                    if (data()[mongodatabase]['guild-data'][msg.guild.id]['members'][msg.author.id]['coolDown']) {
                        if ((data()[mongodatabase]['guild-data'][msg.guild.id]['members'][msg.author.id]['coolDown'] - Date.now()) > 0) {
                            return `Calm down! Wait more ${(data()[mongodatabase]['guild-data'][msg.guild.id]['members'][msg.author.id]['coolDown'] - Date.now()) / 1000} seconds.`
                        } else {
                            data()[mongodatabase]['guild-data'][msg.guild.id]['members'][msg.author.id]['coolDown'] = false
                        }
                    }

                    data()[mongodatabase]['guild-data'][msg.guild.id]['members'][msg.author.id]['coolDown'] = (data()[mongodatabase]['guild-data'][msg.guild.id]['members'][msg.author.id]['coolDown'] || Date.now()) + 2500 / ((msg.member.permissions.has('MANAGE_GUILD') || msg.member.roles.cache.find(role => role.name.match(/mod|dev|admin|owner|creator|founder|staff/ig)) || msg.member.permissions.has('MANAGE_MESSAGES') || msg.member.permissions.has('ADMINISTRATOR') || msg.author.id === msg.guild.ownerID) ? 5 : 1)

                    var message = await msg.channel.send({
                        content: word,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })

                    if (message) {
                        return message.id
                    }

                    return ''
                },

                attemptvalue: 10
            },

            edit: {
                helpf: "(id | phrase)",

                desc: "Edits a message sent by Poopy less than a minute ago.",

                func: async (matches, msg) => {
                    var word = matches[1]
                    var split = splitKeyMod(word)
                    var id = split[0] ?? ''
                    var phrase = split.slice(1).length ? split.slice(1).join(' | ') : ''

                    var messageToEdit = await msg.channel.messages.fetch(id).catch(() => { })

                    if (messageToEdit) {
                        if (messageToEdit.author.id !== bot.user.id || (Date.now() - messageToEdit.createdTimestamp) > 60000) {
                            return ''
                        }

                        await messageToEdit.edit({
                            allowedMentions: {
                                parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                            },
                            content: phrase
                        }).catch(() => { })
                    }

                    return ''
                }
            },

            delete: {
                helpf: "(id)",

                desc: "Deletes the message. If the ID is specified, the message must be sent by Poopy less than a minute ago.",

                func: async (matches, msg) => {
                    var word = matches[1]
                    var id = word || msg.id
                    var messageToDelete = word ? await msg.channel.messages.fetch(id).catch(() => { }) : msg

                    if (messageToDelete) {
                        if ((messageToDelete.author.id !== bot.user.id && messageToDelete.id !== id) || (Date.now() - messageToDelete.createdTimestamp) > 60000) {
                            return ''
                        }

                        await messageToDelete.delete().catch(() => { })
                    }

                    return ''
                },
            },

            yesno: {
                helpf: "(phrase)",

                desc: "Creates a new yes/no choice in the channel. Returns true if yes is chosen, blank otherwise. Has a cooldown.",

                func: async (matches, msg) => {
                    var word = matches[1]
                    
                    if (data2[msg.guild.id][msg.channel.id]['shut']) return ''

                    if (data()[mongodatabase]['guild-data'][msg.guild.id]['members'][msg.author.id]['coolDown']) {
                        if ((data()[mongodatabase]['guild-data'][msg.guild.id]['members'][msg.author.id]['coolDown'] - Date.now()) > 0) {
                            return `Calm down! Wait more ${(data()[mongodatabase]['guild-data'][msg.guild.id]['members'][msg.author.id]['coolDown'] - Date.now()) / 1000} seconds.`
                        } else {
                            data()[mongodatabase]['guild-data'][msg.guild.id]['members'][msg.author.id]['coolDown'] = false
                        }
                    }

                    data()[mongodatabase]['guild-data'][msg.guild.id]['members'][msg.author.id]['coolDown'] = (data()[mongodatabase]['guild-data'][msg.guild.id]['members'][msg.author.id]['coolDown'] || Date.now()) + 2500 / ((msg.member.permissions.has('MANAGE_GUILD') || msg.member.roles.cache.find(role => role.name.match(/mod|dev|admin|owner|creator|founder|staff/ig)) || msg.member.permissions.has('MANAGE_MESSAGES') || msg.member.permissions.has('ADMINISTRATOR') || msg.author.id === msg.guild.ownerID) ? 5 : 1)

                    var result = await yesno(msg.channel, word, msg.member.id).catch(() => { })
                    return result ? 'true' : ''
                },

                attemptvalue: 10
            },

            messagecollector: {
                helpf: "(filter<_msg> | collectPhrase<_msg|resettimer()|stop(sendFinishPhrase)> | timeout | finishPhrase<_collected> | separator) (manage messages permission only)",

                desc: "Creates a message collector that collects any messages sent in the channel that match the filter, within the timeout.\n**_msg** - Keyword used when a message is sent\n**resettimer()** - Resets the collector's timer\n**stop(sendFinishPhrase)** - Stops the collector from running, sends the finishPhrase if sendFinishPhrase isn't blank.\n**_collected** - Used when the collector stops running, containing all collected messages separated with the separator.",

                func: async (matches, msg, isBot) => {
                    var word = matches[1]
                    var split = splitKeyMod(word, { args: 5 })
                    var filterString = split[0] ?? ''
                    var collectphrase = split[1] ?? ''
                    split[2] = await getKeywordsFor(split[2] ?? '', msg, isBot).catch(() => { }) || ''
                    var timeout = isNaN(Number(split[2])) ? 10 : Number(split[2]) <= 1 ? 1 : Number(split[2]) >= 60 ? 60 : Number(split[2]) || 10
                    var finishphrase = split[3] ?? ''
                    var separator = split[4] ?? ''
                    var channel = msg.channel
                    var guildid = msg.guild.id
                    var channelid = channel.id
                    var authorid = msg.author.id

                    if (msg.member.permissions.has('MANAGE_GUILD') || msg.member.roles.cache.find(role => role.name.match(/mod|dev|admin|owner|creator|founder|staff/ig)) || msg.member.permissions.has('MANAGE_MESSAGES') || msg.member.permissions.has('ADMINISTRATOR') || authorid === msg.guild.ownerID || ownerids.find(id => id == msg.author.id) || isBot) {
                        if (data2[guildid][channelid][authorid].messageCollector) {
                            data2[guildid][channelid][authorid].messageCollector.stop()
                            delete data2[guildid][channelid][authorid].messageCollector
                        }

                        var filter = m => !m.author.bot
                        var collected = []
                        var collector = channel.createMessageCollector({ filter, time: timeout * 1000 })

                        data2[guildid][channelid][authorid].messageCollector = collector

                        collector.on('collect', async m => {
                            try {
                                if (data2[msg.guild.id][msg.channel.id]['shut']) return
                                var content = await getKeywordsFor(m.content ?? '', m, false).catch(() => { }) ?? m.content

                                var filterStringM = await getKeywordsFor(filterString, m, true, {
                                    extrakeys: {
                                        _msg: {
                                            func: async () => {
                                                return content
                                            }
                                        }
                                    }
                                }).catch(() => { }) ?? filterString

                                if (filterStringM) {
                                    var collect = await getKeywordsFor(collectphrase, m, true, {
                                        extrakeys: {
                                            _msg: {
                                                func: async () => {
                                                    return content
                                                }
                                            }
                                        },

                                        extrafuncs: {
                                            resettimer: {
                                                func: async () => {
                                                    collector.resetTimer()
                                                    return ''
                                                }
                                            },

                                            stop: {
                                                func: async (matches) => {
                                                    var word = matches[1]
                                                    collector.stop(word ? 'time' : 'user')
                                                    return ''
                                                }
                                            },
                                        }
                                    }).catch(() => { }) ?? ''

                                    collected.push(content)

                                    channel.send({
                                        content: collect,
                                        allowedMentions: {
                                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && authorid !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                        }
                                    }).catch(() => { })
                                }
                            } catch (_) { }
                        })

                        collector.on('end', async (_, reason) => {
                            try {
                                if (data2[msg.guild.id][msg.channel.id]['shut']) return
                                delete data2[guildid][channelid][authorid].messageCollector
                                if (reason === 'time') {
                                    var finishphrasek = await getKeywordsFor(finishphrase, msg, isBot, {
                                        extrakeys: {
                                            _collected: {
                                                func: async () => {
                                                    return collected.join(separator)
                                                }
                                            }
                                        }
                                    }).catch(() => { }) ?? ''

                                    channel.send({
                                        content: finishphrasek,
                                        allowedMentions: {
                                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && authorid !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                        }
                                    }).catch(() => { })
                                }
                            } catch (_) { }
                        })

                        return ''
                    } else {
                        return 'You need the manage messages permission to use this function.'
                    }
                },

                raw: true,

                potential: {
                    keys: {
                        _msg: {},
                        _collected: {}
                    },

                    funcs: {
                        resettimer: {},
                        stop: {}
                    }
                },

                attemptvalue: 10
            },

            stopcollector: {
                helpf: "(sendFinishPhrase)",

                desc: "Stops any message collector you created that is still active in the channel.",

                func: async (matches, msg) => {
                    var word = matches[1]
                    if (data2[msg.guild.id][msg.channel.id][msg.author.id].messageCollector) {
                        data2[msg.guild.id][msg.channel.id][msg.author.id].messageCollector.stop(word ? 'time' : 'user')
                        delete data2[msg.guild.id][msg.channel.id][msg.author.id].messageCollector
                    }
                }
            },

            stopallcollectors: {
                helpf: "(sendFinishPhrase) (manage messages permission only)",

                desc: "Stops all message collectors that are still active in the channel.",

                func: async (matches, msg) => {
                    var word = matches[1]

                    if (msg.member.permissions.has('MANAGE_GUILD') || msg.member.roles.cache.find(role => role.name.match(/mod|dev|admin|owner|creator|founder|staff/ig)) || msg.member.permissions.has('MANAGE_MESSAGES') || msg.member.permissions.has('ADMINISTRATOR') || msg.author.id === msg.guild.ownerID || ownerids.find(id => id == msg.author.id) || isBot) {
                        for (var uid in data2[msg.guild.id][msg.channel.id]) {
                            if (data2[msg.guild.id][msg.channel.id][uid].messageCollector) {
                                data2[msg.guild.id][msg.channel.id][msg.author.id].messageCollector.stop(word ? 'time' : 'user')
                                delete data2[msg.guild.id][msg.channel.id][msg.author.id].messageCollector
                            }
                        }
                    } else {
                        return 'You need the manage messages permission to use this function.'
                    }
                }
            },

            urlencode: {
                helpf: "(phrase)",

                desc: "Encodes the phrase so it's supported by URL components.",

                func: async (matches) => {
                    var word = matches[1]
                    return encodeURIComponent(word)
                },
            },

            urldecode: {
                helpf: "(phrase)",

                desc: "Decodes the phrase so it's just a normal string.",

                func: async (matches) => {
                    var word = matches[1]
                    return decodeURIComponent(word)
                },
            },

            arg: {
                helpf: "(number)",

                desc: "Returns the argument in the message with the index <number>. Putting \"+\" after the number means all other arguments after it.",

                func: async (matches, msg, isBot, string) => {
                    var f = matches[0]
                    var word = matches[1]
                    var index = Number(word.replace(/\+/g, '')) <= 0 ? 0 : Math.round(Number(word.replace(/\+/g, ''))) || 0
                    var words = isBot ? msg.content.replace(new RegExp(`${f}\\(([\\s\\S]*?)\\)`, 'ig'), '').split(' ') : string.replace(new RegExp(`${f}\\(([\\s\\S]*?)\\)`, 'ig'), '').split(' ')
                    if (word.endsWith('+')) return await getKeywordsFor(words.slice(index).join(' ') || '', msg, isBot).catch(() => { }) || ''
                    return await getKeywordsFor(words[index] || '', msg, isBot).catch(() => { }) || ''
                },
            },

            rawarg: {
                helpf: "(number)",

                desc: "Returns the argument in the message with the index <number>, except keywords and functions are not executed automatically. Putting \"+\" after the number means all other arguments after it.",

                func: async (matches, msg, isBot, string) => {
                    var f = matches[0]
                    var word = matches[1]
                    var index = Number(word.replace(/\+/g, '')) <= 0 ? 0 : Math.round(Number(word.replace(/\+/g, ''))) || 0
                    var words = isBot ? msg.oldcontent.replace(new RegExp(`${f}\\(([\\s\\S]*?)\\)`, 'ig'), '').split(' ') : msg.content.replace(new RegExp(`${f}\\(([\\s\\S]*?)\\)`, 'ig'), '').split(' ')
                    if (word.endsWith('+')) return await getKeywordsFor(words.slice(index).join(' ') || '', msg, isBot).catch(() => { }) || ''
                    return await getKeywordsFor(words[index] || '', msg, isBot).catch(() => { }) || ''
                },
            },

            indexofarg: {
                helpf: "(text)",

                desc: "Returns the index of the argument in the message that matches the text inside the function.",

                func: async (matches, msg, isBot, string) => {
                    var f = matches[0]
                    var word = matches[1]
                    var words = isBot ? msg.content.replace(new RegExp(`${f}\\(([\\s\\S]*?)\\)`, 'ig'), '').split(' ') : string.replace(new RegExp(`${f}\\(([\\s\\S]*?)\\)`, 'ig'), '').split(' ')
                    return words.findIndex(w => w.toLowerCase().includes(word.toLowerCase()))
                },
            },

            array: {
                helpf: "(arrayName)",

                desc: "Creates a new array with the specified name. If it already exists, it'll be cleared.",

                func: async (matches, msg, _, string) => {
                    var word = matches[1]
                    var fullword = `${matches[0]}(${matches[1]})`
                    var phrase = string.replace(new RegExp(`${regexClean(fullword)}\\s*`, 'i'), '')
                    data2[msg.author.id]['arrays'][word] = []
                    return [phrase, true]
                },

                attemptvalue: 5
            },

            arraysplit: {
                helpf: "(arrayName | separator | phrase)",

                desc: "Creates a new array by splitting the phrase by the separator (or \"|\" if blank), knowing it'll be raw. If it already exists, it'll be replaced.",

                func: async (matches, msg, isBot, string) => {
                    var word = matches[1]
                    var split = splitKeyMod(word, { args: 3 })
                    var name = await getKeywordsFor(split[0] ?? '', msg, isBot).catch(() => { }) ?? ''
                    var separator = split[1] ? await getKeywordsFor(split[1], msg, isBot).catch(() => { }) : '|'
                    var phr = split[2] ?? ''
                    var fullword = `${matches[0]}(${matches[1]})`
                    var phrase = string.replace(new RegExp(`${regexClean(fullword)}\\s*`, 'i'), '')
                    data2[msg.author.id]['arrays'][name] = splitKeyMod(phr, { separator: separator })
                    return [phrase, true]
                },

                attemptvalue: 5,

                raw: true
            },

            arraylength: {
                helpf: "(arrayName)",

                desc: "Returns the length of the array.",

                func: async (matches, msg) => {
                    var word = matches[1]
                    return (data2[msg.author.id]['arrays'][word] ?? []).length
                }
            },

            push: {
                helpf: "(arrayName | value)",

                desc: "Pushes a new value to an array.",

                func: async (matches, msg) => {
                    var word = matches[1]
                    var split = splitKeyMod(word, { args: 2 })
                    var name = split[0] ?? ''
                    var value = split[1] ?? ''

                    var array = data2[msg.author.id]['arrays'][name]
                    if (!array) return ''

                    array.push(value)

                    return ''
                }
            },

            rawpush: {
                helpf: "(arrayName | value)",

                desc: "Pushes a new raw value to an array.",

                func: async (matches, msg, isBot) => {
                    var word = matches[1]
                    var split = splitKeyMod(word, { args: 2 })
                    var name = await getKeywordsFor(split[0] ?? '', msg, isBot).catch(() => { }) ?? ''
                    var value = split[1] ?? ''

                    var array = data2[msg.author.id]['arrays'][name]
                    if (!array) return ''

                    array.push(value)

                    return ''
                },

                raw: true
            },

            find: {
                helpf: "(arrayName | function<_val>)",

                desc: "Finds a value in the array that matches the function.",

                func: async (matches, msg, isBot) => {
                    var word = matches[1]
                    var split = splitKeyMod(word, { args: 2 })
                    var name = await getKeywordsFor(split[0] ?? '', msg, isBot).catch(() => { }) ?? ''
                    var func = split[1] ?? ''

                    var array = data2[msg.author.id]['arrays'][name]
                    if (!array) return ''

                    return await findAsync(array, async (val) => {
                        var found = await getKeywordsFor(func, msg, isBot, {
                            extrakeys: {
                                _val: {
                                    func: async () => {
                                        return val
                                    }
                                },
                            }
                        }).catch(() => { }) ?? ''

                        return found
                    }).catch(() => { }) ?? ''
                },

                attemptvalue: 5,

                raw: true
            },

            findindex: {
                helpf: "(arrayName | function<_val>)",

                desc: "Finds the key of the value in the array that matches the function.",

                func: async (matches, msg, isBot) => {
                    var word = matches[1]
                    var split = splitKeyMod(word, { args: 2 })
                    var name = await getKeywordsFor(split[0] ?? '', msg, isBot).catch(() => { }) ?? ''
                    var func = split[1] ?? ''

                    var array = data2[msg.author.id]['arrays'][name]
                    if (!array) return ''

                    return await findIndexAsync(array, async (val) => {
                        var found = await getKeywordsFor(func, msg, isBot, {
                            extrakeys: {
                                _val: {
                                    func: async () => {
                                        return val
                                    }
                                },
                            }
                        }).catch(() => { }) ?? ''

                        return found
                    }).catch(() => { }) ?? ''
                },

                attemptvalue: 5,

                raw: true
            },

            foreach: {
                helpf: "(arrayName | function<_index|_val>)",

                desc: "For each value in that array, it'll execute the function.",

                func: async (matches, msg, isBot) => {
                    var word = matches[1]
                    var split = splitKeyMod(word, { args: 2 })
                    var name = await getKeywordsFor(split[0] ?? '', msg, isBot).catch(() => { }) ?? ''
                    var func = split[1] ?? ''

                    var array = data2[msg.author.id]['arrays'][name]
                    if (!array) return ''

                    for (var index in array) {
                        var val = array[index]
                        await getKeywordsFor(func, msg, isBot, {
                            extrakeys: {
                                _index: {
                                    func: async () => {
                                        return index
                                    }
                                },

                                _val: {
                                    func: async () => {
                                        return val
                                    }
                                },
                            }
                        }).catch(() => { })
                    }

                    return ''
                },

                attemptvalue: 5,

                raw: true
            },

            join: {
                helpf: "(arrayName | separator)",

                desc: "Joins all the elements in the array with the separator.",

                func: async (matches, msg, isBot) => {
                    var word = matches[1]
                    var split = splitKeyMod(word, { args: 2 })
                    var name = await getKeywordsFor(split[0] ?? '', msg, isBot).catch(() => { }) ?? ''
                    var separator = split[1] ?? ''

                    var array = data2[msg.author.id]['arrays'][name]
                    if (!array) return ''

                    var asyncArray = await Promise.all(array.map(async val => {
                        return await getKeywordsFor(val, msg, isBot).catch(() => { }) ?? ''
                    })).catch(() => { }) ?? []

                    return asyncArray.join(separator)
                }
            },

            reverse: {
                helpf: "(arrayName)",

                desc: "Reverses the array with that name.",

                func: async (matches, msg) => {
                    var word = matches[1]

                    var array = data2[msg.author.id]['arrays'][word]
                    if (!array) return ''

                    array.reverse()

                    return ''
                }
            },

            sort: {
                helpf: "(arrayName)",

                desc: "Sorts the array alphabetically.",

                func: async (matches, msg) => {
                    var word = matches[1]

                    var array = data2[msg.author.id]['arrays'][word]
                    if (!array) return ''

                    array.sort()

                    return ''
                }
            },

            numsort: {
                helpf: "(arrayName)",

                desc: "Sorts the array numerically.",

                func: async (matches, msg) => {
                    var word = matches[1]

                    var array = data2[msg.author.id]['arrays'][word]
                    if (!array) return ''

                    array.sort((a, b) => {
                        return Number(a) - Number(b)
                    })

                    return ''
                }
            },

            remove: {
                helpf: "(arrayName | index)",

                desc: "Removes the value in the array with that index.",

                func: async (matches, msg) => {
                    var word = matches[1]
                    var split = splitKeyMod(word, { args: 2 })
                    var name = split[0] ?? ''
                    var index = split[1] ?? '0'

                    var array = data2[msg.author.id]['arrays'][name]
                    if (!array) return ''

                    array.splice(index, 1)

                    return ''
                }
            },

            declare: {
                helpf: "(name | value)",

                desc: "Declares a variable with the name and value specified. Variables can be used by typing in {variablename}.",

                func: async (matches, msg, isBot, string) => {
                    var word = matches[1]
                    var fullword = `${matches[0]}(${matches[1]})`
                    var split = splitKeyMod(word)
                    var name = split[0] ?? ''
                    name = regexClean(name)
                    var value = split.slice(1).length ? split.slice(1).join(' | ') : ''
                    var phrase = string.replace(new RegExp(`${regexClean(fullword)}\\s*`, 'i'), '')
                    data2[msg.author.id]['declared'][`{${name}}`] = value.replace(new RegExp(`\\{${name}\\}`, 'ig'), data2[msg.author.id]['declared'][`{${name}}`] || '')
                    var extrakeys = {}
                    extrakeys[`{${name}}`] = {
                        func: async () => {
                            return value.replace(new RegExp(`\\{${name}\\}`, 'ig'), data2[msg.author.id]['declared'][`{${name}}`] || '')
                        }
                    }
                    return [await getKeywordsFor(phrase, msg, isBot, {
                        extrakeys: extrakeys
                    }).catch(() => { }) ?? string, true]
                },

                attemptvalue: 5
            },

            rawdeclare: {
                helpf: "(name | value)",

                desc: "Declares a variable with the name and value specified, but keywords and functions don't execute automatically. Variables can be used by typing in {variablename}.",

                func: async (matches, msg, isBot, string) => {
                    var word = matches[1]
                    var fullword = `${matches[0]}(${matches[1]})`
                    var split = splitKeyMod(word)
                    var name = await getKeywordsFor(split[0] ?? '', msg, isBot).catch(() => { }) ?? ''
                    name = regexClean(name)
                    var value = split.slice(1).length ? split.slice(1).join(' | ') : ''
                    var phrase = string.replace(new RegExp(`${regexClean(fullword)}\\s*`, 'i'), '')
                    data2[msg.author.id]['declared'][`{${name}}`] = value.replace(new RegExp(`\\{${name}\\}`, 'ig'), data2[msg.author.id]['declared'][`{${name}}`] || '')
                    var extrakeys = {}
                    extrakeys[`{${name}}`] = {
                        func: async () => {
                            return await getKeywordsFor(value.replace(new RegExp(`\\{${name}\\}`, 'ig'), data2[msg.author.id]['declared'][`{${name}}`] || ''), msg, isBot).catch(() => { }) ?? ''
                        }
                    }
                    return [await getKeywordsFor(phrase, msg, isBot, {
                        extrakeys: extrakeys
                    }).catch(() => { }) ?? string, true]
                },

                raw: true,

                attemptvalue: 10
            },

            funcdeclare: {
                helpf: "(name | function<_val>)",

                desc: "Declares a function with the name and function specified. Functions can be used by typing in [functionname].",

                func: async (matches, msg, isBot, string) => {
                    var word = matches[1]
                    var fullword = `${matches[0]}(${matches[1]})`
                    var split = splitKeyMod(word)
                    var name = await getKeywordsFor(split[0] ?? '', msg, isBot).catch(() => { }) ?? ''
                    name = regexClean(name)
                    var value = split.slice(1).length ? split.slice(1).join(' | ') : ''
                    var phrase = string.replace(new RegExp(`${regexClean(fullword)}\\s*`, 'i'), '')
                    data2[msg.author.id]['declared'][`[${name}]`] = value
                    var extrafuncs = {}
                    extrafuncs[`[${name}]`] = {
                        func: async (matches) => {
                            var word = matches[1]
                            return await getKeywordsFor(value.replace(new RegExp(`\\[${name}\\]\\(([\\s\\S]*?)\\)`, 'ig'), data2[msg.author.id]['declared'][`[${name}]`] || '').replace(/_val/, word), msg, isBot).catch(() => { }) ?? ''
                        }
                    }
                    return [await getKeywordsFor(phrase, msg, isBot, {
                        extrafuncs: extrafuncs
                    }).catch(() => { }) ?? string, true]
                },

                raw: true,

                parentheses: true,

                attemptvalue: 5
            },

            changewords: {
                helpf: "(phrase)",

                desc: "Replaces all of the words in the phrase with different ones.",

                func: async (matches) => {
                    var word = matches[1]
                    var wrdJSON = json.wordJSON
                    var wrds = []
                    var wrdsR = []
                    for (var i in wrdJSON.data) {
                        var wrd = wrdJSON.data[i]
                        wrds.push(wrd.word.value)
                        wrdsR.push('^' + wrd.word.value)
                    }
                    var wrdRegex = new RegExp(`${wrdsR.join('|')}`, 'i')
                    var words = word.split(' ')
                    for (var i in words) {
                        if (words[i].match(wrdRegex)) words[i] = words[i].replace(wrdRegex, (word) => {
                            var wrd = wrds[Math.floor(Math.random() * wrds.length)]
                            if (word.substring(0, 1) === word.substring(0, 1).toLowerCase()) return wrd
                            else if (word.substring(0, 2) === (word.substring(0, 1).toUpperCase() + word.substring(1, 2).toLowerCase())) return wrd.substring(0, 1).toUpperCase() + wrd.substring(1).toLowerCase()
                            else return wrd.toUpperCase()
                        })
                    }
                    return words.join(' ')
                },
            },

            changenouns: {
                helpf: "(phrase)",

                desc: "Replaces all of the nouns in the phrase with different ones.",

                func: async (matches) => {
                    var word = matches[1]
                    var nounJSON = json.nounJSON
                    var nouns = []
                    var nounsR = []
                    for (var i in nounJSON.data) {
                        var noun = nounJSON.data[i]
                        nouns.push(noun.noun)
                        nounsR.push('^' + noun.noun)
                    }
                    var nounRegex = new RegExp(`${nounsR.join('|')}`, 'i')
                    var words = word.split(' ')
                    for (var i in words) {
                        if (words[i].match(nounRegex)) words[i] = words[i].replace(nounRegex, (word) => {
                            var noun = nouns[Math.floor(Math.random() * nouns.length)]
                            if (word.substring(0, 1) === word.substring(0, 1).toLowerCase()) return noun
                            else if (word.substring(0, 2) === (word.substring(0, 1).toUpperCase() + word.substring(1, 2).toLowerCase())) return noun.substring(0, 1).toUpperCase() + noun.substring(1).toLowerCase()
                            else return noun.toUpperCase()
                        })
                    }
                    return words.join(' ')
                },
            },

            changenounstomembers: {
                helpf: "(phrase)",

                desc: "Replaces all of the nouns in the phrase with members.",

                func: async (matches, msg) => {
                    var word = matches[1]
                    var nounJSON = json.nounJSON
                    var nouns = []
                    var nounsR = []
                    for (var i in nounJSON.data) {
                        var noun = nounJSON.data[i]
                        nouns.push(noun.noun)
                        nounsR.push('^' + noun.noun)
                    }
                    var nounRegex = new RegExp(`${nounsR.join('|')}`, 'i')
                    var words = word.split(' ')
                    for (var i in words) {
                        if (words[i].match(nounRegex)) words[i] = replaceAsync(words[i], nounRegex, async (word) => {
                            var member = await special.keys._member.func(msg)
                            if (word === word.toUpperCase()) return member.toUpperCase()
                            else return member
                        })
                    }
                    return words.join(' ')
                },
            },

            changenounstopsmembers: {
                helpf: "(phrase)",

                desc: "Replaces all of the nouns in the phrase with Phexonia Studios members.",

                func: async (matches) => {
                    var word = matches[1]
                    var nounJSON = json.nounJSON
                    var nouns = []
                    var nounsR = []
                    for (var i in nounJSON.data) {
                        var noun = nounJSON.data[i]
                        nouns.push(noun.noun)
                        nounsR.push('^' + noun.noun)
                    }
                    var nounRegex = new RegExp(`${nounsR.join('|')}`, 'i')
                    var words = word.split(' ')
                    for (var i in words) {
                        if (words[i].match(nounRegex)) words[i] = await replaceAsync(words[i], nounRegex, async (word) => {
                            var psmember = await special.keys._psmember.func()
                            if (word.substring(0, 1) === word.substring(0, 1).toLowerCase()) return psmember
                            else if (word.substring(0, 2) === (word.substring(0, 1).toUpperCase() + word.substring(1, 2).toLowerCase())) return psmember.substring(0, 1).toUpperCase() + psmember.substring(1).toLowerCase()
                            else return psmember.toUpperCase()
                        })
                    }
                    return words.join(' ')
                },
            },

            changeverbs: {
                helpf: "(phrase)",

                desc: "Replaces all of the verbs in the phrase with different ones.",

                func: async (matches) => {
                    var word = matches[1]
                    var verbJSON = json.verbJSON
                    var verbs = []
                    var verbsR = []
                    for (var i in verbJSON.data) {
                        var verb = verbJSON.data[i]
                        verbs.push(verb.verb)
                        verbsR.push('^' + verb.verb)
                    }
                    var verbRegex = new RegExp(`${verbsR.join('|')}`, 'i')
                    var words = word.split(' ')
                    for (var i in words) {
                        if (words[i].match(verbRegex)) words[i] = words[i].replace(verbRegex, (word) => {
                            var verb = verbs[Math.floor(Math.random() * verbs.length)]
                            if (word.substring(0, 1) === word.substring(0, 1).toLowerCase()) return verb
                            else if (word.substring(0, 2) === (word.substring(0, 1).toUpperCase() + word.substring(1, 2).toLowerCase())) return verb.substring(0, 1).toUpperCase() + verb.substring(1).toLowerCase()
                            else return verb.toUpperCase()
                        })
                    }
                    return words.join(' ')
                },
            },

            changeadjs: {
                helpf: "(phrase)",

                desc: "Replaces all of the adjectives in the phrase with different ones.",

                func: async (matches) => {
                    var word = matches[1]
                    var adjJSON = json.adjJSON
                    var adjs = []
                    var adjsR = []
                    for (var i in adjJSON.data) {
                        var adj = adjJSON.data[i]
                        adjs.push(adj.adjective)
                        adjsR.push('^' + adj.adjective)
                    }
                    var adjRegex = new RegExp(`${adjsR.join('|')}`, 'i')
                    var words = word.split(' ')
                    for (var i in words) {
                        if (words[i].match(adjRegex)) words[i] = words[i].replace(adjRegex, (word) => {
                            var adj = adjs[Math.floor(Math.random() * adjs.length)]
                            if (word.substring(0, 1) === word.substring(0, 1).toLowerCase()) return adj
                            else if (word.substring(0, 2) === (word.substring(0, 1).toUpperCase() + word.substring(1, 2).toLowerCase())) return adj.substring(0, 1).toUpperCase() + adj.substring(1).toLowerCase()
                            else return adj.toUpperCase()
                        })
                    }
                    return words.join(' ')
                },
            },

            rgb: {
                helpf: "(hex)",

                desc: "Converts the supplied hex code to RGB.",

                func: async (matches) => {
                    var word = matches[1]
                    var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(word)
                    return result ? `${parseInt(result[1], 16)} ${parseInt(result[2], 16)} ${parseInt(result[3], 16)}` : '0 0 0'
                },
            },

            countryfromcode: {
                helpf: "(countrycode)",

                desc: "Returns the name of the country that matches the country code.",

                func: async (matches) => {
                    var word = matches[1]

                    var countryJSON = json.countryJSON

                    return countryJSON[word.toUpperCase()] ? countryJSON[word.toUpperCase()].name : ''
                }
            },

            nationalityfromcode: {
                helpf: "(countrycode)",

                desc: "Returns a random nationality from the country that matches the country code.",

                func: async (matches) => {
                    var word = matches[1]

                    var countryJSON = json.countryJSON
                    var languageJSON = json.languageJSON

                    return countryJSON[word.toUpperCase()] ? languageJSON[countryJSON[word.toUpperCase()].languages[Math.floor(Math.random() * countryJSON[word.toUpperCase()].languages.length)]].name : ''
                }
            },

            cityfromcode: {
                helpf: "(countrycode)",

                desc: "Returns a random city from the country that matches the country code.",

                func: async (matches) => {
                    var word = matches[1]

                    var countryJSON = json.countryJSON
                    var cityJSON = json.cityJSON

                    if (countryJSON[word.toUpperCase()]) {
                        var cities = []

                        for (var i in cityJSON) {
                            var city = cityJSON[i]
                            if (city.country === word.toUpperCase()) {
                                cities.push(city.name)
                            }
                        }

                        return cities[Math.floor(Math.random() * cities.length)]
                    }

                    return ''
                }
            },

            citylat: {
                helpf: "(city)",

                desc: "Returns the latitude of the city specified.",

                func: async (matches) => {
                    var word = matches[1]

                    var cityJSON = json.cityJSON

                    return cityJSON.find(city => city.name.toLowerCase() === word.toLowerCase()) ? cityJSON.find(city => city.name.toLowerCase() === word.toLowerCase()).lat : '0'
                }
            },

            citylng: {
                helpf: "(city)",

                desc: "Returns the longitude of the city specified.",

                func: async (matches) => {
                    var word = matches[1]

                    var cityJSON = json.cityJSON

                    return cityJSON.find(city => city.name.toLowerCase() === word.toLowerCase()) ? cityJSON.find(city => city.name.toLowerCase() === word.toLowerCase()).lng : '0'
                }
            },

            image: {
                helpf: "(query | page)",

                desc: "Returns a random image out of the search query, if no page is specified.",

                func: async (matches) => {
                    var word = matches[1]
                    var split = splitKeyMod(word, { args: 2 })
                    var query = getIndexOption(split, 0)[0]
                    var page = getIndexOption(split, 1, { n: Infinity }).join(' | ')
                    var urls = []

                    async function search() {
                        return new Promise(resolve => {
                            gis(query, async function (_, results) {
                                for (var i in results) {
                                    var result = results[i]
                                    var url = result.url.replace(/\\u([a-z0-9]){4}/g, (match) => {
                                        return String.fromCharCode(Number('0x' + match.substring(2, match.length)))
                                    })

                                    urls.push(url)
                                }

                                resolve()
                            })
                        })
                    }

                    await search()

                    if (!urls.length) return word

                    var page = parseNumber(page, { dft: Math.floor(Math.random() * urls.length), min: 1, max: urls.length, round: true })

                    return urls[page]
                },

                attemptvalue: 10
            },

            gif: {
                helpf: "(query | page)",

                desc: "Returns a random Tenor GIF out of the search query, if no page is specified.",

                func: async (matches, msg) => {
                    var word = matches[1]
                    var split = splitKeyMod(word, { args: 2 })
                    var query = getIndexOption(split, 0)[0]
                    var page = getIndexOption(split, 1, { n: Infinity }).join(' | ')
                    var urls = []

                    async function search() {
                        return new Promise(resolve => {
                            axios.request(`https://g.tenor.com/v1/search?q=${encodeURIComponent(query)}&key=${process.env.TENORKEY}&limit=100&contentfilter=${msg.channel.nsfw ? 'off' : 'medium'}`).then((res) => {
                                var parsedBody = res.data

                                for (var i in parsedBody.results) {
                                    var result = parsedBody.results[i]
                                    urls.push(result)
                                }

                                resolve()
                            }).catch(() => { })
                        })
                    }

                    await search()

                    var page = parseNumber(page, { dft: Math.floor(Math.random() * urls.length), min: 1, max: urls.length, round: true })

                    return urls[page].itemurl
                },

                attemptvalue: 10
            },

            username: {
                helpf: "(id)",

                desc: "Fetches the username of the user with the specified ID.",

                func: async (matches) => {
                    var word = matches[1]

                    var user = await bot.users.fetch(word).catch(() => { })

                    return user ? user.username : ''
                },
            },

            avatar: {
                helpf: "(id)",

                desc: "Fetches the avatar of the user with the specified ID.",

                func: async (matches) => {
                    var word = matches[1]

                    var user = await bot.users.fetch(word).catch(() => { })

                    return user ? user.displayAvatarURL({ dynamic: true, size: 1024, format: 'png' }) : ''
                },
            },

            emojiid: {
                helpf: "(name)",

                desc: "Fetches the ID of the emoji from name.",

                func: async (matches, msg) => {
                    var word = matches[1]

                    var emoji = msg.guild.emojis.cache.find(emoji => emoji.name == word)

                    return emoji ? emoji.id : ''
                },
            },

            emojianim: {
                helpf: "(id)",

                desc: "Fetches whether the emoji is animated or not from its ID.",

                func: async (matches, msg) => {
                    var word = matches[1]

                    var emoji = msg.guild.emojis.cache.get(word)

                    return emoji ? emoji.animated ? 'true' : '' : ''
                },
            },

            webhook: {
                helpf: "(name | avatar | message) (manage webhooks only)",

                desc: "Creates a webhook with the name and avatar specified that will send the desired message.",

                func: async (matches, msg, isBot) => {
                    var word = matches[1]
                    var split = splitKeyMod(word)
                    var name = split[0] ?? ''
                    var avatar = split[1] ?? ''
                    var message = split.slice(2).length ? split.slice(2).join(' | ') : ''
                    var allBlank = true
                    
                    if (data2[msg.guild.id][msg.channel.id]['shut']) return ''

                    if (data()[mongodatabase]['guild-data'][msg.guild.id]['members'][msg.author.id]['coolDown']) {
                        if ((data()[mongodatabase]['guild-data'][msg.guild.id]['members'][msg.author.id]['coolDown'] - Date.now()) > 0) {
                            return `Calm down! Wait more ${(data()[mongodatabase]['guild-data'][msg.guild.id]['members'][msg.author.id]['coolDown'] - Date.now()) / 1000} seconds.`
                        } else {
                            data()[mongodatabase]['guild-data'][msg.guild.id]['members'][msg.author.id]['coolDown'] = false
                        }
                    }

                    data()[mongodatabase]['guild-data'][msg.guild.id]['members'][msg.author.id]['coolDown'] = (data()[mongodatabase]['guild-data'][msg.guild.id]['members'][msg.author.id]['coolDown'] || Date.now()) + 2500 / ((msg.member.permissions.has('MANAGE_GUILD') || msg.member.roles.cache.find(role => role.name.match(/mod|dev|admin|owner|creator|founder|staff/ig)) || msg.member.permissions.has('MANAGE_MESSAGES') || msg.member.permissions.has('ADMINISTRATOR') || msg.author.id === msg.guild.ownerID) ? 5 : 1)

                    if (msg.channel.parent) {
                        if (msg.channel.parent.isText()) {
                            return 'Webhooks can\'t be used here.'
                        }
                    }

                    for (var i = 0; i < name.length; i++) {
                        var letter = name[i]
                        if (letter !== ' ') {
                            allBlank = false
                        }
                    }

                    if (allBlank) {
                        return 'Invalid name.'
                    }

                    var fetchAvatar = await axios.request({
                        url: avatar,
                        responseType: 'stream'
                    }).catch(() => { })
                    if (!fetchAvatar) {
                        return 'Invalid avatar.'
                    }

                    var avatarFiletype = await fileType.fromStream(fetchAvatar.data).catch(() => { })
                    if (!avatarFiletype) {
                        return 'Invalid avatar.'
                    }

                    if (!(avatarFiletype.mime.startsWith('image'))) {
                        return 'Invalid avatar.'
                    }

                    if (msg.member.permissions.has('MANAGE_WEBHOOKS') || msg.member.permissions.has('ADMINISTRATOR') || msg.member.permissions.has('MANAGE_GUILD') || msg.member.roles.cache.find(role => role.name.match(/mod|dev|admin|owner|creator|founder|staff/ig)) || msg.author.id === msg.guild.ownerID || ownerids.find(id => id == msg.author.id) || isBot) {
                        var webhooks = await msg.channel.fetchWebhooks().catch(() => { })
                        if (webhooks ? webhooks.size : undefined) {
                            var findWebhook = webhooks.find(webhook => bot.user === webhook.owner)
                            if (findWebhook) {
                                await findWebhook.send({
                                    content: message,
                                    username: name,
                                    avatarURL: avatar,
                                    allowedMentions: {
                                        parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    }
                                }).catch(() => { })
                            } else {
                                var createdWebhook = await msg.channel.createWebhook('Poopyhook', { avatar: 'https://cdn.discordapp.com/attachments/760223418968047629/835923489834664056/poopy2.png' }).catch(() => { })
                                if (!createdWebhook) {
                                    return 'I need admin for this command!'
                                } else {
                                    await createdWebhook.send({
                                        content: message,
                                        username: name,
                                        avatarURL: avatar,
                                        allowedMentions: {
                                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                        }
                                    }).catch(() => { })
                                }
                            }
                        } else {
                            var createdWebhook = await msg.channel.createWebhook('Poopyhook', { avatar: 'https://cdn.discordapp.com/attachments/760223418968047629/835923489834664056/poopy2.png' }).catch(() => { })
                            if (!createdWebhook) {
                                return 'I need admin for this command!'
                            } else {
                                await createdWebhook.send({
                                    content: message,
                                    username: name,
                                    avatarURL: avatar,
                                    allowedMentions: {
                                        parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    }
                                }).catch(() => { })
                            }
                        }
                    } else {
                        return 'You need to have the manage webhooks permission to execute that!'
                    }

                    return ''
                },

                attemptvalue: 10
            },

            lasturl: {
                helpf: "(number)",

                desc: "Returns the last URL in the channel. If <number> is supplied, it'll return the last URL with index <number>, knowing the limit is 100.",

                func: async (matches, msg) => {
                    var word = matches[1]
                    var lastUrls = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrls']
                    var number = isNaN(Number(word)) ? 0 : Number(word) <= 0 ? 0 : Number(word) >= lastUrls.length - 1 ? lastUrls.length - 1 : Math.round(Number(word)) || 0
                    return lastUrls[number] ?? ''
                },
            },

            fetchurl: {
                helpf: "(number)",

                desc: "Returns the first URL in the message. If <number> is supplied, it'll return the URL in the message with index <number>.",

                func: async (matches, msg, _, string) => {
                    var word = matches[1]
                    var urls = await getUrls(msg, { string: string }).catch(() => { }) ?? []
                    var number = isNaN(Number(word)) ? 0 : Number(word) <= 0 ? 0 : Number(word) >= urls.length - 1 ? urls.length - 1 : Math.round(Number(word)) || 0
                    return urls[number] ?? ''
                },
            },

            command: {
                helpf: "(name | arguments)",

                desc: `Allows you to execute any command!`,

                func: async (matches, msg, _, string) => {
                    var f = matches[0]
                    var word = matches[1]

                    var commandMatch = string.match(new RegExp(`${f}\\(([\\s\\S]*?)\\)`, 'ig'))
                    if (commandMatch ? commandMatch.length > commandLimit : false) return `Can't use the command function more than ${commandLimit} times.`
                    var split = splitKeyMod(word)
                    var commandname = (split[0] ?? '').toLowerCase()
                    var args = split.slice(1).length ? split.slice(1).join(' | ') : ''
                    var command = commands.find(fcmd => fcmd.name.find(fcmdname => fcmdname === commandname))
                    var localCommand = data()[mongodatabase]['guild-data'][msg.guild.id]['localcmds'].find(cmd => cmd.name === commandname)
                    var error = ''

                    if (data2[msg.guild.id][msg.channel.id]['shut']) return ''

                    if (data()[mongodatabase]['guild-data'][msg.guild.id]['members'][msg.author.id]['coolDown']) {
                        if ((data()[mongodatabase]['guild-data'][msg.guild.id]['members'][msg.author.id]['coolDown'] - Date.now()) > 0) {
                            return `Calm down! Wait more ${(data()[mongodatabase]['guild-data'][msg.guild.id]['members'][msg.author.id]['coolDown'] - Date.now()) / 1000} seconds.`
                        } else {
                            data()[mongodatabase]['guild-data'][msg.guild.id]['members'][msg.author.id]['coolDown'] = false
                        }
                    }

                    if (shit.find(id => id === msg.author.id)) {
                        return 'shit'
                    }

                    if (command || localCommand) {
                        if (data()[mongodatabase]['guild-data'][msg.guild.id]['disabled'].find(cmd => cmd.find(n => n === commandname))) {
                            msg.channel.send('This command is disabled in this server.').catch(() => { })
                        } else {
                            var msgclone = msg

                            msgclone.content = `${commandname} ${args}`

                            await getUrls(msgclone, {
                                string: args,
                                update: true
                            }).catch(err => msg.channel.send({
                                content: err.message,
                                allowedMentions: {
                                    parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            }).catch(() => { }))

                            if (command) {
                                if (command.cooldown) {
                                    data()[mongodatabase]['guild-data'][msg.guild.id]['members'][msg.author.id]['coolDown'] = (data()[mongodatabase]['guild-data'][msg.guild.id]['members'][msg.author.id]['coolDown'] || Date.now()) + command.cooldown / ((msg.member.permissions.has('MANAGE_GUILD') || msg.member.roles.cache.find(role => role.name.match(/mod|dev|admin|owner|creator|founder|staff/ig)) || msg.member.permissions.has('MANAGE_MESSAGES') || msg.member.permissions.has('ADMINISTRATOR') || msg.author.id === msg.guild.ownerID) && (command.type === 'Text' || command.type === 'Main') ? 5 : 1)
                                }

                                cps++
                                data()[mongodatabase]['bot-data']['bot']['commands']++
                                var t = setTimeout(() => {
                                    cps--;
                                    clearTimeout(t)
                                }, 1000)

                                infoPost(`Command \`${commandname}\` used`)
                                await command.execute(msgclone, [commandname].concat(args.split(' '))).catch(err => {
                                    error = err.stack
                                })
                                data()[mongodatabase]['bot-data']['bot']['filecount'] = filecount
                            } else if (localCommand) {
                                cps++
                                data()[mongodatabase]['bot-data']['bot']['commands']++
                                var t = setTimeout(() => {
                                    cps--;
                                    clearTimeout(t)
                                }, 60000)
                                infoPost(`Command \`${commandname}\` used`)
                                var phrase = await getKeywordsFor(localCommand.phrase, msg, true).catch(() => { }) ?? 'error'
                                data()[mongodatabase]['bot-data']['bot']['filecount'] = filecount
                                return phrase
                            }
                        }
                    } else {
                        return 'Invalid command.'
                    }

                    return error
                },

                attemptvalue: 10
            },

            hasperms: {
                helpf: "(id | perm1 | perm2 | perm3 | etc...)",

                desc: "Checks whether the user in the server with the respective ID has all the specified permissions or not. (a list of permissions can be found in https://discord.com/developers/docs/topics/permissions#permissions-bitwise-permission-flags)",

                func: async (matches, msg) => {
                    var word = matches[1]
                    var split = splitKeyMod(word)
                    var id = split[0] ?? ''
                    var perms = split.slice(1).length ? split.slice(1) : ''
                    var permlist = Discord.Permissions.FLAGS

                    for (var i in perms) {
                        var perm = perms[i]

                        if (!(permlist[perm])) {
                            return `Invalid permission: ${perm}`
                        }
                    }

                    var user = await msg.guild.members.fetch(id).catch(() => { })

                    if (user) {
                        for (var i in perms) {
                            var perm = perms[i]

                            if (!(user.permissions.has(perm))) {
                                return ''
                            }
                        }
                    } else {
                        return 'Invalid user ID.'
                    }

                    return 'true'
                },
            },

            filename: {
                helpf: "(url)",

                desc: `Fetches and returns the file name of the specified file.`,

                func: async (matches) => {
                    var word = matches[1]

                    var error
                    var fileinfo = await validateFile(word, 'very true').catch(err => {
                        error = err.stack
                    })
                    if (error) return error

                    return fileinfo.name
                },
            },

            filemime: {
                helpf: "(url)",

                desc: `Fetches and returns the file mime of the specified file.`,

                func: async (matches) => {
                    var word = matches[1]

                    var error
                    var fileinfo = await validateFile(word, 'very true').catch(err => {
                        error = err.stack
                    })
                    if (error) return error

                    return fileinfo.type.mime
                },
            },

            width: {
                helpf: "(url)",

                desc: `Fetches and returns the width of the specified file.`,

                func: async (matches) => {
                    var word = matches[1]

                    var error
                    var fileinfo = await validateFile(word, 'very true').catch(err => {
                        error = err.stack
                    })
                    if (error) return error

                    return fileinfo.info.width
                },
            },

            height: {
                helpf: "(url)",

                desc: `Fetches and returns the height of the specified file.`,

                func: async (matches) => {
                    var word = matches[1]

                    var error
                    var fileinfo = await validateFile(word, 'very true').catch(err => {
                        error = err.stack
                    })
                    if (error) return error

                    return fileinfo.info.height
                },
            },

            duration: {
                helpf: "(url)",

                desc: `Fetches and returns the duration of the specified file.`,

                func: async (matches) => {
                    var word = matches[1]

                    var error
                    var fileinfo = await validateFile(word, 'very true').catch(err => {
                        error = err.stack
                    })
                    if (error) return error

                    return fileinfo.info.duration
                },
            },

            aduration: {
                helpf: "(url)",

                desc: `Fetches and returns the audio duration of the specified file.`,

                func: async (matches) => {
                    var word = matches[1]

                    var error
                    var fileinfo = await validateFile(word, 'very true').catch(err => {
                        error = err.stack
                    })
                    if (error) return error

                    return fileinfo.info.aduration
                },
            },

            size: {
                helpf: "(url)",

                desc: `Fetches and returns the size of the specified file in bytes.`,

                func: async (matches) => {
                    var word = matches[1]

                    var error
                    var fileinfo = await validateFile(word, 'very true').catch(err => {
                        error = err.stack
                    })
                    if (error) return error

                    return fileinfo.info.realsize
                },
            },

            frames: {
                helpf: "(url)",

                desc: `Fetches the number of frames of the specified file.`,

                func: async (matches) => {
                    var word = matches[1]

                    var error
                    var fileinfo = await validateFile(word, 'very true').catch(err => {
                        error = err.stack
                    })
                    if (error) return error

                    return fileinfo.info.frames
                },
            },

            fps: {
                helpf: "(url)",

                desc: `Fetches the FPS of the specified file.`,

                func: async (matches) => {
                    var word = matches[1]

                    var error
                    var fileinfo = await validateFile(word, 'very true').catch(err => {
                        error = err.stack
                    })
                    if (error) return error

                    return fileinfo.info.fps
                },
            },

            audio: {
                helpf: "(url)",

                desc: `Checks whether the specified file has audio or not.`,

                func: async (matches) => {
                    var word = matches[1]

                    var error
                    var fileinfo = await validateFile(word, 'very true').catch(err => {
                        error = err.stack
                    })
                    if (error) return error

                    return fileinfo.info.audio || ''
                },
            },

            pixfmt: {
                helpf: "(url)",

                desc: `Fetches the pixel format of the specified file.`,

                func: async (matches) => {
                    var word = matches[1]

                    var error
                    var fileinfo = await validateFile(word, 'very true').catch(err => {
                        error = err.stack
                    })
                    if (error) return error

                    return fileinfo.info.pixfmt
                },
            }
        }
    }

    for (var key in special.keys) {
        if (poosonia && poosoniakeywordblacklist.find(keyname => keyname == key)) {
            delete special.keys[key]
        }
    }

    for (var func in special.functions) {
        if (poosonia && poosoniafunctionblacklist.find(funcname => funcname == func)) {
            delete special.functions[func]
        }
    }

    var chunkkeyfields = chunkObject(special.keys, 10)
    var keyfields = []

    for (var kg in chunkkeyfields) {
        var keygroup = chunkkeyfields[kg]
        keyfields[kg] = []
        for (var k in keygroup) {
            var key = keygroup[k]
            keyfields[kg].push({
                name: k,
                value: key.desc
            })
        }
    }

    var chunkfuncfields = chunkObject(special.functions, 10)
    var funcfields = []

    for (var fg in chunkfuncfields) {
        var funcgroup = chunkfuncfields[fg]
        funcfields[fg] = []
        for (var f in funcgroup) {
            var func = funcgroup[f]
            funcfields[fg].push({
                name: f + func.helpf,
                value: func.desc
            })
        }
    }
    var deadcommmands = ["dumpy", "twerkmosaic", "amongmosaic", "amongusmosaic", "crewmateamosaic", "tdumpy", "trollfaced", "trollfacedmosaic"]
    var commands = [
        {
            name: ["destroy", "kill", "shutdown"],
            execute: async function (msg) {
                var ownerid = ownerids.find(id => id == msg.author.id);
                if (ownerid === undefined) {
                    msg.channel.send('Owner only!').catch(() => { })
                    return
                } else {
                    msg.channel.send('The salami lid')
                        .then(() => {
                            bot.destroy()
                            process.exit()
                        })
                        .catch(() => { })
                };
            },
            help: {
                "name": "destroy/kill/shutdown",
                "value": "Causes Poopy to shutdown."
            },
            type: "Owner"
        },

        {
            name: ["reset", "restart", "reboot"],
            execute: async function (msg) {
                var ownerid = ownerids.find(id => id == msg.author.id);
                if (ownerid === undefined) {
                    msg.channel.send('Owner only!').catch(() => { })
                    return
                } else {
                    await msg.channel.send('The chorizo slice').catch(() => { })
                    clearInterval(statusInterval)
                    clearInterval(saveInterval)
                    bot.destroy()
                    delete data()[mongodatabase]
                    exec('node .')
                };
            },
            help: {
                "name": "reset/restart/reboot",
                "value": "Resets Poopy."
            },
            cooldown: 60000,
            type: "Owner"
        },

        {
            name: ["leave"],
            execute: async function (msg) {
                if (msg.member.permissions.has('MANAGE_GUILD') || msg.member.roles.cache.find(role => role.name.match(/dev|admin|owner|creator|founder|staff/ig)) || msg.member.permissions.has('MANAGE_WEBHOOKS') || msg.member.permissions.has('ADMINISTRATOR') || msg.author.id === msg.guild.ownerID || ownerids.find(id => id == msg.author.id)) {
                    var phrases = [
                        'idiot',
                        'the salt',
                        'why do you hate me',
                        'i could kill you',
                        'are you mentally disabled',
                        'ratio',
                        'now',
                        'the audacity',
                        'you like boys',
                        'bull',
                        'fat plumber mario',
                        'im crying',
                        'poopoo demon summoned',
                        'im out of ass',
                        'the poopening has begun',
                        'scrotum cancer alert',
                        'stop',
                        'chance of meatballs',
                        'the poopy boss has spawned',
                        `you had one shot ${(msg.member.nickname || msg.author.username).toLowerCase()}`,
                        'this is my undertale',
                        'i hate the antichrist',
                        'not the minors',
                        'i can cut your body',
                        'things i shoved up my arse',
                        'negro',
                        'what is the true meaning of nr n',
                        'brought oil',
                        'father figure',
                        '<https://pikmin3.nintendo.com/buy-now/>',
                        `<@${msg.author.id}>`,
                        'cum sock',
                        'quesadilla',
                        'pig',
                        'youve missed the chance to try crab rice',
                        'mug',
                        ''
                    ]
                    var confirm = await yesno(msg.channel, 'are you sure about this', msg.member.id).catch(() => { })

                    if (confirm) {
                        await msg.channel.send(phrases[Math.floor(Math.random() * phrases.length)]).catch(() => { })
                        msg.guild.leave().catch(() => { })
                    }
                } else {
                    msg.channel.send('You need to be an admin to execute that!').catch(() => { })
                    return
                }
            },
            help: {
                "name": "leave (admin only)",
                "value": "good"
            },
            perms: ["ADMINISTRATOR"],
            type: "Annoying"
        },

        {
            name: ["shutup"],
            execute: async function (msg, args) {
                if (msg.member.permissions.has('MANAGE_GUILD') || msg.member.roles.cache.find(role => role.name.match(/dev|admin|owner|creator|founder|staff/ig)) || msg.member.permissions.has('MANAGE_WEBHOOKS') || msg.member.permissions.has('ADMINISTRATOR') || msg.author.id === msg.guild.ownerID || ownerids.find(id => id == msg.author.id)) {
                    if (data2[msg.guild.id][msg.channel.id]['shut']) return

                    var duration = isNaN(Number(args[1])) ? 10 : Number(args[1]) >= 60 ? 60 : Number(args[1]) ?? 10

                    msg.channel.send('i shit up').catch(() => { })
                    data2[msg.guild.id][msg.channel.id]['shut'] = true
                    await sleep(duration * 1000)
                    data2[msg.guild.id][msg.channel.id]['shut'] = false
                    msg.channel.send('i came back').catch(() => { })
                } else {
                    msg.channel.send('You need to be an admin to execute that!').catch(() => { })
                    return
                }
            },
            help: {
                "name": "<:newpoopy:839191885310066729> shutup [duration (max 60)] (admin only)",
                "value": "he shuts up"
            },
            perms: ["ADMINISTRATOR"],
            type: "Annoying"
        },

        {
            name: ["invite"],
            execute: async function (msg) {
                msg.channel.sendTyping().catch(() => { })
                msg.channel.send(`Bot invite link: https://discord.com/oauth2/authorize?client_id=${bot.user.id}&scope=bot&permissions=275415166152\nOfficial Discord server link: https://discord.gg/R4nEBP5Ymf`).catch(() => { })
                msg.channel.sendTyping().catch(() => { })
            },
            help: {
                "name": "invite",
                "value": "Sends Poopy's invite and Discord server links."
            },
            cooldown: 2500,
            type: "Main"
        },

        {
            name: ["impostor", "imposter", "sus"],
            execute: async function (msg, args) {
                if (msg.member.permissions.has('MANAGE_GUILD') || msg.member.roles.cache.find(role => role.name.match(/mod|dev|admin|owner|creator|founder|staff/ig)) || msg.member.permissions.has('MANAGE_WEBHOOKS') || msg.member.permissions.has('ADMINISTRATOR') || msg.author.id === msg.guild.ownerID || ownerids.find(id => id == msg.author.id)) {
                    if (!msg.mentions.members.size) {
                        var user = args[1]
                        if (args[1] === undefined) {
                            user = msg.author.id
                        }

                        async function getUser(id) {
                            await msg.guild.members.fetch(id)
                                .then(function (user) {
                                    if (!data()[mongodatabase]['guild-data'][msg.guild.id]) {
                                        data()[mongodatabase]['guild-data'][msg.guild.id] = {}
                                    }
                                    if (!data()[mongodatabase]['guild-data'][msg.guild.id]['members'][user.id]) {
                                        data()[mongodatabase]['guild-data'][msg.guild.id]['members'][user.id] = {}
                                    }
                                    if (!data()[mongodatabase]['guild-data'][msg.guild.id]['members'][user.id]['impostor']) {
                                        data()[mongodatabase]['guild-data'][msg.guild.id]['members'][user.id]['impostor'] = false
                                    }
                                    if (data()[mongodatabase]['guild-data'][msg.guild.id]['members'][user.id]['impostor'] === false) {
                                        data()[mongodatabase]['guild-data'][msg.guild.id]['members'][user.id]['impostor'] = true
                                        msg.channel.send({
                                            content: user.user.username + ' is now the Impostor.',
                                            allowedMentions: {
                                                parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                            }
                                        }).catch(() => { })
                                    } else {
                                        data()[mongodatabase]['guild-data'][msg.guild.id]['members'][user.id]['impostor'] = false
                                        msg.channel.send({
                                            content: user.user.username + ' is not the Impostor.',
                                            allowedMentions: {
                                                parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                            }
                                        }).catch(() => { })
                                    }
                                })
                                .catch(function () {
                                    msg.channel.send({
                                        content: 'Invalid user ID: **' + user + '**',
                                        allowedMentions: {
                                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                        }
                                    }).catch(() => { })
                                })
                        }

                        getUser(user)
                    } else {
                        if (!data()[mongodatabase]['guild-data'][msg.guild.id]) {
                            data()[mongodatabase]['guild-data'][msg.guild.id] = {}
                        }
                        if (!data()[mongodatabase]['guild-data'][msg.guild.id]['members'][msg.mentions.members.first().id]) {
                            data()[mongodatabase]['guild-data'][msg.guild.id]['members'][msg.mentions.members.first().id] = {}
                        }
                        if (!data()[mongodatabase]['guild-data'][msg.guild.id]['members'][msg.mentions.members.first().id]['impostor']) {
                            data()[mongodatabase]['guild-data'][msg.guild.id]['members'][msg.mentions.members.first().id]['impostor'] = false
                        }
                        if (data()[mongodatabase]['guild-data'][msg.guild.id]['members'][msg.mentions.members.first().id]['impostor'] === false) {
                            data()[mongodatabase]['guild-data'][msg.guild.id]['members'][msg.mentions.members.first().id]['impostor'] = true
                            msg.channel.send({
                                content: msg.mentions.members.first().user.username + ' is now the Impostor.',
                                allowedMentions: {
                                    parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            }).catch(() => { })
                        } else {
                            data()[mongodatabase]['guild-data'][msg.guild.id]['members'][msg.mentions.members.first().id]['impostor'] = false
                            msg.channel.send({
                                content: msg.mentions.members.first().user.username + ' is not the Impostor.',
                                allowedMentions: {
                                    parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            }).catch(() => { })
                        }
                    }
                }
                else {
                    msg.channel.send('You need to have the manage webhooks permission to execute that!').catch(() => { })
                    return;
                };
            },
            help: {
                "name": "impostor/imposter/sus [user] (manage webhooks permission only)",
                "value": "Trap someone in the impostor forcefully"
            },
            cooldown: 2500,
            perms: ["ADMINISTRATOR", "MANAGE_WEBHOOKS"],
            type: "Webhook"
        },

        {
            name: ["toggledms", "tdms"],
            execute: async function (msg) {
                if (!data()[mongodatabase]['user-data'][msg.author.id]) {
                    data()[mongodatabase]['user-data'][msg.author.id] = {}
                }
                if (data()[mongodatabase]['user-data'][msg.author.id]['dms'] === undefined) {
                    data()[mongodatabase]['user-data'][msg.author.id]['dms'] = false
                }
                if (data()[mongodatabase]['user-data'][msg.author.id]['dms'] === false) {
                    data()[mongodatabase]['user-data'][msg.author.id]['dms'] = true
                    msg.channel.send({
                        content: 'Unrelated DMs from `dm` will **be sent** to you now.',
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                } else {
                    data()[mongodatabase]['user-data'][msg.author.id]['dms'] = false
                    msg.channel.send({
                        content: 'Unrelated DMs from `dm` will **not be sent** to you now.',
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                }
            },
            help: {
                "name": "toggledms/tdms",
                "value": "Disables/enables Poopy's ability to send you DMs through the `dm` command."
            },
            cooldown: 2500,
            type: "Settings"
        },

        {
            name: ["webhook", "customhook", "customwebhook"],
            execute: async function (msg, args) {
                if (msg.member.permissions.has('MANAGE_WEBHOOKS') || msg.member.permissions.has('ADMINISTRATOR') || msg.member.permissions.has('MANAGE_GUILD') || msg.member.roles.cache.find(role => role.name.match(/mod|dev|admin|owner|creator|founder|staff/ig)) || msg.author.id === msg.guild.ownerID || ownerids.find(id => id == msg.author.id)) {
                    var user = args[1]
                    if (args[1] === undefined || (args[1] ? (args[1].startsWith('"') || validUrl.test(args[1])) : false)) {
                        user = msg.author.id
                    }
                    var userMention = msg.mentions.members.first()

                    if (!userMention) {
                        async function getUser(id) {
                            await msg.guild.members.fetch(id)
                                .then(async function (user) {
                                    if (!data()[mongodatabase]['guild-data'][msg.guild.id]) {
                                        data()[mongodatabase]['guild-data'][msg.guild.id] = {}
                                    }
                                    if (!data()[mongodatabase]['guild-data'][msg.guild.id]['members'][user.id]) {
                                        data()[mongodatabase]['guild-data'][msg.guild.id]['members'][user.id] = {}
                                    }
                                    if (!data()[mongodatabase]['guild-data'][msg.guild.id]['members'][user.id]['custom']) {
                                        data()[mongodatabase]['guild-data'][msg.guild.id]['members'][user.id]['custom'] = false
                                    }
                                    if (data()[mongodatabase]['guild-data'][msg.guild.id]['members'][user.id]['custom'] === false) {
                                        var saidMessage = args.join(' ').substring(args[0].length + 1)
                                        var symbolReplacedMessage
                                        symbolreplacements.forEach(symbolReplacement => {
                                            symbolReplacement.target.forEach(target => {
                                                symbolReplacedMessage = saidMessage.replace(new RegExp(target, 'ig'), symbolReplacement.replacement)
                                            })
                                        })
                                        var matchedTextes = symbolReplacedMessage.match(/"([\s\S]*?)"/)
                                        if (!matchedTextes) {
                                            msg.channel.send('Where\'s the name?!').catch(() => { })
                                            return
                                        }
                                        if (!validUrl.test(args[args.length - 1])) {
                                            msg.channel.send('Where\'s the avatar?!').catch(() => { })
                                            return
                                        }
                                        var name = matchedTextes[1]
                                        var allBlank = true

                                        for (var i = 0; i < name.length; i++) {
                                            var letter = name[i]
                                            if (letter !== ' ') {
                                                allBlank = false
                                            }
                                        }

                                        if (allBlank) {
                                            msg.channel.send('Invalid name.').catch(() => { })
                                            return
                                        }
                                        var fetchAvatar = await axios.request({
                                            url: args[args.length - 1],
                                            responseType: 'stream'
                                        }).catch(() => { })
                                        if (!fetchAvatar) {
                                            msg.channel.send('Invalid avatar.').catch(() => { })
                                            return
                                        }
                                        var avatarFiletype = await fileType.fromStream(fetchAvatar.data).catch(() => { })
                                        if (!avatarFiletype) {
                                            msg.channel.send('Invalid avatar.').catch(() => { })
                                            return
                                        }
                                        if (!(avatarFiletype.mime.startsWith('image'))) {
                                            msg.channel.send('Invalid avatar.').catch(() => { })
                                            return
                                        }
                                        var avatar = args[args.length - 1]

                                        data()[mongodatabase]['guild-data'][msg.guild.id]['members'][user.id]['custom'] = {
                                            name: allBlank ? '‚†Ä' : name,
                                            avatar: avatar
                                        }
                                        msg.channel.send({
                                            content: user.user.username + ` is now ${name}.`,
                                            allowedMentions: {
                                                parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                            }
                                        }).catch(() => { })
                                    } else {
                                        msg.channel.send({
                                            content: user.user.username + ` is not ${data()[mongodatabase]['guild-data'][msg.guild.id]['members'][user.id]['custom']['name']}.`,
                                            allowedMentions: {
                                                parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                            }
                                        }).catch(() => { })
                                        data()[mongodatabase]['guild-data'][msg.guild.id]['members'][user.id]['custom'] = false
                                    }
                                })
                                .catch(function () {
                                    msg.channel.send({
                                        content: 'Invalid user ID: **' + user + '**',
                                        allowedMentions: {
                                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                        }
                                    }).catch(() => { })
                                })
                        }

                        getUser(user)
                    } else {
                        if (!data()[mongodatabase]['guild-data'][msg.guild.id]) {
                            data()[mongodatabase]['guild-data'][msg.guild.id] = {}
                        }
                        if (!data()[mongodatabase]['guild-data'][msg.guild.id]['members'][userMention.id]) {
                            data()[mongodatabase]['guild-data'][msg.guild.id]['members'][userMention.id] = {}
                        }
                        if (!data()[mongodatabase]['guild-data'][msg.guild.id]['members'][userMention.id]['custom']) {
                            data()[mongodatabase]['guild-data'][msg.guild.id]['members'][userMention.id]['custom'] = false
                        }
                        if (data()[mongodatabase]['guild-data'][msg.guild.id]['members'][userMention.id]['custom'] === false) {
                            var saidMessage = args.join(' ').substring(args[0].length + 1)
                            var symbolReplacedMessage
                            symbolreplacements.forEach(symbolReplacement => {
                                symbolReplacement.target.forEach(target => {
                                    symbolReplacedMessage = saidMessage.replace(new RegExp(target, 'ig'), symbolReplacement.replacement)
                                })
                            })
                            var matchedTextes = symbolReplacedMessage.match(/"([\s\S]*?)"/)
                            if (!matchedTextes) {
                                msg.channel.send('Where\'s the name?!').catch(() => { })
                                return
                            }
                            if (!validUrl.test(args[args.length - 1])) {
                                msg.channel.send('Where\'s the avatar?!').catch(() => { })
                                return
                            }
                            var name = matchedTextes[1]
                            var fetchAvatar = await axios.request({
                                url: args[args.length - 1],
                                responseType: 'stream'
                            }).catch(() => { })
                            if (!fetchAvatar) {
                                msg.channel.send('Invalid avatar.').catch(() => { })
                                return
                            }
                            var avatarFiletype = await fileType.fromStream(fetchAvatar.data).catch(() => { })
                            if (!avatarFiletype) {
                                msg.channel.send('Invalid avatar.').catch(() => { })
                                return
                            }
                            if (!(avatarFiletype.mime.startsWith('image'))) {
                                msg.channel.send('Invalid avatar.').catch(() => { })
                                return
                            }
                            var avatar = args[args.length - 1]

                            data()[mongodatabase]['guild-data'][msg.guild.id]['members'][userMention.id]['custom'] = {
                                name: name,
                                avatar: avatar
                            }
                            msg.channel.send({
                                content: userMention.user.username + ` is now ${name}.`,
                                allowedMentions: {
                                    parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            }).catch(() => { })
                        } else {
                            msg.channel.send({
                                content: userMention.user.username + ` is not ${data()[mongodatabase]['guild-data'][msg.guild.id]['members'][user.id]['custom']['name']}.`,
                                allowedMentions: {
                                    parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            }).catch(() => { })
                            data()[mongodatabase]['guild-data'][msg.guild.id]['members'][userMention.id]['custom'] = false
                        }
                    }
                } else {
                    msg.channel.send('You need to have the manage webhooks permission to execute that!').catch(() => { })
                    return;
                };
            },
            help: {
                "name": "webhook/customhook/customwebhook [user] \"<text>\" <image> (manage webhooks permission only)",
                "value": "Turns someone into the webhook you specified."
            },
            cooldown: 2500,
            perms: ["ADMINISTRATOR", "MANAGE_WEBHOOKS"],
            type: "Webhook"
        },

        {
            name: ["say", "talk", "speak"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                var del = true
                var deleteIndex = args.indexOf('-nodelete')
                if (deleteIndex > -1) {
                    args.splice(deleteIndex, 1)
                    del = false
                }
                var tts = false
                var ttsIndex = args.indexOf('-tts')
                if (ttsIndex > -1) {
                    args.splice(ttsIndex, 1)
                    tts = true
                }
                var saidMessage = args.join(' ').substring(args[0].length + 1)
                var attachments = []
                msg.attachments.forEach(attachment => {
                    attachments.push(new Discord.MessageAttachment(attachment.url))
                });
                if (args[1] === undefined && attachments.length <= 0) {
                    msg.channel.send('What is the message to say?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var sendObject = {
                    allowedMentions: {
                        parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                    },
                    files: attachments,
                    tts: (msg.member.permissions.has('ADMINISTRATOR') || msg.member.permissions.has('SEND_TTS_MESSAGES') || msg.author.id === msg.guild.ownerID) && tts
                }
                if (saidMessage) {
                    sendObject.content = saidMessage
                }
                var reply = await msg.fetchReference().catch(() => { })
                if (reply) {
                    await reply.reply(sendObject).catch(() => { })
                } else {
                    await msg.channel.send(sendObject).catch(() => { })
                }
                if (del) {
                    msg.delete().catch(() => { })
                }
                msg.channel.sendTyping().catch(() => { })
            },
            help: {
                "name": "say/talk/speak <message> [-nodelete] [-tts]",
                "value": "Poopy says the message after the command."
            },
            cooldown: 2500,
            type: "Main"
        },

        {
            name: ["fetchurls", "geturls"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                var attachments = []
                msg.attachments.forEach(attachment => {
                    attachments.push(new Discord.MessageAttachment(attachment.url))
                });
                if (args[1] === undefined && attachments.length <= 0) {
                    msg.channel.send('What are the URLs to fetch?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var urls = await getUrls(msg).catch(() => { }) ?? []
                await msg.channel.send({
                    allowedMentions: {
                        parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                    },
                    content: urls.join('\n') || 'No URLs fetched.'
                }).catch(() => { })
                msg.channel.sendTyping().catch(() => { })
            },
            help: {
                "name": "<:newpoopy:839191885310066729> fetchurls/geturls <message> [-nodelete] [-tts]",
                "value": "Fetches the file URLs in the message and returns them."
            },
            cooldown: 2500,
            type: "Fetching"
        },

        {
            name: ["brainfuck", "bf"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                var saidMessage = args.join(' ').substring(args[0].length + 1)
                if (args[1] === undefined) {
                    msg.channel.send('What is the code to compile?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var compiled = await brainfuck(saidMessage)
                await msg.channel.send({
                    content: compiled || '‚Äã',
                    allowedMentions: {
                        parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                    }
                }).catch(() => { })
                msg.channel.sendTyping().catch(() => { })
            },
            help: {
                "name": "brainfuck/bf <code>",
                "value": "Compiles the Brainfuck code supplied."
            },
            cooldown: 2500,
            type: "Text"
        },

        {
            name: ["stroke", "gibberish"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                var saidMessage = args.join(' ').substring(args[0].length + 1)
                if (args[1] === undefined) {
                    msg.channel.send('What is the message?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                msg.channel.send({
                    content: gibberish(saidMessage),
                    allowedMentions: {
                        parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                    }
                }).catch(() => { })
                msg.channel.sendTyping().catch(() => { })
            },
            help: {
                "name": "stroke/gibberish <message>",
                "value": "teral stroket  kknerhxtiarhxtlo k"
            },
            cooldown: 2500,
            type: "Text"
        },

        {
            name: ["tobrainfuck", "tobf"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                var saidMessage = args.join(' ').substring(args[0].length + 1)
                if (args[1] === undefined) {
                    msg.channel.send('What is the message to convert?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                msg.channel.send({
                    content: tobrainfuck(saidMessage),
                    allowedMentions: {
                        parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                    }
                }).catch(async () => {
                    var currentcount = filecount
                    filecount++
                    var filepath = `temp/file${currentcount}`
                    fs.mkdirSync(`${filepath}`)
                    fs.writeFileSync(`${filepath}/tobrainfuck.txt`, tobrainfuck(saidMessage))
                    await msg.channel.send({
                        files: [new Discord.MessageAttachment(`${filepath}/tobrainfuck.txt`)]
                    }).catch(() => { })
                    fs.rmSync(`${filepath}`, { force: true, recursive: true })
                })
                msg.channel.sendTyping().catch(() => { })
            },
            help: {
                "name": "tobrainfuck/tobf <message>",
                "value": "Converts the message into Brainfuck."
            },
            cooldown: 2500,
            type: "Text"
        },

        {
            name: ["weirdcore", "text2img", "text2image", "t2i"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                var saidMessage = args.join(' ').substring(args[0].length + 1)
                if (args[1] === undefined) {
                    msg.channel.send('What is the text?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                }
                if (validUrl.test(saidMessage)) {
                    msg.channel.send('URLs in this command will break it.').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
                var resp = await deepai.callStandardApi("text2img", {
                    text: saidMessage,
                }).catch(err => {
                    msg.channel.send({
                        content: err.stack,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                })
                if (resp) {
                    msg.channel.send({
                        files: [new Discord.MessageAttachment(resp.output_url)]
                    }).catch(() => { })
                }
                msg.channel.sendTyping().catch(() => { })
            },
            help: {
                "name": "weirdcore/text2img/text2image/t2i <message>",
                "value": "Generates a picture depending on what the text is. Can look eerie sometimes."
            },
            cooldown: 2500,
            type: "Generation"
        },

        /*{
            name: ["burningtext", "firetext"],
            execute: async function (msg, args) {
                function waitForAttributeValueNot(element, attribute, value) {
                    return function () {
                        return element.getAttribute(attribute).then(result => {
                            return result !== value;
                        });
                    };
                }
    
                msg.channel.sendTyping().catch(() => { })
                var saidMessage = args.join(' ').substring(args[0].length + 1)
                if (args[1] === undefined) {
                    msg.channel.send('What is the text?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                }
                var currentcount = filecount
                filecount++
                fs.mkdirSync(`${filepath}`)
                await waitForChromeSessionEnd(msg)
                var driver = await new Builder().forBrowser('chrome').setChromeOptions(new chrome.Options().setUserPreferences({ "download.default_directory": testing ? `${__dirname}\\temp\\file${currentcount}` : `${__dirname.replace(/\\/g, '/')}/${filepath}` })).build().catch(() => { })
                chromeWindow = driver
                await driver.get('https://cooltext.com/Logo-Design-Burning').catch(() => { })
                var Text = await driver.findElement(By.id('Text')).catch(() => { })
                var PreviewImage = await driver.findElement(By.id('PreviewImage')).catch(() => { })
                var defaultImage = await PreviewImage.getAttribute('src').catch(() => { })
                await Text.clear().catch(() => { })
                await Text.sendKeys(saidMessage).catch(() => { })
                await driver.wait(waitForAttributeValueNot(PreviewImage, 'src', defaultImage), 600000).catch(() => { })
                var RenderButton = await driver.findElement(By.css('input[id="RenderButton"]')).catch(() => { })
                await RenderButton.click().catch(() => { })
                await driver.wait(until.titleIs('Generated Image')).catch(() => { })
                var Download = await driver.findElement(By.css('a[title="Download"]')).catch(() => { })
                await Download.click().catch(() => { })
                await sleep(10000)
                await driver.quit().catch(() => { })
                chromeWindow = false
                var files = fs.readdirSync(`${filepath}`)
                var file = files.find(f => f.includes('cooltext'))
                try {
                    fs.renameSync(`${filepath}/${file}`, `${filepath}/output.gif`)
                } catch (_) {
                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    fs.rmSync(`${filepath}`, { force: true, recursive: true })
                    return
                }
                var fileMsg = await msg.channel.send({
                    files: [new Discord.MessageAttachment(`${filepath}/output.gif`)]
                }).catch(() => { })
                if (!fileMsg) {
                    await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                    var fileLink = await Catbox.upload(`${filepath}/output.gif`).catch(() => { })
                    if (fileLink) {
                        var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                        if (!fileLinkMsg) {
                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                        }
                    } else {
                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                    }
                }
                msg.channel.sendTyping().catch(() => { })
                fs.rmSync(`${filepath}`, { force: true, recursive: true })
            },
            help: {
                "name": "burningtext/firetext <text>",
                "value": "Generates a burning text. (powered by https://cooltext.com/)"
            },
            type: "Manipulation"
        },
    
        {
            name: ["intro"],
            execute: async function (msg, args) {
                function waitForNoAttribute(element, attribute) {
                    return function () {
                        return element.getAttribute(attribute) === undefined
                    };
                }
    
                function waitForAttributeValue(element, attribute, value) {
                    return function () {
                        return element.getAttribute(attribute).then(result => {
                            return result === value;
                        });
                    };
                }
    
                var intros = [
                    'https://introcave.com/intro/274/neon-city-text',
                    'https://introcave.com/intro/1/beauty',
                    'https://introcave.com/intro/14/fashion-intro',
                    'https://introcave.com/intro/57/quick-break-title',
                    'https://introcave.com/intro/171/comic-book-impact-text',
                    'https://introcave.com/intro/175/weight-training-v1-text',
                    'https://introcave.com/intro/177/weight-training-v2-text',
                    'https://introcave.com/intro/193/military-gaming-text',
                    'https://introcave.com/intro/209/vhs-glitch-text',
                    'https://introcave.com/intro/210/sports-arena-text',
                    'https://introcave.com/intro/240/epic-fire-text',
                    'https://introcave.com/intro/254/energy-burst-text',
                    'https://introcave.com/intro/282/liquid-text',
                    'https://introcave.com/intro/69/earth-revolve-text',
                    'https://introcave.com/intro/74/breaking-news-red',
                    'https://introcave.com/intro/139/cosmic-text',
                    'https://introcave.com/intro/144/laser-circuit-text',
                    'https://introcave.com/intro/133/outrun-car-text',
                    'https://introcave.com/intro/205/neon-sign-text',
                    'https://introcave.com/intro/288/short-glitch-text'
                ]
    
                msg.channel.sendTyping().catch(() => { })
                var saidMessage = args.join(' ').substring(args[0].length + 1).substring(0, 50)
                if (args[1] === undefined) {
                    msg.channel.send('What is the text?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                }
                var currentcount = filecount
                filecount++
                fs.mkdirSync(`${filepath}`)
                await waitForChromeSessionEnd(msg)
                var introProcessing = await msg.channel.send(`Processing, do notice this will take ${Math.floor(Math.random() * 14041) + 104} minutes to complete (it won't but you get the idea, it takes long)`).catch(() => { })
                var driver = await new Builder().forBrowser('chrome').setChromeOptions(new chrome.Options().setUserPreferences({ "download.default_directory": testing ? `${__dirname}\\temp\\file${currentcount}` : `${__dirname.replace(/\\/g, '/')}/${filepath}` })).build().catch(() => { })
                chromeWindow = driver
                await driver.get(intros[Math.floor(Math.random() * intros.length)]).catch(() => { })
                var customizeIntro = await driver.findElement(By.id('customizeIntro')).catch(() => { })
                await customizeIntro.click().catch(() => { })
                await sleep(500)
                var step0 = await driver.findElement(By.id('step0')).catch(() => { })
                await driver.wait(waitForNoAttribute(step0, 'style'), 60000).catch(() => { })
                await sleep(500)
                var textes = await driver.findElements(By.css('.form-control.textReplacement')).catch(() => { })
                var nextes = await driver.findElements(By.css('.pull-right.nextStepButton')).catch(() => { })
                for (var i in nextes) {
                    var next = nextes[i]
                    for (var j in textes) {
                        var text = textes[j]
                        await text.sendKeys(saidMessage).catch(() => { })
                        await sleep(100)
                    }
                    await next.click().catch(() => { })
                    await sleep(500)
                }
                var submit = await driver.findElement(By.id('submitCustomizationsButton')).catch(() => { })
                await submit.click().catch(() => { })
                await sleep(500)
                var progress = await driver.findElement(By.css('.progress-bar.progress-bar-striped.active')).catch(() => { })
                await driver.wait(waitForAttributeValue(progress, 'style', 'min-width: 10em; width: 100%;'), 600000).catch(() => { })
                await sleep(500)
                var videoSrc = await driver.findElement(By.id('previewVideoSrc')).catch(() => { })
                var src = await videoSrc.getAttribute('src').catch(() => { })
                await driver.quit().catch(() => { })
                chromeWindow = false
    
                var writeStream = fs.createWriteStream(`${filepath}/output.mp4`)
    
                require(src.startsWith('https') ? 'https' : 'http').get(src, (response) => {
                    response.pipe(writeStream)
                    writeStream.on('finish', async () => {
                        if (!introProcessing.deleted) introProcessing.delete().catch(() => { })
                        var fileMsg = await msg.channel.send({
                            files: [new Discord.MessageAttachment(`${filepath}/output.mp4`)]
                        }).catch(() => { })
                        if (!fileMsg) {
                            await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                            var fileLink = await Catbox.upload(`${filepath}/output.mp4`).catch(() => { })
                            if (fileLink) {
                                var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                if (!fileLinkMsg) {
                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                }
                            } else {
                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                            }
                        }
                        msg.channel.sendTyping().catch(() => { })
                        fs.rmSync(`${filepath}`, { force: true, recursive: true })
                    })
                })
            },
            help: {
                "name": "intro <text>",
                "value": "Generates an intro with the text. (powered by https://introcave.com/)"
            },
            type: "Manipulation"
        },
    
        {
            name: ["banner", "advertisement"],
            execute: async function (msg, args) {
                var defaultbanner = 'https://auto.creavite.co/create/banner/Bright'
    
                var banners = [
                    'https://auto.creavite.co/create/banner/Fish',
                    'https://auto.creavite.co/create/banner/Flow',
                    'https://auto.creavite.co/create/banner/Falling%20Gems',
                    'https://auto.creavite.co/create/banner/Sparks',
                    'https://auto.creavite.co/create/banner/Paths',
                    'https://auto.creavite.co/create/banner/Highway',
                    'https://auto.creavite.co/create/banner/Fragments',
                    'https://auto.creavite.co/create/banner/Arc',
                    'https://auto.creavite.co/create/banner/Splash',
                    'https://auto.creavite.co/create/banner/Dash',
                    'https://auto.creavite.co/create/banner/Vesuvius',
                    'https://auto.creavite.co/create/banner/Bright',
                    'https://auto.creavite.co/create/banner/Triplet'
                ]
    
                msg.channel.sendTyping().catch(() => { })
                var hue = isNaN(Number(args[1])) ? 0 : Number(args[1]) <= 0 ? 0 : Number(args[1]) >= 360 ? 360 : Number(args[1]) || 0
                var saidMessage = args.join(' ').substring(args[0].length + 1)
                symbolreplacements.forEach(symbolReplacement => {
                    symbolReplacement.target.forEach(target => {
                        saidMessage = saidMessage.replace(new RegExp(target, 'ig'), symbolReplacement.replacement)
                    })
                })
                var dft = ['"NAH BRO"', '"PISS"', '"SHIT"', '"COME"', '"KILL YOURSELF"']
                var matchedTextes = saidMessage.match(/"([\s\S]*?)"/g)
                if (!matchedTextes) {
                    matchedTextes = dft
                } else {
                    for (var i in dft) {
                        var dfttext = dft[i]
                        var text = matchedTextes[i]
                        if (!text) {
                            matchedTextes[i] = dfttext
                        }
                    }
                }
                var name = matchedTextes[0].substring(1, matchedTextes[0].length - 1).substring(0, 50)
                var f1 = matchedTextes[1].substring(1, matchedTextes[1].length - 1).substring(0, 50)
                var f2 = matchedTextes[2].substring(1, matchedTextes[2].length - 1).substring(0, 50)
                var f3 = matchedTextes[3].substring(1, matchedTextes[3].length - 1).substring(0, 50)
                var f4 = matchedTextes[4].substring(1, matchedTextes[4].length - 1).substring(0, 50)
                var currentcount = filecount
                filecount++
                fs.mkdirSync(`${filepath}`)
                await waitForChromeSessionEnd(msg)
                var driver = await new Builder().forBrowser('chrome').setChromeOptions(new chrome.Options().setUserPreferences({ "download.default_directory": testing ? `${__dirname}\\temp\\file${currentcount}` : `${__dirname.replace(/\\/g, '/')}/${filepath}` })).build().catch(() => { })
                chromeWindow = driver
                await driver.get(args.find(arg => arg === '-random') ? banners[Math.floor(Math.random() * banners.length)] : defaultbanner).catch(() => { })
                var nametext = await driver.findElement(By.id('server-name')).catch(() => { })
                var iptext = await driver.findElement(By.id('server-ip')).catch(() => { })
                var f1text = await driver.findElement(By.id('feature-1')).catch(() => { })
                var f2text = await driver.findElement(By.id('feature-2')).catch(() => { })
                var f3text = await driver.findElement(By.id('feature-3')).catch(() => { })
                var f4text = await driver.findElement(By.id('feature-4')).catch(() => { })
                var hueslide = await driver.findElement(By.id('hue')).catch(() => { })
                var captcha = await driver.findElement(By.css('iframe[title="reCAPTCHA"]')).catch(() => { })
                var render = await driver.findElement(By.xpath("//button[contains(text(), 'Render')]")).catch(() => { })
                var rendererr
                driver.executeScript("document.getElementById('server-name').scrollIntoView()")
                await sleep(500)
                await nametext.sendKeys(name).catch(() => { })
                await sleep(100)
                await f1text.sendKeys(f1).catch(() => { })
                await sleep(100)
                await f2text.sendKeys(f2).catch(() => { })
                await sleep(100)
                await f3text.sendKeys(f3).catch(() => { })
                await sleep(100)
                await f4text.sendKeys(f4).catch(() => { })
                await sleep(100)
                if (iptext) {
                    await iptext.sendKeys(name).catch(() => { })
                    await sleep(100)
                }
                for (var i = 0; i < hue; i++) {
                    await hueslide.sendKeys(Key.RIGHT).catch(() => { })
                }
                await captcha.click().catch(() => { })
                await sleep(5000)
                await render.click().catch(err => rendererr = err)
                if (rendererr) {
                    await driver.quit().catch(() => { })
                    chromeWindow = false
                    fs.rmSync(`${filepath}`, { force: true, recursive: true })
                    msg.channel.send('i got owned by the captcha').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
                await driver.wait(until.urlIs('https://auto.creavite.co/renders'), 120000).catch(() => { })
                await sleep(500)
                var download = await driver.findElement(By.xpath("//a[contains(text(), 'Download')]")).catch(() => { })
                await download.click().catch(() => { })
                await sleep(5000)
                await driver.quit().catch(() => { })
                chromeWindow = false
                var files = fs.readdirSync(`${filepath}`)
                var file = files.find(f => f.includes('standard'))
                try {
                    fs.renameSync(`${filepath}/${file}`, `${filepath}/output.gif`)
                } catch (_) {
                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    fs.rmSync(`${filepath}`, { force: true, recursive: true })
                    return
                }
                var fileMsg = await msg.channel.send({
                    files: [new Discord.MessageAttachment(`${filepath}/output.gif`)]
                }).catch(() => { })
                if (!fileMsg) {
                    await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                    var fileLink = await Catbox.upload(`${filepath}/output.gif`).catch(() => { })
                    if (fileLink) {
                        var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                        if (!fileLinkMsg) {
                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                        }
                    } else {
                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                    }
                }
                msg.channel.sendTyping().catch(() => { })
                fs.rmSync(`${filepath}`, { force: true, recursive: true })
            },
            help: {
                "name": "banner/advertisement {hue} \"{name}\" \"{feature1}\" \"{feature2}\" \"{feature3}\" \"[feature4]\" [-random]",
                "value": "Generates a banner with all the text inputs provided. **THIS MIGHT NOT WORK MOST OF THE TIME.** (powered by https://auto.creavite.co/)"
            },
            type: "Manipulation"
        },*/

        {
            name: ["uberduck", "tts"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (args[1] === undefined) {
                    msg.channel.send('What is the voice?! A list can be found at https://uberduck.ai/quack-help').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                }
                if (args[2] === undefined) {
                    msg.channel.send('What is the text?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                }

                var saidVoice = args[1]
                var saidMessage = args.join(' ').substring(args[0].length + args[1].length + 2).replace(/'/g, '‚Äô').replace(/"/g, '\\"')

                var rejected = false
                var response = await axios.request({
                    method: 'POST',
                    url: 'https://api.uberduck.ai/speak-synchronous',
                    headers: {
                        Accept: 'audio/wav',
                        Authorization: `Basic ${btoa(`${process.env.UBERDUCKKEY}:${process.env.UBERDUCKSECRET}`)}`,
                        'Content-Type': 'application/json'
                    },
                    data: {
                        voice: saidVoice,
                        speech: saidMessage
                    },
                    responseType: 'arraybuffer'
                }).catch((err) => {
                    rejected = true
                    err.response.data = JSON.parse(err.response.data)
                    return err.response
                })

                if (rejected && response.data.detail) {
                    msg.channel.send(response.data.detail).catch(() => { })
                    return;
                }

                var filepath = await downloadFile(response.data, `output.mp3`, {
                    buffer: true,
                    convert: true
                })
                await sendFile(msg, filepath, `output.mp3`)
            },
            help: {
                "name": "uberduck/tts <voice> <text>",
                "value": "Generates a TTS synthesized speech with Uberduck AI. A list of voices can be found at https://uberduck.ai/quack-help"
            },
            type: "Generation"
        },

        /*{
            name: ["uberduckaudio", "uberduckmusic", "ttsaudio", "ttsmusic"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (args[1] === undefined) {
                    msg.channel.send('What is the voice?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                }
                if (args[2] === undefined) {
                    msg.channel.send('What is the reference audio?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                }
                if (args[3] === undefined) {
                    msg.channel.send('What is the text?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                }
                var saidVoice = args[1]
                var saidAudio = args[2]
                var saidMessage = args.join(' ').substring(args[0].length + args[1].length + 2).replace(/\\n/g, ' ')
                if (saidMessage.length < 3) {
                    msg.channel.send('Text must be longer than 3 digits.').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                }
                if (validUrl.test(saidAudio)) {
                    fetch(saidAudio)
                        .then(response => {
                            fileType.fromStream(response.body)
                                .then(async type => {
                                    var body = await response.text()
                                    if (body.length / 1048576 > 1) {
                                        msg.channel.send(`that file exceeds uberduck's size limit of 1 mb hahahaha`)
                                        msg.channel.sendTyping().catch(() => { })
                                        return;
                                    }
                                    if (type.mime.startsWith('audio')) {
                                        var currentcount = filecount
                                        filecount++
                                        fs.mkdirSync(`${filepath}`)
    
                                        var writeStream = fs.createWriteStream(`${filepath}/${filename}`)
    
                                        require(saidAudio.startsWith('https') ? 'https' : 'http').get(saidAudio, (response) => {
                                            response.pipe(writeStream)
                                            writeStream.on('finish', async () => {
                                                await waitForChromeSessionEnd(msg)
                                                var driver = await new Builder().forBrowser('chrome').setChromeOptions(new chrome.Options().setUserPreferences({ "download.default_directory": testing ? `${__dirname}\\temp\\file${currentcount}` : `${__dirname.replace(/\\/g, '/')}/${filepath}` })).build().catch(() => { })
                                                chromeWindow = driver
                bagd = driver
                                                await driver.get('https://uberduck.ai/').catch(() => { })
                                                await sleep(500)
                                                await driver.manage().addCookie({ name: '__Secure-next-auth.session-token', value: process.env.UBERDUCKTOKEN }).catch(() => { })
                                                await driver.navigate().refresh().catch(() => { })
                                                await sleep(1000)
                                                var audioMode = await driver.findElement(By.css('label[aria-label="Singing mode"]')).catch(() => { })
                                                await audioMode.click().catch(() => { })
                                                await sleep(500)
                                                var selectVoice = await driver.findElement(By.id('selectVoice')).catch(() => { })
                                                var showCustomAudio = await driver.findElement(By.xpath('//*[text()="Show"]')).catch(() => { })
                                                var textInput = await driver.findElement(By.id('synthesizeTextarea')).catch(() => { })
                                                var synthesize = await driver.findElement(By.xpath('//*[text()="Synthesize"]')).catch(() => { })
                                                await textInput.sendKeys(saidMessage).catch(() => { })
                                                await sleep(500)
                                                await selectVoice.click().catch(() => { })
                                                await sleep(2000)
                                                var voices = await driver.findElements(By.css('.select-voice__option')).catch(() => { })
                                                var voiceIndex
                                                for (var i in voices) {
                                                    var voice = voices[i]
                                                    var voiceName = await voice.getAttribute('innerText')
                                                    if (voiceName.replace(/\(.*\)| |\[|\]/g, '').toLowerCase().includes(saidVoice.toLowerCase())) {
                                                        voiceIndex = i
                                                        break
                                                    }
                                                }
                                                if (voiceIndex) {
                                                    var voice = voices[voiceIndex]
                                                    driver.executeScript(`var voices = document.querySelectorAll('.select-voice__option')\nvoices[${voiceIndex}].scrollIntoView()`)
                                                    await sleep(500)
                                                    await voice.click().catch(() => { })
                                                    await sleep(500)
                                                    await showCustomAudio.click().catch(() => { })
                                                    await sleep(500)
                                                    var uploadAudio = await driver.findElement(By.id('reference-file-upload')).catch(() => { })
                                                    await uploadAudio.sendKeys(`${__dirname.replace(/\\/g, '/')}/${filepath}/${filename}`).catch(() => { })
                                                    await sleep(500)
                                                    await synthesize.click().catch(() => { })
                                                    await driver.wait(async function () {
                                                        return await driver.findElement(By.xpath('//*[text()="Download"]')).catch(() => { })
                                                    }, 120000).catch(() => { })
                                                    var download = await driver.findElement(By.xpath('//*[text()="Download"]')).catch(() => { })
                                                    if (download) {
                                                        await download.click().catch(() => { })
                                                        await sleep(5000)
                                                        await driver.quit().catch(() => { })
                                                        chromeWindow = false
                                                        var files = fs.readdirSync(`${filepath}`)
                                                        var file = files.find(f => f.includes('audio'))
                                                        try {
                                                            fs.renameSync(`${filepath}/${file}`, `${filepath}/output.wav`)
                                                        } catch (_) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                            msg.channel.sendTyping().catch(() => { })
                                                            fs.rmSync(`${filepath}`, { force: true, recursive: true })
                                                            return
                                                        }
                                                        var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`${filepath}/output.wav`)).catch(() => { })
                                                        if (!fileMsg) {
                                                            await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                            var fileLink = await Catbox.upload(`${filepath}/output.wav`).catch(() => { })
                                                            if (fileLink) {
                                                                var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                                if (!fileLinkMsg) {
                                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                                }
                                                            } else {
                                                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                            }
                                                        }
                                                        msg.channel.sendTyping().catch(() => { })
                                                        fs.rmSync(`${filepath}`, { force: true, recursive: true })
                                                    } else {
                                                        await driver.quit().catch(() => { })
                                                        chromeWindow = false
                                                        msg.channel.send('Sorry, but your request failed.').catch(() => { })
                                                        msg.channel.sendTyping().catch(() => { })
                                                        fs.rmSync(`${filepath}`, { force: true, recursive: true })
                                                        return;
                                                    }
                                                } else {
                                                    await driver.quit().catch(() => { })
                                                    chromeWindow = false
                                                    msg.channel.send('Not a valid voice.').catch(() => { })
                                                    msg.channel.sendTyping().catch(() => { })
                                                    fs.rmSync(`${filepath}`, { force: true, recursive: true })
                                                    return;
                                                }
                                            })
                                        })
                                    } else {
                                        msg.channel.send(`Unsupported file: \`${saidAudio}\``, {
                                            allowedMentions: {
                                                parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                            }
                                        }).catch(() => { })
                                        msg.channel.sendTyping().catch(() => { })
                                        return
                                    }
                                })
                                .catch(() => {
                                    msg.channel.send(`Unsupported file: \`${saidAudio}\``, {
                                        allowedMentions: {
                                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                        }
                                    }).catch(() => { })
                                    msg.channel.sendTyping().catch(() => { })
                                    return
                                })
                        })
                        .catch(err => {
                            msg.channel.send({
                                content: err.stack,
                                allowedMentions: {
                                    parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                                }, {
                                allowedMentions: {
                                    parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            }).catch(() => { })
                            msg.channel.sendTyping().catch(() => { })
                            return
                        })
                } else {
                    var currentcount = filecount
                    filecount++
                    fs.mkdirSync(`${filepath}`)
                    await waitForChromeSessionEnd(msg)
                    var driver = await new Builder().forBrowser('chrome').setChromeOptions(new chrome.Options().setUserPreferences({ "download.default_directory": testing ? `${__dirname}\\temp\\file${currentcount}` : `${__dirname.replace(/\\/g, '/')}/${filepath}` })).build().catch(() => { })
                    chromeWindow = driver
                bagd = driver
                    await driver.get('https://uberduck.ai/').catch(() => { })
                    await sleep(500)
                    await driver.manage().addCookie({ name: '__Secure-next-auth.session-token', value: process.env.UBERDUCKTOKEN }).catch(() => { })
                    await driver.navigate().refresh().catch(() => { })
                    await sleep(1000)
                    var audioMode = await driver.findElement(By.css('label[aria-label="Singing mode"]')).catch(() => { })
                    await audioMode.click().catch(() => { })
                    await sleep(500)
                    var selectVoice = await driver.findElement(By.id('selectVoice')).catch(() => { })
                    var selectAudio = await driver.findElement(By.id('selectReferenceAudio')).catch(() => { })
                    var textInput = await driver.findElement(By.id('synthesizeTextarea')).catch(() => { })
                    var synthesize = await driver.findElement(By.xpath('//*[text()="Synthesize"]')).catch(() => { })
                    await selectVoice.click().catch(() => { })
                    await sleep(2000)
                    var voices = await driver.findElements(By.css('.select-voice__option')).catch(() => { })
                    var voiceIndex
                    for (var i in voices) {
                        var voice = voices[i]
                        var voiceName = await voice.getAttribute('innerText')
                        if (voiceName.replace(/\(.*\)| |\[|\]/g, '').toLowerCase().includes(saidVoice.toLowerCase())) {
                            voiceIndex = i
                            break
                        }
                    }
                    if (voiceIndex) {
                        var voice = voices[voiceIndex]
                        driver.executeScript(`var voices = document.querySelectorAll('.select-voice__option')\nvoices[${voiceIndex}].scrollIntoView()`)
                        await sleep(500)
                        await voice.click().catch(() => { })
                        await sleep(500)
                        await selectAudio.click().catch(() => { })
                        await sleep(2000)
                        var audios = await driver.findElements(By.css('.select-referenceaudio__option')).catch(() => { })
                        var audioIndex
                        for (var i in audios) {
                            var audio = audios[i]
                            var audioName = await audio.getAttribute('innerText')
                            if (audioName.replace(/\(.*\)| |\[|\]/g, '').toLowerCase().includes(saidAudio.toLowerCase())) {
                                audioIndex = i
                                break
                            }
                        }
                        if (audioIndex) {
                            await sleep(500)
                            await textInput.sendKeys(saidMessage).catch(() => { })
                            await sleep(500)
                            await synthesize.click().catch(() => { })
                            await driver.wait(async function () {
                                return await driver.findElement(By.xpath('//*[text()="Download"]')).catch(() => { })
                            }, 120000).catch(() => { })
                            var download = await driver.findElement(By.xpath('//*[text()="Download"]')).catch(() => { })
                            if (download) {
                                await download.click().catch(() => { })
                                await sleep(5000)
                                await driver.quit().catch(() => { })
                                chromeWindow = false
                                var files = fs.readdirSync(`${filepath}`)
                                var file = files.find(f => f.includes('audio'))
                                try {
                                    fs.renameSync(`${filepath}/${file}`, `${filepath}/output.wav`)
                                } catch (_) {
                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                    msg.channel.sendTyping().catch(() => { })
                                    fs.rmSync(`${filepath}`, { force: true, recursive: true })
                                    return
                                }
                                var fileMsg = await msg.channel.send(new Discord.MessageAttachment(`${filepath}/output.wav`)).catch(() => { })
                                if (!fileMsg) {
                                    await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                    var fileLink = await Catbox.upload(`${filepath}/output.wav`).catch(() => { })
                                    if (fileLink) {
                                        var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                        if (!fileLinkMsg) {
                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                        }
                                    } else {
                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                    }
                                }
                                msg.channel.sendTyping().catch(() => { })
                                fs.rmSync(`${filepath}`, { force: true, recursive: true })
                            } else {
                                await driver.quit().catch(() => { })
                                chromeWindow = false
                                msg.channel.send('Sorry, but your request failed.').catch(() => { })
                                msg.channel.sendTyping().catch(() => { })
                                fs.rmSync(`${filepath}`, { force: true, recursive: true })
                                return;
                            }
                        } else {
                            await driver.quit().catch(() => { })
                            chromeWindow = false
                            msg.channel.send('Not a valid reference audio.').catch(() => { })
                            msg.channel.sendTyping().catch(() => { })
                            fs.rmSync(`${filepath}`, { force: true, recursive: true })
                            return;
                        }
                    } else {
                        await driver.quit().catch(() => { })
                        chromeWindow = false
                        msg.channel.send('Not a valid voice.').catch(() => { })
                        msg.channel.sendTyping().catch(() => { })
                        fs.rmSync(`${filepath}`, { force: true, recursive: true })
                        return;
                    }
                }
            },
            help: {
                "name": "uberduckaudio/uberduckmusic/ttsaudio/ttsmusic <voice> <referenceaudio (text or url)> <text>",
                "value": "Generates TTS with Uberduck AI using the reference audio. (powered by https://uberduck.ai/)"
            },
            type: "Manipulation"
        },*/

        /*{
            name: ["badtranslate"],
            execute: async function (msg, args) {
                function waitForAttributeValueNot(element, attribute, value) {
                    return function () {
                        return element.getAttribute(attribute).then(result => {
                            return result !== value;
                        });
                    };
                }
    
                function waitForAttributeValue(element, attribute, value) {
                    return function () {
                        return element.getAttribute(attribute).then(result => {
                            return result === value;
                        });
                    };
                }
    
                async function clickLanguage(driver, l) {
                    driver.executeScript('window.scrollTo(0, 0)')
                    var error
                    var language = l || languages[Math.floor(Math.random() * languages.length)]
                    await language.click().catch(err => {
                        error = err
                    })
                    if (error) {
                        await clickLanguage(driver, l)
                    }
                }
    
                msg.channel.sendTyping().catch(() => { })
                var languagen = 5
                var languagesindex = args.indexOf('-languages')
                if (languagesindex > -1) {
                    languagen = isNaN(Number(args[languagesindex + 1])) ? 5 : Number(args[languagesindex + 1]) <= 1 ? 1 : Number(args[languagesindex + 1]) >= 5 ? 5 : Math.round(Number(args[languagesindex + 1])) || 5
                    args.splice(languagesindex, 2)
                }
                var saidMessage = args.join(' ').substring(args[0].length + 1)
                if (args[1] === undefined) {
                    msg.channel.send('What is the text?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                }
    
                await waitForChromeSessionEnd(msg)
                var driver = await new Builder().forBrowser('chrome').build().catch(() => { })
                chromeWindow = driver
                await driver.get('https://translate.google.com/?hl=en-EN').catch(() => { })
    
                if (testing) {
                    var agree = await driver.findElement(By.css('button[aria-label="Agree to the use of cookies and other data for the purposes described"]')).catch(() => { })
                    await agree.click().catch(() => { })
                }
    
                var sourcetext = await driver.findElement(By.css('textarea[jsname="BJE2fc"]')).catch(() => { })
                var swapbutton = await driver.findElement(By.css('button[jsname="dnDxad"]')).catch(() => { })
                var languagebutton = await driver.findElement(By.css('button[jsname="zumM6d"]')).catch(() => { })
                var menus = await driver.findElement(By.css('c-wiz[class="bvzp8c"]')).catch(() => { })
                var languages = await driver.findElements(By.css('div[class="ykTHSe"] div[class="pEyuac X4hZJc"] div[class="dykxn MeCBDd j33Gae"] div[class="vSUSRc"] div[class="F29iQc"] div[jsname="sgblj"][class="qSb8Pe"]')).catch(() => { })
    
                await sourcetext.sendKeys(saidMessage).catch(() => { })
                driver.executeScript('window.scrollTo(0, 0)')
    
                for (var i = 0; i < languagen; i++) {
                    await languagebutton.click().catch(() => { })
                    await driver.wait(waitForAttributeValueNot(menus, 'class', 'bvzp8c'), 1000).catch(() => { })
                    await sleep(500)
                    await clickLanguage(driver)
                    await sleep(1000)
                    driver.executeScript('window.scrollTo(0, 0)')
                    await swapbutton.click().catch(() => { })
                    await driver.wait(waitForAttributeValue(menus, 'class', 'bvzp8c'), 1000).catch(() => { })
                    await sleep(500)
                    driver.executeScript('window.scrollTo(0, 0)')
                }
    
                await languagebutton.click().catch(() => { })
                await driver.wait(waitForAttributeValueNot(menus, 'class', 'bvzp8c'), 1000).catch(() => { })
                await sleep(500)
                var english = await driver.findElement(By.css('div[class="ykTHSe"] div[class="pEyuac X4hZJc"] div[class="dykxn MeCBDd j33Gae"] div[class="vSUSRc"] div[class="F29iQc"] div[data-language-code="en"]')).catch(() => { })
                await clickLanguage(driver, english)
                await sleep(1000)
                driver.executeScript('window.scrollTo(0, 0)')
                await swapbutton.click().catch(() => { })
                await driver.wait(waitForAttributeValue(menus, 'class', 'bvzp8c'), 1000).catch(() => { })
                await sleep(500)
                driver.executeScript('window.scrollTo(0, 0)')
    
                var translation = await sourcetext.getAttribute('value').catch(() => { })
    
                await msg.channel.send(translation.replace(/nigg[\w\d]+ ?/ig, '')).catch(() => { })
    
                await driver.quit().catch(() => { })
                chromeWindow = false
                msg.channel.sendTyping().catch(() => { })
            },
            help: {
                "name": "badtranslate <text> [-languages <number (max 5)>]",
                "value": "Passes the text through multiple languages until it becomes a complete mess. Default number of languages is 5."
            },
            type: "Fun"
        },
    
        {
            name: ["verbose"],
            execute: async function (msg, args) {
                function waitForAttributeValueNot(element, attribute, value) {
                    return function () {
                        return element.getAttribute(attribute).then(result => {
                            return result !== value;
                        });
                    };
                }
    
                function waitForAttributeValue(element, attribute, value) {
                    return function () {
                        return element.getAttribute(attribute).then(result => {
                            return result === value;
                        });
                    };
                }
    
                msg.channel.sendTyping().catch(() => { })
                var saidMessage = args.join(' ').substring(args[0].length + 1)
                if (args[1] === undefined) {
                    msg.channel.send('What is the text?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                }
    
                await waitForChromeSessionEnd(msg)
                var driver = await new Builder().forBrowser('chrome').build().catch(() => { })
                chromeWindow = driver
                await driver.get('https://lingojam.com/UltimateVerboseGenerator').catch(() => { })
    
                var sourcetext = await driver.findElement(By.id('english-text')).catch(() => { })
                var targettext = await driver.findElement(By.id('ghetto-text')).catch(() => { })
    
                await sourcetext.clear().catch(() => { })
                await sourcetext.sendKeys(saidMessage).catch(() => { })
    
                await driver.wait(waitForAttributeValueNot(targettext, 'style', 'background-color: white; font-family: Arial; background-image: none;'), 1000).catch(() => { })
                await driver.wait(waitForAttributeValue(targettext, 'style', 'background-color: white; font-family: Arial; background-image: none;'), 1000).catch(() => { })
    
                await sleep(500)
    
                var translation = await targettext.getAttribute('value').catch(() => { })
    
                await msg.channel.send(translation).catch(() => { })
    
                await driver.quit().catch(() => { })
                chromeWindow = false
    
                msg.channel.sendTyping().catch(() => { })
            },
            help: {
                "name": "verbose <text>",
                "value": "Adds verbose to the text making it more complex."
            },
            type: "Fun"
        },
    
        {
            name: ["opposite"],
            execute: async function (msg, args) {
                function waitForAttributeValueNot(element, attribute, value) {
                    return function () {
                        return element.getAttribute(attribute).then(result => {
                            return result !== value;
                        });
                    };
                }
    
                function waitForAttributeValue(element, attribute, value) {
                    return function () {
                        return element.getAttribute(attribute).then(result => {
                            return result === value;
                        });
                    };
                }
    
                msg.channel.sendTyping().catch(() => { })
                var saidMessage = args.join(' ').substring(args[0].length + 1)
                if (args[1] === undefined) {
                    msg.channel.send('What is the text?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                }
    
                await waitForChromeSessionEnd(msg)
                var driver = await new Builder().forBrowser('chrome').build().catch(() => { })
                chromeWindow = driver
                await driver.get('https://lingojam.com/OppositeWordTranslator').catch(() => { })
    
                var sourcetext = await driver.findElement(By.id('english-text')).catch(() => { })
                var targettext = await driver.findElement(By.id('ghetto-text')).catch(() => { })
    
                await sourcetext.clear().catch(() => { })
                await sourcetext.sendKeys(saidMessage).catch(() => { })
    
                await driver.wait(waitForAttributeValueNot(targettext, 'style', 'background-color: white; font-family: Arial; background-image: none;'), 1000).catch(() => { })
                await driver.wait(waitForAttributeValue(targettext, 'style', 'background-color: white; font-family: Arial; background-image: none;'), 1000).catch(() => { })
    
                await sleep(500)
    
                var translation = await targettext.getAttribute('value').catch(() => { })
    
                await msg.channel.send(translation).catch(() => { })
    
                await driver.quit().catch(() => { })
                chromeWindow = false
    
                msg.channel.sendTyping().catch(() => { })
            },
            help: {
                "name": "opposite <text>",
                "value": "Makes all words in the text the opposite."
            },
            type: "Fun"
        },
    
        {
            name: ["heartlocket"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var makesweeturl = 'https://makesweet.com/my/heart-locket'
                var saidMessage = args.join(' ').substring(args[0].length + 1)
                symbolreplacements.forEach(symbolReplacement => {
                    symbolReplacement.target.forEach(target => {
                        saidMessage = saidMessage.replace(new RegExp(target, 'ig'), symbolReplacement.replacement)
                    })
                })
                var matchedTextes = saidMessage.match(/"([\s\S]*?)"/)
                if (!matchedTextes) {
                    matchedTextes = ['" "', ' ']
                }
                var text = matchedTextes[1]
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
                var fileinfo = await validateFile(currenturl).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })
    
                if (!fileinfo) return
                var type = fileinfo.type
    
                if (type.mime.startsWith('image')) {
                    var currentcount = filecount
                    filecount++
                    fs.mkdirSync(`${filepath}`)
    
                    var writeStream = fs.createWriteStream(`${filepath}/${filename}`)
    
                    require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                        response.pipe(writeStream)
                        writeStream.on('finish', async () => {
                            function waitForAttributeValue(element, attribute, value) {
                                return function () {
                                    return element.getAttribute(attribute).then(result => {
                                        return result === value;
                                    });
                                };
                            }
    
                            await waitForChromeSessionEnd(msg)
                            var driver = await new Builder().forBrowser('chrome').setChromeOptions(new chrome.Options().setUserPreferences({ "download.default_directory": testing ? `${__dirname}\\temp\\file${currentcount}` : `${__dirname.replace(/\\/g, '/')}/${filepath}` })).build().catch(() => { })
                            chromeWindow = driver
                            await driver.get(makesweeturl).catch(() => { })
                            var photobtn = await driver.findElement(By.css('input[type="file"]')).catch(() => { })
                            var textbtn = await driver.findElement(By.id('add_text')).catch(() => { })
                            var addbtn = await driver.findElement(By.css('li[id="wb-add"] a')).catch(() => { })
                            var animatebtn = await driver.findElement(By.css('li[id="wb-animate"] a')).catch(() => { })
                            var animategifbtn = await driver.findElement(By.css('li[id="wb-make-gif"] a')).catch(() => { })
                            var savebtnli = await driver.findElement(By.css('li[id="wb-working-save"]')).catch(() => { })
                            var savebtn = await driver.findElement(By.css('li[id="wb-working-save"] a')).catch(() => { })
    
                            if (args.indexOf('-swap') > -1) {
                                await textbtn.click().catch(() => { })
                                await sleep(1000)
                                var textbox = await driver.findElement(By.css('textarea[class="textbar_text"]')).catch(() => { })
                                var textdonebtn = await driver.findElement(By.css('button[class="ok_text ok_button"]')).catch(() => { })
                                await textbox.clear().catch(() => { })
                                await textbox.sendKeys(text).catch(() => { })
                                await textdonebtn.click().catch(() => { })
                                await addbtn.click().catch(() => { })
                                await photobtn.sendKeys(`${__dirname.replace(/\\/g, '/')}/${filepath}/${filename}`).catch(() => { })
                            } else {
                                await photobtn.sendKeys(`${__dirname.replace(/\\/g, '/')}/${filepath}/${filename}`).catch(() => { })
                                await addbtn.click().catch(() => { })
                                await textbtn.click().catch(() => { })
                                await sleep(1000)
                                var textbox = await driver.findElement(By.css('textarea[class="textbar_text"]')).catch(() => { })
                                var textdonebtn = await driver.findElement(By.css('button[class="ok_text ok_button"]')).catch(() => { })
                                await textbox.clear().catch(() => { })
                                await textbox.sendKeys(text).catch(() => { })
                                await textdonebtn.click().catch(() => { })
                            }
    
                            await animatebtn.click().catch(() => { })
                            await animategifbtn.click().catch(() => { })
                            await driver.wait(waitForAttributeValue(savebtnli, 'style', 'display: inline-block;'), 600000).catch(() => { })
                            await savebtn.click().catch(() => { })
                            await sleep(5000)
                            await driver.quit().catch(() => { })
                            chromeWindow = false
                            var files = fs.readdirSync(`${filepath}`)
                            var file = files.find(f => f.includes('makesweet'))
                            try {
                                fs.renameSync(`${filepath}/${file}`, `${filepath}/output.gif`)
                            } catch (_) {
                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                msg.channel.sendTyping().catch(() => { })
                                fs.rmSync(`${filepath}`, { force: true, recursive: true })
                                return
                            }
                            var fileMsg = await msg.channel.send({
                                files: [new Discord.MessageAttachment(`${filepath}/output.gif`)]
                            }).catch(() => { })
                            if (!fileMsg) {
                                await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                var fileLink = await Catbox.upload(`${filepath}/output.gif`).catch(() => { })
                                if (fileLink) {
                                    var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                    if (!fileLinkMsg) {
                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                    }
                                } else {
                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                }
                            }
                            msg.channel.sendTyping().catch(() => { })
                            fs.rmSync(`${filepath}`, { force: true, recursive: true })
                } else if (type.mime.startsWith('video')) {
                    var filepath = await downloadFile(currenturl, `input.mp4`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp4`
                            await execPromise(`ffmpeg -i ${filepath}/${filename} -vframes 1 ${filepath}/frame.png`)
                                function waitForAttributeValue(element, attribute, value) {
                                    return function () {
                                        return element.getAttribute(attribute).then(result => {
                                            return result === value;
                                        });
                                    };
                                }
    
                                await waitForChromeSessionEnd(msg)
                                var driver = await new Builder().forBrowser('chrome').setChromeOptions(new chrome.Options().setUserPreferences({ "download.default_directory": testing ? `${__dirname}\\temp\\file${currentcount}` : `${__dirname.replace(/\\/g, '/')}/${filepath}` })).build().catch(() => { })
                                chromeWindow = driver
                                await driver.get(makesweeturl).catch(() => { })
                                var photobtn = await driver.findElement(By.css('input[type="file"]')).catch(() => { })
                                var textbtn = await driver.findElement(By.id('add_text')).catch(() => { })
                                var addbtn = await driver.findElement(By.css('li[id="wb-add"] a')).catch(() => { })
                                var animatebtn = await driver.findElement(By.css('li[id="wb-animate"] a')).catch(() => { })
                                var animategifbtn = await driver.findElement(By.css('li[id="wb-make-gif"] a')).catch(() => { })
                                var savebtnli = await driver.findElement(By.css('li[id="wb-working-save"]')).catch(() => { })
                                var savebtn = await driver.findElement(By.css('li[id="wb-working-save"] a')).catch(() => { })
    
                                if (args.indexOf('-swap') > -1) {
                                    await textbtn.click().catch(() => { })
                                    await sleep(1000)
                                    var textbox = await driver.findElement(By.css('textarea[class="textbar_text"]')).catch(() => { })
                                    var textdonebtn = await driver.findElement(By.css('button[class="ok_text ok_button"]')).catch(() => { })
                                    await textbox.clear().catch(() => { })
                                    await textbox.sendKeys(text).catch(() => { })
                                    await textdonebtn.click().catch(() => { })
                                    await addbtn.click().catch(() => { })
                                    await photobtn.sendKeys(`${__dirname.replace(/\\/g, '/')}/${filepath}/frame.png`).catch(() => { })
                                } else {
                                    await photobtn.sendKeys(`${__dirname.replace(/\\/g, '/')}/${filepath}/frame.png`).catch(() => { })
                                    await addbtn.click().catch(() => { })
                                    await textbtn.click().catch(() => { })
                                    await sleep(1000)
                                    var textbox = await driver.findElement(By.css('textarea[class="textbar_text"]')).catch(() => { })
                                    var textdonebtn = await driver.findElement(By.css('button[class="ok_text ok_button"]')).catch(() => { })
                                    await textbox.clear().catch(() => { })
                                    await textbox.sendKeys(text).catch(() => { })
                                    await textdonebtn.click().catch(() => { })
                                }
    
                                await animatebtn.click().catch(() => { })
                                await animategifbtn.click().catch(() => { })
                                await driver.wait(waitForAttributeValue(savebtnli, 'style', 'display: inline-block;'), 600000).catch(() => { })
                                await savebtn.click().catch(() => { })
                                await sleep(5000)
                                await driver.quit().catch(() => { })
                                chromeWindow = false
                                var files = fs.readdirSync(`${filepath}`)
                                var file = files.find(f => f.includes('makesweet'))
                                try {
                                    fs.renameSync(`${filepath}/${file}`, `${filepath}/output.gif`)
                                } catch (_) {
                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                    msg.channel.sendTyping().catch(() => { })
                                    fs.rmSync(`${filepath}`, { force: true, recursive: true })
                                    return
                                }
                                var fileMsg = await msg.channel.send({
                                    files: [new Discord.MessageAttachment(`${filepath}/output.gif`)]
                                }).catch(() => { })
                                if (!fileMsg) {
                                    await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                    var fileLink = await Catbox.upload(`${filepath}/output.gif`).catch(() => { })
                                    if (fileLink) {
                                        var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                        if (!fileLinkMsg) {
                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                        }
                                    } else {
                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                    }
                                }
                                msg.channel.sendTyping().catch(() => { })
                                fs.rmSync(`${filepath}`, { force: true, recursive: true })
                            })
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "heartlocket \"[text]\" <file> [-swap]",
                "value": "Creates a Makesweet heartlocket with the file. (powered by https://makesweet.com/)"
            },
            cooldown: 2500,
            type: "Manipulation"
        },
    
        {
            name: ["goldheartlocket", "heartlocket2"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var makesweeturl = 'https://makesweet.com/my/gold-heart-locket'
                var saidMessage = args.join(' ').substring(args[0].length + 1)
                symbolreplacements.forEach(symbolReplacement => {
                    symbolReplacement.target.forEach(target => {
                        saidMessage = saidMessage.replace(new RegExp(target, 'ig'), symbolReplacement.replacement)
                    })
                })
                var matchedTextes = saidMessage.match(/"([\s\S]*?)"/)
                if (!matchedTextes) {
                    matchedTextes = ['" "', ' ']
                }
                var text = matchedTextes[1]
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
                var fileinfo = await validateFile(currenturl).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })
    
                if (!fileinfo) return
                var type = fileinfo.type
    
                if (type.mime.startsWith('image')) {
                    var currentcount = filecount
                    filecount++
                    fs.mkdirSync(`${filepath}`)
    
                    var writeStream = fs.createWriteStream(`${filepath}/${filename}`)
    
                    require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                        response.pipe(writeStream)
                        writeStream.on('finish', async () => {
                            function waitForAttributeValue(element, attribute, value) {
                                return function () {
                                    return element.getAttribute(attribute).then(result => {
                                        return result === value;
                                    });
                                };
                            }
    
                            await waitForChromeSessionEnd(msg)
                            var driver = await new Builder().forBrowser('chrome').setChromeOptions(new chrome.Options().setUserPreferences({ "download.default_directory": testing ? `${__dirname}\\temp\\file${currentcount}` : `${__dirname.replace(/\\/g, '/')}/${filepath}` })).build().catch(() => { })
                            chromeWindow = driver
                            await driver.get(makesweeturl).catch(() => { })
                            var photobtn = await driver.findElement(By.css('input[type="file"]')).catch(() => { })
                            var textbtn = await driver.findElement(By.id('add_text')).catch(() => { })
                            var addbtn = await driver.findElement(By.css('li[id="wb-add"] a')).catch(() => { })
                            var animatebtn = await driver.findElement(By.css('li[id="wb-animate"] a')).catch(() => { })
                            var animategifbtn = await driver.findElement(By.css('li[id="wb-make-gif"] a')).catch(() => { })
                            var savebtnli = await driver.findElement(By.css('li[id="wb-working-save"]')).catch(() => { })
                            var savebtn = await driver.findElement(By.css('li[id="wb-working-save"] a')).catch(() => { })
    
                            if (args.indexOf('-swap') > -1) {
                                await textbtn.click().catch(() => { })
                                await sleep(1000)
                                var textbox = await driver.findElement(By.css('textarea[class="textbar_text"]')).catch(() => { })
                                var textdonebtn = await driver.findElement(By.css('button[class="ok_text ok_button"]')).catch(() => { })
                                await textbox.clear().catch(() => { })
                                await textbox.sendKeys(text).catch(() => { })
                                await textdonebtn.click().catch(() => { })
                                await addbtn.click().catch(() => { })
                                await photobtn.sendKeys(`${__dirname.replace(/\\/g, '/')}/${filepath}/${filename}`).catch(() => { })
                            } else {
                                await photobtn.sendKeys(`${__dirname.replace(/\\/g, '/')}/${filepath}/${filename}`).catch(() => { })
                                await addbtn.click().catch(() => { })
                                await textbtn.click().catch(() => { })
                                await sleep(1000)
                                var textbox = await driver.findElement(By.css('textarea[class="textbar_text"]')).catch(() => { })
                                var textdonebtn = await driver.findElement(By.css('button[class="ok_text ok_button"]')).catch(() => { })
                                await textbox.clear().catch(() => { })
                                await textbox.sendKeys(text).catch(() => { })
                                await textdonebtn.click().catch(() => { })
                            }
    
                            await animatebtn.click().catch(() => { })
                            await animategifbtn.click().catch(() => { })
                            await driver.wait(waitForAttributeValue(savebtnli, 'style', 'display: inline-block;'), 600000).catch(() => { })
                            await savebtn.click().catch(() => { })
                            await sleep(5000)
                            await driver.quit().catch(() => { })
                            chromeWindow = false
                            var files = fs.readdirSync(`${filepath}`)
                            var file = files.find(f => f.includes('makesweet'))
                            try {
                                fs.renameSync(`${filepath}/${file}`, `${filepath}/output.gif`)
                            } catch (_) {
                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                msg.channel.sendTyping().catch(() => { })
                                fs.rmSync(`${filepath}`, { force: true, recursive: true })
                                return
                            }
                            var fileMsg = await msg.channel.send({
                                files: [new Discord.MessageAttachment(`${filepath}/output.gif`)]
                            }).catch(() => { })
                            if (!fileMsg) {
                                await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                var fileLink = await Catbox.upload(`${filepath}/output.gif`).catch(() => { })
                                if (fileLink) {
                                    var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                    if (!fileLinkMsg) {
                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                    }
                                } else {
                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                }
                            }
                            msg.channel.sendTyping().catch(() => { })
                            fs.rmSync(`${filepath}`, { force: true, recursive: true })
                } else if (type.mime.startsWith('video')) {
                    var filepath = await downloadFile(currenturl, `input.mp4`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp4`
                            await execPromise(`ffmpeg -i ${filepath}/${filename} -vframes 1 ${filepath}/frame.png`)
                                function waitForAttributeValue(element, attribute, value) {
                                    return function () {
                                        return element.getAttribute(attribute).then(result => {
                                            return result === value;
                                        });
                                    };
                                }
    
                                await waitForChromeSessionEnd(msg)
                                var driver = await new Builder().forBrowser('chrome').setChromeOptions(new chrome.Options().setUserPreferences({ "download.default_directory": testing ? `${__dirname}\\temp\\file${currentcount}` : `${__dirname.replace(/\\/g, '/')}/${filepath}` })).build().catch(() => { })
                                chromeWindow = driver
                                await driver.get(makesweeturl).catch(() => { })
                                var photobtn = await driver.findElement(By.css('input[type="file"]')).catch(() => { })
                                var textbtn = await driver.findElement(By.id('add_text')).catch(() => { })
                                var addbtn = await driver.findElement(By.css('li[id="wb-add"] a')).catch(() => { })
                                var animatebtn = await driver.findElement(By.css('li[id="wb-animate"] a')).catch(() => { })
                                var animategifbtn = await driver.findElement(By.css('li[id="wb-make-gif"] a')).catch(() => { })
                                var savebtnli = await driver.findElement(By.css('li[id="wb-working-save"]')).catch(() => { })
                                var savebtn = await driver.findElement(By.css('li[id="wb-working-save"] a')).catch(() => { })
    
                                if (args.indexOf('-swap') > -1) {
                                    await textbtn.click().catch(() => { })
                                    await sleep(1000)
                                    var textbox = await driver.findElement(By.css('textarea[class="textbar_text"]')).catch(() => { })
                                    var textdonebtn = await driver.findElement(By.css('button[class="ok_text ok_button"]')).catch(() => { })
                                    await textbox.clear().catch(() => { })
                                    await textbox.sendKeys(text).catch(() => { })
                                    await textdonebtn.click().catch(() => { })
                                    await addbtn.click().catch(() => { })
                                    await photobtn.sendKeys(`${__dirname.replace(/\\/g, '/')}/${filepath}/frame.png`).catch(() => { })
                                } else {
                                    await photobtn.sendKeys(`${__dirname.replace(/\\/g, '/')}/${filepath}/frame.png`).catch(() => { })
                                    await addbtn.click().catch(() => { })
                                    await textbtn.click().catch(() => { })
                                    await sleep(1000)
                                    var textbox = await driver.findElement(By.css('textarea[class="textbar_text"]')).catch(() => { })
                                    var textdonebtn = await driver.findElement(By.css('button[class="ok_text ok_button"]')).catch(() => { })
                                    await textbox.clear().catch(() => { })
                                    await textbox.sendKeys(text).catch(() => { })
                                    await textdonebtn.click().catch(() => { })
                                }
    
                                await animatebtn.click().catch(() => { })
                                await animategifbtn.click().catch(() => { })
                                await driver.wait(waitForAttributeValue(savebtnli, 'style', 'display: inline-block;'), 600000).catch(() => { })
                                await savebtn.click().catch(() => { })
                                await sleep(5000)
                                await driver.quit().catch(() => { })
                                chromeWindow = false
                                var files = fs.readdirSync(`${filepath}`)
                                var file = files.find(f => f.includes('makesweet'))
                                try {
                                    fs.renameSync(`${filepath}/${file}`, `${filepath}/output.gif`)
                                } catch (_) {
                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                    msg.channel.sendTyping().catch(() => { })
                                    fs.rmSync(`${filepath}`, { force: true, recursive: true })
                                    return
                                }
                                var fileMsg = await msg.channel.send({
                                    files: [new Discord.MessageAttachment(`${filepath}/output.gif`)]
                                }).catch(() => { })
                                if (!fileMsg) {
                                    await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                    var fileLink = await Catbox.upload(`${filepath}/output.gif`).catch(() => { })
                                    if (fileLink) {
                                        var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                        if (!fileLinkMsg) {
                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                        }
                                    } else {
                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                    }
                                }
                                msg.channel.sendTyping().catch(() => { })
                                fs.rmSync(`${filepath}`, { force: true, recursive: true })
                            })
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "goldheartlocket/heartlocket2 \"[text]\" <file> [-swap]",
                "value": "Creates a golden Makesweet heartlocket with the file. (powered by https://makesweet.com/)"
            },
            cooldown: 2500,
            type: "Manipulation"
        },
    
        {
            name: ["gift", "heartgift"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var makesweeturl = 'https://makesweet.com/my/gift-box'
                var saidMessage = args.join(' ').substring(args[0].length + 1)
                symbolreplacements.forEach(symbolReplacement => {
                    symbolReplacement.target.forEach(target => {
                        saidMessage = saidMessage.replace(new RegExp(target, 'ig'), symbolReplacement.replacement)
                    })
                })
                var matchedTextes = saidMessage.match(/"([\s\S]*?)"/)
                if (!matchedTextes) {
                    matchedTextes = ['" "', ' ']
                }
                var text = matchedTextes[1]
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
                var fileinfo = await validateFile(currenturl).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })
    
                if (!fileinfo) return
                var type = fileinfo.type
    
                if (type.mime.startsWith('image')) {
                    var currentcount = filecount
                    filecount++
                    fs.mkdirSync(`${filepath}`)
    
                    var writeStream = fs.createWriteStream(`${filepath}/${filename}`)
    
                    require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                        response.pipe(writeStream)
                        writeStream.on('finish', async () => {
                            function waitForAttributeValue(element, attribute, value) {
                                return function () {
                                    return element.getAttribute(attribute).then(result => {
                                        return result === value;
                                    });
                                };
                            }
    
                            await waitForChromeSessionEnd(msg)
                            var driver = await new Builder().forBrowser('chrome').setChromeOptions(new chrome.Options().setUserPreferences({ "download.default_directory": testing ? `${__dirname}\\temp\\file${currentcount}` : `${__dirname.replace(/\\/g, '/')}/${filepath}` })).build().catch(() => { })
                            chromeWindow = driver
                            await driver.get(makesweeturl).catch(() => { })
                            var photobtn = await driver.findElement(By.css('input[type="file"]')).catch(() => { })
                            var textbtn = await driver.findElement(By.id('add_text')).catch(() => { })
                            var addbtn = await driver.findElement(By.css('li[id="wb-add"] a')).catch(() => { })
                            var animatebtn = await driver.findElement(By.css('li[id="wb-animate"] a')).catch(() => { })
                            var animategifbtn = await driver.findElement(By.css('li[id="wb-make-gif"] a')).catch(() => { })
                            var savebtnli = await driver.findElement(By.css('li[id="wb-working-save"]')).catch(() => { })
                            var savebtn = await driver.findElement(By.css('li[id="wb-working-save"] a')).catch(() => { })
    
                            if (args.indexOf('-swap') > -1) {
                                await textbtn.click().catch(() => { })
                                await sleep(1000)
                                var textbox = await driver.findElement(By.css('textarea[class="textbar_text"]')).catch(() => { })
                                var textdonebtn = await driver.findElement(By.css('button[class="ok_text ok_button"]')).catch(() => { })
                                await textbox.clear().catch(() => { })
                                await textbox.sendKeys(text).catch(() => { })
                                await textdonebtn.click().catch(() => { })
                                await addbtn.click().catch(() => { })
                                await photobtn.sendKeys(`${__dirname.replace(/\\/g, '/')}/${filepath}/${filename}`).catch(() => { })
                            } else {
                                await photobtn.sendKeys(`${__dirname.replace(/\\/g, '/')}/${filepath}/${filename}`).catch(() => { })
                                await addbtn.click().catch(() => { })
                                await textbtn.click().catch(() => { })
                                await sleep(1000)
                                var textbox = await driver.findElement(By.css('textarea[class="textbar_text"]')).catch(() => { })
                                var textdonebtn = await driver.findElement(By.css('button[class="ok_text ok_button"]')).catch(() => { })
                                await textbox.clear().catch(() => { })
                                await textbox.sendKeys(text).catch(() => { })
                                await textdonebtn.click().catch(() => { })
                            }
    
                            await animatebtn.click().catch(() => { })
                            await animategifbtn.click().catch(() => { })
                            await driver.wait(waitForAttributeValue(savebtnli, 'style', 'display: inline-block;'), 600000).catch(() => { })
                            await savebtn.click().catch(() => { })
                            await sleep(5000)
                            await driver.quit().catch(() => { })
                            chromeWindow = false
                            var files = fs.readdirSync(`${filepath}`)
                            var file = files.find(f => f.includes('makesweet'))
                            try {
                                fs.renameSync(`${filepath}/${file}`, `${filepath}/output.gif`)
                            } catch (_) {
                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                msg.channel.sendTyping().catch(() => { })
                                fs.rmSync(`${filepath}`, { force: true, recursive: true })
                                return
                            }
                            var fileMsg = await msg.channel.send({
                                files: [new Discord.MessageAttachment(`${filepath}/output.gif`)]
                            }).catch(() => { })
                            if (!fileMsg) {
                                await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                var fileLink = await Catbox.upload(`${filepath}/output.gif`).catch(() => { })
                                if (fileLink) {
                                    var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                    if (!fileLinkMsg) {
                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                    }
                                } else {
                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                }
                            }
                            msg.channel.sendTyping().catch(() => { })
                            fs.rmSync(`${filepath}`, { force: true, recursive: true })
                } else if (type.mime.startsWith('video')) {
                    var filepath = await downloadFile(currenturl, `input.mp4`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp4`
                            await execPromise(`ffmpeg -i ${filepath}/${filename} -vframes 1 ${filepath}/frame.png`)
                                function waitForAttributeValue(element, attribute, value) {
                                    return function () {
                                        return element.getAttribute(attribute).then(result => {
                                            return result === value;
                                        });
                                    };
                                }
    
                                await waitForChromeSessionEnd(msg)
                                var driver = await new Builder().forBrowser('chrome').setChromeOptions(new chrome.Options().setUserPreferences({ "download.default_directory": testing ? `${__dirname}\\temp\\file${currentcount}` : `${__dirname.replace(/\\/g, '/')}/${filepath}` })).build().catch(() => { })
                                chromeWindow = driver
                                await driver.get(makesweeturl).catch(() => { })
                                var photobtn = await driver.findElement(By.css('input[type="file"]')).catch(() => { })
                                var textbtn = await driver.findElement(By.id('add_text')).catch(() => { })
                                var addbtn = await driver.findElement(By.css('li[id="wb-add"] a')).catch(() => { })
                                var animatebtn = await driver.findElement(By.css('li[id="wb-animate"] a')).catch(() => { })
                                var animategifbtn = await driver.findElement(By.css('li[id="wb-make-gif"] a')).catch(() => { })
                                var savebtnli = await driver.findElement(By.css('li[id="wb-working-save"]')).catch(() => { })
                                var savebtn = await driver.findElement(By.css('li[id="wb-working-save"] a')).catch(() => { })
    
                                if (args.indexOf('-swap') > -1) {
                                    await textbtn.click().catch(() => { })
                                    await sleep(1000)
                                    var textbox = await driver.findElement(By.css('textarea[class="textbar_text"]')).catch(() => { })
                                    var textdonebtn = await driver.findElement(By.css('button[class="ok_text ok_button"]')).catch(() => { })
                                    await textbox.clear().catch(() => { })
                                    await textbox.sendKeys(text).catch(() => { })
                                    await textdonebtn.click().catch(() => { })
                                    await addbtn.click().catch(() => { })
                                    await photobtn.sendKeys(`${__dirname.replace(/\\/g, '/')}/${filepath}/frame.png`).catch(() => { })
                                } else {
                                    await photobtn.sendKeys(`${__dirname.replace(/\\/g, '/')}/${filepath}/frame.png`).catch(() => { })
                                    await addbtn.click().catch(() => { })
                                    await textbtn.click().catch(() => { })
                                    await sleep(1000)
                                    var textbox = await driver.findElement(By.css('textarea[class="textbar_text"]')).catch(() => { })
                                    var textdonebtn = await driver.findElement(By.css('button[class="ok_text ok_button"]')).catch(() => { })
                                    await textbox.clear().catch(() => { })
                                    await textbox.sendKeys(text).catch(() => { })
                                    await textdonebtn.click().catch(() => { })
                                }
    
                                await animatebtn.click().catch(() => { })
                                await animategifbtn.click().catch(() => { })
                                await driver.wait(waitForAttributeValue(savebtnli, 'style', 'display: inline-block;'), 600000).catch(() => { })
                                await savebtn.click().catch(() => { })
                                await sleep(5000)
                                await driver.quit().catch(() => { })
                                chromeWindow = false
                                var files = fs.readdirSync(`${filepath}`)
                                var file = files.find(f => f.includes('makesweet'))
                                try {
                                    fs.renameSync(`${filepath}/${file}`, `${filepath}/output.gif`)
                                } catch (_) {
                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                    msg.channel.sendTyping().catch(() => { })
                                    fs.rmSync(`${filepath}`, { force: true, recursive: true })
                                    return
                                }
                                var fileMsg = await msg.channel.send({
                                    files: [new Discord.MessageAttachment(`${filepath}/output.gif`)]
                                }).catch(() => { })
                                if (!fileMsg) {
                                    await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                    var fileLink = await Catbox.upload(`${filepath}/output.gif`).catch(() => { })
                                    if (fileLink) {
                                        var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                        if (!fileLinkMsg) {
                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                        }
                                    } else {
                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                    }
                                }
                                msg.channel.sendTyping().catch(() => { })
                                fs.rmSync(`${filepath}`, { force: true, recursive: true })
                            })
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "gift/heartgift \"[text]\" <file> [-swap]",
                "value": "im bri'ish (powered by https://makesweet.com/)"
            },
            cooldown: 2500,
            type: "Manipulation"
        },
    
        {
            name: ["billboard", "sign"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                var makesweeturl = 'https://makesweet.com/my/billboard-cityscape'
                var textincluded = true
                var saidMessage = args.join(' ').substring(args[0].length + 1)
                symbolreplacements.forEach(symbolReplacement => {
                    symbolReplacement.target.forEach(target => {
                        saidMessage = saidMessage.replace(new RegExp(target, 'ig'), symbolReplacement.replacement)
                    })
                })
                var matchedTextes = saidMessage.match(/"([\s\S]*?)"/)
                if (!matchedTextes) {
                    textincluded = false
                    matchedTextes = ['""', '']
                }
                var text = matchedTextes[1]
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined && !textincluded) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
                if (textincluded) {
                    var currentcount = filecount
                    filecount++
                    fs.mkdirSync(`${filepath}`)
    
                    function waitForAttributeValue(element, attribute, value) {
                        return function () {
                            return element.getAttribute(attribute).then(result => {
                                return result === value;
                            });
                        };
                    }
    
                    await waitForChromeSessionEnd(msg)
                    var driver = await new Builder().forBrowser('chrome').setChromeOptions(new chrome.Options().setUserPreferences({ "download.default_directory": testing ? `${__dirname}\\temp\\file${currentcount}` : `${__dirname.replace(/\\/g, '/')}/${filepath}` })).build().catch(() => { })
                    chromeWindow = driver
                    await driver.get(makesweeturl).catch(() => { })
                    var textbtn = await driver.findElement(By.id('add_text')).catch(() => { })
                    var animatebtn = await driver.findElement(By.css('li[id="wb-animate"] a')).catch(() => { })
                    var animategifbtn = await driver.findElement(By.css('li[id="wb-make-gif"] a')).catch(() => { })
                    var savebtnli = await driver.findElement(By.css('li[id="wb-working-save"]')).catch(() => { })
                    var savebtn = await driver.findElement(By.css('li[id="wb-working-save"] a')).catch(() => { })
                    await textbtn.click().catch(() => { })
                    await sleep(1000)
                    var textbox = await driver.findElement(By.css('textarea[class="textbar_text"]')).catch(() => { })
                    var textdonebtn = await driver.findElement(By.css('button[class="ok_text ok_button"]')).catch(() => { })
                    await textbox.clear().catch(() => { })
                    await textbox.sendKeys(text).catch(() => { })
                    await textdonebtn.click().catch(() => { })
                    await animatebtn.click().catch(() => { })
                    await animategifbtn.click().catch(() => { })
                    await driver.wait(waitForAttributeValue(savebtnli, 'style', 'display: inline-block;'), 600000).catch(() => { })
                    await savebtn.click().catch(() => { })
                    await sleep(5000)
                    await driver.quit().catch(() => { })
                    chromeWindow = false
                    var files = fs.readdirSync(`${filepath}`)
                    var file = files.find(f => f.includes('makesweet'))
                    try {
                        fs.renameSync(`${filepath}/${file}`, `${filepath}/output.gif`)
                    } catch (_) {
                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                        msg.channel.sendTyping().catch(() => { })
                        fs.rmSync(`${filepath}`, { force: true, recursive: true })
                        return
                    }
                    var fileMsg = await msg.channel.send({
                        files: [new Discord.MessageAttachment(`${filepath}/output.gif`)]
                    }).catch(() => { })
                    if (!fileMsg) {
                        await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                        var fileLink = await Catbox.upload(`${filepath}/output.gif`).catch(() => { })
                        if (fileLink) {
                            var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                            if (!fileLinkMsg) {
                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                            }
                        } else {
                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                        }
                    }
                    msg.channel.sendTyping().catch(() => { })
                    fs.rmSync(`${filepath}`, { force: true, recursive: true })
                    return
                }
    
                var fileinfo = await validateFile(currenturl).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })
    
                if (!fileinfo) return
                var type = fileinfo.type
    
                if (type.mime.startsWith('image')) {
                    var currentcount = filecount
                    filecount++
                    fs.mkdirSync(`${filepath}`)
    
                    var writeStream = fs.createWriteStream(`${filepath}/${filename}`)
    
                    require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                        response.pipe(writeStream)
                        writeStream.on('finish', async () => {
                            function waitForAttributeValue(element, attribute, value) {
                                return function () {
                                    return element.getAttribute(attribute).then(result => {
                                        return result === value;
                                    });
                                };
                            }
    
                            await waitForChromeSessionEnd(msg)
                            chromeWindow = driver
                            var driver = await new Builder().forBrowser('chrome').setChromeOptions(new chrome.Options().setUserPreferences({ "download.default_directory": testing ? `${__dirname}\\temp\\file${currentcount}` : `${__dirname.replace(/\\/g, '/')}/${filepath}` })).build().catch(() => { })
                            await driver.get(makesweeturl).catch(() => { })
                            var photobtn = await driver.findElement(By.css('input[type="file"]')).catch(() => { })
                            var animatebtn = await driver.findElement(By.css('li[id="wb-animate"] a')).catch(() => { })
                            var animategifbtn = await driver.findElement(By.css('li[id="wb-make-gif"] a')).catch(() => { })
                            var savebtnli = await driver.findElement(By.css('li[id="wb-working-save"]')).catch(() => { })
                            var savebtn = await driver.findElement(By.css('li[id="wb-working-save"] a')).catch(() => { })
                            await photobtn.sendKeys(`${__dirname.replace(/\\/g, '/')}/${filepath}/${filename}`).catch(() => { })
                            await animatebtn.click().catch(() => { })
                            await animategifbtn.click().catch(() => { })
                            await driver.wait(waitForAttributeValue(savebtnli, 'style', 'display: inline-block;'), 600000).catch(() => { })
                            await savebtn.click().catch(() => { })
                            await sleep(5000)
                            await driver.quit().catch(() => { })
                            chromeWindow = false
                            var files = fs.readdirSync(`${filepath}`)
                            var file = files.find(f => f.includes('makesweet'))
                            try {
                                fs.renameSync(`${filepath}/${file}`, `${filepath}/output.gif`)
                            } catch (_) {
                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                msg.channel.sendTyping().catch(() => { })
                                fs.rmSync(`${filepath}`, { force: true, recursive: true })
                                return
                            }
                            var fileMsg = await msg.channel.send({
                                files: [new Discord.MessageAttachment(`${filepath}/output.gif`)]
                            }).catch(() => { })
                            if (!fileMsg) {
                                await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                var fileLink = await Catbox.upload(`${filepath}/output.gif`).catch(() => { })
                                if (fileLink) {
                                    var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                    if (!fileLinkMsg) {
                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                    }
                                } else {
                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                }
                            }
                            msg.channel.sendTyping().catch(() => { })
                            fs.rmSync(`${filepath}`, { force: true, recursive: true })
                } else if (type.mime.startsWith('video')) {
                    var filepath = await downloadFile(currenturl, `input.mp4`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp4`
                            await execPromise(`ffmpeg -i ${filepath}/${filename} -vframes 1 ${filepath}/frame.png`)
                                function waitForAttributeValue(element, attribute, value) {
                                    return function () {
                                        return element.getAttribute(attribute).then(result => {
                                            return result === value;
                                        });
                                    };
                                }
    
                                await waitForChromeSessionEnd(msg)
                                var driver = await new Builder().forBrowser('chrome').setChromeOptions(new chrome.Options().setUserPreferences({ "download.default_directory": testing ? `${__dirname}\\temp\\file${currentcount}` : `${__dirname.replace(/\\/g, '/')}/${filepath}` })).build().catch(() => { })
                                chromeWindow = driver
                                await driver.get(makesweeturl).catch(() => { })
                                var photobtn = await driver.findElement(By.css('input[type="file"]')).catch(() => { })
                                var animatebtn = await driver.findElement(By.css('li[id="wb-animate"] a')).catch(() => { })
                                var animategifbtn = await driver.findElement(By.css('li[id="wb-make-gif"] a')).catch(() => { })
                                var savebtnli = await driver.findElement(By.css('li[id="wb-working-save"]')).catch(() => { })
                                var savebtn = await driver.findElement(By.css('li[id="wb-working-save"] a')).catch(() => { })
                                await photobtn.sendKeys(`${__dirname.replace(/\\/g, '/')}/${filepath}/frame.png`).catch(() => { })
                                await animatebtn.click().catch(() => { })
                                await animategifbtn.click().catch(() => { })
                                await driver.wait(waitForAttributeValue(savebtnli, 'style', 'display: inline-block;'), 600000).catch(() => { })
                                await savebtn.click().catch(() => { })
                                await sleep(5000)
                                await driver.quit().catch(() => { })
                                chromeWindow = false
                                var files = fs.readdirSync(`${filepath}`)
                                var file = files.find(f => f.includes('makesweet'))
                                try {
                                    fs.renameSync(`${filepath}/${file}`, `${filepath}/output.gif`)
                                } catch (_) {
                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                    msg.channel.sendTyping().catch(() => { })
                                    fs.rmSync(`${filepath}`, { force: true, recursive: true })
                                    return
                                }
                                var fileMsg = await msg.channel.send({
                                    files: [new Discord.MessageAttachment(`${filepath}/output.gif`)]
                                }).catch(() => { })
                                if (!fileMsg) {
                                    await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                    var fileLink = await Catbox.upload(`${filepath}/output.gif`).catch(() => { })
                                    if (fileLink) {
                                        var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                        if (!fileLinkMsg) {
                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                        }
                                    } else {
                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                    }
                                }
                                msg.channel.sendTyping().catch(() => { })
                                fs.rmSync(`${filepath}`, { force: true, recursive: true })
                            })
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "billboard/sign <file> or \"<text>\"",
                "value": "Billboard for sale! (powered by https://makesweet.com/)"
            },
            cooldown: 2500,
            type: "Manipulation"
        },
    
        {
            name: ["flyingflag"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                var makesweeturl = 'https://makesweet.com/my/flag'
                var textincluded = true
                var saidMessage = args.join(' ').substring(args[0].length + 1)
                symbolreplacements.forEach(symbolReplacement => {
                    symbolReplacement.target.forEach(target => {
                        saidMessage = saidMessage.replace(new RegExp(target, 'ig'), symbolReplacement.replacement)
                    })
                })
                var matchedTextes = saidMessage.match(/"([\s\S]*?)"/)
                if (!matchedTextes) {
                    textincluded = false
                    matchedTextes = ['""', '']
                }
                var text = matchedTextes[1]
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined && !textincluded) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
                if (textincluded) {
                    var currentcount = filecount
                    filecount++
                    fs.mkdirSync(`${filepath}`)
    
                    function waitForAttributeValue(element, attribute, value) {
                        return function () {
                            return element.getAttribute(attribute).then(result => {
                                return result === value;
                            });
                        };
                    }
    
                    await waitForChromeSessionEnd(msg)
                    var driver = await new Builder().forBrowser('chrome').setChromeOptions(new chrome.Options().setUserPreferences({ "download.default_directory": testing ? `${__dirname}\\temp\\file${currentcount}` : `${__dirname.replace(/\\/g, '/')}/${filepath}` })).build().catch(() => { })
                    chromeWindow = driver
                    await driver.get(makesweeturl).catch(() => { })
                    var textbtn = await driver.findElement(By.id('add_text')).catch(() => { })
                    var animatebtn = await driver.findElement(By.css('li[id="wb-animate"] a')).catch(() => { })
                    var animategifbtn = await driver.findElement(By.css('li[id="wb-make-gif"] a')).catch(() => { })
                    var savebtnli = await driver.findElement(By.css('li[id="wb-working-save"]')).catch(() => { })
                    var savebtn = await driver.findElement(By.css('li[id="wb-working-save"] a')).catch(() => { })
                    await textbtn.click().catch(() => { })
                    await sleep(1000)
                    var textbox = await driver.findElement(By.css('textarea[class="textbar_text"]')).catch(() => { })
                    var textdonebtn = await driver.findElement(By.css('button[class="ok_text ok_button"]')).catch(() => { })
                    await textbox.clear().catch(() => { })
                    await textbox.sendKeys(text).catch(() => { })
                    await textdonebtn.click().catch(() => { })
                    await animatebtn.click().catch(() => { })
                    await animategifbtn.click().catch(() => { })
                    await driver.wait(waitForAttributeValue(savebtnli, 'style', 'display: inline-block;'), 600000).catch(() => { })
                    await savebtn.click().catch(() => { })
                    await sleep(5000)
                    await driver.quit().catch(() => { })
                    chromeWindow = false
                    var files = fs.readdirSync(`${filepath}`)
                    var file = files.find(f => f.includes('makesweet'))
                    try {
                        fs.renameSync(`${filepath}/${file}`, `${filepath}/output.gif`)
                    } catch (_) {
                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                        msg.channel.sendTyping().catch(() => { })
                        fs.rmSync(`${filepath}`, { force: true, recursive: true })
                        return
                    }
                    var fileMsg = await msg.channel.send({
                        files: [new Discord.MessageAttachment(`${filepath}/output.gif`)]
                    }).catch(() => { })
                    if (!fileMsg) {
                        await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                        var fileLink = await Catbox.upload(`${filepath}/output.gif`).catch(() => { })
                        if (fileLink) {
                            var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                            if (!fileLinkMsg) {
                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                            }
                        } else {
                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                        }
                    }
                    msg.channel.sendTyping().catch(() => { })
                    fs.rmSync(`${filepath}`, { force: true, recursive: true })
                    return
                }
    
                var fileinfo = await validateFile(currenturl).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })
    
                if (!fileinfo) return
                var type = fileinfo.type
    
                if (type.mime.startsWith('image')) {
                    var currentcount = filecount
                    filecount++
                    fs.mkdirSync(`${filepath}`)
    
                    var writeStream = fs.createWriteStream(`${filepath}/${filename}`)
    
                    require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                        response.pipe(writeStream)
                        writeStream.on('finish', async () => {
                            function waitForAttributeValue(element, attribute, value) {
                                return function () {
                                    return element.getAttribute(attribute).then(result => {
                                        return result === value;
                                    });
                                };
                            }
    
                            await waitForChromeSessionEnd(msg)
                            var driver = await new Builder().forBrowser('chrome').setChromeOptions(new chrome.Options().setUserPreferences({ "download.default_directory": testing ? `${__dirname}\\temp\\file${currentcount}` : `${__dirname.replace(/\\/g, '/')}/${filepath}` })).build().catch(() => { })
                            chromeWindow = driver
                            await driver.get(makesweeturl).catch(() => { })
                            var photobtn = await driver.findElement(By.css('input[type="file"]')).catch(() => { })
                            var animatebtn = await driver.findElement(By.css('li[id="wb-animate"] a')).catch(() => { })
                            var animategifbtn = await driver.findElement(By.css('li[id="wb-make-gif"] a')).catch(() => { })
                            var savebtnli = await driver.findElement(By.css('li[id="wb-working-save"]')).catch(() => { })
                            var savebtn = await driver.findElement(By.css('li[id="wb-working-save"] a')).catch(() => { })
                            await photobtn.sendKeys(`${__dirname.replace(/\\/g, '/')}/${filepath}/${filename}`).catch(() => { })
                            await animatebtn.click().catch(() => { })
                            await animategifbtn.click().catch(() => { })
                            await driver.wait(waitForAttributeValue(savebtnli, 'style', 'display: inline-block;'), 600000).catch(() => { })
                            await savebtn.click().catch(() => { })
                            await sleep(5000)
                            await driver.quit().catch(() => { })
                            chromeWindow = false
                            var files = fs.readdirSync(`${filepath}`)
                            var file = files.find(f => f.includes('makesweet'))
                            try {
                                fs.renameSync(`${filepath}/${file}`, `${filepath}/output.gif`)
                            } catch (_) {
                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                msg.channel.sendTyping().catch(() => { })
                                fs.rmSync(`${filepath}`, { force: true, recursive: true })
                                return
                            }
                            var fileMsg = await msg.channel.send({
                                files: [new Discord.MessageAttachment(`${filepath}/output.gif`)]
                            }).catch(() => { })
                            if (!fileMsg) {
                                await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                var fileLink = await Catbox.upload(`${filepath}/output.gif`).catch(() => { })
                                if (fileLink) {
                                    var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                    if (!fileLinkMsg) {
                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                    }
                                } else {
                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                }
                            }
                            msg.channel.sendTyping().catch(() => { })
                            fs.rmSync(`${filepath}`, { force: true, recursive: true })
                } else if (type.mime.startsWith('video')) {
                    var filepath = await downloadFile(currenturl, `input.mp4`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp4`
                            await execPromise(`ffmpeg -i ${filepath}/${filename} -vframes 1 ${filepath}/frame.png`)
                                function waitForAttributeValue(element, attribute, value) {
                                    return function () {
                                        return element.getAttribute(attribute).then(result => {
                                            return result === value;
                                        });
                                    };
                                }
    
                                await waitForChromeSessionEnd(msg)
                                var driver = await new Builder().forBrowser('chrome').setChromeOptions(new chrome.Options().setUserPreferences({ "download.default_directory": testing ? `${__dirname}\\temp\\file${currentcount}` : `${__dirname.replace(/\\/g, '/')}/${filepath}` })).build().catch(() => { })
                                chromeWindow = driver
                                await driver.get(makesweeturl).catch(() => { })
                                var photobtn = await driver.findElement(By.css('input[type="file"]')).catch(() => { })
                                var animatebtn = await driver.findElement(By.css('li[id="wb-animate"] a')).catch(() => { })
                                var animategifbtn = await driver.findElement(By.css('li[id="wb-make-gif"] a')).catch(() => { })
                                var savebtnli = await driver.findElement(By.css('li[id="wb-working-save"]')).catch(() => { })
                                var savebtn = await driver.findElement(By.css('li[id="wb-working-save"] a')).catch(() => { })
                                await photobtn.sendKeys(`${__dirname.replace(/\\/g, '/')}/${filepath}/frame.png`).catch(() => { })
                                await animatebtn.click().catch(() => { })
                                await animategifbtn.click().catch(() => { })
                                await driver.wait(waitForAttributeValue(savebtnli, 'style', 'display: inline-block;'), 600000).catch(() => { })
                                await savebtn.click().catch(() => { })
                                await sleep(5000)
                                await driver.quit().catch(() => { })
                                chromeWindow = false
                                var files = fs.readdirSync(`${filepath}`)
                                var file = files.find(f => f.includes('makesweet'))
                                try {
                                    fs.renameSync(`${filepath}/${file}`, `${filepath}/output.gif`)
                                } catch (_) {
                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                    msg.channel.sendTyping().catch(() => { })
                                    fs.rmSync(`${filepath}`, { force: true, recursive: true })
                                    return
                                }
                                var fileMsg = await msg.channel.send({
                                    files: [new Discord.MessageAttachment(`${filepath}/output.gif`)]
                                }).catch(() => { })
                                if (!fileMsg) {
                                    await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                    var fileLink = await Catbox.upload(`${filepath}/output.gif`).catch(() => { })
                                    if (fileLink) {
                                        var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                        if (!fileLinkMsg) {
                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                        }
                                    } else {
                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                    }
                                }
                                msg.channel.sendTyping().catch(() => { })
                                fs.rmSync(`${filepath}`, { force: true, recursive: true })
                            })
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "flyingflag <file> or \"<text>\"",
                "value": "the flag of my home country (powered by https://makesweet.com/)"
            },
            cooldown: 2500,
            type: "Manipulation"
        },
    
        {
            name: ["flyingflag2"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                var makesweeturl = 'https://makesweet.com/my/blue-sky-flag'
                var textincluded = true
                var saidMessage = args.join(' ').substring(args[0].length + 1)
                symbolreplacements.forEach(symbolReplacement => {
                    symbolReplacement.target.forEach(target => {
                        saidMessage = saidMessage.replace(new RegExp(target, 'ig'), symbolReplacement.replacement)
                    })
                })
                var matchedTextes = saidMessage.match(/"([\s\S]*?)"/)
                if (!matchedTextes) {
                    textincluded = false
                    matchedTextes = ['""', '']
                }
                var text = matchedTextes[1]
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined && !textincluded) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
                if (textincluded) {
                    var currentcount = filecount
                    filecount++
                    fs.mkdirSync(`${filepath}`)
    
                    function waitForAttributeValue(element, attribute, value) {
                        return function () {
                            return element.getAttribute(attribute).then(result => {
                                return result === value;
                            });
                        };
                    }
    
                    await waitForChromeSessionEnd(msg)
                    var driver = await new Builder().forBrowser('chrome').setChromeOptions(new chrome.Options().setUserPreferences({ "download.default_directory": testing ? `${__dirname}\\temp\\file${currentcount}` : `${__dirname.replace(/\\/g, '/')}/${filepath}` })).build().catch(() => { })
                    chromeWindow = driver
                    await driver.get(makesweeturl).catch(() => { })
                    var textbtn = await driver.findElement(By.id('add_text')).catch(() => { })
                    var animatebtn = await driver.findElement(By.css('li[id="wb-animate"] a')).catch(() => { })
                    var animategifbtn = await driver.findElement(By.css('li[id="wb-make-gif"] a')).catch(() => { })
                    var savebtnli = await driver.findElement(By.css('li[id="wb-working-save"]')).catch(() => { })
                    var savebtn = await driver.findElement(By.css('li[id="wb-working-save"] a')).catch(() => { })
                    await textbtn.click().catch(() => { })
                    await sleep(1000)
                    var textbox = await driver.findElement(By.css('textarea[class="textbar_text"]')).catch(() => { })
                    var textdonebtn = await driver.findElement(By.css('button[class="ok_text ok_button"]')).catch(() => { })
                    await textbox.clear().catch(() => { })
                    await textbox.sendKeys(text).catch(() => { })
                    await textdonebtn.click().catch(() => { })
                    await animatebtn.click().catch(() => { })
                    await animategifbtn.click().catch(() => { })
                    await driver.wait(waitForAttributeValue(savebtnli, 'style', 'display: inline-block;'), 600000).catch(() => { })
                    await savebtn.click().catch(() => { })
                    await sleep(5000)
                    await driver.quit().catch(() => { })
                    chromeWindow = false
                    var files = fs.readdirSync(`${filepath}`)
                    var file = files.find(f => f.includes('makesweet'))
                    try {
                        fs.renameSync(`${filepath}/${file}`, `${filepath}/output.gif`)
                    } catch (_) {
                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                        msg.channel.sendTyping().catch(() => { })
                        fs.rmSync(`${filepath}`, { force: true, recursive: true })
                        return
                    }
                    var fileMsg = await msg.channel.send({
                        files: [new Discord.MessageAttachment(`${filepath}/output.gif`)]
                    }).catch(() => { })
                    if (!fileMsg) {
                        await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                        var fileLink = await Catbox.upload(`${filepath}/output.gif`).catch(() => { })
                        if (fileLink) {
                            var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                            if (!fileLinkMsg) {
                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                            }
                        } else {
                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                        }
                    }
                    msg.channel.sendTyping().catch(() => { })
                    fs.rmSync(`${filepath}`, { force: true, recursive: true })
                    return
                }
    
                var fileinfo = await validateFile(currenturl).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })
    
                if (!fileinfo) return
                var type = fileinfo.type
    
                if (type.mime.startsWith('image')) {
                    var currentcount = filecount
                    filecount++
                    fs.mkdirSync(`${filepath}`)
    
                    var writeStream = fs.createWriteStream(`${filepath}/${filename}`)
    
                    require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                        response.pipe(writeStream)
                        writeStream.on('finish', async () => {
                            function waitForAttributeValue(element, attribute, value) {
                                return function () {
                                    return element.getAttribute(attribute).then(result => {
                                        return result === value;
                                    });
                                };
                            }
    
                            await waitForChromeSessionEnd(msg)
                            var driver = await new Builder().forBrowser('chrome').setChromeOptions(new chrome.Options().setUserPreferences({ "download.default_directory": testing ? `${__dirname}\\temp\\file${currentcount}` : `${__dirname.replace(/\\/g, '/')}/${filepath}` })).build().catch(() => { })
                            chromeWindow = driver
                            await driver.get(makesweeturl).catch(() => { })
                            var photobtn = await driver.findElement(By.css('input[type="file"]')).catch(() => { })
                            var animatebtn = await driver.findElement(By.css('li[id="wb-animate"] a')).catch(() => { })
                            var animategifbtn = await driver.findElement(By.css('li[id="wb-make-gif"] a')).catch(() => { })
                            var savebtnli = await driver.findElement(By.css('li[id="wb-working-save"]')).catch(() => { })
                            var savebtn = await driver.findElement(By.css('li[id="wb-working-save"] a')).catch(() => { })
                            await photobtn.sendKeys(`${__dirname.replace(/\\/g, '/')}/${filepath}/${filename}`).catch(() => { })
                            await animatebtn.click().catch(() => { })
                            await animategifbtn.click().catch(() => { })
                            await driver.wait(waitForAttributeValue(savebtnli, 'style', 'display: inline-block;'), 600000).catch(() => { })
                            await savebtn.click().catch(() => { })
                            await sleep(5000)
                            await driver.quit().catch(() => { })
                            chromeWindow = false
                            var files = fs.readdirSync(`${filepath}`)
                            var file = files.find(f => f.includes('makesweet'))
                            try {
                                fs.renameSync(`${filepath}/${file}`, `${filepath}/output.gif`)
                            } catch (_) {
                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                msg.channel.sendTyping().catch(() => { })
                                fs.rmSync(`${filepath}`, { force: true, recursive: true })
                                return
                            }
                            var fileMsg = await msg.channel.send({
                                files: [new Discord.MessageAttachment(`${filepath}/output.gif`)]
                            }).catch(() => { })
                            if (!fileMsg) {
                                await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                var fileLink = await Catbox.upload(`${filepath}/output.gif`).catch(() => { })
                                if (fileLink) {
                                    var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                    if (!fileLinkMsg) {
                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                    }
                                } else {
                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                }
                            }
                            msg.channel.sendTyping().catch(() => { })
                            fs.rmSync(`${filepath}`, { force: true, recursive: true })
                } else if (type.mime.startsWith('video')) {
                    var filepath = await downloadFile(currenturl, `input.mp4`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp4`
                            await execPromise(`ffmpeg -i ${filepath}/${filename} -vframes 1 ${filepath}/frame.png`)
                                function waitForAttributeValue(element, attribute, value) {
                                    return function () {
                                        return element.getAttribute(attribute).then(result => {
                                            return result === value;
                                        });
                                    };
                                }
    
                                await waitForChromeSessionEnd(msg)
                                var driver = await new Builder().forBrowser('chrome').setChromeOptions(new chrome.Options().setUserPreferences({ "download.default_directory": testing ? `${__dirname}\\temp\\file${currentcount}` : `${__dirname.replace(/\\/g, '/')}/${filepath}` })).build().catch(() => { })
                                chromeWindow = driver
                                await driver.get(makesweeturl).catch(() => { })
                                var photobtn = await driver.findElement(By.css('input[type="file"]')).catch(() => { })
                                var animatebtn = await driver.findElement(By.css('li[id="wb-animate"] a')).catch(() => { })
                                var animategifbtn = await driver.findElement(By.css('li[id="wb-make-gif"] a')).catch(() => { })
                                var savebtnli = await driver.findElement(By.css('li[id="wb-working-save"]')).catch(() => { })
                                var savebtn = await driver.findElement(By.css('li[id="wb-working-save"] a')).catch(() => { })
                                await photobtn.sendKeys(`${__dirname.replace(/\\/g, '/')}/${filepath}/frame.png`).catch(() => { })
                                await animatebtn.click().catch(() => { })
                                await animategifbtn.click().catch(() => { })
                                await driver.wait(waitForAttributeValue(savebtnli, 'style', 'display: inline-block;'), 600000).catch(() => { })
                                await savebtn.click().catch(() => { })
                                await sleep(5000)
                                await driver.quit().catch(() => { })
                                chromeWindow = false
                                var files = fs.readdirSync(`${filepath}`)
                                var file = files.find(f => f.includes('makesweet'))
                                try {
                                    fs.renameSync(`${filepath}/${file}`, `${filepath}/output.gif`)
                                } catch (_) {
                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                    msg.channel.sendTyping().catch(() => { })
                                    fs.rmSync(`${filepath}`, { force: true, recursive: true })
                                    return
                                }
                                var fileMsg = await msg.channel.send({
                                    files: [new Discord.MessageAttachment(`${filepath}/output.gif`)]
                                }).catch(() => { })
                                if (!fileMsg) {
                                    await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                    var fileLink = await Catbox.upload(`${filepath}/output.gif`).catch(() => { })
                                    if (fileLink) {
                                        var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                        if (!fileLinkMsg) {
                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                        }
                                    } else {
                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                    }
                                }
                                msg.channel.sendTyping().catch(() => { })
                                fs.rmSync(`${filepath}`, { force: true, recursive: true })
                            })
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "flyingflag2 <file> or \"<text>\"",
                "value": "the new flag of my home country (powered by https://makesweet.com/)"
            },
            cooldown: 2500,
            type: "Manipulation"
        },
    
        {
            name: ["sun", "heartsun"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                var makesweeturl = 'https://makesweet.com/my/valentine'
                var textincluded = true
                var saidMessage = args.join(' ').substring(args[0].length + 1)
                symbolreplacements.forEach(symbolReplacement => {
                    symbolReplacement.target.forEach(target => {
                        saidMessage = saidMessage.replace(new RegExp(target, 'ig'), symbolReplacement.replacement)
                    })
                })
                var matchedTextes = saidMessage.match(/"([\s\S]*?)"/)
                if (!matchedTextes) {
                    textincluded = false
                    matchedTextes = ['""', '']
                }
                var text = matchedTextes[1]
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined && !textincluded) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
                if (textincluded) {
                    var currentcount = filecount
                    filecount++
                    fs.mkdirSync(`${filepath}`)
    
                    function waitForAttributeValue(element, attribute, value) {
                        return function () {
                            return element.getAttribute(attribute).then(result => {
                                return result === value;
                            });
                        };
                    }
    
                    await waitForChromeSessionEnd(msg)
                    var driver = await new Builder().forBrowser('chrome').setChromeOptions(new chrome.Options().setUserPreferences({ "download.default_directory": testing ? `${__dirname}\\temp\\file${currentcount}` : `${__dirname.replace(/\\/g, '/')}/${filepath}` })).build().catch(() => { })
                    chromeWindow = driver
                    await driver.get(makesweeturl).catch(() => { })
                    var textbtn = await driver.findElement(By.id('add_text')).catch(() => { })
                    var animatebtn = await driver.findElement(By.css('li[id="wb-animate"] a')).catch(() => { })
                    var animategifbtn = await driver.findElement(By.css('li[id="wb-make-gif"] a')).catch(() => { })
                    var savebtnli = await driver.findElement(By.css('li[id="wb-working-save"]')).catch(() => { })
                    var savebtn = await driver.findElement(By.css('li[id="wb-working-save"] a')).catch(() => { })
                    await textbtn.click().catch(() => { })
                    await sleep(1000)
                    var textbox = await driver.findElement(By.css('textarea[class="textbar_text"]')).catch(() => { })
                    var textdonebtn = await driver.findElement(By.css('button[class="ok_text ok_button"]')).catch(() => { })
                    await textbox.clear().catch(() => { })
                    await textbox.sendKeys(text).catch(() => { })
                    await textdonebtn.click().catch(() => { })
                    await animatebtn.click().catch(() => { })
                    await animategifbtn.click().catch(() => { })
                    await driver.wait(waitForAttributeValue(savebtnli, 'style', 'display: inline-block;'), 600000).catch(() => { })
                    await savebtn.click().catch(() => { })
                    await sleep(5000)
                    await driver.quit().catch(() => { })
                    chromeWindow = false
                    var files = fs.readdirSync(`${filepath}`)
                    var file = files.find(f => f.includes('makesweet'))
                    try {
                        fs.renameSync(`${filepath}/${file}`, `${filepath}/output.gif`)
                    } catch (_) {
                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                        msg.channel.sendTyping().catch(() => { })
                        fs.rmSync(`${filepath}`, { force: true, recursive: true })
                        return
                    }
                    var fileMsg = await msg.channel.send({
                        files: [new Discord.MessageAttachment(`${filepath}/output.gif`)]
                    }).catch(() => { })
                    if (!fileMsg) {
                        await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                        var fileLink = await Catbox.upload(`${filepath}/output.gif`).catch(() => { })
                        if (fileLink) {
                            var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                            if (!fileLinkMsg) {
                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                            }
                        } else {
                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                        }
                    }
                    msg.channel.sendTyping().catch(() => { })
                    fs.rmSync(`${filepath}`, { force: true, recursive: true })
                    return
                }
    
                var fileinfo = await validateFile(currenturl).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })
    
                if (!fileinfo) return
                var type = fileinfo.type
    
                if (type.mime.startsWith('image')) {
                    var currentcount = filecount
                    filecount++
                    fs.mkdirSync(`${filepath}`)
    
                    var writeStream = fs.createWriteStream(`${filepath}/${filename}`)
    
                    require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                        response.pipe(writeStream)
                        writeStream.on('finish', async () => {
                            function waitForAttributeValue(element, attribute, value) {
                                return function () {
                                    return element.getAttribute(attribute).then(result => {
                                        return result === value;
                                    });
                                };
                            }
    
                            await waitForChromeSessionEnd(msg)
                            var driver = await new Builder().forBrowser('chrome').setChromeOptions(new chrome.Options().setUserPreferences({ "download.default_directory": testing ? `${__dirname}\\temp\\file${currentcount}` : `${__dirname.replace(/\\/g, '/')}/${filepath}` })).build().catch(() => { })
                            chromeWindow = driver
                            await driver.get(makesweeturl).catch(() => { })
                            var photobtn = await driver.findElement(By.css('input[type="file"]')).catch(() => { })
                            var animatebtn = await driver.findElement(By.css('li[id="wb-animate"] a')).catch(() => { })
                            var animategifbtn = await driver.findElement(By.css('li[id="wb-make-gif"] a')).catch(() => { })
                            var savebtnli = await driver.findElement(By.css('li[id="wb-working-save"]')).catch(() => { })
                            var savebtn = await driver.findElement(By.css('li[id="wb-working-save"] a')).catch(() => { })
                            await photobtn.sendKeys(`${__dirname.replace(/\\/g, '/')}/${filepath}/${filename}`).catch(() => { })
                            await animatebtn.click().catch(() => { })
                            await animategifbtn.click().catch(() => { })
                            await driver.wait(waitForAttributeValue(savebtnli, 'style', 'display: inline-block;'), 600000).catch(() => { })
                            await savebtn.click().catch(() => { })
                            await sleep(5000)
                            await driver.quit().catch(() => { })
                            chromeWindow = false
                            var files = fs.readdirSync(`${filepath}`)
                            var file = files.find(f => f.includes('makesweet'))
                            try {
                                fs.renameSync(`${filepath}/${file}`, `${filepath}/output.gif`)
                            } catch (_) {
                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                msg.channel.sendTyping().catch(() => { })
                                fs.rmSync(`${filepath}`, { force: true, recursive: true })
                                return
                            }
                            var fileMsg = await msg.channel.send({
                                files: [new Discord.MessageAttachment(`${filepath}/output.gif`)]
                            }).catch(() => { })
                            if (!fileMsg) {
                                await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                var fileLink = await Catbox.upload(`${filepath}/output.gif`).catch(() => { })
                                if (fileLink) {
                                    var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                    if (!fileLinkMsg) {
                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                    }
                                } else {
                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                }
                            }
                            msg.channel.sendTyping().catch(() => { })
                            fs.rmSync(`${filepath}`, { force: true, recursive: true })
                } else if (type.mime.startsWith('video')) {
                    var filepath = await downloadFile(currenturl, `input.mp4`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp4`
                            await execPromise(`ffmpeg -i ${filepath}/${filename} -vframes 1 ${filepath}/frame.png`)
                                function waitForAttributeValue(element, attribute, value) {
                                    return function () {
                                        return element.getAttribute(attribute).then(result => {
                                            return result === value;
                                        });
                                    };
                                }
    
                                await waitForChromeSessionEnd(msg)
                                var driver = await new Builder().forBrowser('chrome').setChromeOptions(new chrome.Options().setUserPreferences({ "download.default_directory": testing ? `${__dirname}\\temp\\file${currentcount}` : `${__dirname.replace(/\\/g, '/')}/${filepath}` })).build().catch(() => { })
                                chromeWindow = driver
                                await driver.get(makesweeturl).catch(() => { })
                                var photobtn = await driver.findElement(By.css('input[type="file"]')).catch(() => { })
                                var animatebtn = await driver.findElement(By.css('li[id="wb-animate"] a')).catch(() => { })
                                var animategifbtn = await driver.findElement(By.css('li[id="wb-make-gif"] a')).catch(() => { })
                                var savebtnli = await driver.findElement(By.css('li[id="wb-working-save"]')).catch(() => { })
                                var savebtn = await driver.findElement(By.css('li[id="wb-working-save"] a')).catch(() => { })
                                await photobtn.sendKeys(`${__dirname.replace(/\\/g, '/')}/${filepath}/frame.png`).catch(() => { })
                                await animatebtn.click().catch(() => { })
                                await animategifbtn.click().catch(() => { })
                                await driver.wait(waitForAttributeValue(savebtnli, 'style', 'display: inline-block;'), 600000).catch(() => { })
                                await savebtn.click().catch(() => { })
                                await sleep(5000)
                                await driver.quit().catch(() => { })
                                chromeWindow = false
                                var files = fs.readdirSync(`${filepath}`)
                                var file = files.find(f => f.includes('makesweet'))
                                try {
                                    fs.renameSync(`${filepath}/${file}`, `${filepath}/output.gif`)
                                } catch (_) {
                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                    msg.channel.sendTyping().catch(() => { })
                                    fs.rmSync(`${filepath}`, { force: true, recursive: true })
                                    return
                                }
                                var fileMsg = await msg.channel.send({
                                    files: [new Discord.MessageAttachment(`${filepath}/output.gif`)]
                                }).catch(() => { })
                                if (!fileMsg) {
                                    await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                    var fileLink = await Catbox.upload(`${filepath}/output.gif`).catch(() => { })
                                    if (fileLink) {
                                        var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                        if (!fileLinkMsg) {
                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                        }
                                    } else {
                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                    }
                                }
                                msg.channel.sendTyping().catch(() => { })
                                fs.rmSync(`${filepath}`, { force: true, recursive: true })
                            })
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "sun/heartsun <file> or \"<text>\"",
                "value": "im underaged (powered by https://makesweet.com/)"
            },
            cooldown: 2500,
            type: "Manipulation"
        },
    
        {
            name: ["fortunecookie", "fortune"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                var makesweeturl = 'https://makesweet.com/my/fortune-cookie'
                var textincluded = true
                var saidMessage = args.join(' ').substring(args[0].length + 1)
                symbolreplacements.forEach(symbolReplacement => {
                    symbolReplacement.target.forEach(target => {
                        saidMessage = saidMessage.replace(new RegExp(target, 'ig'), symbolReplacement.replacement)
                    })
                })
                var matchedTextes = saidMessage.match(/"([\s\S]*?)"/)
                if (!matchedTextes) {
                    textincluded = false
                    matchedTextes = ['""', '']
                }
                var text = matchedTextes[1]
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined && !textincluded) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
                if (textincluded) {
                    var currentcount = filecount
                    filecount++
                    fs.mkdirSync(`${filepath}`)
    
                    function waitForAttributeValue(element, attribute, value) {
                        return function () {
                            return element.getAttribute(attribute).then(result => {
                                return result === value;
                            });
                        };
                    }
    
                    await waitForChromeSessionEnd(msg)
                    var driver = await new Builder().forBrowser('chrome').setChromeOptions(new chrome.Options().setUserPreferences({ "download.default_directory": testing ? `${__dirname}\\temp\\file${currentcount}` : `${__dirname.replace(/\\/g, '/')}/${filepath}` })).build().catch(() => { })
                    chromeWindow = driver
                    await driver.get(makesweeturl).catch(() => { })
                    var textbtn = await driver.findElement(By.id('add_text')).catch(() => { })
                    var animatebtn = await driver.findElement(By.css('li[id="wb-animate"] a')).catch(() => { })
                    var animategifbtn = await driver.findElement(By.css('li[id="wb-make-gif"] a')).catch(() => { })
                    var savebtnli = await driver.findElement(By.css('li[id="wb-working-save"]')).catch(() => { })
                    var savebtn = await driver.findElement(By.css('li[id="wb-working-save"] a')).catch(() => { })
                    await textbtn.click().catch(() => { })
                    await sleep(1000)
                    var textbox = await driver.findElement(By.css('textarea[class="textbar_text"]')).catch(() => { })
                    var textdonebtn = await driver.findElement(By.css('button[class="ok_text ok_button"]')).catch(() => { })
                    await textbox.clear().catch(() => { })
                    await textbox.sendKeys(text).catch(() => { })
                    await textdonebtn.click().catch(() => { })
                    await animatebtn.click().catch(() => { })
                    await animategifbtn.click().catch(() => { })
                    await driver.wait(waitForAttributeValue(savebtnli, 'style', 'display: inline-block;'), 600000).catch(() => { })
                    await savebtn.click().catch(() => { })
                    await sleep(5000)
                    await driver.quit().catch(() => { })
                    chromeWindow = false
                    var files = fs.readdirSync(`${filepath}`)
                    var file = files.find(f => f.includes('makesweet'))
                    try {
                        fs.renameSync(`${filepath}/${file}`, `${filepath}/output.gif`)
                    } catch (_) {
                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                        msg.channel.sendTyping().catch(() => { })
                        fs.rmSync(`${filepath}`, { force: true, recursive: true })
                        return
                    }
                    var fileMsg = await msg.channel.send({
                        files: [new Discord.MessageAttachment(`${filepath}/output.gif`)]
                    }).catch(() => { })
                    if (!fileMsg) {
                        await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                        var fileLink = await Catbox.upload(`${filepath}/output.gif`).catch(() => { })
                        if (fileLink) {
                            var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                            if (!fileLinkMsg) {
                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                            }
                        } else {
                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                        }
                    }
                    msg.channel.sendTyping().catch(() => { })
                    fs.rmSync(`${filepath}`, { force: true, recursive: true })
                    return
                }
    
                var fileinfo = await validateFile(currenturl).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })
    
                if (!fileinfo) return
                var type = fileinfo.type
    
                if (type.mime.startsWith('image')) {
                    var currentcount = filecount
                    filecount++
                    fs.mkdirSync(`${filepath}`)
    
                    var writeStream = fs.createWriteStream(`${filepath}/${filename}`)
    
                    require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                        response.pipe(writeStream)
                        writeStream.on('finish', async () => {
                            function waitForAttributeValue(element, attribute, value) {
                                return function () {
                                    return element.getAttribute(attribute).then(result => {
                                        return result === value;
                                    });
                                };
                            }
    
                            await waitForChromeSessionEnd(msg)
                            var driver = await new Builder().forBrowser('chrome').setChromeOptions(new chrome.Options().setUserPreferences({ "download.default_directory": testing ? `${__dirname}\\temp\\file${currentcount}` : `${__dirname.replace(/\\/g, '/')}/${filepath}` })).build().catch(() => { })
                            chromeWindow = driver
                            await driver.get(makesweeturl).catch(() => { })
                            var photobtn = await driver.findElement(By.css('input[type="file"]')).catch(() => { })
                            var animatebtn = await driver.findElement(By.css('li[id="wb-animate"] a')).catch(() => { })
                            var animategifbtn = await driver.findElement(By.css('li[id="wb-make-gif"] a')).catch(() => { })
                            var savebtnli = await driver.findElement(By.css('li[id="wb-working-save"]')).catch(() => { })
                            var savebtn = await driver.findElement(By.css('li[id="wb-working-save"] a')).catch(() => { })
                            await photobtn.sendKeys(`${__dirname.replace(/\\/g, '/')}/${filepath}/${filename}`).catch(() => { })
                            await animatebtn.click().catch(() => { })
                            await animategifbtn.click().catch(() => { })
                            await driver.wait(waitForAttributeValue(savebtnli, 'style', 'display: inline-block;'), 600000).catch(() => { })
                            await savebtn.click().catch(() => { })
                            await sleep(5000)
                            await driver.quit().catch(() => { })
                            chromeWindow = false
                            var files = fs.readdirSync(`${filepath}`)
                            var file = files.find(f => f.includes('makesweet'))
                            try {
                                fs.renameSync(`${filepath}/${file}`, `${filepath}/output.gif`)
                            } catch (_) {
                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                msg.channel.sendTyping().catch(() => { })
                                fs.rmSync(`${filepath}`, { force: true, recursive: true })
                                return
                            }
                            var fileMsg = await msg.channel.send({
                                files: [new Discord.MessageAttachment(`${filepath}/output.gif`)]
                            }).catch(() => { })
                            if (!fileMsg) {
                                await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                var fileLink = await Catbox.upload(`${filepath}/output.gif`).catch(() => { })
                                if (fileLink) {
                                    var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                    if (!fileLinkMsg) {
                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                    }
                                } else {
                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                }
                            }
                            msg.channel.sendTyping().catch(() => { })
                            fs.rmSync(`${filepath}`, { force: true, recursive: true })
                } else if (type.mime.startsWith('video')) {
                    var filepath = await downloadFile(currenturl, `input.mp4`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp4`
                            await execPromise(`ffmpeg -i ${filepath}/${filename} -vframes 1 ${filepath}/frame.png`)
                                function waitForAttributeValue(element, attribute, value) {
                                    return function () {
                                        return element.getAttribute(attribute).then(result => {
                                            return result === value;
                                        });
                                    };
                                }
    
                                await waitForChromeSessionEnd(msg)
                                var driver = await new Builder().forBrowser('chrome').setChromeOptions(new chrome.Options().setUserPreferences({ "download.default_directory": testing ? `${__dirname}\\temp\\file${currentcount}` : `${__dirname.replace(/\\/g, '/')}/${filepath}` })).build().catch(() => { })
                                chromeWindow = driver
                                await driver.get(makesweeturl).catch(() => { })
                                var photobtn = await driver.findElement(By.css('input[type="file"]')).catch(() => { })
                                var animatebtn = await driver.findElement(By.css('li[id="wb-animate"] a')).catch(() => { })
                                var animategifbtn = await driver.findElement(By.css('li[id="wb-make-gif"] a')).catch(() => { })
                                var savebtnli = await driver.findElement(By.css('li[id="wb-working-save"]')).catch(() => { })
                                var savebtn = await driver.findElement(By.css('li[id="wb-working-save"] a')).catch(() => { })
                                await photobtn.sendKeys(`${__dirname.replace(/\\/g, '/')}/${filepath}/frame.png`).catch(() => { })
                                await animatebtn.click().catch(() => { })
                                await animategifbtn.click().catch(() => { })
                                await driver.wait(waitForAttributeValue(savebtnli, 'style', 'display: inline-block;'), 600000).catch(() => { })
                                await savebtn.click().catch(() => { })
                                await sleep(5000)
                                await driver.quit().catch(() => { })
                                chromeWindow = false
                                var files = fs.readdirSync(`${filepath}`)
                                var file = files.find(f => f.includes('makesweet'))
                                try {
                                    fs.renameSync(`${filepath}/${file}`, `${filepath}/output.gif`)
                                } catch (_) {
                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                    msg.channel.sendTyping().catch(() => { })
                                    fs.rmSync(`${filepath}`, { force: true, recursive: true })
                                    return
                                }
                                var fileMsg = await msg.channel.send({
                                    files: [new Discord.MessageAttachment(`${filepath}/output.gif`)]
                                }).catch(() => { })
                                if (!fileMsg) {
                                    await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                    var fileLink = await Catbox.upload(`${filepath}/output.gif`).catch(() => { })
                                    if (fileLink) {
                                        var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                        if (!fileLinkMsg) {
                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                        }
                                    } else {
                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                    }
                                }
                                msg.channel.sendTyping().catch(() => { })
                                fs.rmSync(`${filepath}`, { force: true, recursive: true })
                            })
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "fortunecookie/fortune <file> or \"<text>\"",
                "value": "Reveals your fortune...? (powered by https://makesweet.com/)"
            },
            cooldown: 2500,
            type: "Manipulation"
        },
    
        {
            name: ["cube"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var animationname = 'Horiz. Rotating Cube'
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
                var fileinfo = await validateFile(currenturl).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })
    
                if (!fileinfo) return
                var type = fileinfo.type
    
                if (type.mime.startsWith('image')) {
                    var currentcount = filecount
                    filecount++
                    fs.mkdirSync(`${filepath}`)
    
                    var writeStream = fs.createWriteStream(`${filepath}/${filename}`)
    
                    require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                        response.pipe(writeStream)
                        writeStream.on('finish', async () => {
                            function waitForAttributeValue(element, attribute, value) {
                                return function () {
                                    return element.getAttribute(attribute).then(result => {
                                        return result === value;
                                    });
                                };
                            }
    
                            await waitForChromeSessionEnd(msg)
                            var driver = await new Builder().forBrowser('chrome').setChromeOptions(new chrome.Options().setUserPreferences({ "download.default_directory": testing ? `${__dirname}\\temp\\file${currentcount}` : `${__dirname.replace(/\\/g, '/')}/${filepath}` })).build().catch(() => { })
                            chromeWindow = driver
                            await driver.get('https://www.3dgifmaker.com/').catch(() => { })
                            var inputbtn = await driver.findElement(By.css('input[class="upload-button__input"]')).catch(() => { })
                            var animationmenu = await driver.findElement(By.css('div[class="react-dropdown-select animation-select__input css-wmw4vi-ReactDropdownSelect e1gzf2xs0"]')).catch(() => { })
                            var fpspencil = await driver.findElement(By.css('div[class="slider-input home-main-card__frame-rate-slider"] div span[class="slider-input__pencil"]')).catch(() => { })
                            var fps = await driver.findElement(By.css('div[class="slider-input home-main-card__frame-rate-slider"] div input[class="slider-input__input slider-input__input--hidden"]')).catch(() => { })
                            var framespencil = await driver.findElement(By.css('div[class="slider-input home-main-card__total-frames-slider"] div span[class="slider-input__pencil"]')).catch(() => { })
                            var frames = await driver.findElement(By.css('div[class="slider-input home-main-card__total-frames-slider"] div input[class="slider-input__input slider-input__input--hidden"]')).catch(() => { })
                            var transparentcheck = await driver.findElement(By.css('input[class="transparent-checkbox__input"]')).catch(() => { })
                            var downloadgif = await driver.findElement(By.css('span[class="home-main-card__options-group home-main-card__options-group--download-buttons"] button')).catch(() => { })
                            await inputbtn.sendKeys(`${__dirname.replace(/\\/g, '/')}/${filepath}/${filename}`).catch(() => { })
                            await animationmenu.click().catch(() => { })
                            var animation = await driver.findElement(By.css(`span[aria-label="${animationname}"]`)).catch(() => { })
                            await animation.click().catch(() => { })
                            await fpspencil.click().catch(() => { })
                            await fps.clear().catch(() => { })
                            await fps.sendKeys('65').catch(() => { })
                            await fpspencil.click().catch(() => { })
                            await framespencil.click().catch(() => { })
                            await frames.clear().catch(() => { })
                            await frames.sendKeys('50').catch(() => { })
                            await framespencil.click().catch(() => { })
                            await transparentcheck.click().catch(() => { })
                            await downloadgif.click().catch(() => { })
                            var downloadinggif = await driver.findElement(By.css('span[class="home-main-card__options-group home-main-card__options-group--download-buttons"] button[class="create-button create-button--downloading"]')).catch(() => { })
                            await driver.wait(waitForAttributeValue(downloadinggif, 'class', 'create-button'), 600000).catch(() => { })
                            await sleep(5000)
                            await driver.quit().catch(() => { })
                            chromeWindow = false
                            var files = fs.readdirSync(`${filepath}`)
                            var file = files.find(f => f.includes('3dgifmaker'))
                            try {
                                fs.renameSync(`${filepath}/${file}`, `${filepath}/output.gif`)
                            } catch (_) {
                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                msg.channel.sendTyping().catch(() => { })
                                fs.rmSync(`${filepath}`, { force: true, recursive: true })
                                return
                            }
                            var fileMsg = await msg.channel.send({
                                files: [new Discord.MessageAttachment(`${filepath}/output.gif`)]
                            }).catch(() => { })
                            if (!fileMsg) {
                                await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                var fileLink = await Catbox.upload(`${filepath}/output.gif`).catch(() => { })
                                if (fileLink) {
                                    var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                    if (!fileLinkMsg) {
                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                    }
                                } else {
                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                }
                            }
                            msg.channel.sendTyping().catch(() => { })
                            fs.rmSync(`${filepath}`, { force: true, recursive: true })
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "cube <image/gif>",
                "value": "Creates a 3D rotating cube out of the image/GIF. (powered by https://www.3dgifmaker.com/)"
            },
            cooldown: 2500,
            type: "Manipulation"
        },
    
        {
            name: ["diagonalcube"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var animationname = 'Diag. Rotating Cube'
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
                var fileinfo = await validateFile(currenturl).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })
    
                if (!fileinfo) return
                var type = fileinfo.type
    
                if (type.mime.startsWith('image')) {
                    var currentcount = filecount
                    filecount++
                    fs.mkdirSync(`${filepath}`)
    
                    var writeStream = fs.createWriteStream(`${filepath}/${filename}`)
    
                    require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                        response.pipe(writeStream)
                        writeStream.on('finish', async () => {
                            function waitForAttributeValue(element, attribute, value) {
                                return function () {
                                    return element.getAttribute(attribute).then(result => {
                                        return result === value;
                                    });
                                };
                            }
    
                            await waitForChromeSessionEnd(msg)
                            var driver = await new Builder().forBrowser('chrome').setChromeOptions(new chrome.Options().setUserPreferences({ "download.default_directory": testing ? `${__dirname}\\temp\\file${currentcount}` : `${__dirname.replace(/\\/g, '/')}/${filepath}` })).build().catch(() => { })
                            chromeWindow = driver
                            await driver.get('https://www.3dgifmaker.com/').catch(() => { })
                            var inputbtn = await driver.findElement(By.css('input[class="upload-button__input"]')).catch(() => { })
                            var animationmenu = await driver.findElement(By.css('div[class="react-dropdown-select animation-select__input css-wmw4vi-ReactDropdownSelect e1gzf2xs0"]')).catch(() => { })
                            var fpspencil = await driver.findElement(By.css('div[class="slider-input home-main-card__frame-rate-slider"] div span[class="slider-input__pencil"]')).catch(() => { })
                            var fps = await driver.findElement(By.css('div[class="slider-input home-main-card__frame-rate-slider"] div input[class="slider-input__input slider-input__input--hidden"]')).catch(() => { })
                            var framespencil = await driver.findElement(By.css('div[class="slider-input home-main-card__total-frames-slider"] div span[class="slider-input__pencil"]')).catch(() => { })
                            var frames = await driver.findElement(By.css('div[class="slider-input home-main-card__total-frames-slider"] div input[class="slider-input__input slider-input__input--hidden"]')).catch(() => { })
                            var transparentcheck = await driver.findElement(By.css('input[class="transparent-checkbox__input"]')).catch(() => { })
                            var downloadgif = await driver.findElement(By.css('span[class="home-main-card__options-group home-main-card__options-group--download-buttons"] button')).catch(() => { })
                            await inputbtn.sendKeys(`${__dirname.replace(/\\/g, '/')}/${filepath}/${filename}`).catch(() => { })
                            await animationmenu.click().catch(() => { })
                            var animation = await driver.findElement(By.css(`span[aria-label="${animationname}"]`)).catch(() => { })
                            await animation.click().catch(() => { })
                            await fpspencil.click().catch(() => { })
                            await fps.clear().catch(() => { })
                            await fps.sendKeys('65').catch(() => { })
                            await fpspencil.click().catch(() => { })
                            await framespencil.click().catch(() => { })
                            await frames.clear().catch(() => { })
                            await frames.sendKeys('50').catch(() => { })
                            await framespencil.click().catch(() => { })
                            await transparentcheck.click().catch(() => { })
                            await downloadgif.click().catch(() => { })
                            var downloadinggif = await driver.findElement(By.css('span[class="home-main-card__options-group home-main-card__options-group--download-buttons"] button[class="create-button create-button--downloading"]')).catch(() => { })
                            await driver.wait(waitForAttributeValue(downloadinggif, 'class', 'create-button'), 600000).catch(() => { })
                            await sleep(5000)
                            await driver.quit().catch(() => { })
                            chromeWindow = false
                            var files = fs.readdirSync(`${filepath}`)
                            var file = files.find(f => f.includes('3dgifmaker'))
                            try {
                                fs.renameSync(`${filepath}/${file}`, `${filepath}/output.gif`)
                            } catch (_) {
                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                msg.channel.sendTyping().catch(() => { })
                                fs.rmSync(`${filepath}`, { force: true, recursive: true })
                                return
                            }
                            var fileMsg = await msg.channel.send({
                                files: [new Discord.MessageAttachment(`${filepath}/output.gif`)]
                            }).catch(() => { })
                            if (!fileMsg) {
                                await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                var fileLink = await Catbox.upload(`${filepath}/output.gif`).catch(() => { })
                                if (fileLink) {
                                    var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                    if (!fileLinkMsg) {
                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                    }
                                } else {
                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                }
                            }
                            msg.channel.sendTyping().catch(() => { })
                            fs.rmSync(`${filepath}`, { force: true, recursive: true })
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "diagonalcube <image/gif>",
                "value": "Creates a 3D diagonal rotating cube out of the image/GIF. (powered by https://www.3dgifmaker.com/)"
            },
            cooldown: 2500,
            type: "Manipulation"
        },
    
        {
            name: ["pyramid"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var animationname = 'Pyramid'
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
                var fileinfo = await validateFile(currenturl).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })
    
                if (!fileinfo) return
                var type = fileinfo.type
    
                if (type.mime.startsWith('image')) {
                    var currentcount = filecount
                    filecount++
                    fs.mkdirSync(`${filepath}`)
    
                    var writeStream = fs.createWriteStream(`${filepath}/${filename}`)
    
                    require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                        response.pipe(writeStream)
                        writeStream.on('finish', async () => {
                            function waitForAttributeValue(element, attribute, value) {
                                return function () {
                                    return element.getAttribute(attribute).then(result => {
                                        return result === value;
                                    });
                                };
                            }
    
                            await waitForChromeSessionEnd(msg)
                            var driver = await new Builder().forBrowser('chrome').setChromeOptions(new chrome.Options().setUserPreferences({ "download.default_directory": testing ? `${__dirname}\\temp\\file${currentcount}` : `${__dirname.replace(/\\/g, '/')}/${filepath}` })).build().catch(() => { })
                            chromeWindow = driver
                            await driver.get('https://www.3dgifmaker.com/').catch(() => { })
                            var inputbtn = await driver.findElement(By.css('input[class="upload-button__input"]')).catch(() => { })
                            var animationmenu = await driver.findElement(By.css('div[class="react-dropdown-select animation-select__input css-wmw4vi-ReactDropdownSelect e1gzf2xs0"]')).catch(() => { })
                            var fpspencil = await driver.findElement(By.css('div[class="slider-input home-main-card__frame-rate-slider"] div span[class="slider-input__pencil"]')).catch(() => { })
                            var fps = await driver.findElement(By.css('div[class="slider-input home-main-card__frame-rate-slider"] div input[class="slider-input__input slider-input__input--hidden"]')).catch(() => { })
                            var framespencil = await driver.findElement(By.css('div[class="slider-input home-main-card__total-frames-slider"] div span[class="slider-input__pencil"]')).catch(() => { })
                            var frames = await driver.findElement(By.css('div[class="slider-input home-main-card__total-frames-slider"] div input[class="slider-input__input slider-input__input--hidden"]')).catch(() => { })
                            var transparentcheck = await driver.findElement(By.css('input[class="transparent-checkbox__input"]')).catch(() => { })
                            var downloadgif = await driver.findElement(By.css('span[class="home-main-card__options-group home-main-card__options-group--download-buttons"] button')).catch(() => { })
                            await inputbtn.sendKeys(`${__dirname.replace(/\\/g, '/')}/${filepath}/${filename}`).catch(() => { })
                            await animationmenu.click().catch(() => { })
                            var animation = await driver.findElement(By.css(`span[aria-label="${animationname}"]`)).catch(() => { })
                            await animation.click().catch(() => { })
                            await fpspencil.click().catch(() => { })
                            await fps.clear().catch(() => { })
                            await fps.sendKeys('65').catch(() => { })
                            await fpspencil.click().catch(() => { })
                            await framespencil.click().catch(() => { })
                            await frames.clear().catch(() => { })
                            await frames.sendKeys('50').catch(() => { })
                            await framespencil.click().catch(() => { })
                            await transparentcheck.click().catch(() => { })
                            await downloadgif.click().catch(() => { })
                            var downloadinggif = await driver.findElement(By.css('span[class="home-main-card__options-group home-main-card__options-group--download-buttons"] button[class="create-button create-button--downloading"]')).catch(() => { })
                            await driver.wait(waitForAttributeValue(downloadinggif, 'class', 'create-button'), 600000).catch(() => { })
                            await sleep(5000)
                            await driver.quit().catch(() => { })
                            chromeWindow = false
                            var files = fs.readdirSync(`${filepath}`)
                            var file = files.find(f => f.includes('3dgifmaker'))
                            try {
                                fs.renameSync(`${filepath}/${file}`, `${filepath}/output.gif`)
                            } catch (_) {
                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                msg.channel.sendTyping().catch(() => { })
                                fs.rmSync(`${filepath}`, { force: true, recursive: true })
                                return
                            }
                            var fileMsg = await msg.channel.send({
                                files: [new Discord.MessageAttachment(`${filepath}/output.gif`)]
                            }).catch(() => { })
                            if (!fileMsg) {
                                await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                var fileLink = await Catbox.upload(`${filepath}/output.gif`).catch(() => { })
                                if (fileLink) {
                                    var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                    if (!fileLinkMsg) {
                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                    }
                                } else {
                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                }
                            }
                            msg.channel.sendTyping().catch(() => { })
                            fs.rmSync(`${filepath}`, { force: true, recursive: true })
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "pyramid <image/gif>",
                "value": "Creates a 3D rotating pyramid out of the image/GIF. (powered by https://www.3dgifmaker.com/)"
            },
            cooldown: 2500,
            type: "Manipulation"
        },
    
        {
            name: ["sphere"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var animationname = 'Rotating Sphere'
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
                var fileinfo = await validateFile(currenturl).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })
    
                if (!fileinfo) return
                var type = fileinfo.type
    
                if (type.mime.startsWith('image')) {
                    var currentcount = filecount
                    filecount++
                    fs.mkdirSync(`${filepath}`)
    
                    var writeStream = fs.createWriteStream(`${filepath}/${filename}`)
    
                    require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                        response.pipe(writeStream)
                        writeStream.on('finish', async () => {
                            function waitForAttributeValue(element, attribute, value) {
                                return function () {
                                    return element.getAttribute(attribute).then(result => {
                                        return result === value;
                                    });
                                };
                            }
    
                            await waitForChromeSessionEnd(msg)
                            var driver = await new Builder().forBrowser('chrome').setChromeOptions(new chrome.Options().setUserPreferences({ "download.default_directory": testing ? `${__dirname}\\temp\\file${currentcount}` : `${__dirname.replace(/\\/g, '/')}/${filepath}` })).build().catch(() => { })
                            chromeWindow = driver
                            await driver.get('https://www.3dgifmaker.com/').catch(() => { })
                            var inputbtn = await driver.findElement(By.css('input[class="upload-button__input"]')).catch(() => { })
                            var animationmenu = await driver.findElement(By.css('div[class="react-dropdown-select animation-select__input css-wmw4vi-ReactDropdownSelect e1gzf2xs0"]')).catch(() => { })
                            var fpspencil = await driver.findElement(By.css('div[class="slider-input home-main-card__frame-rate-slider"] div span[class="slider-input__pencil"]')).catch(() => { })
                            var fps = await driver.findElement(By.css('div[class="slider-input home-main-card__frame-rate-slider"] div input[class="slider-input__input slider-input__input--hidden"]')).catch(() => { })
                            var framespencil = await driver.findElement(By.css('div[class="slider-input home-main-card__total-frames-slider"] div span[class="slider-input__pencil"]')).catch(() => { })
                            var frames = await driver.findElement(By.css('div[class="slider-input home-main-card__total-frames-slider"] div input[class="slider-input__input slider-input__input--hidden"]')).catch(() => { })
                            var transparentcheck = await driver.findElement(By.css('input[class="transparent-checkbox__input"]')).catch(() => { })
                            var downloadgif = await driver.findElement(By.css('span[class="home-main-card__options-group home-main-card__options-group--download-buttons"] button')).catch(() => { })
                            await inputbtn.sendKeys(`${__dirname.replace(/\\/g, '/')}/${filepath}/${filename}`).catch(() => { })
                            await animationmenu.click().catch(() => { })
                            var animation = await driver.findElement(By.css(`span[aria-label="${animationname}"]`)).catch(() => { })
                            await animation.click().catch(() => { })
                            await fpspencil.click().catch(() => { })
                            await fps.clear().catch(() => { })
                            await fps.sendKeys('65').catch(() => { })
                            await fpspencil.click().catch(() => { })
                            await framespencil.click().catch(() => { })
                            await frames.clear().catch(() => { })
                            await frames.sendKeys('50').catch(() => { })
                            await framespencil.click().catch(() => { })
                            await transparentcheck.click().catch(() => { })
                            await downloadgif.click().catch(() => { })
                            var downloadinggif = await driver.findElement(By.css('span[class="home-main-card__options-group home-main-card__options-group--download-buttons"] button[class="create-button create-button--downloading"]')).catch(() => { })
                            await driver.wait(waitForAttributeValue(downloadinggif, 'class', 'create-button'), 600000).catch(() => { })
                            await sleep(5000)
                            await driver.quit().catch(() => { })
                            chromeWindow = false
                            var files = fs.readdirSync(`${filepath}`)
                            var file = files.find(f => f.includes('3dgifmaker'))
                            try {
                                fs.renameSync(`${filepath}/${file}`, `${filepath}/output.gif`)
                            } catch (_) {
                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                msg.channel.sendTyping().catch(() => { })
                                fs.rmSync(`${filepath}`, { force: true, recursive: true })
                                return
                            }
                            var fileMsg = await msg.channel.send({
                                files: [new Discord.MessageAttachment(`${filepath}/output.gif`)]
                            }).catch(() => { })
                            if (!fileMsg) {
                                await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                var fileLink = await Catbox.upload(`${filepath}/output.gif`).catch(() => { })
                                if (fileLink) {
                                    var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                    if (!fileLinkMsg) {
                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                    }
                                } else {
                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                }
                            }
                            msg.channel.sendTyping().catch(() => { })
                            fs.rmSync(`${filepath}`, { force: true, recursive: true })
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "sphere <image/gif>",
                "value": "Creates a 3D rotating sphere out of the image/GIF. (powered by https://www.3dgifmaker.com/)"
            },
            cooldown: 2500,
            type: "Manipulation"
        },
    
        {
            name: ["donut"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var animationname = 'Rotating Donut'
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
                var fileinfo = await validateFile(currenturl).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })
    
                if (!fileinfo) return
                var type = fileinfo.type
    
                if (type.mime.startsWith('image')) {
                    var currentcount = filecount
                    filecount++
                    fs.mkdirSync(`${filepath}`)
    
                    var writeStream = fs.createWriteStream(`${filepath}/${filename}`)
    
                    require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                        response.pipe(writeStream)
                        writeStream.on('finish', async () => {
                            function waitForAttributeValue(element, attribute, value) {
                                return function () {
                                    return element.getAttribute(attribute).then(result => {
                                        return result === value;
                                    });
                                };
                            }
    
                            await waitForChromeSessionEnd(msg)
                            var driver = await new Builder().forBrowser('chrome').setChromeOptions(new chrome.Options().setUserPreferences({ "download.default_directory": testing ? `${__dirname}\\temp\\file${currentcount}` : `${__dirname.replace(/\\/g, '/')}/${filepath}` })).build().catch(() => { })
                            chromeWindow = driver
                            await driver.get('https://www.3dgifmaker.com/').catch(() => { })
                            var inputbtn = await driver.findElement(By.css('input[class="upload-button__input"]')).catch(() => { })
                            var animationmenu = await driver.findElement(By.css('div[class="react-dropdown-select animation-select__input css-wmw4vi-ReactDropdownSelect e1gzf2xs0"]')).catch(() => { })
                            var fpspencil = await driver.findElement(By.css('div[class="slider-input home-main-card__frame-rate-slider"] div span[class="slider-input__pencil"]')).catch(() => { })
                            var fps = await driver.findElement(By.css('div[class="slider-input home-main-card__frame-rate-slider"] div input[class="slider-input__input slider-input__input--hidden"]')).catch(() => { })
                            var framespencil = await driver.findElement(By.css('div[class="slider-input home-main-card__total-frames-slider"] div span[class="slider-input__pencil"]')).catch(() => { })
                            var frames = await driver.findElement(By.css('div[class="slider-input home-main-card__total-frames-slider"] div input[class="slider-input__input slider-input__input--hidden"]')).catch(() => { })
                            var transparentcheck = await driver.findElement(By.css('input[class="transparent-checkbox__input"]')).catch(() => { })
                            var downloadgif = await driver.findElement(By.css('span[class="home-main-card__options-group home-main-card__options-group--download-buttons"] button')).catch(() => { })
                            await inputbtn.sendKeys(`${__dirname.replace(/\\/g, '/')}/${filepath}/${filename}`).catch(() => { })
                            await animationmenu.click().catch(() => { })
                            var animation = await driver.findElement(By.css(`span[aria-label="${animationname}"]`)).catch(() => { })
                            await animation.click().catch(() => { })
                            await fpspencil.click().catch(() => { })
                            await fps.clear().catch(() => { })
                            await fps.sendKeys('65').catch(() => { })
                            await fpspencil.click().catch(() => { })
                            await framespencil.click().catch(() => { })
                            await frames.clear().catch(() => { })
                            await frames.sendKeys('50').catch(() => { })
                            await framespencil.click().catch(() => { })
                            await transparentcheck.click().catch(() => { })
                            await downloadgif.click().catch(() => { })
                            var downloadinggif = await driver.findElement(By.css('span[class="home-main-card__options-group home-main-card__options-group--download-buttons"] button[class="create-button create-button--downloading"]')).catch(() => { })
                            await driver.wait(waitForAttributeValue(downloadinggif, 'class', 'create-button'), 600000).catch(() => { })
                            await sleep(5000)
                            await driver.quit().catch(() => { })
                            chromeWindow = false
                            var files = fs.readdirSync(`${filepath}`)
                            var file = files.find(f => f.includes('3dgifmaker'))
                            try {
                                fs.renameSync(`${filepath}/${file}`, `${filepath}/output.gif`)
                            } catch (_) {
                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                msg.channel.sendTyping().catch(() => { })
                                fs.rmSync(`${filepath}`, { force: true, recursive: true })
                                return
                            }
                            var fileMsg = await msg.channel.send({
                                files: [new Discord.MessageAttachment(`${filepath}/output.gif`)]
                            }).catch(() => { })
                            if (!fileMsg) {
                                await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                var fileLink = await Catbox.upload(`${filepath}/output.gif`).catch(() => { })
                                if (fileLink) {
                                    var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                    if (!fileLinkMsg) {
                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                    }
                                } else {
                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                }
                            }
                            msg.channel.sendTyping().catch(() => { })
                            fs.rmSync(`${filepath}`, { force: true, recursive: true })
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "donut <image/gif>",
                "value": "Creates a 3D rotating donut out of the image/GIF. (powered by https://www.3dgifmaker.com/)"
            },
            cooldown: 2500,
            type: "Manipulation"
        },
    
        {
            name: ["planet", "solarsystem"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var animationname = 'Sun and Planet'
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
                var fileinfo = await validateFile(currenturl).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })
    
                if (!fileinfo) return
                var type = fileinfo.type
    
                if (type.mime.startsWith('image')) {
                    var currentcount = filecount
                    filecount++
                    fs.mkdirSync(`${filepath}`)
    
                    var writeStream = fs.createWriteStream(`${filepath}/${filename}`)
    
                    require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                        response.pipe(writeStream)
                        writeStream.on('finish', async () => {
                            function waitForAttributeValue(element, attribute, value) {
                                return function () {
                                    return element.getAttribute(attribute).then(result => {
                                        return result === value;
                                    });
                                };
                            }
    
                            await waitForChromeSessionEnd(msg)
                            var driver = await new Builder().forBrowser('chrome').setChromeOptions(new chrome.Options().setUserPreferences({ "download.default_directory": testing ? `${__dirname}\\temp\\file${currentcount}` : `${__dirname.replace(/\\/g, '/')}/${filepath}` })).build().catch(() => { })
                            chromeWindow = driver
                            await driver.get('https://www.3dgifmaker.com/').catch(() => { })
                            var inputbtn = await driver.findElement(By.css('input[class="upload-button__input"]')).catch(() => { })
                            var animationmenu = await driver.findElement(By.css('div[class="react-dropdown-select animation-select__input css-wmw4vi-ReactDropdownSelect e1gzf2xs0"]')).catch(() => { })
                            var fpspencil = await driver.findElement(By.css('div[class="slider-input home-main-card__frame-rate-slider"] div span[class="slider-input__pencil"]')).catch(() => { })
                            var fps = await driver.findElement(By.css('div[class="slider-input home-main-card__frame-rate-slider"] div input[class="slider-input__input slider-input__input--hidden"]')).catch(() => { })
                            var framespencil = await driver.findElement(By.css('div[class="slider-input home-main-card__total-frames-slider"] div span[class="slider-input__pencil"]')).catch(() => { })
                            var frames = await driver.findElement(By.css('div[class="slider-input home-main-card__total-frames-slider"] div input[class="slider-input__input slider-input__input--hidden"]')).catch(() => { })
                            var transparentcheck = await driver.findElement(By.css('input[class="transparent-checkbox__input"]')).catch(() => { })
                            var downloadgif = await driver.findElement(By.css('span[class="home-main-card__options-group home-main-card__options-group--download-buttons"] button')).catch(() => { })
                            await inputbtn.sendKeys(`${__dirname.replace(/\\/g, '/')}/${filepath}/${filename}`).catch(() => { })
                            await animationmenu.click().catch(() => { })
                            var animation = await driver.findElement(By.css(`span[aria-label="${animationname}"]`)).catch(() => { })
                            await animation.click().catch(() => { })
                            await fpspencil.click().catch(() => { })
                            await fps.clear().catch(() => { })
                            await fps.sendKeys('65').catch(() => { })
                            await fpspencil.click().catch(() => { })
                            await framespencil.click().catch(() => { })
                            await frames.clear().catch(() => { })
                            await frames.sendKeys('50').catch(() => { })
                            await framespencil.click().catch(() => { })
                            await transparentcheck.click().catch(() => { })
                            await downloadgif.click().catch(() => { })
                            var downloadinggif = await driver.findElement(By.css('span[class="home-main-card__options-group home-main-card__options-group--download-buttons"] button[class="create-button create-button--downloading"]')).catch(() => { })
                            await driver.wait(waitForAttributeValue(downloadinggif, 'class', 'create-button'), 600000).catch(() => { })
                            await sleep(5000)
                            await driver.quit().catch(() => { })
                            chromeWindow = false
                            var files = fs.readdirSync(`${filepath}`)
                            var file = files.find(f => f.includes('3dgifmaker'))
                            try {
                                fs.renameSync(`${filepath}/${file}`, `${filepath}/output.gif`)
                            } catch (_) {
                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                msg.channel.sendTyping().catch(() => { })
                                fs.rmSync(`${filepath}`, { force: true, recursive: true })
                                return
                            }
                            var fileMsg = await msg.channel.send({
                                files: [new Discord.MessageAttachment(`${filepath}/output.gif`)]
                            }).catch(() => { })
                            if (!fileMsg) {
                                await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                var fileLink = await Catbox.upload(`${filepath}/output.gif`).catch(() => { })
                                if (fileLink) {
                                    var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                    if (!fileLinkMsg) {
                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                    }
                                } else {
                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                }
                            }
                            msg.channel.sendTyping().catch(() => { })
                            fs.rmSync(`${filepath}`, { force: true, recursive: true })
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "planet/solarsystem <image/gif>",
                "value": "Creates a 3D rotating solar system out of the image/GIF. (powered by https://www.3dgifmaker.com/)"
            },
            cooldown: 2500,
            type: "Manipulation"
        },
    
        {
            name: ["3dspin"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var animationname = '360 Spin'
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
                var fileinfo = await validateFile(currenturl).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })
    
                if (!fileinfo) return
                var type = fileinfo.type
    
                if (type.mime.startsWith('image')) {
                    var currentcount = filecount
                    filecount++
                    fs.mkdirSync(`${filepath}`)
    
                    var writeStream = fs.createWriteStream(`${filepath}/${filename}`)
    
                    require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                        response.pipe(writeStream)
                        writeStream.on('finish', async () => {
                            function waitForAttributeValue(element, attribute, value) {
                                return function () {
                                    return element.getAttribute(attribute).then(result => {
                                        return result === value;
                                    });
                                };
                            }
    
                            await waitForChromeSessionEnd(msg)
                            var driver = await new Builder().forBrowser('chrome').setChromeOptions(new chrome.Options().setUserPreferences({ "download.default_directory": testing ? `${__dirname}\\temp\\file${currentcount}` : `${__dirname.replace(/\\/g, '/')}/${filepath}` })).build().catch(() => { })
                            chromeWindow = driver
                            await driver.get('https://www.3dgifmaker.com/').catch(() => { })
                            var inputbtn = await driver.findElement(By.css('input[class="upload-button__input"]')).catch(() => { })
                            var animationmenu = await driver.findElement(By.css('div[class="react-dropdown-select animation-select__input css-wmw4vi-ReactDropdownSelect e1gzf2xs0"]')).catch(() => { })
                            var fpspencil = await driver.findElement(By.css('div[class="slider-input home-main-card__frame-rate-slider"] div span[class="slider-input__pencil"]')).catch(() => { })
                            var fps = await driver.findElement(By.css('div[class="slider-input home-main-card__frame-rate-slider"] div input[class="slider-input__input slider-input__input--hidden"]')).catch(() => { })
                            var framespencil = await driver.findElement(By.css('div[class="slider-input home-main-card__total-frames-slider"] div span[class="slider-input__pencil"]')).catch(() => { })
                            var frames = await driver.findElement(By.css('div[class="slider-input home-main-card__total-frames-slider"] div input[class="slider-input__input slider-input__input--hidden"]')).catch(() => { })
                            var transparentcheck = await driver.findElement(By.css('input[class="transparent-checkbox__input"]')).catch(() => { })
                            var downloadgif = await driver.findElement(By.css('span[class="home-main-card__options-group home-main-card__options-group--download-buttons"] button')).catch(() => { })
                            await inputbtn.sendKeys(`${__dirname.replace(/\\/g, '/')}/${filepath}/${filename}`).catch(() => { })
                            await animationmenu.click().catch(() => { })
                            var animation = await driver.findElement(By.css(`span[aria-label="${animationname}"]`)).catch(() => { })
                            await animation.click().catch(() => { })
                            await fpspencil.click().catch(() => { })
                            await fps.clear().catch(() => { })
                            await fps.sendKeys('65').catch(() => { })
                            await fpspencil.click().catch(() => { })
                            await framespencil.click().catch(() => { })
                            await frames.clear().catch(() => { })
                            await frames.sendKeys('50').catch(() => { })
                            await framespencil.click().catch(() => { })
                            await transparentcheck.click().catch(() => { })
                            await downloadgif.click().catch(() => { })
                            var downloadinggif = await driver.findElement(By.css('span[class="home-main-card__options-group home-main-card__options-group--download-buttons"] button[class="create-button create-button--downloading"]')).catch(() => { })
                            await driver.wait(waitForAttributeValue(downloadinggif, 'class', 'create-button'), 600000).catch(() => { })
                            await sleep(5000)
                            await driver.quit().catch(() => { })
                            chromeWindow = false
                            var files = fs.readdirSync(`${filepath}`)
                            var file = files.find(f => f.includes('3dgifmaker'))
                            try {
                                fs.renameSync(`${filepath}/${file}`, `${filepath}/output.gif`)
                            } catch (_) {
                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                msg.channel.sendTyping().catch(() => { })
                                fs.rmSync(`${filepath}`, { force: true, recursive: true })
                                return
                            }
                            var fileMsg = await msg.channel.send({
                                files: [new Discord.MessageAttachment(`${filepath}/output.gif`)]
                            }).catch(() => { })
                            if (!fileMsg) {
                                await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                var fileLink = await Catbox.upload(`${filepath}/output.gif`).catch(() => { })
                                if (fileLink) {
                                    var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                    if (!fileLinkMsg) {
                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                    }
                                } else {
                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                }
                            }
                            msg.channel.sendTyping().catch(() => { })
                            fs.rmSync(`${filepath}`, { force: true, recursive: true })
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "3dspin <image/gif>",
                "value": "Creates a 3D spinning image/GIF. (powered by https://www.3dgifmaker.com/)"
            },
            cooldown: 2500,
            type: "Manipulation"
        },
    
        {
            name: ["3dflip"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var animationname = 'Front Flip'
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
                var fileinfo = await validateFile(currenturl).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })
    
                if (!fileinfo) return
                var type = fileinfo.type
    
                if (type.mime.startsWith('image')) {
                    var currentcount = filecount
                    filecount++
                    fs.mkdirSync(`${filepath}`)
    
                    var writeStream = fs.createWriteStream(`${filepath}/${filename}`)
    
                    require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                        response.pipe(writeStream)
                        writeStream.on('finish', async () => {
                            function waitForAttributeValue(element, attribute, value) {
                                return function () {
                                    return element.getAttribute(attribute).then(result => {
                                        return result === value;
                                    });
                                };
                            }
    
                            await waitForChromeSessionEnd(msg)
                            var driver = await new Builder().forBrowser('chrome').setChromeOptions(new chrome.Options().setUserPreferences({ "download.default_directory": testing ? `${__dirname}\\temp\\file${currentcount}` : `${__dirname.replace(/\\/g, '/')}/${filepath}` })).build().catch(() => { })
                            chromeWindow = driver
                            await driver.get('https://www.3dgifmaker.com/').catch(() => { })
                            var inputbtn = await driver.findElement(By.css('input[class="upload-button__input"]')).catch(() => { })
                            var animationmenu = await driver.findElement(By.css('div[class="react-dropdown-select animation-select__input css-wmw4vi-ReactDropdownSelect e1gzf2xs0"]')).catch(() => { })
                            var fpspencil = await driver.findElement(By.css('div[class="slider-input home-main-card__frame-rate-slider"] div span[class="slider-input__pencil"]')).catch(() => { })
                            var fps = await driver.findElement(By.css('div[class="slider-input home-main-card__frame-rate-slider"] div input[class="slider-input__input slider-input__input--hidden"]')).catch(() => { })
                            var framespencil = await driver.findElement(By.css('div[class="slider-input home-main-card__total-frames-slider"] div span[class="slider-input__pencil"]')).catch(() => { })
                            var frames = await driver.findElement(By.css('div[class="slider-input home-main-card__total-frames-slider"] div input[class="slider-input__input slider-input__input--hidden"]')).catch(() => { })
                            var transparentcheck = await driver.findElement(By.css('input[class="transparent-checkbox__input"]')).catch(() => { })
                            var downloadgif = await driver.findElement(By.css('span[class="home-main-card__options-group home-main-card__options-group--download-buttons"] button')).catch(() => { })
                            await inputbtn.sendKeys(`${__dirname.replace(/\\/g, '/')}/${filepath}/${filename}`).catch(() => { })
                            await animationmenu.click().catch(() => { })
                            var animation = await driver.findElement(By.css(`span[aria-label="${animationname}"]`)).catch(() => { })
                            await animation.click().catch(() => { })
                            await fpspencil.click().catch(() => { })
                            await fps.clear().catch(() => { })
                            await fps.sendKeys('65').catch(() => { })
                            await fpspencil.click().catch(() => { })
                            await framespencil.click().catch(() => { })
                            await frames.clear().catch(() => { })
                            await frames.sendKeys('50').catch(() => { })
                            await framespencil.click().catch(() => { })
                            await transparentcheck.click().catch(() => { })
                            await downloadgif.click().catch(() => { })
                            var downloadinggif = await driver.findElement(By.css('span[class="home-main-card__options-group home-main-card__options-group--download-buttons"] button[class="create-button create-button--downloading"]')).catch(() => { })
                            await driver.wait(waitForAttributeValue(downloadinggif, 'class', 'create-button'), 600000).catch(() => { })
                            await sleep(5000)
                            await driver.quit().catch(() => { })
                            chromeWindow = false
                            var files = fs.readdirSync(`${filepath}`)
                            var file = files.find(f => f.includes('3dgifmaker'))
                            try {
                                fs.renameSync(`${filepath}/${file}`, `${filepath}/output.gif`)
                            } catch (_) {
                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                msg.channel.sendTyping().catch(() => { })
                                fs.rmSync(`${filepath}`, { force: true, recursive: true })
                                return
                            }
                            var fileMsg = await msg.channel.send({
                                files: [new Discord.MessageAttachment(`${filepath}/output.gif`)]
                            }).catch(() => { })
                            if (!fileMsg) {
                                await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                var fileLink = await Catbox.upload(`${filepath}/output.gif`).catch(() => { })
                                if (fileLink) {
                                    var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                    if (!fileLinkMsg) {
                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                    }
                                } else {
                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                }
                            }
                            msg.channel.sendTyping().catch(() => { })
                            fs.rmSync(`${filepath}`, { force: true, recursive: true })
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "3dflip <image/gif>",
                "value": "Creates a 3D front flipping image/GIF. (powered by https://www.3dgifmaker.com/)"
            },
            cooldown: 2500,
            type: "Manipulation"
        },
    
        {
            name: ["tiltedzoom", "tiltzoom"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var animationname = 'Tilted Zoom'
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
                var fileinfo = await validateFile(currenturl).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })
    
                if (!fileinfo) return
                var type = fileinfo.type
    
                if (type.mime.startsWith('image')) {
                    var currentcount = filecount
                    filecount++
                    fs.mkdirSync(`${filepath}`)
    
                    var writeStream = fs.createWriteStream(`${filepath}/${filename}`)
    
                    require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                        response.pipe(writeStream)
                        writeStream.on('finish', async () => {
                            function waitForAttributeValue(element, attribute, value) {
                                return function () {
                                    return element.getAttribute(attribute).then(result => {
                                        return result === value;
                                    });
                                };
                            }
    
                            await waitForChromeSessionEnd(msg)
                            var driver = await new Builder().forBrowser('chrome').setChromeOptions(new chrome.Options().setUserPreferences({ "download.default_directory": testing ? `${__dirname}\\temp\\file${currentcount}` : `${__dirname.replace(/\\/g, '/')}/${filepath}` })).build().catch(() => { })
                            chromeWindow = driver
                            await driver.get('https://www.3dgifmaker.com/').catch(() => { })
                            var inputbtn = await driver.findElement(By.css('input[class="upload-button__input"]')).catch(() => { })
                            var animationmenu = await driver.findElement(By.css('div[class="react-dropdown-select animation-select__input css-wmw4vi-ReactDropdownSelect e1gzf2xs0"]')).catch(() => { })
                            var fpspencil = await driver.findElement(By.css('div[class="slider-input home-main-card__frame-rate-slider"] div span[class="slider-input__pencil"]')).catch(() => { })
                            var fps = await driver.findElement(By.css('div[class="slider-input home-main-card__frame-rate-slider"] div input[class="slider-input__input slider-input__input--hidden"]')).catch(() => { })
                            var framespencil = await driver.findElement(By.css('div[class="slider-input home-main-card__total-frames-slider"] div span[class="slider-input__pencil"]')).catch(() => { })
                            var frames = await driver.findElement(By.css('div[class="slider-input home-main-card__total-frames-slider"] div input[class="slider-input__input slider-input__input--hidden"]')).catch(() => { })
                            var transparentcheck = await driver.findElement(By.css('input[class="transparent-checkbox__input"]')).catch(() => { })
                            var downloadgif = await driver.findElement(By.css('span[class="home-main-card__options-group home-main-card__options-group--download-buttons"] button')).catch(() => { })
                            await inputbtn.sendKeys(`${__dirname.replace(/\\/g, '/')}/${filepath}/${filename}`).catch(() => { })
                            await animationmenu.click().catch(() => { })
                            var animation = await driver.findElement(By.css(`span[aria-label="${animationname}"]`)).catch(() => { })
                            await animation.click().catch(() => { })
                            await fpspencil.click().catch(() => { })
                            await fps.clear().catch(() => { })
                            await fps.sendKeys('65').catch(() => { })
                            await fpspencil.click().catch(() => { })
                            await framespencil.click().catch(() => { })
                            await frames.clear().catch(() => { })
                            await frames.sendKeys('50').catch(() => { })
                            await framespencil.click().catch(() => { })
                            await transparentcheck.click().catch(() => { })
                            await downloadgif.click().catch(() => { })
                            var downloadinggif = await driver.findElement(By.css('span[class="home-main-card__options-group home-main-card__options-group--download-buttons"] button[class="create-button create-button--downloading"]')).catch(() => { })
                            await driver.wait(waitForAttributeValue(downloadinggif, 'class', 'create-button'), 600000).catch(() => { })
                            await sleep(5000)
                            await driver.quit().catch(() => { })
                            chromeWindow = false
                            var files = fs.readdirSync(`${filepath}`)
                            var file = files.find(f => f.includes('3dgifmaker'))
                            try {
                                fs.renameSync(`${filepath}/${file}`, `${filepath}/output.gif`)
                            } catch (_) {
                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                msg.channel.sendTyping().catch(() => { })
                                fs.rmSync(`${filepath}`, { force: true, recursive: true })
                                return
                            }
                            var fileMsg = await msg.channel.send({
                                files: [new Discord.MessageAttachment(`${filepath}/output.gif`)]
                            }).catch(() => { })
                            if (!fileMsg) {
                                await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                var fileLink = await Catbox.upload(`${filepath}/output.gif`).catch(() => { })
                                if (fileLink) {
                                    var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                    if (!fileLinkMsg) {
                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                    }
                                } else {
                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                }
                            }
                            msg.channel.sendTyping().catch(() => { })
                            fs.rmSync(`${filepath}`, { force: true, recursive: true })
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "tiltedzoom/tiltzoom <image/gif>",
                "value": "a family friendly command (powered by https://www.3dgifmaker.com/)"
            },
            cooldown: 2500,
            type: "Manipulation"
        },
    
        {
            name: ["insidesphere"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var animationname = 'Inside Sphere'
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
                var fileinfo = await validateFile(currenturl).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })
    
                if (!fileinfo) return
                var type = fileinfo.type
    
                if (type.mime.startsWith('image')) {
                    var currentcount = filecount
                    filecount++
                    fs.mkdirSync(`${filepath}`)
    
                    var writeStream = fs.createWriteStream(`${filepath}/${filename}`)
    
                    require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                        response.pipe(writeStream)
                        writeStream.on('finish', async () => {
                            function waitForAttributeValue(element, attribute, value) {
                                return function () {
                                    return element.getAttribute(attribute).then(result => {
                                        return result === value;
                                    });
                                };
                            }
    
                            await waitForChromeSessionEnd(msg)
                            var driver = await new Builder().forBrowser('chrome').setChromeOptions(new chrome.Options().setUserPreferences({ "download.default_directory": testing ? `${__dirname}\\temp\\file${currentcount}` : `${__dirname.replace(/\\/g, '/')}/${filepath}` })).build().catch(() => { })
                            chromeWindow = driver
                            await driver.get('https://www.3dgifmaker.com/').catch(() => { })
                            var inputbtn = await driver.findElement(By.css('input[class="upload-button__input"]')).catch(() => { })
                            var animationmenu = await driver.findElement(By.css('div[class="react-dropdown-select animation-select__input css-wmw4vi-ReactDropdownSelect e1gzf2xs0"]')).catch(() => { })
                            var fpspencil = await driver.findElement(By.css('div[class="slider-input home-main-card__frame-rate-slider"] div span[class="slider-input__pencil"]')).catch(() => { })
                            var fps = await driver.findElement(By.css('div[class="slider-input home-main-card__frame-rate-slider"] div input[class="slider-input__input slider-input__input--hidden"]')).catch(() => { })
                            var framespencil = await driver.findElement(By.css('div[class="slider-input home-main-card__total-frames-slider"] div span[class="slider-input__pencil"]')).catch(() => { })
                            var frames = await driver.findElement(By.css('div[class="slider-input home-main-card__total-frames-slider"] div input[class="slider-input__input slider-input__input--hidden"]')).catch(() => { })
                            var transparentcheck = await driver.findElement(By.css('input[class="transparent-checkbox__input"]')).catch(() => { })
                            var downloadgif = await driver.findElement(By.css('span[class="home-main-card__options-group home-main-card__options-group--download-buttons"] button')).catch(() => { })
                            await inputbtn.sendKeys(`${__dirname.replace(/\\/g, '/')}/${filepath}/${filename}`).catch(() => { })
                            await animationmenu.click().catch(() => { })
                            var animation = await driver.findElement(By.css(`span[aria-label="${animationname}"]`)).catch(() => { })
                            await animation.click().catch(() => { })
                            await fpspencil.click().catch(() => { })
                            await fps.clear().catch(() => { })
                            await fps.sendKeys('65').catch(() => { })
                            await fpspencil.click().catch(() => { })
                            await framespencil.click().catch(() => { })
                            await frames.clear().catch(() => { })
                            await frames.sendKeys('50').catch(() => { })
                            await framespencil.click().catch(() => { })
                            await transparentcheck.click().catch(() => { })
                            await downloadgif.click().catch(() => { })
                            var downloadinggif = await driver.findElement(By.css('span[class="home-main-card__options-group home-main-card__options-group--download-buttons"] button[class="create-button create-button--downloading"]')).catch(() => { })
                            await driver.wait(waitForAttributeValue(downloadinggif, 'class', 'create-button'), 600000).catch(() => { })
                            await sleep(5000)
                            await driver.quit().catch(() => { })
                            chromeWindow = false
                            var files = fs.readdirSync(`${filepath}`)
                            var file = files.find(f => f.includes('3dgifmaker'))
                            try {
                                fs.renameSync(`${filepath}/${file}`, `${filepath}/output.gif`)
                            } catch (_) {
                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                msg.channel.sendTyping().catch(() => { })
                                fs.rmSync(`${filepath}`, { force: true, recursive: true })
                                return
                            }
                            var fileMsg = await msg.channel.send({
                                files: [new Discord.MessageAttachment(`${filepath}/output.gif`)]
                            }).catch(() => { })
                            if (!fileMsg) {
                                await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                var fileLink = await Catbox.upload(`${filepath}/output.gif`).catch(() => { })
                                if (fileLink) {
                                    var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                    if (!fileLinkMsg) {
                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                    }
                                } else {
                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                }
                            }
                            msg.channel.sendTyping().catch(() => { })
                            fs.rmSync(`${filepath}`, { force: true, recursive: true })
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "insidesphere <image/gif>",
                "value": "Makes it look like as if you were inside the image/GIF. (powered by https://www.3dgifmaker.com/)"
            },
            cooldown: 2500,
            type: "Manipulation"
        },
    
        {
            name: ["balloon"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var animationname = 'Expanding Balloon'
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
                var fileinfo = await validateFile(currenturl).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })
    
                if (!fileinfo) return
                var type = fileinfo.type
    
                if (type.mime.startsWith('image')) {
                    var currentcount = filecount
                    filecount++
                    fs.mkdirSync(`${filepath}`)
    
                    var writeStream = fs.createWriteStream(`${filepath}/${filename}`)
    
                    require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                        response.pipe(writeStream)
                        writeStream.on('finish', async () => {
                            function waitForAttributeValue(element, attribute, value) {
                                return function () {
                                    return element.getAttribute(attribute).then(result => {
                                        return result === value;
                                    });
                                };
                            }
    
                            await waitForChromeSessionEnd(msg)
                            var driver = await new Builder().forBrowser('chrome').setChromeOptions(new chrome.Options().setUserPreferences({ "download.default_directory": testing ? `${__dirname}\\temp\\file${currentcount}` : `${__dirname.replace(/\\/g, '/')}/${filepath}` })).build().catch(() => { })
                            chromeWindow = driver
                            await driver.get('https://www.3dgifmaker.com/').catch(() => { })
                            var inputbtn = await driver.findElement(By.css('input[class="upload-button__input"]')).catch(() => { })
                            var animationmenu = await driver.findElement(By.css('div[class="react-dropdown-select animation-select__input css-wmw4vi-ReactDropdownSelect e1gzf2xs0"]')).catch(() => { })
                            var fpspencil = await driver.findElement(By.css('div[class="slider-input home-main-card__frame-rate-slider"] div span[class="slider-input__pencil"]')).catch(() => { })
                            var fps = await driver.findElement(By.css('div[class="slider-input home-main-card__frame-rate-slider"] div input[class="slider-input__input slider-input__input--hidden"]')).catch(() => { })
                            var framespencil = await driver.findElement(By.css('div[class="slider-input home-main-card__total-frames-slider"] div span[class="slider-input__pencil"]')).catch(() => { })
                            var frames = await driver.findElement(By.css('div[class="slider-input home-main-card__total-frames-slider"] div input[class="slider-input__input slider-input__input--hidden"]')).catch(() => { })
                            var transparentcheck = await driver.findElement(By.css('input[class="transparent-checkbox__input"]')).catch(() => { })
                            var downloadgif = await driver.findElement(By.css('span[class="home-main-card__options-group home-main-card__options-group--download-buttons"] button')).catch(() => { })
                            await inputbtn.sendKeys(`${__dirname.replace(/\\/g, '/')}/${filepath}/${filename}`).catch(() => { })
                            await animationmenu.click().catch(() => { })
                            var animation = await driver.findElement(By.css(`span[aria-label="${animationname}"]`)).catch(() => { })
                            await animation.click().catch(() => { })
                            await fpspencil.click().catch(() => { })
                            await fps.clear().catch(() => { })
                            await fps.sendKeys('65').catch(() => { })
                            await fpspencil.click().catch(() => { })
                            await framespencil.click().catch(() => { })
                            await frames.clear().catch(() => { })
                            await frames.sendKeys('50').catch(() => { })
                            await framespencil.click().catch(() => { })
                            await transparentcheck.click().catch(() => { })
                            await downloadgif.click().catch(() => { })
                            var downloadinggif = await driver.findElement(By.css('span[class="home-main-card__options-group home-main-card__options-group--download-buttons"] button[class="create-button create-button--downloading"]')).catch(() => { })
                            await driver.wait(waitForAttributeValue(downloadinggif, 'class', 'create-button'), 600000).catch(() => { })
                            await sleep(5000)
                            await driver.quit().catch(() => { })
                            chromeWindow = false
                            var files = fs.readdirSync(`${filepath}`)
                            var file = files.find(f => f.includes('3dgifmaker'))
                            try {
                                fs.renameSync(`${filepath}/${file}`, `${filepath}/output.gif`)
                            } catch (_) {
                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                msg.channel.sendTyping().catch(() => { })
                                fs.rmSync(`${filepath}`, { force: true, recursive: true })
                                return
                            }
                            var fileMsg = await msg.channel.send({
                                files: [new Discord.MessageAttachment(`${filepath}/output.gif`)]
                            }).catch(() => { })
                            if (!fileMsg) {
                                await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                var fileLink = await Catbox.upload(`${filepath}/output.gif`).catch(() => { })
                                if (fileLink) {
                                    var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                    if (!fileLinkMsg) {
                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                    }
                                } else {
                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                }
                            }
                            msg.channel.sendTyping().catch(() => { })
                            fs.rmSync(`${filepath}`, { force: true, recursive: true })
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "balloon <image/gif>",
                "value": "Makes the image/GIF expand in the shape of a sphere. (powered by https://www.3dgifmaker.com/)"
            },
            cooldown: 2500,
            type: "Manipulation"
        },
    
        {
            name: ["spiralshrink", "spiralvanish", "undertale"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var animationname = 'Spiral and Vanish'
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
                var fileinfo = await validateFile(currenturl).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })
    
                if (!fileinfo) return
                var type = fileinfo.type
    
                if (type.mime.startsWith('image')) {
                    var currentcount = filecount
                    filecount++
                    fs.mkdirSync(`${filepath}`)
    
                    var writeStream = fs.createWriteStream(`${filepath}/${filename}`)
    
                    require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                        response.pipe(writeStream)
                        writeStream.on('finish', async () => {
                            function waitForAttributeValue(element, attribute, value) {
                                return function () {
                                    return element.getAttribute(attribute).then(result => {
                                        return result === value;
                                    });
                                };
                            }
    
                            await waitForChromeSessionEnd(msg)
                            var driver = await new Builder().forBrowser('chrome').setChromeOptions(new chrome.Options().setUserPreferences({ "download.default_directory": testing ? `${__dirname}\\temp\\file${currentcount}` : `${__dirname.replace(/\\/g, '/')}/${filepath}` })).build().catch(() => { })
                            chromeWindow = driver
                            await driver.get('https://www.3dgifmaker.com/').catch(() => { })
                            var inputbtn = await driver.findElement(By.css('input[class="upload-button__input"]')).catch(() => { })
                            var animationmenu = await driver.findElement(By.css('div[class="react-dropdown-select animation-select__input css-wmw4vi-ReactDropdownSelect e1gzf2xs0"]')).catch(() => { })
                            var fpspencil = await driver.findElement(By.css('div[class="slider-input home-main-card__frame-rate-slider"] div span[class="slider-input__pencil"]')).catch(() => { })
                            var fps = await driver.findElement(By.css('div[class="slider-input home-main-card__frame-rate-slider"] div input[class="slider-input__input slider-input__input--hidden"]')).catch(() => { })
                            var framespencil = await driver.findElement(By.css('div[class="slider-input home-main-card__total-frames-slider"] div span[class="slider-input__pencil"]')).catch(() => { })
                            var frames = await driver.findElement(By.css('div[class="slider-input home-main-card__total-frames-slider"] div input[class="slider-input__input slider-input__input--hidden"]')).catch(() => { })
                            var transparentcheck = await driver.findElement(By.css('input[class="transparent-checkbox__input"]')).catch(() => { })
                            var downloadgif = await driver.findElement(By.css('span[class="home-main-card__options-group home-main-card__options-group--download-buttons"] button')).catch(() => { })
                            await inputbtn.sendKeys(`${__dirname.replace(/\\/g, '/')}/${filepath}/${filename}`).catch(() => { })
                            await animationmenu.click().catch(() => { })
                            var animation = await driver.findElement(By.css(`span[aria-label="${animationname}"]`)).catch(() => { })
                            await animation.click().catch(() => { })
                            await fpspencil.click().catch(() => { })
                            await fps.clear().catch(() => { })
                            await fps.sendKeys('65').catch(() => { })
                            await fpspencil.click().catch(() => { })
                            await framespencil.click().catch(() => { })
                            await frames.clear().catch(() => { })
                            await frames.sendKeys('40').catch(() => { })
                            await framespencil.click().catch(() => { })
                            await transparentcheck.click().catch(() => { })
                            await downloadgif.click().catch(() => { })
                            var downloadinggif = await driver.findElement(By.css('span[class="home-main-card__options-group home-main-card__options-group--download-buttons"] button[class="create-button create-button--downloading"]')).catch(() => { })
                            await driver.wait(waitForAttributeValue(downloadinggif, 'class', 'create-button'), 600000).catch(() => { })
                            await sleep(5000)
                            await driver.quit().catch(() => { })
                            chromeWindow = false
                            var files = fs.readdirSync(`${filepath}`)
                            var file = files.find(f => f.includes('3dgifmaker'))
                            try {
                                fs.renameSync(`${filepath}/${file}`, `${filepath}/output.gif`)
                            } catch (_) {
                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                msg.channel.sendTyping().catch(() => { })
                                fs.rmSync(`${filepath}`, { force: true, recursive: true })
                                return
                            }
                            var fileMsg = await msg.channel.send({
                                files: [new Discord.MessageAttachment(`${filepath}/output.gif`)]
                            }).catch(() => { })
                            if (!fileMsg) {
                                await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                var fileLink = await Catbox.upload(`${filepath}/output.gif`).catch(() => { })
                                if (fileLink) {
                                    var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                    if (!fileLinkMsg) {
                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                    }
                                } else {
                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                }
                            }
                            msg.channel.sendTyping().catch(() => { })
                            fs.rmSync(`${filepath}`, { force: true, recursive: true })
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "spiralshrink/spiralvanish/undertale <image/gif>",
                "value": "Shrinks the image/GIF while also rotating it. (powered by https://www.3dgifmaker.com/)"
            },
            cooldown: 2500,
            type: "Manipulation"
        },*/

        {
            name: ["generatetext", "predicttext"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                var saidMessage = args.join(' ').substring(args[0].length + 1)
                if (args[1] === undefined) {
                    msg.channel.send('What is the text to generate?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                }
                if (validUrl.test(saidMessage)) {
                    msg.channel.send('URLs in this command will break it.').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
                var resp = await deepai.callStandardApi("text-generator", {
                    text: saidMessage,
                }).catch(err => {
                    msg.channel.send({
                        content: err.stack,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                })
                if (resp) {
                    msg.channel.send({
                        content: resp.output,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                }
                msg.channel.sendTyping().catch(() => { })
            },
            help: {
                "name": "generatetext/predicttext <message>",
                "value": "Tries to predict subsequent text from the specified message."
            },
            type: "Text"
        },

        {
            name: ["translate", "tr"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (args[1] === undefined) {
                    msg.channel.send('What is the text to translate?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                }
                var lresponse = await axios.request({
                    method: 'GET',
                    url: 'https://microsoft-translator-text.p.rapidapi.com/languages',
                    params: { 'api-version': '3.0' },
                    headers: {
                        'x-rapidapi-host': 'microsoft-translator-text.p.rapidapi.com',
                        'x-rapidapi-key': randomKey('RAPIDAPIKEY')
                    }
                }).catch(() => { })
                var languages = []
                for (var i in lresponse.data.translation) {
                    lresponse.data.translation[i].language = i
                    languages.push(lresponse.data.translation[i])
                }

                var source = null
                var sourceindex = args.indexOf('-source')
                if (sourceindex > -1) {
                    if (languages.find(language => (language.language === args[sourceindex + 1].toLowerCase()) || (language.name === args[sourceindex + 1].toLowerCase()))) {
                        source = languages.find(language => (language.language === args[sourceindex + 1].toLowerCase()) || (language.name === args[sourceindex + 1].toLowerCase())).language
                    } else {
                        msg.channel.send(`Not a supported source language. A list of supported languages are:\n${languages.map(language => `${language.name} (${language.language})`).join(', ')}`).catch(() => { })
                        return
                    }
                    args.splice(sourceindex, 2)
                }

                var target = 'en'
                var targetindex = args.indexOf('-target')
                if (targetindex > -1) {
                    if (languages.find(language => (language.language === args[targetindex + 1].toLowerCase()) || (language.name === args[targetindex + 1].toLowerCase()))) {
                        target = languages.find(language => (language.language === args[targetindex + 1].toLowerCase()) || (language.name === args[targetindex + 1].toLowerCase())).language
                    } else {
                        msg.channel.send(`Not a supported target language. A list of supported languages are:\n${languages.map(language => `${language.name} (\`${language.language}\`)`).join(', ')}`).catch(() => { })
                        return
                    }
                    args.splice(targetindex, 2)
                }

                var saidMessage = args.join(' ').substring(args[0].length + 1)

                var options = {
                    method: 'POST',
                    url: 'https://microsoft-translator-text.p.rapidapi.com/translate',
                    params: { from: source, to: target, 'api-version': '3.0', profanityAction: 'NoAction', textType: 'plain' },
                    headers: {
                        'content-type': 'application/json',
                        'x-rapidapi-host': 'microsoft-translator-text.p.rapidapi.com',
                        'x-rapidapi-key': randomKey('RAPIDAPIKEY')
                    },
                    data: [{ Text: saidMessage }]
                };

                var response = await axios.request(options).catch(async () => {
                    await msg.channel.send('Error.').catch(() => { })
                })

                msg.channel.send({
                    content: response.data[0].translations[0].text,
                    allowedMentions: {
                        parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                    }
                }).catch(() => { })
                msg.channel.sendTyping().catch(() => { })
            },
            help: {
                "name": "translate/tr <message> [-source <language>] [-target <language>]",
                "value": "Translates the specified message. The default source language is auto and the default target language is English."
            },
            type: "Text"
        },

        {
            name: ["badtranslate", "badtr"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (args[1] === undefined) {
                    msg.channel.send('What is the text to translate?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                }
                var lresponse = await axios.request({
                    method: 'GET',
                    url: 'https://microsoft-translator-text.p.rapidapi.com/languages',
                    params: { 'api-version': '3.0' },
                    headers: {
                        'x-rapidapi-host': 'microsoft-translator-text.p.rapidapi.com',
                        'x-rapidapi-key': randomKey('RAPIDAPIKEY')
                    }
                }).catch(() => { })
                var languages = []
                for (var i in lresponse.data.translation) {
                    lresponse.data.translation[i].language = i
                    languages.push(lresponse.data.translation[i])
                }

                var source = null
                var sourceindex = args.indexOf('-source')
                if (sourceindex > -1) {
                    if (languages.find(language => (language.language === args[sourceindex + 1].toLowerCase()) || (language.name === args[sourceindex + 1].toLowerCase()))) {
                        source = languages.find(language => (language.language === args[sourceindex + 1].toLowerCase()) || (language.name === args[sourceindex + 1].toLowerCase())).language
                    } else {
                        msg.channel.send(`Not a supported source language. A list of supported languages are:\n${languages.map(language => `${language.name} (${language.language})`).join(', ')}`).catch(() => { })
                        return
                    }
                    args.splice(sourceindex, 2)
                }

                var target = 'en'
                var targetindex = args.indexOf('-target')
                if (targetindex > -1) {
                    if (languages.find(language => (language.language === args[targetindex + 1].toLowerCase()) || (language.name === args[targetindex + 1].toLowerCase()))) {
                        target = languages.find(language => (language.language === args[targetindex + 1].toLowerCase()) || (language.name === args[targetindex + 1].toLowerCase())).language
                    } else {
                        msg.channel.send(`Not a supported target language. A list of supported languages are:\n${languages.map(language => `${language.name} (\`${language.language}\`)`).join(', ')}`).catch(() => { })
                        return
                    }
                    args.splice(targetindex, 2)
                }

                var repeat = 5
                var languagesindex = args.indexOf('-languages')
                if (languagesindex > -1) {
                    repeat = isNaN(Number(args[languagesindex + 1])) ? 5 : Number(args[languagesindex + 1]) <= 2 ? 2 : Number(args[languagesindex + 1]) >= 25 ? 25 : Math.round(Number(args[languagesindex + 1])) || 5
                    args.splice(languagesindex, 2)
                }
                var maxlength = Math.round(2000 / repeat)

                var saidMessage = args.join(' ').substring(args[0].length + 1)

                if (saidMessage.length > maxlength) {
                    msg.channel.send(`The input length must be smaller or equal to 2000 divided by the number of repetitions. (in this case ${maxlength} characters)`)
                    return
                }

                var output = saidMessage
                var lastlanguage = source
                var currentlanguage = languages[Math.floor(Math.random() * languages.length)].language

                var lmessage = await msg.channel.send(`Translating from ${languages.find(language => language.language === lastlanguage) ? languages.find(language => language.language === lastlanguage).name : 'Auto'} to ${languages.find(language => language.language === currentlanguage).name}. (${output})`).catch(() => { })

                for (var i = 0; i < repeat; i++) {
                    var options = {
                        method: 'POST',
                        url: 'https://microsoft-translator-text.p.rapidapi.com/translate',
                        params: { from: lastlanguage, to: currentlanguage, 'api-version': '3.0', profanityAction: 'NoAction', textType: 'plain' },
                        headers: {
                            'content-type': 'application/json',
                            'x-rapidapi-host': 'microsoft-translator-text.p.rapidapi.com',
                            'x-rapidapi-key': randomKey('RAPIDAPIKEY')
                        },
                        data: [{ Text: output }]
                    };

                    var response = await axios.request(options).catch(async () => {
                        await msg.channel.send('Error.').catch(() => { })
                    })

                    if (!response) {
                        return
                    }

                    output = response.data[0].translations[0].text
                    lastlanguage = currentlanguage
                    currentlanguage = i == repeat - 2 ? target : languages[Math.floor(Math.random() * languages.length)].language
                    if (lmessage && i != repeat - 1) {
                        await lmessage.edit(`Translating from ${languages.find(language => language.language === lastlanguage) ? languages.find(language => language.language === lastlanguage).name : 'Auto'} to ${languages.find(language => language.language === currentlanguage).name}. (${output})`).catch(() => { })
                    }
                }

                if (lmessage) {
                    await lmessage.delete().catch(() => { })
                }

                msg.channel.send({
                    content: output,
                    allowedMentions: {
                        parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                    }
                }).catch(() => { })
                msg.channel.sendTyping().catch(() => { })
            },
            help: {
                "name": "badtranslate/badtr <message> [-source <language>] [-target <language>] [-languages <number (max 25)>]",
                "value": "Badly translates the specified message. The default source language is auto and the default target language is English."
            },
            type: "Text"
        },

        {
            name: ["cleverbot", "respond"],
            execute: async function (msg, args) {
                var continuous = true
                var once = args.findIndex(arg => arg === '-once')
                if (once > -1) {
                    args.splice(once, 1)
                    continuous = false
                }
                var channel = msg.channel
                var guildid = msg.guild.id
                var channelid = channel.id
                var authorid = msg.author.id
                var saidMessage = args.join(' ').substring(args[0].length + 1)
                if (saidMessage) {
                    var resp = await cleverbot(saidMessage, channelid).catch(err => {
                        channel.send({
                            content: err.stack,
                            allowedMentions: {
                                parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                            }
                        }).catch(() => { })
                    })

                    if (resp) {
                        channel.send({
                            content: resp,
                            allowedMentions: {
                                parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                            }
                        }).catch(() => { })
                    }
                } else {
                    if (!continuous && !args[1]) {
                        channel.send('What is the message to respond to?!').catch(() => { })
                        return
                    }
                    channel.send('Hello, I will respond to your messages now.').catch(() => { })
                }
                channel.sendTyping().catch(() => { })
                if (continuous) {
                    if (data2[guildid][channelid][authorid].messageCollector) {
                        data2[guildid][channelid][authorid].messageCollector.stop()
                        delete data2[guildid][channelid][authorid].messageCollector
                    }

                    var filter = m => !m.author.bot && m.author.id === msg.author.id
                    var collector = channel.createMessageCollector({ filter, time: 30000 })

                    data2[guildid][channelid][authorid].messageCollector = collector

                    collector.on('collect', async m => {
                        if (data2[msg.guild.id][msg.channel.id]['shut']) return
                        try {
                            var content = await getKeywordsFor(m.content ?? '', m, false).catch(() => { }) ?? m.content

                            collector.resetTimer()

                            var resp = await cleverbot(content, channelid).catch(err => {
                                channel.send({
                                    content: err.stack,
                                    allowedMentions: {
                                        parse: ((!m.member.permissions.has('ADMINISTRATOR') && !m.member.permissions.has('MENTION_EVERYONE') && m.author.id !== m.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    }
                                }).catch(() => { })
                            })
                            if (resp) {
                                channel.send({
                                    content: resp,
                                    allowedMentions: {
                                        parse: ((!m.member.permissions.has('ADMINISTRATOR') && !m.member.permissions.has('MENTION_EVERYONE') && m.author.id !== m.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    }
                                }).catch(() => { })
                            }
                        } catch (_) { }
                    })

                    collector.on('end', async (_, reason) => {
                        if (data2[msg.guild.id][msg.channel.id]['shut']) return
                        try {
                            delete data2[guildid][channelid][authorid].messageCollector
                            if (reason === 'time') {
                                channel.send({
                                    content: 'I\'m running out of time...',
                                    allowedMentions: {
                                        parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && authorid !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    }
                                }).catch(() => { })
                            }
                        } catch (_) { }
                    })
                }
            },
            help: {
                "name": "cleverbot/respond {message} [-once]",
                "value": "Poopy responds to your messages with Cleverbot's AI."
            },
            type: "Text"
        },

        {
            name: ["spam", "flood"],
            execute: async function (msg, args) {
                if (msg.member.permissions.has('MANAGE_GUILD') || msg.member.roles.cache.find(role => role.name.match(/mod|dev|admin|owner|creator|founder|staff/ig)) || msg.member.permissions.has('MANAGE_MESSAGES') || msg.member.permissions.has('ADMINISTRATOR') || msg.author.id === msg.guild.ownerID) {
                    if (args[1] === undefined && args[2] === undefined) {
                        msg.channel.send('How much do I spam?!').catch(() => { })
                        return;
                    }
                    msg.channel.sendTyping().catch(() => { })
                    var del = true
                    var deleteIndex = args.indexOf('-nodelete')
                    if (deleteIndex > -1) {
                        args.splice(deleteIndex, 1)
                        del = false
                    }
                    var tts = false
                    var ttsIndex = args.indexOf('-tts')
                    if (ttsIndex > -1) {
                        args.splice(ttsIndex, 1)
                        tts = true
                    }
                    var saidMessage = args.join(' ').substring(args[0].length + args[1].length + 2)
                    var attachments = []
                    msg.attachments.forEach(attachment => {
                        attachments.push(new Discord.MessageAttachment(attachment.url))
                    });
                    var numToRepeat = Number(args[1]);
                    if (isNaN(numToRepeat)) {
                        msg.channel.send({
                            content: 'Invalid number: **' + args[1] + '**',
                            allowedMentions: {
                                parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                            }
                        }).catch(() => { })
                        msg.channel.sendTyping().catch(() => { })
                        return;
                    }
                    else if (numToRepeat > 25) {
                        msg.channel.send('Number must be smaller or equal to **25**.').catch(() => { })
                        msg.channel.sendTyping().catch(() => { })
                        return;
                    }
                    if (args[2] === undefined && attachments.length <= 0) {
                        msg.channel.send('What is the message to spam?!').catch(() => { })
                        msg.channel.sendTyping().catch(() => { })
                        return;
                    };
                    var sendObject = {
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        },
                        files: attachments,
                        tts: (msg.member.permissions.has('ADMINISTRATOR') || msg.member.permissions.has('SEND_TTS_MESSAGES') || msg.author.id === msg.guild.ownerID) && tts
                    }
                    if (saidMessage) {
                        sendObject.content = saidMessage
                    }
                    if (del) {
                        msg.delete().catch(() => { })
                    }
                    for (var i = 0; i < numToRepeat; i++) {
                        if (data2[msg.guild.id][msg.channel.id]['shut']) break
                        await msg.channel.send(sendObject).catch(() => { })
                    };
                    msg.channel.sendTyping().catch(() => { })
                }
                else {
                    msg.channel.send('You need to have the manage messages permission to execute that!').catch(() => { })
                    return;
                };
            },
            help: {
                "name": "spam/flood <times> <message> [-nodelete] [-tts] (manage messages permission only)",
                "value": "Spam a message! Limit is 25.\nExample usage: p:spam 5 stupid"
            },
            cooldown: 10000,
            perms: ["MANAGE_MESSAGES", "ADMINISTRATOR"],
            type: "Annoying"
        },

        {
            name: ["eval", "execute"],
            execute: async function (msg, args) {
                var ownerid = (ownerids.find(id => id == msg.author.id));
                if (ownerid === undefined) {
                    msg.channel.send('Owner only!').catch(() => { })
                    return
                }
                var saidMessage = args.join(' ').substring(args[0].length + 1)
                var no = illKillYouIfYouUseEval.find(id => id === msg.guild.id || saidMessage.includes(id))
                if (no) {
                    msg.channel.send('<:YouIdiot:735259116737658890>').catch(() => { })
                    return
                }
                try {
                    var evalMessage = eval(saidMessage)

                    if (typeof (evalMessage) !== 'string') evalMessage = util.inspect(evalMessage)

                    evalMessage = evalMessage.match(/[\s\S]{1,2000}/g)

                    for (var i in evalMessage) {
                        if (data2[msg.guild.id][msg.channel.id]['shut']) break
                        var ev = evalMessage[i]
                        await msg.channel.send({
                            content: ev,
                            allowedMentions: {
                                parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                            }
                        }).catch(() => {
                            msg.channel.send('‚Äã').catch(() => { })
                            return
                        })
                    }
                } catch (error) {
                    msg.channel.send({
                        content: error.message,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    return
                }
            },
            help: {
                "name": "eval/execute {code}",
                "value": "Evaluation command. (pretty much execute the code you want)"
            },
            type: "Owner"
        },

        {
            name: ["dm"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (args[1] === undefined) {
                    msg.channel.send('Who do I DM?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var anon = false
                var anonIndex = args.indexOf('-anonymous')
                if (anonIndex > -1) {
                    args.splice(anonIndex, 1)
                    anon = true
                }
                var saidMessage = args.join(' ').substring(args[0].length + args[1].length + 2)
                var attachments = []
                msg.attachments.forEach(attachment => {
                    attachments.push(new Discord.MessageAttachment(attachment.url))
                });
                if (args[2] === undefined && attachments.length <= 0) {
                    msg.channel.send('What is the message to DM?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                if (!msg.mentions.members.size) {
                    var id = args[1]

                    var member = await bot.users.fetch(id)
                        .catch(function () {
                            msg.channel.send({
                                content: 'Invalid user id: **' + id + '**',
                                allowedMentions: {
                                    parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            }).catch(() => { })
                            msg.channel.sendTyping().catch(() => { })
                            return
                        });

                    if (member) {
                        if (!data()[mongodatabase]['user-data'][member.id]) {
                            data()[mongodatabase]['user-data'][member.id] = {}
                        }
                        if (!data2[member.id]) {
                            data2[member.id] = {}
                        }
                        if (member.id === msg.author.id) {
                            member.send({
                                content: (anon ? '' : `${msg.author.tag} from ${msg.guild.name}:\n\n`) + saidMessage,
                                files: attachments
                            }).then(function () {
                                msg.react('‚úÖ').catch(() => { })
                                msg.channel.sendTyping().catch(() => { })
                            })
                                .catch(function () {
                                    msg.channel.send('unblock me').catch(() => { })
                                    msg.channel.sendTyping().catch(() => { })
                                    return
                                })
                            return
                        }
                        if (data()[mongodatabase]['user-data'][member.id]['dms'] === undefined && !data2[member.id]['dmconsent']) {
                            data2[msg.author.id]['dmconsent'] = true

                            var pending = await msg.channel.send('Pending response.').catch(() => { })
                            var send = await yesno(member, `${!anon ? msg.author.tag : 'Someone'} is trying to send you a message. Will you consent to any unrelated DMs sent with the \`dm\` command?`, member.id).catch(() => { })

                            if (send !== undefined) {
                                data()[mongodatabase]['user-data'][member.id]['dms'] = send
                                member.send({
                                    content: `Unrelated DMs from \`dm\` will **${!send ? 'not ' : ''}be sent** to you now.`,
                                    allowedMentions: {
                                        parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    }
                                }).catch(() => { })
                                if (pending) {
                                    pending.edit(send ? 'You can send DMs to the user now.' : 'blocked on twitter').catch(() => { })
                                }
                            } else {
                                pending.edit('Couldn\'t send a message to this user. Make sure they share any of the servers I\'m in, or not have me blocked.').catch(() => { })
                            }
                        } else {
                            if (data()[mongodatabase]['user-data'][member.id]['dms'] === false) {
                                msg.channel.send('I don\'t have the permission to send unrelated DMs to this user.').catch(() => { })
                                msg.channel.sendTyping().catch(() => { })
                                return
                            }
                            member.send({
                                content: (!anon ? `${msg.author.tag} from ${msg.guild.name}:\n\n` : '') + saidMessage,
                                files: attachments
                            }).then(function () {
                                msg.react('‚úÖ').catch(() => { })
                                msg.channel.sendTyping().catch(() => { })
                            })
                                .catch(function () {
                                    msg.channel.send('Couldn\'t send a message to this user. Make sure they share any of the servers I\'m in, or not have me blocked.').catch(() => { })
                                    msg.channel.sendTyping().catch(() => { })
                                    return
                                })
                        }
                    }
                }
                else {
                    var member = msg.mentions.members.first()
                    if (!data()[mongodatabase]['user-data'][member.id]) {
                        data()[mongodatabase]['user-data'][member.id] = {}
                    }
                    if (!data2[member.id]) {
                        data2[member.id] = {}
                    }
                    if (member.id === msg.author.id) {
                        member.send({
                            content: (anon ? '' : `${msg.author.tag} from ${msg.guild.name}:\n\n`) + saidMessage,
                            files: attachments
                        }).then(function () {
                            msg.react('‚úÖ').catch(() => { })
                            msg.channel.sendTyping().catch(() => { })
                        })
                            .catch(function () {
                                msg.channel.send('unblock me').catch(() => { })
                                msg.channel.sendTyping().catch(() => { })
                                return
                            })
                        return
                    }
                    if (data()[mongodatabase]['user-data'][member.id]['dms'] === undefined && !data2[member.id]['dmconsent']) {
                        data2[msg.author.id]['dmconsent'] = true

                        var pending = await msg.channel.send('Pending response.').catch(() => { })
                        var send = await yesno(member, `${!anon ? msg.author.tag : 'Someone'} is trying to send you a message. Will you consent to any unrelated DMs sent with the \`dm\` command?`, member.id).catch(() => { })

                        if (send !== undefined) {
                            data()[mongodatabase]['user-data'][member.id]['dms'] = send
                            member.send({
                                content: `Unrelated DMs from \`dm\` will **${!send ? 'not ' : ''}be sent** to you now.`,
                                allowedMentions: {
                                    parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            }).catch(() => { })
                            if (pending) {
                                pending.edit(send ? 'You can send DMs to the user now.' : 'blocked on twitter').catch(() => { })
                            }
                        } else {
                            pending.edit('Couldn\'t send a message to this user. Make sure they share any of the servers I\'m in, or not have me blocked.').catch(() => { })
                        }
                    } else {
                        if (data()[mongodatabase]['user-data'][member.id]['dms'] === false) {
                            msg.channel.send('I don\'t have the permission to send unrelated DMs to this user.').catch(() => { })
                            msg.channel.sendTyping().catch(() => { })
                            return
                        }
                        member.send({
                            content: (!anon ? `${msg.author.tag} from ${msg.guild.name}:\n\n` : '') + saidMessage,
                            files: attachments
                        }).then(function () {
                            msg.react('‚úÖ').catch(() => { })
                            msg.channel.sendTyping().catch(() => { })
                        })
                            .catch(function () {
                                msg.channel.send('Couldn\'t send a message to this user. Make sure they share any of the servers I\'m in, or not have me blocked.').catch(() => { })
                                msg.channel.sendTyping().catch(() => { })
                                return
                            })
                    }
                }
            },
            help: {
                "name": "dm <user> <message> [-anonymous]",
                "value": "Allows Poopy to DM an user the message inside the command."
            },
            type: "Annoying"
        },

        {
            name: ["react"],
            execute: async function (msg, args) {
                if (args[1] === undefined) {
                    msg.channel.send('Where are the arguments?!').catch(() => { })
                    return;
                }
                msg.channel.sendTyping().catch(() => { })
                var saidEmojis = args[1];
                var saidMessage = args[2];

                if (saidMessage === undefined) {
                    saidMessage = msg.id
                }

                if (saidEmojis) {
                    var saidEmojisArray = saidEmojis.split(',');
                    saidEmojisArray.forEach(
                        saidEmoji => {
                            async function getMessage(id) {
                                var messageToReact = await msg.channel.messages.fetch(id)
                                    .catch(function () {
                                        msg.channel.send({
                                            content: 'Invalid message id: **' + id + '**',
                                            allowedMentions: {
                                                parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                            }
                                        }).catch(() => { })
                                        msg.channel.sendTyping().catch(() => { })
                                        return
                                    })

                                if (messageToReact) {
                                    messageToReact.react(saidEmoji)
                                        .then(function () {
                                            msg.channel.sendTyping().catch(() => { })
                                        })
                                        .catch(function () {
                                            msg.channel.send({
                                                content: 'Invalid emoji: **' + saidEmoji + '**',
                                                allowedMentions: {
                                                    parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                                }
                                            }).catch(() => { })
                                            msg.channel.sendTyping().catch(() => { })
                                            return;
                                        })
                                }
                            }

                            getMessage(saidMessage)
                        }
                    )
                };
            },
            help: {
                "name": "react <emojis> {messageid}",
                "value": "React to a message inside the channel with an emoji. (each emoji should be separated with \",\")"
            },
            type: "Main"
        },

        {
            name: ["avatar", "av", "pfp"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (args[1] === undefined) {
                    var avatar = new Discord.MessageAttachment(msg.author.displayAvatarURL({ dynamic: true, size: 1024, format: 'png' }));
                    msg.channel.send({
                        content: msg.author.username + '\'s avatar is:',
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        },
                        files: [avatar]
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                if (!msg.mentions.members.size) {
                    async function getMember(id) {
                        var member = await bot.users.fetch(id)
                            .catch(function () {
                                msg.channel.send({
                                    content: 'Invalid user id: **' + id + '**',
                                    allowedMentions: {
                                        parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    }
                                }).catch(() => { })
                                msg.channel.sendTyping().catch(() => { })
                                return
                            })

                        if (member) {
                            var avatar = new Discord.MessageAttachment(member.displayAvatarURL({ dynamic: true, size: 1024, format: 'png' }));
                            msg.channel.send({
                                content: member.username + '\'s avatar is:',
                                allowedMentions: {
                                    parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                },
                                files: [avatar]
                            }).catch(() => { })
                        }
                    }

                    getMember(args[1]);
                }
                else {
                    var mention = msg.mentions.members.first();
                    var avatar = new Discord.MessageAttachment(mention.user.displayAvatarURL({ dynamic: true, size: 1024, format: 'png' }));
                    msg.channel.send({
                        content: mention.user.username + '\'s avatar is:',
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        },
                        files: [avatar]
                    }).catch(() => { })
                }
                msg.channel.sendTyping().catch(() => { })
            },
            help: {
                "name": "avatar/av/pfp [user]",
                "value": "Replies with the user's avatar."
            },
            cooldown: 2500,
            type: "Main"
        },

        {
            name: ["poop"],
            execute: async function (msg) {
                msg.channel.sendTyping().catch(() => { })
                msg.channel.send({
                    content: poopPhrases[Math.floor(Math.random() * poopPhrases.length)]
                        .replace(/{fart}/, Math.floor(Math.random() * 291) + 10)
                        .replace(/{seconds}/, Math.floor((Math.random() * 59) + 2))
                        .replace(/{mention}/, `<@${msg.author.id}>`),
                    allowedMentions: {
                        parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                    }
                }).catch(() => { })
                msg.channel.sendTyping().catch(() => { })
            },
            help: {
                "name": "poop",
                "value": "Poopy says a random funny."
            },
            type: "OG"
        },

        {
            name: ["stats", "botstats"],
            execute: async function (msg) {
                var totalSeconds = (bot.uptime / 1000);
                var days = Math.floor(totalSeconds / 86400);
                totalSeconds %= 86400;
                var hours = Math.floor(totalSeconds / 3600);
                totalSeconds %= 3600;
                var minutes = Math.floor(totalSeconds / 60);
                var seconds = Math.floor(totalSeconds % 60);
                var usage = process.memoryUsage()
                var mused = usage.heapUsed / 1024 / 1024
                var rss = usage.rss / 1024 / 1024
                var cusage = process.cpuUsage()
                var cused = (cusage.user + cusage.system) / 1024 / 1024
                var cpu = os.cpus()[0].model
                var servers = bot.guilds.cache.size
                var channels = bot.channels.cache.size
                var emojis = bot.emojis.cache.size
                var files = fs.readdirSync('temp').length
                var messages = data()[mongodatabase]['bot-data']['bot']['messages']
                var users = Object.keys(data()[mongodatabase]['user-data']).length
                var pcommands = data()[mongodatabase]['bot-data']['bot']['commands']
                var reboots = data()[mongodatabase]['bot-data']['bot']['reboots']
                var members = 0

                for (var id in data()[mongodatabase]['guild-data']) {
                    var guild = data()[mongodatabase]['guild-data'][id]
                    if (guild['members']) members += Object.keys(guild['members']).length
                }

                var statsEmbed = {
                    title: 'Poopy\'s Stats',
                    color: 0x472604,
                    footer: {
                        icon_url: bot.user.displayAvatarURL({ dynamic: true, size: 1024, format: 'png' }),
                        text: bot.user.username
                    },
                    fields: [
                        {
                            name: "Servers",
                            value: servers.toString(),
                            inline: true
                        },
                        {
                            name: "Channels",
                            value: channels.toString(),
                            inline: true
                        },
                        {
                            name: "Messages",
                            value: messages.toString(),
                            inline: true
                        },
                        {
                            name: "Emojis",
                            value: emojis.toString(),
                            inline: true
                        },
                        {
                            name: "Users",
                            value: users.toString(),
                            inline: true
                        },
                        {
                            name: "Members",
                            value: members.toString(),
                            inline: true
                        },
                        {
                            name: "Uptime",
                            value: `${days}d ${hours}h ${minutes}m ${seconds}s`,
                            inline: true
                        },
                        {
                            name: "Commands",
                            value: commands.length.toString(),
                            inline: true
                        },
                        {
                            name: "Processed Commands",
                            value: pcommands.toString(),
                            inline: true
                        },
                        {
                            name: "Commands per Minute",
                            value: cps.toString(),
                            inline: true
                        },
                        {
                            name: "File Count",
                            value: filecount.toString(),
                            inline: true
                        },
                        {
                            name: "Processing Files",
                            value: files.toString(),
                            inline: true
                        },
                        {
                            name: "Reboots",
                            value: reboots.toString(),
                            inline: true
                        },
                        {
                            name: "CPU",
                            value: cpu.toString(),
                            inline: true
                        },
                        {
                            name: "Memory Usage",
                            value: `${Math.round(mused * 100) / 100} MB`,
                            inline: true
                        },
                        {
                            name: "Resident Set Size",
                            value: `${Math.round(rss * 100) / 100} MB`,
                            inline: true
                        },
                        {
                            name: "CPU Usage",
                            value: `${Math.round(cused * 100) / 100} MB`,
                            inline: true
                        },
                    ]
                }

                msg.channel.send({
                    embeds: [statsEmbed],
                    allowedMentions: {
                        parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                    }
                }).catch(() => { })
            },
            help: {
                "name": "stats/botstats",
                "value": "Shows Poopy's stats."
            },
            cooldown: 2500,
            type: "Main"
        },

        {
            name: ["specialkeys", "keywords", "functions"],
            execute: async function (msg) {
                var keynumber = 1
                var modnumber = 1
                var infoEmbed = {
                    "title": 'Special Keywords/Functions',
                    "color": 0x472604,
                    "footer": {
                        icon_url: bot.user.displayAvatarURL({ dynamic: true, size: 1024, format: 'png' }),
                        text: bot.user.username
                    },
                    "fields": [
                        {
                            "name": "WHAT are keywords and functions?",
                            "value": "Keywords and functions are special words that can be used in any command which are replaced with something new (keywords), or generate something new with the arguments inside their parentheses (functions), depending on their purpose.",
                        },
                        {
                            "name": "Example Usages",
                            "value": "```\np:say _member really likes _member\n```\n```\np:img _word\n```\n```\np:meme4 \"lower(FOOL)\"\n```\n```\np:meme4 \"upper(_arab)!\"\n```\n```\np:spam 25 _sayori\n```\n```\np:say choice(da minion | da bob)\n```",
                        },
                        {
                            "name": "Templates",
                            "value": "Speech Bubble\n```\ncommand(vmerge | https://cdn.discordapp.com/attachments/760223418968047629/938887195471786034/unknown.png lasturl())\n```\nSquare Crop\n```\ncommand(crop | declare(url | lasturl()) declare(width | width({url})) declare(height | height({url})) declare(biggest | if(equal({width} | {height}) | both | if(bigger({width} | {height}) | width | height))) {url} if(notequal({biggest} | both) | -x if(equal({biggest} | width) | math({width} / 2 - {height} / 2) | 0) -y if(equal({biggest} | height) | math({height} / 2 - {width} / 2) | 0) -w if(equal({biggest} | width) | {height} | {width}) -h if(equal({biggest} |height) | {width} | {height})))\n```\nHerobrine\n```\ncommand(overlay | https://cdn.discordapp.com/attachments/879658786376265768/930909703595253810/herobrines.png lasturl() -origin center bottom -offsetpos -135 -221 -width 30 -height 30 -keepaspectratio increase)\n```"
                        }
                    ]
                }
                var keyEmbed = {
                    "title": `Special Keywords`,
                    "description": "Here's a list of all keywords that can be used.",
                    "color": 0x472604,
                    "footer": {
                        "icon_url": bot.user.displayAvatarURL({ dynamic: true, size: 1024, format: 'png' }),
                        "text": `Page ${keynumber}/${keyfields.length}`
                    },
                    "fields": keyfields[keynumber - 1]
                };
                var modEmbed = {
                    "title": `Special Functions`,
                    "description": "Here's a list of all functions that can be used.",
                    "color": 0x472604,
                    "footer": {
                        "icon_url": bot.user.displayAvatarURL({ dynamic: true, size: 1024, format: 'png' }),
                        "text": `Page ${modnumber}/${funcfields.length}`
                    },
                    "fields": funcfields[modnumber - 1]
                };
                var keyreactions = [
                    {
                        reaction: "861253229723123762",
                        function: () => {
                            return 1
                        },
                    },
                    {
                        reaction: "861253229726793728",
                        function: (number) => {
                            return number - 1
                        },
                    },
                    {
                        reaction: "861253230070988860",
                        function: () => {
                            return Math.floor(Math.random() * keyfields.length) + 1
                        },
                    },
                    {
                        reaction: "861253229798621205",
                        function: (number) => {
                            return number + 1
                        },
                    },
                    {
                        reaction: "861253229740556308",
                        function: () => {
                            return keyfields.length
                        },
                    },
                ]

                var funcreactions = [
                    {
                        reaction: "861253229723123762",
                        function: () => {
                            return 1
                        },
                    },
                    {
                        reaction: "861253229726793728",
                        function: (number) => {
                            return number - 1
                        },
                    },
                    {
                        reaction: "861253230070988860",
                        function: () => {
                            return Math.floor(Math.random() * funcfields.length) + 1
                        },
                    },
                    {
                        reaction: "861253229798621205",
                        function: (number) => {
                            return number + 1
                        },
                    },
                    {
                        reaction: "861253229740556308",
                        function: () => {
                            return funcfields.length
                        },
                    },
                ]

                var keybuttonRow = new Discord.MessageActionRow()
                keyreactions.forEach(reaction => {
                    var button = new Discord.MessageButton()
                        .setStyle('PRIMARY')
                        .setEmoji(reaction.reaction)
                        .setCustomId(reaction.reaction)
                    keybuttonRow.addComponents([button])
                })

                var funcbuttonRow = new Discord.MessageActionRow()
                funcreactions.forEach(reaction => {
                    var button = new Discord.MessageButton()
                        .setStyle('PRIMARY')
                        .setEmoji(reaction.reaction)
                        .setCustomId(reaction.reaction)
                    funcbuttonRow.addComponents([button])
                })

                await msg.author.send({
                    embeds: [infoEmbed]
                }).catch(() => {
                    msg.channel.send('Couldn\'t send info to you. Do you have me blocked?')
                    return
                })

                await msg.author.send({
                    embeds: [keyEmbed],
                    components: [keybuttonRow]
                }).then(async sentMessage => {
                    var helpMessage = sentMessage
                    var filter = (button) => {
                        if (!(button.user.id === msg.author.id && button.user.id !== bot.user.id && !button.user.bot)) {
                            button.deferUpdate().catch(() => { })
                            return
                        }
                        if (keyreactions.find(findreaction => findreaction.reaction === button.customId).function(keynumber) > keyfields.length || keyreactions.find(findreaction => findreaction.reaction === button.customId).function(keynumber) < 1) {
                            button.deferUpdate().catch(() => { })
                            return
                        }
                        keynumber = keyreactions.find(findreaction => findreaction.reaction === button.customId).function(keynumber)
                        keyEmbed = {
                            "title": `Keywords`,
                            "description": "Here's a list of all keywords that can be used.",
                            "color": 0x472604,
                            "footer": {
                                "icon_url": bot.user.displayAvatarURL({ dynamic: true, size: 1024, format: 'png' }),
                                "text": `Page ${keynumber}/${keyfields.length}`
                            },
                            "fields": keyfields[keynumber - 1]
                        };
                        helpMessage.edit({
                            embeds: [keyEmbed],
                            components: [keybuttonRow]
                        }).catch(() => { })
                        button.deferUpdate().catch(() => { })
                    }
                    helpMessage.awaitMessageComponent({ componentType: 'BUTTON', time: 600000, filter }).then(() => {
                        if (!helpMessage) return
                        helpMessage.edit({
                            embeds: [keyEmbed]
                        }).catch(() => { })
                    })
                        .catch(() => { })
                })
                    .catch(() => {
                        msg.channel.send('Couldn\'t send keywords to you. Do you have me blocked?')
                        return
                    })

                await msg.author.send({
                    embeds: [modEmbed],
                    components: [funcbuttonRow]
                }).then(async sentMessage => {
                    var helpMessage = sentMessage
                    var filter = (button) => {
                        if (!(button.user.id === msg.author.id && button.user.id !== bot.user.id && !button.user.bot)) {
                            button.deferUpdate().catch(() => { })
                            return
                        }
                        if (funcreactions.find(findreaction => findreaction.reaction === button.customId).function(modnumber) > funcfields.length || funcreactions.find(findreaction => findreaction.reaction === button.customId).function(modnumber) < 1) {
                            button.deferUpdate().catch(() => { })
                            return
                        }
                        modnumber = funcreactions.find(findreaction => findreaction.reaction === button.customId).function(modnumber)
                        modEmbed = {
                            "title": `Functions`,
                            "description": "Here's a list of all functions that can be used.",
                            "color": 0x472604,
                            "footer": {
                                "icon_url": bot.user.displayAvatarURL({ dynamic: true, size: 1024, format: 'png' }),
                                "text": `Page ${modnumber}/${funcfields.length}`
                            },
                            "fields": funcfields[modnumber - 1]
                        };
                        helpMessage.edit({
                            embeds: [modEmbed],
                            components: [funcbuttonRow]
                        }).catch(() => { })
                        button.deferUpdate().catch(() => { })
                    }
                    helpMessage.awaitMessageComponent({ componentType: 'BUTTON', time: 600000, filter }).then(() => {
                        if (!helpMessage) return
                        helpMessage.edit({
                            embeds: [modEmbed]
                        }).catch(() => { })
                    })
                        .catch(() => { })
                })
                    .catch(() => {
                        msg.channel.send('Couldn\'t send functions to you. Do you have me blocked?')
                        return
                    })

                msg.channel.send('‚úÖ Check your DMs.').catch(() => { })
            },
            help: {
                "name": "specialkeys/keywords/functions",
                "value": "DMs you a list of special keywords that can be used for all commands."
            },
            cooldown: 2500,
            type: "Unique"
        },

        {
            name: ["battlestats", "userstats"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (args[1] === undefined) {
                    if (!data()[mongodatabase]['user-data'][msg.author.id]) {
                        data()[mongodatabase]['user-data'][msg.author.id] = {}
                    }
                    if (!data()[mongodatabase]['user-data'][msg.author.id]['health']) {
                        data()[mongodatabase]['user-data'][msg.author.id]['health'] = 100
                    }
                    var statsEmbed = {
                        title: msg.author.username + '\'s Stats',
                        color: 0x472604,
                        footer: {
                            icon_url: bot.user.displayAvatarURL({ dynamic: true, size: 1024, format: 'png' }),
                            text: bot.user.username
                        },
                        fields: [
                            {
                                name: "Health",
                                value: data()[mongodatabase]['user-data'][msg.author.id]['health'] + ' HP'
                            }
                        ]
                    }
                    msg.channel.send({
                        embeds: [statsEmbed],
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                }
                if (!msg.mentions.members.size) {
                    async function getMember(id) {
                        var member = await bot.users.fetch(id)
                            .catch(function () {
                                msg.channel.send({
                                    content: 'Invalid user id: **' + id + '**',
                                    allowedMentions: {
                                        parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    }
                                }).catch(() => { })
                                msg.channel.sendTyping().catch(() => { })
                                return
                            })

                        if (member) {
                            if (!data()[mongodatabase]['user-data'][member.id]) {
                                data()[mongodatabase]['user-data'][member.id] = {}
                            }
                            if (!data()[mongodatabase]['user-data'][member.id]['health']) {
                                data()[mongodatabase]['user-data'][member.id]['health'] = 100
                            }
                            var statsEmbed = {
                                title: member.username + '\'s Stats',
                                color: 0x472604,
                                footer: {
                                    icon_url: bot.user.displayAvatarURL({ dynamic: true, size: 1024, format: 'png' }),
                                    text: bot.user.username
                                },
                                fields: [
                                    {
                                        name: "Health",
                                        value: data()[mongodatabase]['user-data'][member.id]['health'] + ' HP'
                                    }
                                ]
                            }
                            msg.channel.send({
                                embeds: [statsEmbed],
                                allowedMentions: {
                                    parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            }).catch(() => { })
                            msg.channel.sendTyping().catch(() => { })
                        }
                    }

                    getMember(args[1]);
                }
                else {
                    var mention = msg.mentions.members.first();
                    if (!data()[mongodatabase]['user-data'][mention.id]) {
                        data()[mongodatabase]['user-data'][mention.id] = {}
                    }
                    if (!data()[mongodatabase]['user-data'][mention.id]['health']) {
                        data()[mongodatabase]['user-data'][mention.id]['health'] = 100
                    }
                    var statsEmbed = {
                        title: mention.user.username + '\'s Stats',
                        color: 0x472604,
                        footer: {
                            icon_url: bot.user.displayAvatarURL({ dynamic: true, size: 1024, format: 'png' }),
                            text: bot.user.username
                        },
                        fields: [
                            {
                                name: "Health",
                                value: data()[mongodatabase]['user-data'][mention.id]['health'] + ' HP'
                            }
                        ]
                    }
                    msg.channel.send({
                        embeds: [statsEmbed],
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                }
            },
            help: {
                "name": "battlestats/userstats {user}",
                "value": "Shows the user's battle stats."
            },
            cooldown: 2500,
            type: "Battling"
        },

        {
            name: ["tcommands", "toggledcommands", "togglecommands"],
            execute: async function (msg, args) {
                var options = {
                    list: async (msg) => {
                        var list = []

                        data()[mongodatabase]['guild-data'][msg.guild.id]['disabled'].forEach(cmd => {
                            list.push(`- \`${cmd.join('/')}\``)
                        })

                        if (!list.length) {
                            list = ['None.']
                        }

                        var listEmbed = {
                            title: `List of disabled commands for ${msg.guild.name}`,
                            description: list.join('\n'),
                            color: 0x472604,
                            footer: {
                                icon_url: bot.user.displayAvatarURL({ dynamic: true, size: 1024, format: 'png' }),
                                text: bot.user.username
                            }
                        }

                        msg.channel.send({
                            embeds: [listEmbed],
                            allowedMentions: {
                                parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                            }
                        }).catch(() => { })
                    },

                    toggle: async (msg, args) => {
                        if (msg.member.permissions.has('MANAGE_GUILD') || msg.member.roles.cache.find(role => role.name.match(/mod|dev|admin|owner|creator|founder|staff/ig)) || msg.member.permissions.has('ADMINISTRATOR') || msg.author.id === msg.guild.ownerID || (ownerids.find(id => id == msg.author.id))) {
                            if (!args[2]) {
                                msg.channel.send('You gotta specify a command!')
                                return
                            }

                            var findCommand = commands.find(cmd => cmd.name.find(n => n === args[2].toLowerCase()))

                            if (findCommand) {
                                var findDCommand = data()[mongodatabase]['guild-data'][msg.guild.id]['disabled'].find(cmd => cmd.find(n => n === args[2].toLowerCase()))

                                if (findDCommand) {
                                    var index = data()[mongodatabase]['guild-data'][msg.guild.id]['disabled'].findIndex(cmd => {
                                        return cmd.find(n => {
                                            return n === args[2].toLowerCase()
                                        })
                                    })

                                    data()[mongodatabase]['guild-data'][msg.guild.id]['disabled'].splice(index, 1)

                                    msg.channel.send(`Enabled \`${findCommand.name.join('/')}\`.`)
                                } else {
                                    if (findCommand.name.find(n => n === args[0].toLowerCase())) {
                                        msg.channel.send(`You can't disable the disabling command!`)
                                        return
                                    }

                                    data()[mongodatabase]['guild-data'][msg.guild.id]['disabled'].push(findCommand.name)

                                    msg.channel.send(`Disabled \`${findCommand.name.join('/')}\`.`)
                                }
                            } else {
                                msg.channel.send('Not a valid command.')
                                return
                            }
                        } else {
                            msg.channel.send('You need to be an administrator to execute that!').catch(() => { })
                            return;
                        };
                    },
                }

                if (!args[1]) {
                    msg.channel.send({
                        embeds: [
                            {
                                "title": "Available Options",
                                "description": "**list** - Gets a list of disabled commands.\n**toggle** <command> (admin only) - Disables/enables a command, if it exists.",
                                "color": 0x472604,
                                "footer": {
                                    "icon_url": bot.user.displayAvatarURL({ dynamic: true, size: 1024, format: 'png' }),
                                    "text": bot.user.username
                                },
                            }
                        ]
                    }).catch(() => { })
                    return
                }

                if (!options[args[1].toLowerCase()]) {
                    msg.channel.send('Not a valid option.')
                    return
                }

                await options[args[1].toLowerCase()](msg, args)
            },
            help: {
                "name": "tcommands/toggledcommands/togglecommands <option>",
                "value": "**list** - Gets a list of disabled commands.\n**toggle** <command> (admin only) - Disables/enables a command, if it exists."
            },
            cooldown: 5000,
            type: "Settings"
        },

        {
            name: ["chaincommands"],
            execute: async function (msg) {
                if (msg.member.permissions.has('MANAGE_GUILD') || msg.member.roles.cache.find(role => role.name.match(/mod|dev|admin|owner|creator|founder|staff/ig)) || msg.member.permissions.has('ADMINISTRATOR') || msg.author.id === msg.guild.ownerID || ownerids.find(id => id == msg.author.id)) {
                    data()[mongodatabase]['guild-data'][msg.guild.id]['chaincommands'] = !data()[mongodatabase]['guild-data'][msg.guild.id]['chaincommands']
                    msg.channel.send('Set to **' + data()[mongodatabase]['guild-data'][msg.guild.id]['chaincommands'] + '**.').catch(() => { })
                } else {
                    msg.channel.send('You need to be an administrator to execute that!').catch(() => { })
                    return;
                };
            },
            help: {
                "name": "chaincommands (admin only)",
                "value": "Enable or disable the ability to chain commands, if you don't want the chat to get spammy of course."
            },
            cooldown: 5000,
            perms: ["ADMINISTRATOR"],
            type: "Settings"
        },

        {
            name: ["localcommands", "localcmds", "servercommands", "servercmds"],
            execute: async function (msg, args) {
                var options = {
                    list: async (msg) => {
                        var number = 1
                        var localCmdsArray = []
                        for (var i in data()[mongodatabase]['guild-data'][msg.guild.id]['localcmds']) {
                            var cmd = data()[mongodatabase]['guild-data'][msg.guild.id]['localcmds'][i]
                            localCmdsArray.push(`- ${cmd.name}`)
                        }
                        var localCmds = localCmdsArray.length ? chunkArray(localCmdsArray, 10) : [['None.']]
                        var cmdEmbed = {
                            "title": `List of local commands for ${msg.guild.name}`,
                            "description": localCmds[number - 1].join('\n'),
                            "color": 0x472604,
                            "footer": {
                                "icon_url": bot.user.displayAvatarURL({ dynamic: true, size: 1024, format: 'png' }),
                                "text": `Page ${number}/${localCmds.length}`
                            },
                        };
                        var reactions = [
                            {
                                reaction: "861253229723123762",
                                function: () => {
                                    return 1
                                },
                            },
                            {
                                reaction: "861253229726793728",
                                function: (number) => {
                                    return number - 1
                                },
                            },
                            {
                                reaction: "861253230070988860",
                                function: () => {
                                    return Math.floor(Math.random() * localCmds.length) + 1
                                },
                            },
                            {
                                reaction: "861253229798621205",
                                function: (number) => {
                                    return number + 1
                                },
                            },
                            {
                                reaction: "861253229740556308",
                                function: () => {
                                    return localCmds.length
                                },
                            },
                        ]
                        var buttonRow = new Discord.MessageActionRow()
                        reactions.forEach(reaction => {
                            var button = new Discord.MessageButton()
                                .setStyle('PRIMARY')
                                .setEmoji(reaction.reaction)
                                .setCustomId(reaction.reaction)
                            buttonRow.addComponents([button])
                        })

                        await msg.channel.send({
                            embeds: [cmdEmbed],
                            components: [buttonRow]
                        }).then(async sentMessage => {
                            var helpMessage = sentMessage
                            var filter = (button) => {
                                if (data2[msg.guild.id][msg.author.id]['promises'].find(promise => promise.promise === p).active === false) return
                                if (!(button.user.id === msg.author.id && button.user.id !== bot.user.id && !button.user.bot)) {
                                    button.deferUpdate().catch(() => { })
                                    return
                                }
                                if (reactions.find(findreaction => findreaction.reaction === button.customId).function(number) > localCmds.length || reactions.find(findreaction => findreaction.reaction === button.customId).function(number) < 1) {
                                    button.deferUpdate().catch(() => { })
                                    return
                                }
                                number = reactions.find(findreaction => findreaction.reaction === button.customId).function(number)
                                cmdEmbed = {
                                    "title": `List of local commands for ${msg.guild.name}`,
                                    "description": localCmds[number - 1].join('\n'),
                                    "color": 0x472604,
                                    "footer": {
                                        "icon_url": bot.user.displayAvatarURL({ dynamic: true, size: 1024, format: 'png' }),
                                        "text": `Page ${number}/${localCmds.length}`
                                    },
                                };
                                helpMessage.edit({
                                    embeds: [cmdEmbed],
                                    components: [buttonRow]
                                }).catch(() => { })
                                button.deferUpdate().catch(() => { })
                            }
                            for (var i in data2[msg.guild.id][msg.author.id]['promises']) {
                                if (data2[msg.guild.id][msg.author.id]['promises'][i]) {
                                    data2[msg.guild.id][msg.author.id]['promises'][i]['active'] = false
                                }
                            }
                            var p = helpMessage.awaitMessageComponent({ componentType: 'BUTTON', time: 600000, filter }).then(() => {
                                for (var i in data2[msg.guild.id][msg.author.id]['promises']) {
                                    if (data2[msg.guild.id][msg.author.id]['promises'][i] == p) {
                                        data2[msg.guild.id][msg.author.id]['promises'][i] = undefined
                                        break
                                    }
                                }
                                if (!helpMessage.edit) return
                                helpMessage.edit({
                                    embeds: [cmdEmbed]
                                }).catch(() => { })
                            })
                                .catch((err) => {
                                    if (err.message.endsWith('reason: time')) {
                                        helpMessage.edit({
                                            embeds: [cmdEmbed]
                                        }).catch(() => { })
                                    }
                                })
                            data2[msg.guild.id][msg.author.id]['promises'].push({ promise: p, active: true })
                        })
                            .catch(() => { })
                    },

                    phrase: async (msg, args) => {
                        if (!args[1]) {
                            msg.channel.send('You gotta specify a command name!').catch(() => { })
                            return
                        }

                        var findCommand = data()[mongodatabase]['guild-data'][msg.guild.id]['localcmds'].findIndex(cmd => cmd.name === args[1].toLowerCase())

                        if (findCommand > -1) {
                            msg.channel.send(`\`${data()[mongodatabase]['guild-data'][msg.guild.id]['localcmds'][findCommand].phrase}\``).catch(() => { })
                        } else {
                            msg.channel.send(`Not a valid command.`).catch(() => { })
                            return
                        }
                    },

                    add: async (msg, args) => {
                        if (msg.member.permissions.has('MANAGE_GUILD') || msg.member.roles.cache.find(role => role.name.match(/mod|dev|admin|owner|creator|founder|staff/ig)) || msg.member.permissions.has('ADMINISTRATOR') || msg.author.id === msg.guild.ownerID || ownerids.find(id => id == msg.author.id)) {
                            if (!args[1]) {
                                msg.channel.send('You gotta specify a command name!').catch(() => { })
                                return
                            }
                            if (!args[2]) {
                                msg.channel.send('You gotta specify a command phrase!').catch(() => { })
                                return
                            }

                            var saidMessage = args.join(' ').substring(args[0].length + args[1].length + 2)
                            var findCommand = commands.find(cmd => cmd.name.find(n => n === args[1].toLowerCase())) || data()[mongodatabase]['guild-data'][msg.guild.id]['localcmds'].find(cmd => cmd.name === args[1].toLowerCase())

                            if (findCommand) {
                                msg.channel.send(`That name was already taken!`).catch(() => { })
                                return
                            } else {
                                data()[mongodatabase]['guild-data'][msg.guild.id]['localcmds'].push({
                                    name: args[1].toLowerCase(),
                                    phrase: saidMessage
                                })

                                msg.channel.send({
                                    content: `‚úÖ Added \`${args[1].toLowerCase()}\` command with phrase \`${saidMessage}\``,
                                    allowedMentions: {
                                        parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    }
                                }).catch(() => { })
                            }
                        } else {
                            msg.channel.send('You need to be an administrator to execute that!').catch(() => { })
                            return;
                        };
                    },

                    import: async (msg, args) => {
                        if (msg.member.permissions.has('MANAGE_GUILD') || msg.member.roles.cache.find(role => role.name.match(/mod|dev|admin|owner|creator|founder|staff/ig)) || msg.member.permissions.has('ADMINISTRATOR') || msg.author.id === msg.guild.ownerID || ownerids.find(id => id == msg.author.id)) {
                            if (!args[1]) {
                                msg.channel.send('You gotta specify the ID!').catch(() => { })
                                return
                            }

                            var id = args[1].replace(/#/g, '')

                            var findCommandTemplate = data()[mongodatabase]['bot-data']['bot']['commandTemplates'].find(cmd => cmd.id == id)

                            if (findCommandTemplate) {
                                var name = args[2] ? args[2].toLowerCase() : findCommandTemplate.name

                                var findCommand = commands.find(cmd => cmd.name.find(n => n === name)) || data()[mongodatabase]['guild-data'][msg.guild.id]['localcmds'].find(cmd => cmd.name === name)

                                if (findCommand) {
                                    msg.channel.send(`The name of that command was already taken!`).catch(() => { })
                                    return
                                }

                                data()[mongodatabase]['guild-data'][msg.guild.id]['localcmds'].push({
                                    name: name,
                                    phrase: findCommandTemplate.phrase
                                })

                                msg.channel.send({
                                    content: `‚úÖ Imported \`${name}\` command with phrase \`${findCommandTemplate.phrase}\``,
                                    allowedMentions: {
                                        parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    }
                                }).catch(() => { })
                            } else {
                                msg.channel.send('Not a valid ID.').catch(() => { })
                            }
                        } else {
                            msg.channel.send('You need to be an administrator to execute that!').catch(() => { })
                            return;
                        };
                    },

                    edit: async (msg, args) => {
                        if (msg.member.permissions.has('MANAGE_GUILD') || msg.member.roles.cache.find(role => role.name.match(/mod|dev|admin|owner|creator|founder|staff/ig)) || msg.member.permissions.has('ADMINISTRATOR') || msg.author.id === msg.guild.ownerID || ownerids.find(id => id == msg.author.id)) {
                            if (!args[1]) {
                                msg.channel.send('You gotta specify a command name!').catch(() => { })
                                return
                            }
                            if (!args[2]) {
                                msg.channel.send('You gotta specify a command phrase!').catch(() => { })
                                return
                            }

                            var saidMessage = args.join(' ').substring(args[0].length + args[1].length + 2)
                            var findCommand = data()[mongodatabase]['guild-data'][msg.guild.id]['localcmds'].findIndex(cmd => cmd.name === args[1].toLowerCase())

                            if (findCommand > -1) {
                                data()[mongodatabase]['guild-data'][msg.guild.id]['localcmds'][findCommand] = {
                                    name: args[1].toLowerCase(),
                                    phrase: saidMessage
                                }

                                msg.channel.send({
                                    content: `‚úÖ Edited \`${args[1].toLowerCase()}\` command with phrase \`${saidMessage}\``,
                                    allowedMentions: {
                                        parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    }
                                }).catch(() => { })
                            } else {
                                msg.channel.send(`Not a valid command.`).catch(() => { })
                                return
                            }
                        } else {
                            msg.channel.send('You need to be an administrator to execute that!').catch(() => { })
                            return;
                        };
                    },

                    delete: async (msg, args) => {
                        if (msg.member.permissions.has('MANAGE_GUILD') || msg.member.roles.cache.find(role => role.name.match(/mod|dev|admin|owner|creator|founder|staff/ig)) || msg.member.permissions.has('ADMINISTRATOR') || msg.author.id === msg.guild.ownerID || ownerids.find(id => id == msg.author.id)) {
                            if (!args[1]) {
                                msg.channel.send('You gotta specify a command name!').catch(() => { })
                                return
                            }

                            var findCommand = data()[mongodatabase]['guild-data'][msg.guild.id]['localcmds'].findIndex(cmd => cmd.name === args[1].toLowerCase())

                            if (findCommand > -1) {
                                data()[mongodatabase]['guild-data'][msg.guild.id]['localcmds'].splice(findCommand, 1)

                                msg.channel.send({
                                    content: `‚úÖ Removed \`${args[1].toLowerCase()}\` command.`,
                                    allowedMentions: {
                                        parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    }
                                }).catch(() => { })
                            } else {
                                msg.channel.send(`Not a valid command.`).catch(() => { })
                                return
                            }
                        } else {
                            msg.channel.send('You need to be an administrator to execute that!').catch(() => { })
                            return;
                        };
                    },
                }

                if (!args[1]) {
                    msg.channel.send({
                        embeds: [
                            {
                                "title": "Available Options",
                                "description": "**list** - Gets a list of local commands.\n**phrase** <commandname> - Displays the phrase of a specific command.\n**add** <commandname> <phrase> (admin only) - Adds a new local command, if the name is available for use.\n**import** <id> [name] (admin only) - Imports a new local command from Poopy's command template database (`commandtemplates` command) by ID.\n**edit** <commandname> <phrase> (admin only) - Edits the local command, if it exists.\n**delete** <commandname> (admin only) - Deletes the local command, if it exists.",
                                "color": 0x472604,
                                "footer": {
                                    "icon_url": bot.user.displayAvatarURL({ dynamic: true, size: 1024, format: 'png' }),
                                    "text": bot.user.username
                                },
                            }
                        ]
                    }).catch(() => { })
                    return
                }

                if (!options[args[1].toLowerCase()]) {
                    msg.channel.send('Not a valid option.').catch(() => { })
                    return
                }

                await options[args[1].toLowerCase()](msg, args.slice(1))
            },
            help: {
                "name": "localcommands/localcmds <option>",
                "value": "Note: Keywords can be used.\n\n**list** - Gets a list of local commands.\n**phrase** <commandname> - Displays the phrase of a specific command.\n**add** <commandname> <phrase> (admin only) - Adds a new local command, if the name is available for use.\n**import** <id> [name] (admin only) - Imports a new local command from Poopy's command template database (`commandtemplates` command) by ID.\n**edit** <commandname> <phrase> (admin only) - Edits the local command, if it exists.\n**delete** <commandname> (admin only) - Deletes the local command, if it exists."
            },
            cooldown: 5000,
            type: "Unique"
        },

        {
            name: ["messages"],
            execute: async function (msg, args) {
                var options = {
                    list: async (msg) => {
                        var currentcount = filecount
                        filecount++
                        var filepath = `temp/file${currentcount}`
                        fs.mkdirSync(`${filepath}`)
                        fs.writeFileSync(`${filepath}/messagelist.txt`, data()[mongodatabase]['guild-data'][msg.guild.id]['messages'].join('\n\n-----------------------------------------------\n\n') || 'lmao theres nothing')
                        await msg.channel.send({
                            files: [new Discord.MessageAttachment(`${filepath}/messagelist.txt`)]
                        }).catch(() => { })
                        fs.rmSync(`${filepath}`, { force: true, recursive: true })
                    },

                    search: async (msg, args) => {
                        if (!args[1]) {
                            msg.channel.send('You gotta specify the query!').catch(() => { })
                            return
                        }

                        var saidMessage = args.join(' ').substring(args[0].length + 1)
                        var cleanMessage = Discord.Util.cleanContent(saidMessage, msg).replace(/\@/g, '@‚Äå')
                        var results = []

                        data()[mongodatabase]['guild-data'][msg.guild.id]['messages'].forEach(message => {
                            if (message.toLowerCase().includes(cleanMessage.toLowerCase())) {
                                results.push(message)
                            }
                        })

                        if (results.length) {
                            results.sort((a, b) => Math.abs(1 - similarity(a.toLowerCase(), cleanMessage.toLowerCase())) - Math.abs(1 - similarity(b.toLowerCase(), cleanMessage.toLowerCase())))
                        }

                        var currentcount = filecount
                        filecount++
                        var filepath = `temp/file${currentcount}`
                        fs.mkdirSync(`${filepath}`)
                        fs.writeFileSync(`${filepath}/messagelist.txt`, results.join('\n\n-----------------------------------------------\n\n') || 'lmao theres nothing')
                        await msg.channel.send({
                            files: [new Discord.MessageAttachment(`${filepath}/messagelist.txt`)]
                        }).catch(() => { })
                        fs.rmSync(`${filepath}`, { force: true, recursive: true })
                    },

                    random: async (msg) => {
                        msg.channel.send(data()[mongodatabase]['guild-data'][msg.guild.id]['messages'][Math.floor(Math.random() * data()[mongodatabase]['guild-data'][msg.guild.id]['messages'].length)]).catch(() => { })
                    },

                    add: async (msg, args) => {
                        if (!args[1]) {
                            msg.channel.send('You gotta specify the message!').catch(() => { })
                            return
                        }

                        var saidMessage = args.join(' ').substring(args[0].length + 1)
                        var cleanMessage = Discord.Util.cleanContent(saidMessage, msg).replace(/\@/g, '@‚Äå')
                        var findMessage = data()[mongodatabase]['guild-data'][msg.guild.id]['messages'].find(message => message.toLowerCase() === cleanMessage.toLowerCase())

                        if (findMessage) {
                            msg.channel.send(`That message already exists.`).catch(() => { })
                            return
                        } else {
                            var send = true

                            if (cleanMessage.match(/nigg|https?\:\/\/.*(rule34|e621|pornhub|hentaihaven|xxx|iplogger|discord\.gg\/[\d\w]+\/?$|discord\.gift)/ig)) {
                                send = await yesno(msg.channel, 'That message looks dangerous, are you sure about this?', msg.member.id).catch(() => { }) ?? false
                            }

                            var messages = [cleanMessage].concat(data()[mongodatabase]['guild-data'][msg.guild.id]['messages'])
                            messages.splice(1000)
                            data()[mongodatabase]['guild-data'][msg.guild.id]['messages'] = messages

                            msg.channel.send({
                                content: `‚úÖ Added ${cleanMessage}`,
                                allowedMentions: {
                                    parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            }).catch(() => { })
                        }
                    },

                    delete: async (msg, args) => {
                        if (!args[1]) {
                            msg.channel.send('You gotta specify the message!').catch(() => { })
                            return
                        }

                        var saidMessage = args.join(' ').substring(args[0].length + 1)
                        var cleanMessage = Discord.Util.cleanContent(saidMessage, msg).replace(/\@/g, '@‚Äå')
                        var findMessage = data()[mongodatabase]['guild-data'][msg.guild.id]['messages'].findIndex(message => message.toLowerCase() === cleanMessage.toLowerCase())

                        if (findMessage > -1) {
                            data()[mongodatabase]['guild-data'][msg.guild.id]['messages'].splice(findMessage, 1)

                            msg.channel.send(`‚úÖ Removed.`).catch(() => { })
                        } else {
                            msg.channel.send(`Not found.`).catch(() => { })
                        }
                    },

                    clear: async (msg) => {
                        if (msg.member.permissions.has('MANAGE_GUILD') || msg.member.roles.cache.find(role => role.name.match(/mod|dev|admin|owner|creator|founder|staff/ig)) || msg.member.permissions.has('ADMINISTRATOR') || msg.author.id === msg.guild.ownerID || ownerids.find(id => id == msg.author.id)) {
                            var confirm = await yesno(msg.channel, 'are you sure about this', msg.member.id).catch(() => { })

                            if (confirm) {
                                data()[mongodatabase]['guild-data'][msg.guild.id]['messages'] = []

                                msg.channel.send(`‚úÖ All the messages from the database have been cleared.`).catch(() => { })
                            }
                        } else {
                            msg.channel.send('You need to be an administrator to execute that!').catch(() => { })
                        };
                    },

                    read: async (msg) => {
                        if (msg.member.permissions.has('MANAGE_GUILD') || msg.member.roles.cache.find(role => role.name.match(/mod|dev|admin|owner|creator|founder|staff/ig)) || msg.member.permissions.has('ADMINISTRATOR') || msg.author.id === msg.guild.ownerID || ownerids.find(id => id == msg.author.id)) {
                            data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['read'] = !(data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['read'])

                            var read = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['read']
                            msg.channel.send(`I **can${!read ? '\'t' : ''} read** messages from the channel now.`).catch(() => { })
                        } else {
                            msg.channel.send('You need to be an administrator to execute that!').catch(() => { })
                            return;
                        };
                    },

                    readall: async (msg) => {
                        if (msg.member.permissions.has('MANAGE_GUILD') || msg.member.roles.cache.find(role => role.name.match(/mod|dev|admin|owner|creator|founder|staff/ig)) || msg.member.permissions.has('ADMINISTRATOR') || msg.author.id === msg.guild.ownerID || ownerids.find(id => id == msg.author.id)) {
                            data()[mongodatabase]['guild-data'][msg.guild.id]['read'] = !(data()[mongodatabase]['guild-data'][msg.guild.id]['read'])
                            var channels = msg.guild.channels.cache

                            channels.forEach(channel => {
                                if (channel.isText()) {
                                    if (!data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][channel.id]) {
                                        data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][channel.id] = {}
                                    }

                                    data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][channel.id]['read'] = data()[mongodatabase]['guild-data'][msg.guild.id]['read']
                                }
                            })

                            var read = data()[mongodatabase]['guild-data'][msg.guild.id]['read']
                            msg.channel.send(`I **can${!read ? '\'t' : ''} read** messages from all channels now.`).catch(() => { })
                        } else {
                            msg.channel.send('You need to be an administrator to execute that!').catch(() => { })
                            return;
                        };
                    },
                }

                if (!args[1]) {
                    msg.channel.send({
                        embeds: [
                            {
                                "title": "Available Options",
                                "description": "**list** - Sends a text file with a list of all messages that exist within the guild's message database.\n\n**search** <query> - Searches for every message in the server that matches the query.\n\n**random** - Sends a random message from the database to the channel.\n\n**add** <message> - Adds a new message to the guild's database, if it is available for use.\n\n**delete** <message> - Deletes the message, if it exists.\n\n**clear** (admin only) - Clears ALL the messages from the database.\n\n**read** (admin only) - Toggles whether the bot can read the messages from the channel or not.\n\n**readall** (admin only) - Toggles whether the bot can read the messages from all channels or not.",
                                "color": 0x472604,
                                "footer": {
                                    "icon_url": bot.user.displayAvatarURL({ dynamic: true, size: 1024, format: 'png' }),
                                    "text": bot.user.username
                                },
                            }
                        ]
                    }).catch(() => { })
                    return
                }

                if (!options[args[1].toLowerCase()]) {
                    msg.channel.send('Not a valid option.').catch(() => { })
                    return
                }

                await options[args[1].toLowerCase()](msg, args.slice(1))
            },
            help: {
                "name": "messages <option>",
                "value": "Allows you to see or manage the server's message database. Used by the `_message` keyword and has a 1000 messages limit.\n\n**list** - Sends a text file with a list of all messages that exist within the guild's message database.\n\n**search** <query> - Searches for every message in the server that matches the query.\n\n**random** - Sends a random message from the database to the channel.\n\n**add** <message> - Adds a new message to the guild's database, if it is available for use.\n\n**delete** <message> - Deletes the message, if it exists.\n\n**clear** (admin only) - Clears ALL the messages from the database.\n\n**read** (admin only) - Toggles whether the bot can read the messages from the channel or not.\n\n**readall** (admin only) - Toggles whether the bot can read the messages from all channels or not."
            },
            cooldown: 2500,
            type: "Unique"
        },

        {
            name: ["commandtemplates", "cmdtemplates"],
            execute: async function (msg, args) {
                async function createCommand(msg, args) {
                    if (!args[1]) {
                        msg.channel.send('You gotta specify the name!').catch(() => { })
                        return
                    }

                    if (!args[2]) {
                        msg.channel.send('You gotta specify the phrase!').catch(() => { })
                        return
                    }

                    var name = args[1].toLowerCase()

                    var params = {}

                    var imageindex = args.indexOf('-image')
                    if (imageindex > -1 && args[imageindex + 1]) {
                        if (validUrl.test(args[imageindex + 1])) {
                            params.image = args[imageindex + 1]
                        } else {
                            msg.channel.send('Not a valid image URL.').catch(() => { })
                            return
                        }
                    }

                    var saidMessage = args.join(' ').substring(args[0].length + args[1].length + 2)

                    var optionIndex = args.findIndex(arg => arg.match(/-(description|syntax|image)/))
                    var argmatches = saidMessage.match(/-(description|syntax)/g)
                    if (argmatches) {
                        for (var i in argmatches) {
                            var argmatch = argmatches[i]
                            var argIndex = args.indexOf(argmatch)
                            var nextArgs = args.slice(argIndex + 1)
                            var arg = ''
                            for (var j in nextArgs) {
                                var nextArg = nextArgs[j]
                                if (nextArg.match(/-(description|syntax|image)/)) break
                                arg += `${nextArg} `
                            }
                            arg = arg.substring(0, arg.length - 1)

                            params[argmatch.substring(1)] = arg
                        }
                    }

                    var phraseArgs = args
                    if (optionIndex > -1) {
                        phraseArgs.splice(optionIndex)
                    }
                    phraseArgs.splice(0, 2)

                    if (phraseArgs.length <= 0) {
                        msg.channel.send('You gotta specify the phrase!').catch(() => { })
                        return
                    }

                    params.phrase = phraseArgs.join(' ')

                    var findCommand = data()[mongodatabase]['bot-data']['bot']['commandTemplates'].find(cmd => cmd.name === name && cmd.creator === msg.author.id)

                    if (findCommand) {
                        msg.channel.send(`You've already created a command with that name! (ID: \`${findCommand.id}\`)`).catch(() => { })
                        return
                    } else {
                        var id = generateId(true)

                        var commands = [{
                            name: name,
                            description: params.description,
                            phrase: params.phrase,
                            image: params.image,
                            syntax: params.syntax,
                            id: id,
                            creator: msg.author.id,
                            date: Math.floor(Date.now() / 1000)
                        }].concat(data()[mongodatabase]['bot-data']['bot']['commandTemplates'])
                        data()[mongodatabase]['bot-data']['bot']['commandTemplates'] = commands

                        msg.channel.send({
                            content: `‚úÖ \`${name}\` was successfully registered to the command template database! (ID: \`${id}\`)`,
                            allowedMentions: {
                                parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                            }
                        }).catch(() => { })
                    }
                }

                var options = {
                    list: async (msg) => {
                        var number = 1
                        var dcmdTemplates = data()[mongodatabase]['bot-data']['bot']['commandTemplates']
                        var none = {
                            "title": `there is nothing`,
                            "description": 'wow',
                            "color": 0x472604,
                            "footer": {
                                "icon_url": bot.user.displayAvatarURL({ dynamic: true, size: 1024, format: 'png' }),
                                "text": bot.user.username
                            },
                        }

                        if (dcmdTemplates.length <= 0) {
                            msg.channel.send({
                                embeds: [none]
                            }).catch(() => { })
                            return
                        }

                        dcmdTemplates.sort((a, b) => {
                            if (a.name > b.name) {
                                return 1;
                            }
                            if (a.name < b.name) {
                                return -1;
                            }
                            return 0;
                        })

                        var cmdTemplates = []
                        for (var i in dcmdTemplates) {
                            var cmd = dcmdTemplates[i]

                            var name = cmd.name
                            var description = cmd.description
                            var syntax = cmd.syntax
                            var phrase = cmd.phrase
                            var image = cmd.image
                            var id = cmd.id
                            var creator = cmd.creator
                            var date = cmd.date

                            var long = phrase.length > 1016

                            if (long) {
                                phrase = phrase.substring(0, 1013) + '...'
                            }

                            var embed = {
                                "title": `${name}${syntax ? ` ${syntax}` : ''}`,
                                "color": 0x472604,
                                "fields": [
                                    {
                                        name: "Description",
                                        value: description || 'No description available.'
                                    },
                                    {
                                        name: "ID",
                                        value: `\`${id}\``
                                    },
                                    {
                                        name: "Phrase",
                                        value: `\`\`\`\n${phrase}\n\`\`\``
                                    },
                                    {
                                        name: "Date Updated",
                                        value: `<t:${date}>`
                                    }
                                ],
                                "footer": {
                                    "icon_url": bot.user.displayAvatarURL({ dynamic: true, size: 1024, format: 'png' }),
                                    "text": `Made by ${creator} - Command ${Number(i) + 1}/${dcmdTemplates.length}`
                                },
                            }

                            if (image) {
                                embed.image = {
                                    url: image
                                }
                            }

                            cmdTemplates.push(embed)
                        }

                        var cmdEmbed = cmdTemplates[number - 1]
                        var reactions = [
                            {
                                reaction: "861253229723123762",
                                function: () => {
                                    return 1
                                },
                            },
                            {
                                reaction: "861253229726793728",
                                function: (number) => {
                                    return number - 1
                                },
                            },
                            {
                                reaction: "861253230070988860",
                                function: () => {
                                    return Math.floor(Math.random() * cmdTemplates.length) + 1
                                },
                            },
                            {
                                reaction: "861253229798621205",
                                function: (number) => {
                                    return number + 1
                                },
                            },
                            {
                                reaction: "861253229740556308",
                                function: () => {
                                    return cmdTemplates.length
                                },
                            },
                        ]
                        var buttonRow = new Discord.MessageActionRow()
                        reactions.forEach(reaction => {
                            var button = new Discord.MessageButton()
                                .setStyle('PRIMARY')
                                .setEmoji(reaction.reaction)
                                .setCustomId(reaction.reaction)
                            buttonRow.addComponents([button])
                        })

                        var importButtonRow = new Discord.MessageActionRow()
                        var importButton = new Discord.MessageButton()
                            .setStyle('PRIMARY')
                            .setEmoji('939523064658526278')
                            .setCustomId('import')
                        importButtonRow.addComponents([importButton])

                        await msg.channel.send({
                            embeds: [cmdEmbed],
                            components: [buttonRow, importButtonRow]
                        }).then(async sentMessage => {
                            var helpMessage = sentMessage
                            var filter = (button) => {
                                if (data2[msg.guild.id][msg.author.id]['promises'].find(promise => promise.promise === p).active === false) return
                                if (!(button.user.id === msg.author.id && button.user.id !== bot.user.id && !button.user.bot)) {
                                    button.deferUpdate().catch(() => { })
                                    return
                                }
                                if (button.customId == importButton.customId) {
                                    if (msg.member.permissions.has('MANAGE_GUILD') || msg.member.roles.cache.find(role => role.name.match(/mod|dev|admin|owner|creator|founder|staff/ig)) || msg.member.permissions.has('ADMINISTRATOR') || msg.author.id === msg.guild.ownerID || ownerids.find(id => id == msg.author.id)) {
                                        var findCommandTemplate = dcmdTemplates[number - 1]

                                        if (findCommandTemplate) {
                                            var name = findCommandTemplate.name

                                            var findCommand = commands.find(cmd => cmd.name.find(n => n === name)) || data()[mongodatabase]['guild-data'][msg.guild.id]['localcmds'].find(cmd => cmd.name === name)

                                            if (findCommand) {
                                                button.reply({
                                                    content: `The name of that command was already taken!`,
                                                    ephemeral: true
                                                }).catch(() => { })
                                                return
                                            }

                                            data()[mongodatabase]['guild-data'][msg.guild.id]['localcmds'].push({
                                                name: name,
                                                phrase: findCommandTemplate.phrase
                                            })

                                            msg.channel.send({
                                                content: `‚úÖ Imported \`${name}\` command with phrase \`${findCommandTemplate.phrase}\``,
                                                allowedMentions: {
                                                    parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                                }
                                            }).catch(() => { })
                                        } else {
                                            button.reply({
                                                content: 'Error fetching command.',
                                                ephemeral: true
                                            }).catch(() => { })
                                        }
                                    } else {
                                        button.reply({
                                            content: 'You need to be an administrator to execute that!',
                                            ephemeral: true
                                        }).catch(() => { })
                                    };
                                    button.deferUpdate().catch(() => { })
                                    return;
                                }
                                if (reactions.find(findreaction => findreaction.reaction === button.customId).function(number) > cmdTemplates.length || reactions.find(findreaction => findreaction.reaction === button.customId).function(number) < 1) {
                                    button.deferUpdate().catch(() => { })
                                    return
                                }
                                number = reactions.find(findreaction => findreaction.reaction === button.customId).function(number)
                                cmdEmbed = cmdTemplates[number - 1]
                                helpMessage.edit({
                                    embeds: [cmdEmbed],
                                    components: [buttonRow, importButtonRow]
                                }).catch(() => { })
                                button.deferUpdate().catch(() => { })
                            }
                            for (var i in data2[msg.guild.id][msg.author.id]['promises']) {
                                if (data2[msg.guild.id][msg.author.id]['promises'][i]) {
                                    data2[msg.guild.id][msg.author.id]['promises'][i]['active'] = false
                                }
                            }
                            var p = helpMessage.awaitMessageComponent({ componentType: 'BUTTON', time: 600000, filter }).then(() => {
                                for (var i in data2[msg.guild.id][msg.author.id]['promises']) {
                                    if (data2[msg.guild.id][msg.author.id]['promises'][i] == p) {
                                        data2[msg.guild.id][msg.author.id]['promises'][i] = undefined
                                        break
                                    }
                                }
                                if (!helpMessage.edit) return
                                helpMessage.edit({
                                    embeds: [cmdEmbed],
                                    components: []
                                }).catch(() => { })
                            })
                                .catch((err) => {
                                    if (err.message.endsWith('reason: time')) {
                                        helpMessage.edit({
                                            embeds: [cmdEmbed]
                                        }).catch(() => { })
                                    }
                                })
                            data2[msg.guild.id][msg.author.id]['promises'].push({ promise: p, active: true })
                        })
                            .catch(() => { })
                    },

                    search: async (msg, args) => {
                        if (!args[1]) {
                            msg.channel.send('You gotta specify the name of the command you want to search!').catch(() => { })
                            return
                        }

                        var saidMessage = args.join('').substring(args[0].length + 1).toLowerCase()

                        var number = 1
                        var ddcmdTemplates = data()[mongodatabase]['bot-data']['bot']['commandTemplates']
                        var none = {
                            "title": `there is nothing`,
                            "description": 'wow',
                            "color": 0x472604,
                            "footer": {
                                "icon_url": bot.user.displayAvatarURL({ dynamic: true, size: 1024, format: 'png' }),
                                "text": bot.user.username
                            },
                        }

                        if (ddcmdTemplates.length <= 0) {
                            msg.channel.send({
                                embeds: [none]
                            }).catch(() => { })
                            return
                        }

                        var dcmdTemplates = []

                        ddcmdTemplates.forEach(cmd => {
                            if (cmd.name.includes(saidMessage)) {
                                dcmdTemplates.push(cmd)
                            }
                        })

                        if (dcmdTemplates.length) {
                            dcmdTemplates.sort((a, b) => Math.abs(1 - similarity(a.name, saidMessage)) - Math.abs(1 - similarity(b.name, saidMessage)))
                        } else {
                            msg.channel.send({
                                embeds: [none]
                            }).catch(() => { })
                            return
                        }

                        var cmdTemplates = []
                        for (var i in dcmdTemplates) {
                            var cmd = dcmdTemplates[i]

                            var name = cmd.name
                            var description = cmd.description
                            var syntax = cmd.syntax
                            var phrase = cmd.phrase
                            var image = cmd.image
                            var id = cmd.id
                            var creator = cmd.creator
                            var date = cmd.date

                            var long = phrase.length > 1016

                            if (long) {
                                phrase = phrase.substring(0, 1013) + '...'
                            }

                            var embed = {
                                "title": `${name}${syntax ? ` ${syntax}` : ''}`,
                                "color": 0x472604,
                                "fields": [
                                    {
                                        name: "Description",
                                        value: description || 'No description available.'
                                    },
                                    {
                                        name: "ID",
                                        value: `\`${id}\``
                                    },
                                    {
                                        name: "Phrase",
                                        value: `\`\`\`\n${phrase}\n\`\`\``
                                    },
                                    {
                                        name: "Date Updated",
                                        value: `<t:${date}>`
                                    }
                                ],
                                "footer": {
                                    "icon_url": bot.user.displayAvatarURL({ dynamic: true, size: 1024, format: 'png' }),
                                    "text": `Made by ${creator} - Command ${Number(i) + 1}/${dcmdTemplates.length}`
                                },
                            }

                            if (image) {
                                embed.image = {
                                    url: image
                                }
                            }

                            cmdTemplates.push(embed)
                        }

                        var cmdEmbed = cmdTemplates[number - 1]
                        var reactions = [
                            {
                                reaction: "861253229723123762",
                                function: () => {
                                    return 1
                                },
                            },
                            {
                                reaction: "861253229726793728",
                                function: (number) => {
                                    return number - 1
                                },
                            },
                            {
                                reaction: "861253230070988860",
                                function: () => {
                                    return Math.floor(Math.random() * cmdTemplates.length) + 1
                                },
                            },
                            {
                                reaction: "861253229798621205",
                                function: (number) => {
                                    return number + 1
                                },
                            },
                            {
                                reaction: "861253229740556308",
                                function: () => {
                                    return cmdTemplates.length
                                },
                            },
                        ]
                        var buttonRow = new Discord.MessageActionRow()
                        reactions.forEach(reaction => {
                            var button = new Discord.MessageButton()
                                .setStyle('PRIMARY')
                                .setEmoji(reaction.reaction)
                                .setCustomId(reaction.reaction)
                            buttonRow.addComponents([button])
                        })

                        var importButtonRow = new Discord.MessageActionRow()
                        var importButton = new Discord.MessageButton()
                            .setStyle('PRIMARY')
                            .setEmoji('939523064658526278')
                            .setCustomId('import')
                        importButtonRow.addComponents([importButton])

                        await msg.channel.send({
                            embeds: [cmdEmbed],
                            components: [buttonRow, importButtonRow]
                        }).then(async sentMessage => {
                            var helpMessage = sentMessage
                            var filter = (button) => {
                                if (data2[msg.guild.id][msg.author.id]['promises'].find(promise => promise.promise === p).active === false) return
                                if (!(button.user.id === msg.author.id && button.user.id !== bot.user.id && !button.user.bot)) {
                                    button.deferUpdate().catch(() => { })
                                    return
                                }
                                if (button.customId == importButton.customId) {
                                    if (msg.member.permissions.has('MANAGE_GUILD') || msg.member.roles.cache.find(role => role.name.match(/mod|dev|admin|owner|creator|founder|staff/ig)) || msg.member.permissions.has('ADMINISTRATOR') || msg.author.id === msg.guild.ownerID || ownerids.find(id => id == msg.author.id)) {
                                        var findCommandTemplate = dcmdTemplates[number - 1]

                                        if (findCommandTemplate) {
                                            var name = findCommandTemplate.name

                                            var findCommand = commands.find(cmd => cmd.name.find(n => n === name)) || data()[mongodatabase]['guild-data'][msg.guild.id]['localcmds'].find(cmd => cmd.name === name)

                                            if (findCommand) {
                                                button.reply({
                                                    content: `The name of that command was already taken!`,
                                                    ephemeral: true
                                                }).catch(() => { })
                                                return
                                            }

                                            data()[mongodatabase]['guild-data'][msg.guild.id]['localcmds'].push({
                                                name: name,
                                                phrase: findCommandTemplate.phrase
                                            })

                                            msg.channel.send({
                                                content: `‚úÖ Imported \`${name}\` command with phrase \`${findCommandTemplate.phrase}\``,
                                                allowedMentions: {
                                                    parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                                }
                                            }).catch(() => { })
                                        } else {
                                            button.reply({
                                                content: 'Error fetching command.',
                                                ephemeral: true
                                            }).catch(() => { })
                                        }
                                    } else {
                                        button.reply({
                                            content: 'You need to be an administrator to execute that!',
                                            ephemeral: true
                                        }).catch(() => { })
                                    };
                                    button.deferUpdate().catch(() => { })
                                    return;
                                }
                                if (reactions.find(findreaction => findreaction.reaction === button.customId).function(number) > cmdTemplates.length || reactions.find(findreaction => findreaction.reaction === button.customId).function(number) < 1) {
                                    button.deferUpdate().catch(() => { })
                                    return
                                }
                                number = reactions.find(findreaction => findreaction.reaction === button.customId).function(number)
                                cmdEmbed = cmdTemplates[number - 1]
                                helpMessage.edit({
                                    embeds: [cmdEmbed],
                                    components: [buttonRow, importButtonRow]
                                }).catch(() => { })
                                button.deferUpdate().catch(() => { })
                            }
                            for (var i in data2[msg.guild.id][msg.author.id]['promises']) {
                                if (data2[msg.guild.id][msg.author.id]['promises'][i]) {
                                    data2[msg.guild.id][msg.author.id]['promises'][i]['active'] = false
                                }
                            }
                            var p = helpMessage.awaitMessageComponent({ componentType: 'BUTTON', time: 600000, filter }).then(() => {
                                for (var i in data2[msg.guild.id][msg.author.id]['promises']) {
                                    if (data2[msg.guild.id][msg.author.id]['promises'][i] == p) {
                                        data2[msg.guild.id][msg.author.id]['promises'][i] = undefined
                                        break
                                    }
                                }
                                if (!helpMessage.edit) return
                                helpMessage.edit({
                                    embeds: [cmdEmbed],
                                    components: []
                                }).catch(() => { })
                            })
                                .catch((err) => {
                                    if (err.message.endsWith('reason: time')) {
                                        helpMessage.edit({
                                            embeds: [cmdEmbed]
                                        }).catch(() => { })
                                    }
                                })
                            data2[msg.guild.id][msg.author.id]['promises'].push({ promise: p, active: true })
                        })
                            .catch(() => { })
                    },

                    register: async (msg, args) => {
                        await createCommand(msg, args)
                    },

                    add: async (msg, args) => {
                        await createCommand(msg, args)
                    },

                    edit: async (msg, args) => {
                        if (!args[1]) {
                            msg.channel.send('You gotta specify the ID!').catch(() => { })
                            return
                        }

                        var id = args[1].replace(/#/g, '')
                        var command = data()[mongodatabase]['bot-data']['bot']['commandTemplates'].find(cmd => cmd.id === id)
                        var commandIndex = data()[mongodatabase]['bot-data']['bot']['commandTemplates'].findIndex(cmd => cmd.id === id)

                        if (command && commandIndex > -1) {
                            if (command.creator !== msg.author.id) {
                                msg.channel.send(`idiot you didn't make that command`).catch(() => { })
                                return
                            }

                            var params = {
                                date: Math.floor(Date.now() / 1000)
                            }

                            var nameindex = args.indexOf('-name')
                            if (nameindex > -1 && args[nameindex + 1]) {
                                params.name = args[nameindex + 1].toLowerCase()
                            }

                            var imageindex = args.indexOf('-image')
                            if (imageindex > -1 && args[imageindex + 1]) {
                                if (validUrl.test(args[imageindex + 1])) {
                                    params.image = args[imageindex + 1]
                                } else {
                                    msg.channel.send('Not a valid image URL.').catch(() => { })
                                    return
                                }
                            }

                            var saidMessage = args.join(' ').substring(args[0].length + args[1].length + 2)

                            var argmatches = saidMessage.match(/-(phrase|description|syntax)/g)
                            if (argmatches) {
                                for (var i in argmatches) {
                                    var argmatch = argmatches[i]
                                    var argIndex = args.indexOf(argmatch)
                                    var nextArgs = args.slice(argIndex + 1)
                                    var arg = ''
                                    for (var j in nextArgs) {
                                        var nextArg = nextArgs[j]
                                        if (nextArg.match(/-(phrase|description|syntax|name|image)/)) break
                                        arg += `${nextArg} `
                                    }
                                    arg = arg.substring(0, arg.length - 1)

                                    params[argmatch.substring(1)] = arg
                                }
                            }

                            if (params.name) {
                                var findCommand = data()[mongodatabase]['bot-data']['bot']['commandTemplates'].find(cmd => cmd.name === params.name && cmd.creator === msg.author.id)

                                if (findCommand) {
                                    msg.channel.send(`You've already created a command with that name! (ID: \`${findCommand.id}\`)`).catch(() => { })
                                    return
                                }
                            }

                            for (var param in params) {
                                data()[mongodatabase]['bot-data']['bot']['commandTemplates'][commandIndex][param] = params[param]
                            }

                            msg.channel.send(`‚úÖ Command successfully updated.`).catch(() => { })
                        } else {
                            msg.channel.send('Not a valid ID.').catch(() => { })
                        }
                    },

                    delete: async (msg, args) => {
                        if (!args[1]) {
                            msg.channel.send('You gotta specify the ID!').catch(() => { })
                            return
                        }

                        var id = args[1].replace(/#/g, '')
                        var command = data()[mongodatabase]['bot-data']['bot']['commandTemplates'].find(cmd => cmd.id === id)
                        var commandIndex = data()[mongodatabase]['bot-data']['bot']['commandTemplates'].findIndex(cmd => cmd.id === id)

                        if (command && commandIndex > -1) {
                            if (command.creator !== msg.author.id) {
                                msg.channel.send(`idiot you didn't make that command`).catch(() => { })
                                return
                            }

                            data()[mongodatabase]['bot-data']['bot']['commandTemplates'].splice(commandIndex, 1)

                            msg.channel.send(`‚úÖ Command successfully deleted.`).catch(() => { })
                        } else {
                            msg.channel.send('Not a valid ID.').catch(() => { })
                        }
                    },
                }

                if (!args[1]) {
                    msg.channel.send({
                        embeds: [
                            {
                                "title": "Available Options",
                                "description": "**list** - Sends an navigable embed with a list of all command templates made by the users of Poopy.\n\n**search** <query> - Searches for every command in the command database that matches the query.\n\n**register**/**add** <name> <phrase> {-description <text>} [-image <url>] [-syntax <text>] - Registers the command with the respective name, description and syntax (if supplied), it'll then be assigned an ID that can be used to import it via the `localcmds` command.\n\n**edit** <id> [-name <text>] [-phrase <text>] [-description <text>] [-image <url>] [-syntax <text>] - Allows you to edit the command with the respective ID in the database, if it exists and you made it.\n\n**delete** <id> - Permanently deletes the command from the database with the respective ID, if it exists and YOU made it.",
                                "color": 0x472604,
                                "footer": {
                                    "icon_url": bot.user.displayAvatarURL({ dynamic: true, size: 1024, format: 'png' }),
                                    "text": bot.user.username
                                },
                            }
                        ]
                    }).catch(() => { })
                    return
                }

                if (!options[args[1].toLowerCase()]) {
                    msg.channel.send('Not a valid option.').catch(() => { })
                    return
                }

                await options[args[1].toLowerCase()](msg, args.slice(1))
            },
            help: {
                "name": "commandtemplates/cmdtemplates <option>",
                "value": "Gives you access to a global database of command templates you can use in your servers! Anyone can contribute to it.\nfun fact: this was made because im too lazy to add commands myself haha\n\n**list** - Sends an navigable embed with a list of all command templates made by the users of Poopy.\n\n**search** <query> - Searches for every command in the command database that matches the query.\n\n**register**/**add** <name> <phrase> {-description <text>} [-image <url>] [-syntax <text>] - Registers the command with the respective name, description and syntax (if supplied), it'll then be assigned an ID that can be used to import it via the `localcmds` command.\n\n**edit** <id> [-name <text>] [-phrase <text>] [-description <text>] [-image <url>] [-syntax <text>] - Allows you to edit the command with the respective ID in the database, if it exists and you made it.\n\n**delete** <id> - Permanently deletes the command from the database with the respective ID, if it exists and YOU made it."
            },
            cooldown: 5000,
            type: "Unique"
        },

        {
            name: ["setprefix"],
            execute: async function (msg, args) {
                if (msg.member.permissions.has('MANAGE_GUILD') || msg.member.roles.cache.find(role => role.name.match(/mod|dev|admin|owner|creator|founder|staff/ig)) || msg.member.permissions.has('ADMINISTRATOR') || msg.author.id === msg.guild.ownerID || ownerids.find(id => id == msg.author.id)) {
                    if (args[1] === undefined) {
                        msg.channel.send('You must specify a prefix!').catch(() => { })
                        return
                    }
                    for (var i in args) {
                        var arg = args[i]
                        if (arg == '') {
                            args.splice(i, 1)
                        }
                    }
                    var saidMessage = args.join(' ').substring(args[0].length + 1).split(/[\s]+/).join(' ')
                    if (saidMessage.length > 20) {
                        msg.channel.send('The prefix can\'t be bigger than 20 characters.').catch(() => { })
                        return
                    }
                    data()[mongodatabase]['guild-data'][msg.guild.id]['prefix'] = saidMessage
                    msg.channel.send('The prefix was set to `' + (testing ? `2${data()[mongodatabase]['guild-data'][msg.guild.id]['prefix']}` : data()[mongodatabase]['guild-data'][msg.guild.id]['prefix']) + '` (if this is wrong, mention me with "reset prefix")').catch(() => { })
                } else {
                    msg.channel.send('You need to be an administrator to execute that!').catch(() => { })
                    return;
                };
            },
            help: {
                "name": "setprefix <prefix> (admin only)",
                "value": "Set Poopy's prefix to anything you want.\nPro Tip: mentioning Poopy with \"reset prefix\" will reset it to his default prefix."
            },
            cooldown: 5000,
            perms: ["ADMINISTRATOR"],
            type: "Settings"
        },

        {
            name: ["heyapple"],
            execute: async function (msg) {
                msg.channel.sendTyping().catch(() => { })
                var attachment = new Discord.MessageAttachment('templates/heyapple.mp4')
                msg.channel.send({
                    files: [attachment]
                }).catch(() => { })
                msg.channel.sendTyping().catch(() => { })
            },
            help: {
                "name": "heyapple",
                "value": "Try and hit me if you‚Äôre able."
            },
            cooldown: 2500,
            type: "OG"
        },

        {
            name: ["canigetadmin"],
            execute: async function (msg) {
                msg.channel.sendTyping().catch(() => { })
                var attachment = new Discord.MessageAttachment('templates/no.mp4')
                msg.channel.send({
                    files: [attachment]
                }).catch(() => { })
                msg.channel.sendTyping().catch(() => { })
            },
            help: {
                "name": "canigetadmin",
                "value": "Yo can I get admin? üòÇ"
            },
            cooldown: 2500,
            type: "OG"
        },

        {
            name: ["baldi"],
            execute: async function (msg) {
                msg.channel.sendTyping().catch(() => { })
                var attachment = new Discord.MessageAttachment('templates/baldi.mp4')
                msg.channel.send({
                    files: [attachment]
                }).catch(() => { })
                msg.channel.sendTyping().catch(() => { })
            },
            help: {
                "name": "baldi",
                "value": "YO MAMA!"
            },
            cooldown: 2500,
            type: "OG"
        },

        {
            name: ["punch"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                var saidMessage = args.join(' ').substring(args[0].length + 1)
                var attachments = []
                msg.attachments.forEach(attachment => {
                    attachments.push(new Discord.MessageAttachment(attachment.url))
                });
                if (args[1] === undefined && attachments.length <= 0) {
                    msg.channel.send('What/who is the subject?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                if ((Math.floor(Math.random() * 2)) === 0) {
                    if (!msg.mentions.members.size) {
                        async function getMember(id) {
                            var member = await bot.users.fetch(id)
                                .catch(function () {
                                    msg.channel.send({
                                        content: '<@' + msg.author.id + '> punched **' + (saidMessage || 'this') + '**! It did **10** damage!',
                                        allowedMentions: {
                                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                        },
                                        files: attachments
                                    }).catch(() => { })
                                    msg.channel.sendTyping().catch(() => { })
                                })

                            if (member) {
                                saidMessage = member.username
                                msg.channel.send({
                                    content: '<@' + msg.author.id + '> punched **' + (saidMessage || 'this') + '**! It did **10** damage!',
                                    allowedMentions: {
                                        parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    },
                                    files: attachments
                                }).catch(() => { })
                                if (!data()[mongodatabase]['user-data'][member.id]) {
                                    data()[mongodatabase]['user-data'][member.id] = {}
                                    data()[mongodatabase]['user-data'][member.id]['health'] = 100
                                }
                                data()[mongodatabase]['user-data'][member.id]['health'] = data()[mongodatabase]['user-data'][member.id]['health'] - 10
                                if (data()[mongodatabase]['user-data'][member.id]['health'] <= 0) {
                                    data()[mongodatabase]['user-data'][member.id]['health'] = 100
                                    msg.channel.send('**' + member.username + '** died!', {
                                        allowedMentions: {
                                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                        }
                                    }).catch(() => { })
                                    msg.channel.sendTyping().catch(() => { })
                                    return
                                }
                                msg.channel.sendTyping().catch(() => { })
                            }
                        }

                        getMember(saidMessage);
                    }
                    else {
                        var member = msg.mentions.members.first()
                        saidMessage = member.user.username
                        msg.channel.send({
                            content: '<@' + msg.author.id + '> punched **' + (saidMessage || 'this') + '**! It did **10** damage!',
                            allowedMentions: {
                                parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                            },
                            files: attachments
                        }).catch(() => { })
                        if (!data()[mongodatabase]['user-data'][member.id]) {
                            data()[mongodatabase]['user-data'][member.id] = {}
                            data()[mongodatabase]['user-data'][member.id]['health'] = 100
                        }
                        data()[mongodatabase]['user-data'][member.id]['health'] = data()[mongodatabase]['user-data'][member.id]['health'] - 10
                        if (data()[mongodatabase]['user-data'][member.id]['health'] <= 0) {
                            data()[mongodatabase]['user-data'][member.id]['health'] = 100
                            msg.channel.send({
                                content: '**' + member.user.username + '** died!',
                                allowedMentions: {
                                    parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            }).catch(() => { })
                            msg.channel.sendTyping().catch(() => { })
                            return
                        }
                        msg.channel.sendTyping().catch(() => { })
                    }
                }
                else {
                    msg.channel.send('You missed!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                }
            },
            help: {
                "name": "punch <subject>",
                "value": "Punch something!"
            },
            type: "Battling"
        },

        {
            name: ["slap"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                var saidMessage = args.join(' ').substring(args[0].length + 1)
                var attachments = []
                msg.attachments.forEach(attachment => {
                    attachments.push(new Discord.MessageAttachment(attachment.url))
                });
                if (args[1] === undefined && attachments.length <= 0) {
                    msg.channel.send('What/who is the subject?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                if ((Math.floor(Math.random() * 3)) > 0) {
                    if (!msg.mentions.members.size) {
                        async function getMember(id) {
                            var member = await bot.users.fetch(id)
                                .catch(function () {
                                    msg.channel.send({
                                        content: '<@' + msg.author.id + '> slapped **' + (saidMessage || 'this') + '**! It did **5** damage!',
                                        allowedMentions: {
                                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                        },
                                        files: attachments
                                    }).catch(() => { })
                                    msg.channel.sendTyping().catch(() => { })
                                })

                            if (member) {
                                saidMessage = member.username
                                msg.channel.send({
                                    content: '<@' + msg.author.id + '> slapped **' + (saidMessage || 'this') + '**! It did **5** damage!',
                                    allowedMentions: {
                                        parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    },
                                    files: attachments
                                }).catch(() => { })
                                if (!data()[mongodatabase]['user-data'][member.id]) {
                                    data()[mongodatabase]['user-data'][member.id] = {}
                                    data()[mongodatabase]['user-data'][member.id]['health'] = 100
                                }
                                data()[mongodatabase]['user-data'][member.id]['health'] = data()[mongodatabase]['user-data'][member.id]['health'] - 10
                                if (data()[mongodatabase]['user-data'][member.id]['health'] <= 0) {
                                    data()[mongodatabase]['user-data'][member.id]['health'] = 100
                                    msg.channel.send({
                                        content: '**' + member.username + '** died!',
                                        allowedMentions: {
                                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                        }
                                    }).catch(() => { })
                                    msg.channel.sendTyping().catch(() => { })
                                    return
                                }
                                msg.channel.sendTyping().catch(() => { })
                            }
                        }

                        getMember(saidMessage);
                    }
                    else {
                        var member = msg.mentions.members.first()
                        saidMessage = member.user.username
                        msg.channel.send({
                            content: '<@' + msg.author.id + '> slapped **' + (saidMessage || 'this') + '**! It did **5** damage!',
                            allowedMentions: {
                                parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                            },
                            files: attachments
                        }).catch(() => { })
                        if (!data()[mongodatabase]['user-data'][member.id]) {
                            data()[mongodatabase]['user-data'][member.id] = {}
                            data()[mongodatabase]['user-data'][member.id]['health'] = 100
                        }
                        data()[mongodatabase]['user-data'][member.id]['health'] = data()[mongodatabase]['user-data'][member.id]['health'] - 10
                        if (data()[mongodatabase]['user-data'][member.id]['health'] <= 0) {
                            data()[mongodatabase]['user-data'][member.id]['health'] = 100
                            msg.channel.send({
                                content: '**' + member.user.username + '** died!',
                                allowedMentions: {
                                    parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            }).catch(() => { })
                            msg.channel.sendTyping().catch(() => { })
                            return
                        }
                        msg.channel.sendTyping().catch(() => { })
                    }
                } else {
                    msg.channel.send('You missed!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                }
            },
            help: {
                "name": "slap <subject>",
                "value": "Slap something! Has a small chance of missing."
            },
            type: "Battling"
        },

        {
            name: ["slam"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                var saidMessage = args.join(' ').substring(args[0].length + 1)
                var attachments = []
                msg.attachments.forEach(attachment => {
                    attachments.push(new Discord.MessageAttachment(attachment.url))
                });
                if (args[1] === undefined && attachments.length <= 0) {
                    msg.channel.send('What/who is the subject?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                if ((Math.floor(Math.random() * 4)) === 0) {
                    if (!msg.mentions.members.size) {
                        async function getMember(id) {
                            var member = await bot.users.fetch(id)
                                .catch(function () {
                                    msg.channel.send({
                                        content: '<@' + msg.author.id + '> slammed **' + (saidMessage || 'this') + '**! It did **30** damage!',
                                        allowedMentions: {
                                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                        },
                                        files: attachments
                                    }).catch(() => { })
                                    msg.channel.sendTyping().catch(() => { })
                                })

                            if (member) {
                                saidMessage = member.username
                                msg.channel.send({
                                    content: '<@' + msg.author.id + '> slammed **' + (saidMessage || 'this') + '**! It did **30** damage!',
                                    allowedMentions: {
                                        parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    },
                                    files: attachments
                                }).catch(() => { })
                                if (!data()[mongodatabase]['user-data'][member.id]) {
                                    data()[mongodatabase]['user-data'][member.id] = {}
                                    data()[mongodatabase]['user-data'][member.id]['health'] = 100
                                }
                                data()[mongodatabase]['user-data'][member.id]['health'] = data()[mongodatabase]['user-data'][member.id]['health'] - 30
                                if (data()[mongodatabase]['user-data'][member.id]['health'] <= 0) {
                                    data()[mongodatabase]['user-data'][member.id]['health'] = 100
                                    msg.channel.send({
                                        content: '**' + member.username + '** died!',
                                        allowedMentions: {
                                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                        }
                                    }).catch(() => { })
                                    msg.channel.sendTyping().catch(() => { })
                                    return
                                }
                                msg.channel.sendTyping().catch(() => { })
                            }
                        }

                        getMember(saidMessage);
                    }
                    else {
                        var member = msg.mentions.members.first()
                        saidMessage = member.user.username
                        msg.channel.send({
                            content: '<@' + msg.author.id + '> slammed **' + (saidMessage || 'this') + '**! It did **30** damage!',
                            allowedMentions: {
                                parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                            },
                            files: attachments
                        }).catch(() => { })
                        if (!data()[mongodatabase]['user-data'][member.id]) {
                            data()[mongodatabase]['user-data'][member.id] = {}
                            data()[mongodatabase]['user-data'][member.id]['health'] = 100
                        }
                        data()[mongodatabase]['user-data'][member.id]['health'] = data()[mongodatabase]['user-data'][member.id]['health'] - 30
                        if (data()[mongodatabase]['user-data'][member.id]['health'] <= 0) {
                            data()[mongodatabase]['user-data'][member.id]['health'] = 100
                            msg.channel.send({
                                content: '**' + member.user.username + '** died!',
                                allowedMentions: {
                                    parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            }).catch(() => { })
                            msg.channel.sendTyping().catch(() => { })
                            return
                        }
                    }
                } else {
                    msg.channel.send('You missed!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                }
            },
            help: {
                "name": "slam <subject>",
                "value": "Slam something! Has a high chance of missing."
            },
            type: "Battling"
        },

        {
            name: ["poopallover"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                var saidMessage = args.join(' ').substring(args[0].length + 1)
                var attachments = []
                msg.attachments.forEach(attachment => {
                    attachments.push(new Discord.MessageAttachment(attachment.url))
                });
                if (args[1] === undefined && attachments.length <= 0) {
                    msg.channel.send('What/who is the subject?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                msg.channel.send({
                    content: '**' + (saidMessage || 'this') + '** has been successfully pooped on.',
                    allowedMentions: {
                        parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                    },
                    files: attachments
                }).catch(() => { })
                msg.channel.sendTyping().catch(() => { })
            },
            help: {
                "name": "poopallover <subject>",
                "value": "Poop on something."
            },
            type: "OG"
        },

        {
            name: ["chainpunch"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                var saidMessage = args.join(' ').substring(args[0].length + 1)
                var attachments = []
                msg.attachments.forEach(attachment => {
                    attachments.push(new Discord.MessageAttachment(attachment.url))
                });
                if (args[1] === undefined && attachments.length <= 0) {
                    msg.channel.send('What/who is the subject?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                if ((Math.floor(Math.random() * 2)) === 0) {
                    var damage = Math.floor(Math.random() * 18) + 6;
                    if (!msg.mentions.members.size) {
                        async function getMember(id) {
                            var member = await bot.users.fetch(id)
                                .catch(function () {
                                    msg.channel.send({
                                        content: '<@' + msg.author.id + '> chain punched **' + (saidMessage || 'this') + '**! It did **' + damage + '** damage!',
                                        allowedMentions: {
                                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                        },
                                        files: attachments
                                    }).catch(() => { })
                                    msg.channel.sendTyping().catch(() => { })
                                })

                            if (member) {
                                saidMessage = member.username
                                msg.channel.send({
                                    content: '<@' + msg.author.id + '> chain punched **' + (saidMessage || 'this') + '**! It did **' + damage + '** damage!',
                                    allowedMentions: {
                                        parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    },
                                    files: attachments
                                }).catch(() => { })
                                if (!data()[mongodatabase]['user-data'][member.id]) {
                                    data()[mongodatabase]['user-data'][member.id] = {}
                                    data()[mongodatabase]['user-data'][member.id]['health'] = 100
                                }
                                data()[mongodatabase]['user-data'][member.id]['health'] = data()[mongodatabase]['user-data'][member.id]['health'] - damage
                                if (data()[mongodatabase]['user-data'][member.id]['health'] <= 0) {
                                    data()[mongodatabase]['user-data'][member.id]['health'] = 100
                                    msg.channel.send({
                                        content: '**' + member.username + '** died!',
                                        allowedMentions: {
                                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                        }
                                    }).catch(() => { })
                                    msg.channel.sendTyping().catch(() => { })
                                    return
                                }
                                msg.channel.sendTyping().catch(() => { })
                            }
                        }

                        getMember(saidMessage);
                    }
                    else {
                        var member = msg.mentions.members.first()
                        saidMessage = member.user.username
                        msg.channel.send({
                            content: '<@' + msg.author.id + '> chain punched **' + (saidMessage || 'this') + '**! It did **' + damage + '** damage!',
                            allowedMentions: {
                                parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                            },
                            files: attachments
                        }).catch(() => { })
                        if (!data()[mongodatabase]['user-data'][member.id]) {
                            data()[mongodatabase]['user-data'][member.id] = {}
                            data()[mongodatabase]['user-data'][member.id]['health'] = 100
                        }
                        data()[mongodatabase]['user-data'][member.id]['health'] = data()[mongodatabase]['user-data'][member.id]['health'] - damage
                        if (data()[mongodatabase]['user-data'][member.id]['health'] <= 0) {
                            data()[mongodatabase]['user-data'][member.id]['health'] = 100
                            msg.channel.send({
                                content: '**' + member.user.username + '** died!',
                                allowedMentions: {
                                    parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            }).catch(() => { })
                            msg.channel.sendTyping().catch(() => { })
                            return
                        }
                    }
                } else {
                    msg.channel.send('You missed!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                }
            },
            help: {
                "name": "chainpunch <subject>",
                "value": "Chain punch something! Does random damage, and has a pretty high chance to miss."
            },
            type: "Battling"
        },

        {
            name: ["ratemyfarts"],
            execute: async function (msg) {
                msg.channel.sendTyping().catch(() => { })
                msg.channel.send('Let\'s see...').catch(() => { })
                var fartRating = Math.floor(Math.random() * 100) + 1
                if (!data()[mongodatabase]['user-data'][msg.author.id]) {
                    data()[mongodatabase]['user-data'][msg.author.id] = {}
                }
                if (!data()[mongodatabase]['user-data'][msg.author.id]['fartRate']) {
                    data()[mongodatabase]['user-data'][msg.author.id]['fartRate'] = fartRating;
                }
                if (!data()[mongodatabase]['user-data'][msg.author.id]['lastFartRate']) {
                    data()[mongodatabase]['user-data'][msg.author.id]['lastFartRate'] = Date.now();
                }
                var lastFartRating = Date.now() - data()[mongodatabase]['user-data'][msg.author.id]['lastFartRate']
                if (lastFartRating >= 600000) {
                    data()[mongodatabase]['user-data'][msg.author.id]['fartRate'] = fartRating;
                    data()[mongodatabase]['user-data'][msg.author.id]['lastFartRate'] = Date.now();
                }
                if (data()[mongodatabase]['user-data'][msg.author.id]['fartRate'] >= 70) {
                    msg.channel.send('**' + data()[mongodatabase]['user-data'][msg.author.id]['fartRate'] + '**/100, great farts!').catch(() => { })
                }
                else {
                    msg.channel.send('**' + data()[mongodatabase]['user-data'][msg.author.id]['fartRate'] + '**/100').catch(() => { })
                }
                msg.channel.sendTyping().catch(() => { })
            },
            help: {
                "name": "ratemyfarts",
                "value": "Poopy rates your farts."
            },
            cooldown: 2500,
            type: "OG"
        },

        {
            name: ["help", "commands", "cmds"],
            execute: async function (msg, args) {
                var saidMessage = args.join(' ').substring(args[0].length + 1)
                var number = 1
                if (saidMessage) {
                    var fCmds = []

                    commands.forEach(cmd => {
                        if (cmd.name.find(name => name.toLowerCase().includes(saidMessage.toLowerCase()))) {
                            fCmds.push(cmd)
                        }
                    })

                    if (fCmds.length) {
                        fCmds.sort((a, b) => Math.abs(1 - similarity(a.name.find(name => name.toLowerCase().includes(saidMessage.toLowerCase())), saidMessage)) - Math.abs(1 - similarity(b.name.find(name => name.toLowerCase().includes(saidMessage.toLowerCase())), saidMessage)))

                        var findCmds = fCmds.map(cmd => {
                            return {
                                title: cmd.help.name,
                                fields: [
                                    {
                                        "name": "Description",
                                        "value": cmd.help.value
                                    },
                                    {
                                        "name": "Cooldown",
                                        "value": cmd.cooldown ? `${cmd.cooldown / 1000} seconds` : 'None'
                                    },
                                    {
                                        "name": "Type",
                                        "value": cmd.type
                                    },
                                ]
                            }
                        })

                        var cmdEmbed = {
                            "title": findCmds[number - 1].title,
                            "color": 0x472604,
                            "footer": {
                                "icon_url": bot.user.displayAvatarURL({ dynamic: true, size: 1024, format: 'png' }),
                                "text": `Command ${number}/${findCmds.length}`
                            },
                            "fields": findCmds[number - 1].fields,
                        }
                        var reactions = [
                            {
                                reaction: "861253229723123762",
                                function: () => {
                                    return 1
                                },
                            },
                            {
                                reaction: "861253229726793728",
                                function: (number) => {
                                    return number - 1
                                },
                            },
                            {
                                reaction: "861253230070988860",
                                function: () => {
                                    return Math.floor(Math.random() * findCmds.length) + 1
                                },
                            },
                            {
                                reaction: "861253229798621205",
                                function: (number) => {
                                    return number + 1
                                },
                            },
                            {
                                reaction: "861253229740556308",
                                function: () => {
                                    return findCmds.length
                                },
                            },
                        ]
                        var buttonRow = new Discord.MessageActionRow()
                        reactions.forEach(reaction => {
                            var button = new Discord.MessageButton()
                                .setStyle('PRIMARY')
                                .setEmoji(reaction.reaction)
                                .setCustomId(reaction.reaction)
                            buttonRow.addComponents([button])
                        })

                        msg.channel.send({
                            embeds: [cmdEmbed],
                            components: [buttonRow]
                        }).then(async sentMessage => {
                            var helpMessage = sentMessage
                            var filter = (button) => {
                                if (data2[msg.author.id]['promises'].find(promise => promise.promise === p).active === false) return
                                if (!(button.user.id === msg.author.id && button.user.id !== bot.user.id && !button.user.bot)) {
                                    button.deferUpdate().catch(() => { })
                                    return
                                }
                                if (reactions.find(findreaction => findreaction.reaction === button.customId).function(number) > findCmds.length || reactions.find(findreaction => findreaction.reaction === button.customId).function(number) < 1) {
                                    button.deferUpdate().catch(() => { })
                                    return
                                }
                                number = reactions.find(findreaction => findreaction.reaction === button.customId).function(number)
                                cmdEmbed = {
                                    "title": findCmds[number - 1].title,
                                    "color": 0x472604,
                                    "footer": {
                                        "icon_url": bot.user.displayAvatarURL({ dynamic: true, size: 1024, format: 'png' }),
                                        "text": `Command ${number}/${findCmds.length}`
                                    },
                                    "fields": findCmds[number - 1].fields,
                                };
                                helpMessage.edit({
                                    embeds: [cmdEmbed],
                                    components: [buttonRow]
                                }).catch(() => { })
                                button.deferUpdate().catch(() => { })
                            }
                            for (var i in data2[msg.author.id]['promises']) {
                                if (data2[msg.author.id]['promises'][i]) {
                                    data2[msg.author.id]['promises'][i]['active'] = false
                                }
                            }
                            var p = helpMessage.awaitMessageComponent({ componentType: 'BUTTON', time: 600000, filter }).then(() => {
                                for (var i in data2[msg.author.id]['promises']) {
                                    if (data2[msg.author.id]['promises'][i] == p) {
                                        data2[msg.author.id]['promises'][i] = undefined
                                        break
                                    }
                                }
                                if (!helpMessage.edit) return
                                helpMessage.edit({
                                    embeds: [cmdEmbed],
                                    components: []
                                }).catch(() => { })
                            })
                                .catch((err) => {
                                    if (err.message.endsWith('reason: time')) {
                                        helpMessage.edit({
                                            embeds: [cmdEmbed],
                                            components: []
                                        }).catch(() => { })
                                    }
                                })
                            data2[msg.author.id]['promises'].push({ promise: p, active: true })
                        })
                            .catch(() => { })
                    } else {
                        msg.channel.send({
                            embeds: [
                                {
                                    "description": "No commands match your search.",
                                    "color": 0x472604,
                                    "footer": {
                                        "icon_url": bot.user.displayAvatarURL({ dynamic: true, size: 1024, format: 'png' }),
                                        "text": bot.user.username
                                    },
                                }
                            ]
                        }).catch(() => { })
                    }
                    return
                }
                var jsonid = ownerids.find(id => id == msg.author.id) || jsoning.find(id => id == msg.author.id);
                var ownerid = ownerids.find(id => id == msg.author.id);
                var cmdEmbed = {
                    "title": `${shelpCmds[number - 1].type} Commands`,
                    "description": "Arguments between \"<>\" are required.\nArguments between \"[]\" are optional.\nArguments between \"{}\" are optional but should normally be supplied.\nMultiple commands can be executed separating them with \"-|-\".\nFile manipulation commands have special options that can be used:\n`-encodingpreset <preset>` - More info in `reencode` command.\n`-ext <extension>` - Uses the specified file extension when processing the file.\n`-filename <name>` - Saves the file as the specified name.\n`-catbox` - Forces the file to be uploaded to catbox.moe.\n`-nosend` - Does not send the file, but stores its catbox.moe URL in the channel's last urls.",
                    "color": 0x472604,
                    "footer": {
                        "icon_url": bot.user.displayAvatarURL({ dynamic: true, size: 1024, format: 'png' }),
                        "text": `Page ${number}/${shelpCmds.length}`
                    },
                    "fields": shelpCmds[number - 1].commands
                };
                var reactions = [
                    {
                        reaction: "861253229723123762",
                        function: () => {
                            return 1
                        },
                    },
                    {
                        reaction: "861253229726793728",
                        function: (number) => {
                            return number - 1
                        },
                    },
                    {
                        reaction: "861253230070988860",
                        function: () => {
                            return Math.floor(Math.random() * shelpCmds.length) + 1
                        },
                    },
                    {
                        reaction: "861253229798621205",
                        function: (number) => {
                            return number + 1
                        },
                    },
                    {
                        reaction: "861253229740556308",
                        function: () => {
                            return shelpCmds.length
                        },
                    },
                ]
                var buttonRow = new Discord.MessageActionRow()
                reactions.forEach(reaction => {
                    var button = new Discord.MessageButton()
                        .setStyle('PRIMARY')
                        .setEmoji(reaction.reaction)
                        .setCustomId(reaction.reaction)
                    buttonRow.addComponents([button])
                })

                var categoryOptions = {}

                for (var i in shelpCmds) {
                    var shelp = shelpCmds[i]
                    if (categoryOptions[shelp.type] == undefined) {
                        categoryOptions[shelp.type] = Number(i) + 1
                    }
                }

                var categoriesMenu = Object.keys(categoryOptions).map(cat => {
                    return {
                        label: cat,
                        description: categories[cat] || '',
                        value: cat
                    }
                })

                var menuRow = new Discord.MessageActionRow()
                var selectMenu = new Discord.MessageSelectMenu()
                    .setCustomId('select')
                    .setPlaceholder('Select Category')
                    .addOptions(categoriesMenu)

                menuRow.addComponents([selectMenu])

                await msg.author.send({
                    embeds: [cmdEmbed],
                    components: [buttonRow, menuRow]
                }).then(async sentMessage => {
                    var helpMessage = sentMessage
                    if (jsonid !== undefined) {
                        var jsoncmdEmbed = {
                            "title": "JSON Club Commands",
                            "color": 0x472604,
                            "footer": {
                                "icon_url": bot.user.displayAvatarURL({ dynamic: true, size: 1024, format: 'png' }),
                                "text": bot.user.username
                            },
                            "fields": jsonCmds
                        };
                        await msg.author.send({
                            embeds: [jsoncmdEmbed]
                        }).catch(() => { })
                    }
                    if (ownerid !== undefined) {
                        var devcmdEmbed = {
                            "title": "Owner Commands",
                            "color": 0x472604,
                            "footer": {
                                "icon_url": bot.user.displayAvatarURL({ dynamic: true, size: 1024, format: 'png' }),
                                "text": bot.user.username
                            },
                            "fields": devCmds
                        };
                        await msg.author.send({
                            embeds: [devcmdEmbed]
                        }).catch(() => { })
                    }
                    msg.channel.send('‚úÖ Check your DMs.').catch(() => { })
                    var filter = (interaction) => {
                        if (data2[msg.author.id]['promises'].find(promise => promise.promise === p).active === false) return

                        if (interaction.isButton()) {
                            var button = interaction

                            if (!(button.user.id === msg.author.id && button.user.id !== bot.user.id && !button.user.bot)) {
                                button.deferUpdate().catch(() => { })
                                return
                            }
                            if (reactions.find(findreaction => findreaction.reaction === button.customId).function(number) > shelpCmds.length || reactions.find(findreaction => findreaction.reaction === button.customId).function(number) < 1) {
                                button.deferUpdate().catch(() => { })
                                return
                            }
                            number = reactions.find(findreaction => findreaction.reaction === button.customId).function(number)
                            menuRow = new Discord.MessageActionRow()
                            selectMenu = new Discord.MessageSelectMenu()
                                .setCustomId('select')
                                .setPlaceholder(shelpCmds[number - 1].type)
                                .addOptions(categoriesMenu)
                            menuRow.addComponents([selectMenu])
                            cmdEmbed = {
                                "title": `${shelpCmds[number - 1].type} Commands`,
                                "description": "Arguments between \"<>\" are required.\nArguments between \"[]\" are optional.\nArguments between \"{}\" are optional but should normally be supplied.\nMultiple commands can be executed separating them with \"-|-\".\nFile manipulation commands have special options that can be used:\n`-encodingpreset <preset>` - More info in `reencode` command.\n`-ext <extension>` - Uses the specified file extension when processing the file.\n`-filename <name>` - Saves the file as the specified name.\n`-catbox` - Forces the file to be uploaded to catbox.moe.\n`-nosend` - Does not send the file, but stores its catbox.moe URL in the channel's last urls.",
                                "color": 0x472604,
                                "footer": {
                                    "icon_url": bot.user.displayAvatarURL({ dynamic: true, size: 1024, format: 'png' }),
                                    "text": `Page ${number}/${shelpCmds.length}`
                                },
                                "fields": shelpCmds[number - 1].commands
                            };
                            button.update({
                                embeds: [cmdEmbed],
                                components: [buttonRow, menuRow]
                            }).catch(() => { })
                        } else if (interaction.isSelectMenu()) {
                            var option = interaction

                            if (!(option.user.id === msg.author.id && option.user.id !== bot.user.id && !option.user.bot)) {
                                option.deferUpdate().catch(() => { })
                                return
                            }
                            number = categoryOptions[option.values[0]]
                            menuRow = new Discord.MessageActionRow()
                            selectMenu = new Discord.MessageSelectMenu()
                                .setCustomId('select')
                                .setPlaceholder(shelpCmds[number - 1].type)
                                .addOptions(categoriesMenu)
                            menuRow.addComponents([selectMenu])
                            cmdEmbed = {
                                "title": `${shelpCmds[number - 1].type} Commands`,
                                "description": "Arguments between \"<>\" are required.\nArguments between \"[]\" are optional.\nArguments between \"{}\" are optional but should normally be supplied.\nMultiple commands can be executed separating them with \"-|-\".\nFile manipulation commands have special options that can be used:\n`-encodingpreset <preset>` - More info in `reencode` command.\n`-ext <extension>` - Uses the specified file extension when processing the file.\n`-filename <name>` - Saves the file as the specified name.\n`-catbox` - Forces the file to be uploaded to catbox.moe.\n`-nosend` - Does not send the file, but stores its catbox.moe URL in the channel's last urls.",
                                "color": 0x472604,
                                "footer": {
                                    "icon_url": bot.user.displayAvatarURL({ dynamic: true, size: 1024, format: 'png' }),
                                    "text": `Page ${number}/${shelpCmds.length}`
                                },
                                "fields": shelpCmds[number - 1].commands
                            };
                            option.update({
                                embeds: [cmdEmbed],
                                components: [buttonRow, menuRow]
                            }).catch(() => { })
                        }
                    }
                    for (var i in data2[msg.author.id]['promises']) {
                        if (data2[msg.author.id]['promises'][i]) {
                            data2[msg.author.id]['promises'][i]['active'] = false
                        }
                    }
                    var p = helpMessage.awaitMessageComponent({ time: 600000, filter }).then(() => {
                        for (var i in data2[msg.author.id]['promises']) {
                            if (data2[msg.author.id]['promises'][i] == p) {
                                data2[msg.author.id]['promises'][i] = undefined
                                break
                            }
                        }
                        if (!helpMessage.edit) return
                        helpMessage.edit({
                            embeds: [cmdEmbed],
                            components: []
                        }).catch(() => { })
                    })
                        .catch((err) => {
                            if (err.message.endsWith('reason: time')) {
                                helpMessage.edit({
                                    embeds: [cmdEmbed],
                                    components: []
                                }).catch(() => { })
                            }
                        })
                    data2[msg.author.id]['promises'].push({ promise: p, active: true })
                })
                    .catch(() => {
                        msg.channel.send('Couldn\'t send help to you. Do you have me blocked?')
                        return
                    })
            },
            help: {
                "name": "help/commands/cmds [command]",
                "value": "HELP! You can specify the command parameter if you want help on a certain command."
            },
            cooldown: 2500,
            type: "Main"
        },

        {
            name: ["tango", "deleteembed", "dembed"],
            execute: async function (msg, args) {
                var saidMessage = args.join(' ').substring(args[0].length + 1)
                var rulesChannel = msg.guild.channels.cache.find(channel => channel.name === 'rules' || channel.name.includes('rule'))
                var tangoEmbed = {
                    "author": {
                        "name": msg.author.tag,
                        "icon_url": msg.author.displayAvatarURL({ dynamic: true, size: 1024, format: 'png' })
                    },
                    "description": `**Message sent by <@${msg.author.id}> deleted in <#${rulesChannel && rulesChannel.id || msg.channel.id}>**\n${saidMessage}`,
                    "color": 0xFF470F,
                    "timestamp": Date.now(),
                    "footer": {
                        "text": `Author: ${msg.author.id} | Message ID: ${msg.id}`
                    },
                };
                msg.channel.send({
                    allowedMentions: {
                        parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                    },
                    embeds: [tangoEmbed]
                }).catch(() => { })
            },
            help: {
                "name": "tango/deleteembed/dembed {message}",
                "value": "tango"
            },
            cooldown: 2500,
            type: "Inside Joke"
        },

        {
            name: ["img", "image"],
            execute: async function (msg, args) {
                async function image() {
                    var page = 0
                    var pageindex = args.indexOf('-page')
                    if (pageindex > -1) {
                        page = isNaN(Number(args[pageindex + 1])) ? 0 : Number(args[pageindex + 1]) <= 1 ? 1 : Math.round(Number(args[pageindex + 1])) || 0
                        args.splice(pageindex, 2)
                    }

                    var bing = false
                    var bingindex = args.indexOf('-bing')
                    if (bingindex > -1) {
                        bing = true
                        args.splice(bingindex, 1)
                    }
                    var search = args.slice(1).join(" ");

                    var urls = await fetchImages(search, bing).catch(() => { })

                    if (!urls) {
                        msg.channel.send('Error.').catch(() => { })
                        msg.channel.sendTyping().catch(() => { })
                        return;
                    }

                    if (!urls.length) {
                        msg.channel.send('Not found.').catch(() => { })
                        msg.channel.sendTyping().catch(() => { })
                        return;
                    }

                    var number = 1
                    if (page) {
                        number = Number(page)
                        if (isNaN(number)) {
                            msg.channel.send({
                                content: '**' + page + '** is not a number.',
                                allowedMentions: {
                                    parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            }).catch(() => { })
                            msg.channel.sendTyping().catch(() => { })
                            return;
                        };
                        if (number > urls.length) number = urls.length;
                        if (number < 1) number = 1
                        var imgEmbed = {
                            "title": "Image Search Results For " + search,
                            "description": "Use the arrows to navigate.",
                            "color": 0x472604,
                            "footer": {
                                "text": "Image " + number + "/" + urls.length
                            },
                            "image": {
                                "url": urls[number - 1]
                            },
                            "author": {
                                "name": msg.author.tag,
                                "icon_url": msg.author.displayAvatarURL({ dynamic: true, size: 1024, format: 'png' })
                            }
                        };
                        var reactions = [
                            {
                                reaction: "861253229723123762",
                                function: () => {
                                    return 1
                                },
                            },
                            {
                                reaction: "861253229726793728",
                                function: (number) => {
                                    return number - 1
                                },
                            },
                            {
                                reaction: "861253230070988860",
                                function: () => {
                                    return Math.floor(Math.random() * urls.length) + 1
                                },
                            },
                            {
                                reaction: "861253229798621205",
                                function: (number) => {
                                    return number + 1
                                },
                            },
                            {
                                reaction: "861253229740556308",
                                function: () => {
                                    return urls.length
                                },
                            },
                        ]
                        var buttonRow = new Discord.MessageActionRow()
                        reactions.forEach(reaction => {
                            var button = new Discord.MessageButton()
                                .setStyle('PRIMARY')
                                .setEmoji(reaction.reaction)
                                .setCustomId(reaction.reaction)
                            buttonRow.addComponents([button])
                        })
                        var buttonRow2 = new Discord.MessageActionRow()
                        var benson = new Discord.MessageButton()
                            .setStyle('DANGER')
                            .setEmoji('874406183933444156')
                            .setCustomId('delete')
                        buttonRow2.addComponents([benson])

                        var imgMessage = await msg.channel.send({
                            embeds: [imgEmbed],
                            components: [buttonRow, buttonRow2]
                        }).catch(() => { })
                        if (!imgMessage) {
                            msg.channel.sendTyping().catch(() => { })
                            return
                        }
                        data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl2'] = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl']
                        data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] = urls[number - 1]
                        var lastUrls = [urls[number - 1]].concat(data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrls'])
                        lastUrls.splice(100)
                        data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrls'] = lastUrls
                        msg.channel.sendTyping().catch(() => { })
                        var filter = (button) => {
                            if (data2[msg.guild.id][msg.author.id]['promises'].find(promise => promise.promise === p).active === false) return
                            if (!(button.user.id === msg.author.id && button.user.id !== bot.user.id && !button.user.bot)) {
                                button.deferUpdate().catch(() => { })
                                return
                            }
                            if (button.customId === 'delete') {
                                button.deferUpdate().catch(() => { })
                                imgMessage.delete().catch(() => { })
                                return
                            }
                            if (reactions.find(findreaction => findreaction.reaction === button.customId).function(number) > urls.length || reactions.find(findreaction => findreaction.reaction === button.customId).function(number) < 1) {
                                button.deferUpdate().catch(() => { })
                                return
                            }
                            number = reactions.find(findreaction => findreaction.reaction === button.customId).function(number)
                            imgEmbed = {
                                "title": "Image Search Results For " + search,
                                "description": "Use the arrows to navigate.",
                                "color": 0x472604,
                                "footer": {
                                    "text": "Image " + number + "/" + urls.length
                                },
                                "image": {
                                    "url": urls[number - 1]
                                },
                                "author": {
                                    "name": msg.author.tag,
                                    "icon_url": msg.author.displayAvatarURL({ dynamic: true, size: 1024, format: 'png' })
                                }
                            };
                            data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl2'] = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl']
                            data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] = urls[number - 1]
                            var lastUrls = [urls[number - 1]].concat(data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrls'])
                            lastUrls.splice(100)
                            data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrls'] = lastUrls
                            imgMessage.edit({
                                embeds: [imgEmbed],
                                components: [buttonRow, buttonRow2]
                            }).catch(() => { })
                            button.deferUpdate().catch(() => { })
                        }
                        for (var i in data2[msg.guild.id][msg.author.id]['promises']) {
                            if (data2[msg.guild.id][msg.author.id]['promises'][i]) {
                                data2[msg.guild.id][msg.author.id]['promises'][i]['active'] = false
                            }
                        }
                        var p = imgMessage.awaitMessageComponent({ componentType: 'BUTTON', time: 600000, filter }).then(() => {
                            for (var i in data2[msg.guild.id][msg.author.id]['promises']) {
                                if (data2[msg.guild.id][msg.author.id]['promises'][i] == p) {
                                    data2[msg.guild.id][msg.author.id]['promises'][i] = undefined
                                    break
                                }
                            }
                            if (!imgMessage.edit) return
                            imgMessage.edit({
                                embeds: [imgEmbed],
                                components: []
                            }).catch(() => { })
                        })
                            .catch((err) => {
                                if (err.message.endsWith('reason: time')) {
                                    imgMessage.edit({
                                        embeds: [imgEmbed],
                                        components: []
                                    }).catch(() => { })
                                }
                            })
                        data2[msg.guild.id][msg.author.id]['promises'].push({ promise: p, active: true })
                    } else {
                        var imgEmbed = {
                            "title": "Image Search Results For: " + search,
                            "description": "Use the arrows to navigate.",
                            "color": 0x472604,
                            "footer": {
                                "text": "Image " + number + "/" + urls.length
                            },
                            "image": {
                                "url": urls[number - 1]
                            },
                            "author": {
                                "name": msg.author.tag,
                                "icon_url": msg.author.displayAvatarURL({ dynamic: true, size: 1024, format: 'png' })
                            }
                        };
                        var reactions = [
                            {
                                reaction: "861253229723123762",
                                function: () => {
                                    return 1
                                },
                            },
                            {
                                reaction: "861253229726793728",
                                function: (number) => {
                                    return number - 1
                                },
                            },
                            {
                                reaction: "861253230070988860",
                                function: () => {
                                    return Math.floor(Math.random() * urls.length) + 1
                                },
                            },
                            {
                                reaction: "861253229798621205",
                                function: (number) => {
                                    return number + 1
                                },
                            },
                            {
                                reaction: "861253229740556308",
                                function: () => {
                                    return urls.length
                                },
                            },
                        ]
                        var buttonRow = new Discord.MessageActionRow()
                        reactions.forEach(reaction => {
                            var button = new Discord.MessageButton()
                                .setStyle('PRIMARY')
                                .setEmoji(reaction.reaction)
                                .setCustomId(reaction.reaction)
                            buttonRow.addComponents([button])
                        })
                        var buttonRow2 = new Discord.MessageActionRow()
                        var benson = new Discord.MessageButton()
                            .setStyle('DANGER')
                            .setEmoji('874406183933444156')
                            .setCustomId('delete')
                        buttonRow2.addComponents([benson])

                        var imgMessage = await msg.channel.send({
                            embeds: [imgEmbed],
                            components: [buttonRow, buttonRow2]
                        }).catch(() => { })
                        data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl2'] = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl']
                        data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] = urls[number - 1]
                        var lastUrls = [urls[number - 1]].concat(data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrls'])
                        lastUrls.splice(100)
                        data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrls'] = lastUrls
                        msg.channel.sendTyping().catch(() => { })
                        var filter = (button) => {
                            if (data2[msg.guild.id][msg.author.id]['promises'].find(promise => promise.promise === p).active === false) return
                            if (!(button.user.id === msg.author.id && button.user.id !== bot.user.id && !button.user.bot)) {
                                button.deferUpdate().catch(() => { })
                                return
                            }
                            if (button.customId === 'delete') {
                                button.deferUpdate().catch(() => { })
                                imgMessage.delete().catch(() => { })
                                return
                            }
                            if (reactions.find(findreaction => findreaction.reaction === button.customId).function(number) > urls.length || reactions.find(findreaction => findreaction.reaction === button.customId).function(number) < 1) {
                                button.deferUpdate().catch(() => { })
                                return
                            }
                            number = reactions.find(findreaction => findreaction.reaction === button.customId).function(number)
                            imgEmbed = {
                                "title": "Image Search Results For: " + search,
                                "description": "Use the arrows to navigate.",
                                "color": 0x472604,
                                "footer": {
                                    "text": "Image " + number + "/" + urls.length
                                },
                                "image": {
                                    "url": urls[number - 1]
                                },
                                "author": {
                                    "name": msg.author.tag,
                                    "icon_url": msg.author.displayAvatarURL({ dynamic: true, size: 1024, format: 'png' })
                                }
                            };
                            data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl2'] = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl']
                            data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] = urls[number - 1]
                            var lastUrls = [urls[number - 1]].concat(data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrls'])
                            lastUrls.splice(100)
                            data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrls'] = lastUrls
                            imgMessage.edit({
                                embeds: [imgEmbed],
                                components: [buttonRow, buttonRow2]
                            }).catch(() => { })
                            button.deferUpdate().catch(() => { })
                        }
                        for (var i in data2[msg.guild.id][msg.author.id]['promises']) {
                            if (data2[msg.guild.id][msg.author.id]['promises'][i]) {
                                data2[msg.guild.id][msg.author.id]['promises'][i]['active'] = false
                            }
                        }
                        var p = imgMessage.awaitMessageComponent({ componentType: 'BUTTON', time: 600000, filter }).then(() => {
                            for (var i in data2[msg.guild.id][msg.author.id]['promises']) {
                                if (data2[msg.guild.id][msg.author.id]['promises'][i] == p) {
                                    data2[msg.guild.id][msg.author.id]['promises'][i] = undefined
                                    break
                                }
                            }
                            if (!imgMessage.edit) return
                            imgMessage.edit({
                                embeds: [imgEmbed],
                                components: []
                            }).catch(() => { })
                        })
                            .catch((err) => {
                                if (err.message.endsWith('reason: time')) {
                                    imgMessage.edit({
                                        embeds: [imgEmbed],
                                        components: []
                                    }).catch(() => { })
                                }
                            })
                        data2[msg.guild.id][msg.author.id]['promises'].push({ promise: p, active: true })
                    }
                }

                msg.channel.sendTyping().catch(() => { })
                if (args[1] === undefined) {
                    msg.channel.send('What do I search for?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                }

                image(msg, args)
            },
            help: {
                "name": "img/image <query> [-page <number>] [-bing]",
                "value": "Search for a random image in Google.\nExample usage: p:img Burger -page 5"
            },
            cooldown: 2500,
            type: "Fetching"
        },

        {
            name: ["gif", "tenor"],
            execute: async function (msg, args) {
                async function gif(msg, parts) {
                    var page = 0
                    var pageindex = args.indexOf('-page')
                    if (pageindex > -1) {
                        page = isNaN(Number(args[pageindex + 1])) ? 0 : Number(args[pageindex + 1]) <= 1 ? 1 : Math.round(Number(args[pageindex + 1])) || 0
                        parts.splice(pageindex, 2)
                    }
                    var search = parts.slice(1).join(" ");

                    axios.request(`https://g.tenor.com/v1/search?q=${encodeURIComponent(search)}&key=${process.env.TENORKEY}&limit=100&contentfilter=${msg.channel.nsfw ? 'off' : 'medium'}`).then(async (res) => {
                        var results = res.data.results

                        var urls = [];

                        for (var i in results) {
                            var result = results[i]
                            urls.push(result.media[0].gif.url)
                        }

                        if (!urls.length) {
                            msg.channel.send('Not found.').catch(() => { })
                            msg.channel.sendTyping().catch(() => { })
                            return;
                        }

                        var number = 1
                        if (page) {
                            number = Number(page)
                            if (isNaN(number)) {
                                msg.channel.send({
                                    content: '**' + page + '** is not a number.',
                                    allowedMentions: {
                                        parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    }
                                }).catch(() => { })
                                msg.channel.sendTyping().catch(() => { })
                                return;
                            };
                            if (number > urls.length) number = urls.length;
                            if (number < 1) number = 1
                            var imgEmbed = {
                                "title": "Tenor GIF Search Results For " + search,
                                "description": "Use the arrows to navigate.",
                                "color": 0x472604,
                                "footer": {
                                    "text": "GIF " + number + "/" + urls.length
                                },
                                "image": {
                                    "url": urls[number - 1]
                                },
                                "author": {
                                    "name": msg.author.tag,
                                    "icon_url": msg.author.displayAvatarURL({ dynamic: true, size: 1024, format: 'png' })
                                }
                            };
                            var reactions = [
                                {
                                    reaction: "861253229723123762",
                                    function: () => {
                                        return 1
                                    },
                                },
                                {
                                    reaction: "861253229726793728",
                                    function: (number) => {
                                        return number - 1
                                    },
                                },
                                {
                                    reaction: "861253230070988860",
                                    function: () => {
                                        return Math.floor(Math.random() * urls.length) + 1
                                    },
                                },
                                {
                                    reaction: "861253229798621205",
                                    function: (number) => {
                                        return number + 1
                                    },
                                },
                                {
                                    reaction: "861253229740556308",
                                    function: () => {
                                        return urls.length
                                    },
                                },
                            ]
                            var buttonRow = new Discord.MessageActionRow()
                            reactions.forEach(reaction => {
                                var button = new Discord.MessageButton()
                                    .setStyle('PRIMARY')
                                    .setEmoji(reaction.reaction)
                                    .setCustomId(reaction.reaction)
                                buttonRow.addComponents([button])
                            })
                            var buttonRow2 = new Discord.MessageActionRow()
                            var benson = new Discord.MessageButton()
                                .setStyle('DANGER')
                                .setEmoji('874406183933444156')
                                .setCustomId('delete')
                            buttonRow2.addComponents([benson])

                            var imgMessage = await msg.channel.send({
                                embeds: [imgEmbed],
                                components: [buttonRow, buttonRow2]
                            }).catch(() => { })
                            if (!imgMessage) {
                                msg.channel.sendTyping().catch(() => { })
                                return
                            }
                            data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl2'] = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl']
                            data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] = urls[number - 1]
                            var lastUrls = [urls[number - 1]].concat(data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrls'])
                            lastUrls.splice(100)
                            data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrls'] = lastUrls
                            msg.channel.sendTyping().catch(() => { })
                            var filter = (button) => {
                                if (data2[msg.guild.id][msg.author.id]['promises'].find(promise => promise.promise === p).active === false) return
                                if (!(button.user.id === msg.author.id && button.user.id !== bot.user.id && !button.user.bot)) {
                                    button.deferUpdate().catch(() => { })
                                    return
                                }
                                if (button.customId === 'delete') {
                                    button.deferUpdate().catch(() => { })
                                    imgMessage.delete().catch(() => { })
                                    return
                                }
                                if (reactions.find(findreaction => findreaction.reaction === button.customId).function(number) > urls.length || reactions.find(findreaction => findreaction.reaction === button.customId).function(number) < 1) {
                                    button.deferUpdate().catch(() => { })
                                    return
                                }
                                number = reactions.find(findreaction => findreaction.reaction === button.customId).function(number)
                                imgEmbed = {
                                    "title": "Tenor GIF Search Results For " + search,
                                    "description": "Use the arrows to navigate.",
                                    "color": 0x472604,
                                    "footer": {
                                        "text": "GIF " + number + "/" + urls.length
                                    },
                                    "image": {
                                        "url": urls[number - 1]
                                    },
                                    "author": {
                                        "name": msg.author.tag,
                                        "icon_url": msg.author.displayAvatarURL({ dynamic: true, size: 1024, format: 'png' })
                                    }
                                };
                                data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl2'] = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl']
                                data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] = urls[number - 1]
                                var lastUrls = [urls[number - 1]].concat(data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrls'])
                                lastUrls.splice(100)
                                data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrls'] = lastUrls
                                imgMessage.edit({
                                    embeds: [imgEmbed],
                                    components: [buttonRow, buttonRow2]
                                }).catch(() => { })
                                button.deferUpdate().catch(() => { })
                            }
                            for (var i in data2[msg.guild.id][msg.author.id]['promises']) {
                                if (data2[msg.guild.id][msg.author.id]['promises'][i]) {
                                    data2[msg.guild.id][msg.author.id]['promises'][i]['active'] = false
                                }
                            }
                            var p = imgMessage.awaitMessageComponent({ componentType: 'BUTTON', time: 600000, filter }).then(() => {
                                for (var i in data2[msg.guild.id][msg.author.id]['promises']) {
                                    if (data2[msg.guild.id][msg.author.id]['promises'][i] == p) {
                                        data2[msg.guild.id][msg.author.id]['promises'][i] = undefined
                                        break
                                    }
                                }
                                if (!imgMessage.edit) return
                                imgMessage.edit({
                                    embeds: [imgEmbed],
                                    components: []
                                }).catch(() => { })
                            })
                                .catch((err) => {
                                    if (err.message.endsWith('reason: time')) {
                                        imgMessage.edit({
                                            embeds: [imgEmbed],
                                            components: []
                                        }).catch(() => { })
                                    }
                                })
                            data2[msg.guild.id][msg.author.id]['promises'].push({ promise: p, active: true })
                        } else {
                            var imgEmbed = {
                                "title": "Tenor GIF Search Results For: " + search,
                                "description": "Use the arrows to navigate.",
                                "color": 0x472604,
                                "footer": {
                                    "text": "GIF " + number + "/" + urls.length
                                },
                                "image": {
                                    "url": urls[number - 1]
                                },
                                "author": {
                                    "name": msg.author.tag,
                                    "icon_url": msg.author.displayAvatarURL({ dynamic: true, size: 1024, format: 'png' })
                                }
                            };
                            var reactions = [
                                {
                                    reaction: "861253229723123762",
                                    function: () => {
                                        return 1
                                    },
                                },
                                {
                                    reaction: "861253229726793728",
                                    function: (number) => {
                                        return number - 1
                                    },
                                },
                                {
                                    reaction: "861253230070988860",
                                    function: () => {
                                        return Math.floor(Math.random() * urls.length) + 1
                                    },
                                },
                                {
                                    reaction: "861253229798621205",
                                    function: (number) => {
                                        return number + 1
                                    },
                                },
                                {
                                    reaction: "861253229740556308",
                                    function: () => {
                                        return urls.length
                                    },
                                },
                            ]
                            var buttonRow = new Discord.MessageActionRow()
                            reactions.forEach(reaction => {
                                var button = new Discord.MessageButton()
                                    .setStyle('PRIMARY')
                                    .setEmoji(reaction.reaction)
                                    .setCustomId(reaction.reaction)
                                buttonRow.addComponents([button])
                            })
                            var buttonRow2 = new Discord.MessageActionRow()
                            var benson = new Discord.MessageButton()
                                .setStyle('DANGER')
                                .setEmoji('874406183933444156')
                                .setCustomId('delete')
                            buttonRow2.addComponents([benson])

                            var imgMessage = await msg.channel.send({
                                embeds: [imgEmbed],
                                components: [buttonRow, buttonRow2]
                            }).catch(() => { })
                            data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl2'] = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl']
                            data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] = urls[number - 1]
                            var lastUrls = [urls[number - 1]].concat(data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrls'])
                            lastUrls.splice(100)
                            data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrls'] = lastUrls
                            msg.channel.sendTyping().catch(() => { })
                            var filter = (button) => {
                                if (data2[msg.guild.id][msg.author.id]['promises'].find(promise => promise.promise === p).active === false) return
                                if (!(button.user.id === msg.author.id && button.user.id !== bot.user.id && !button.user.bot)) {
                                    button.deferUpdate().catch(() => { })
                                    return
                                }
                                if (button.customId === 'delete') {
                                    button.deferUpdate().catch(() => { })
                                    imgMessage.delete().catch(() => { })
                                    return
                                }
                                if (reactions.find(findreaction => findreaction.reaction === button.customId).function(number) > urls.length || reactions.find(findreaction => findreaction.reaction === button.customId).function(number) < 1) {
                                    button.deferUpdate().catch(() => { })
                                    return
                                }
                                number = reactions.find(findreaction => findreaction.reaction === button.customId).function(number)
                                imgEmbed = {
                                    "title": "Tenor GIF Search Results For: " + search,
                                    "description": "Use the arrows to navigate.",
                                    "color": 0x472604,
                                    "footer": {
                                        "text": "GIF " + number + "/" + urls.length
                                    },
                                    "image": {
                                        "url": urls[number - 1]
                                    },
                                    "author": {
                                        "name": msg.author.tag,
                                        "icon_url": msg.author.displayAvatarURL({ dynamic: true, size: 1024, format: 'png' })
                                    }
                                };
                                data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl2'] = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl']
                                data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] = urls[number - 1]
                                var lastUrls = [urls[number - 1]].concat(data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrls'])
                                lastUrls.splice(100)
                                data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrls'] = lastUrls
                                imgMessage.edit({
                                    embeds: [imgEmbed],
                                    components: [buttonRow, buttonRow2]
                                }).catch(() => { })
                                button.deferUpdate().catch(() => { })

                            }
                            for (var i in data2[msg.guild.id][msg.author.id]['promises']) {
                                if (data2[msg.guild.id][msg.author.id]['promises'][i]) {
                                    data2[msg.guild.id][msg.author.id]['promises'][i]['active'] = false
                                }
                            }
                            var p = imgMessage.awaitMessageComponent({ componentType: 'BUTTON', time: 600000, filter }).then(() => {
                                for (var i in data2[msg.guild.id][msg.author.id]['promises']) {
                                    if (data2[msg.guild.id][msg.author.id]['promises'][i] == p) {
                                        data2[msg.guild.id][msg.author.id]['promises'][i] = undefined
                                        break
                                    }
                                }
                                if (!imgMessage.edit) return
                                imgMessage.edit({
                                    embeds: [imgEmbed],
                                    components: []
                                }).catch(() => { })
                            })
                                .catch((err) => {
                                    if (err.message.endsWith('reason: time')) {
                                        imgMessage.edit({
                                            embeds: [imgEmbed],
                                            components: []
                                        }).catch(() => { })
                                    }
                                })
                            data2[msg.guild.id][msg.author.id]['promises'].push({ promise: p, active: true })
                        }
                    }).catch(() => { })
                }

                msg.channel.sendTyping().catch(() => { })
                if (args[1] === undefined) {
                    msg.channel.send('What do I search for?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                }

                gif(msg, args)
            },
            help: {
                "name": "gif/tenor <query> [-page <number>]",
                "value": "Search for a random GIF in Tenor.\nExample usage: p:gif house exploding -page 3"
            },
            cooldown: 2500,
            type: "Fetching"
        },

        {
            name: ["youtube", "yt", "video"],
            execute: async function (msg, args) {
                async function video(msg, parts) {
                    var page = 0
                    var pageindex = args.indexOf('-page')
                    if (pageindex > -1) {
                        page = isNaN(Number(args[pageindex + 1])) ? 0 : Number(args[pageindex + 1]) <= 1 ? 1 : Math.round(Number(args[pageindex + 1])) || 0
                        parts.splice(pageindex, 2)
                    }
                    var search = parts.slice(1).join(" ");

                    youtube.search.list({
                        type: 'video',
                        q: search,
                        part: 'snippet',
                        maxResults: 50,
                        safeSearch: msg.channel.nsfw ? 'none' : 'strict'
                    }).then(async (body) => {
                        var results = body.data.items

                        var urls = [];

                        for (var i in results) {
                            var result = results[i]
                            var title = result.snippet.title.replace(/&quot;/g, '"').replace(/&#\d+;/g, (match) => {
                                return String.fromCharCode(match.substring(2, match.length - 1))
                            })

                            urls.push({
                                url: `https://www.youtube.com/watch?v=${result.id.videoId}`,
                                thumb: result.snippet.thumbnails.high.url,
                                title: title
                            })
                        }

                        if (!urls.length) {
                            msg.channel.send('Not found.').catch(() => { })
                            msg.channel.sendTyping().catch(() => { })
                            return;
                        }

                        var number = 1
                        if (page) {
                            number = Number(page)
                            if (isNaN(number)) {
                                msg.channel.send({
                                    content: '**' + page + '** is not a number.',
                                    allowedMentions: {
                                        parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                    }
                                }).catch(() => { })
                                msg.channel.sendTyping().catch(() => { })
                                return;
                            };
                            if (number > urls.length) number = urls.length;
                            if (number < 1) number = 1
                            var thumbresponse = await axios.request(urls[number - 1].thumb.replace('hqdefault', 'hq720')).catch(() => { })
                            var imgEmbed = {
                                "title": "YouTube Video Search Results For " + search,
                                "description": `[${urls[number - 1].title}](${urls[number - 1].url})`,
                                "color": 0x472604,
                                "footer": {
                                    "text": "Video " + number + "/" + urls.length
                                },
                                "image": {
                                    "url": thumbresponse ? (thumbresponse.status >= 200 && thumbresponse.status < 300) ? urls[number - 1].thumb.replace('hqdefault', 'hq720') : urls[number - 1].thumb : urls[number - 1].thumb
                                },
                                "author": {
                                    "name": msg.author.tag,
                                    "icon_url": msg.author.displayAvatarURL({ dynamic: true, size: 1024, format: 'png' })
                                }
                            };
                            var reactions = [
                                {
                                    reaction: "861253229723123762",
                                    function: () => {
                                        return 1
                                    },
                                },
                                {
                                    reaction: "861253229726793728",
                                    function: (number) => {
                                        return number - 1
                                    },
                                },
                                {
                                    reaction: "861253230070988860",
                                    function: () => {
                                        return Math.floor(Math.random() * urls.length) + 1
                                    },
                                },
                                {
                                    reaction: "861253229798621205",
                                    function: (number) => {
                                        return number + 1
                                    },
                                },
                                {
                                    reaction: "861253229740556308",
                                    function: () => {
                                        return urls.length
                                    },
                                },
                            ]
                            var buttonRow = new Discord.MessageActionRow()
                            reactions.forEach(reaction => {
                                var button = new Discord.MessageButton()
                                    .setStyle('PRIMARY')
                                    .setEmoji(reaction.reaction)
                                    .setCustomId(reaction.reaction)
                                buttonRow.addComponents([button])
                            })
                            var buttonRow2 = new Discord.MessageActionRow()
                            var benson = new Discord.MessageButton()
                                .setStyle('DANGER')
                                .setEmoji('874406183933444156')
                                .setCustomId('delete')
                            buttonRow2.addComponents([benson])

                            var imgMessage = await msg.channel.send({
                                embeds: [imgEmbed],
                                components: [buttonRow, buttonRow2]
                            }).catch(() => { })
                            if (!imgMessage) {
                                msg.channel.sendTyping().catch(() => { })
                                return
                            }
                            msg.channel.sendTyping().catch(() => { })
                            var filter = async (button) => {
                                if (data2[msg.guild.id][msg.author.id]['promises'].find(promise => promise.promise === p).active === false) return
                                if (!(button.user.id === msg.author.id && button.user.id !== bot.user.id && !button.user.bot)) {
                                    button.deferUpdate().catch(() => { })
                                    return
                                }
                                if (button.customId === 'delete') {
                                    button.deferUpdate().catch(() => { })
                                    imgMessage.delete().catch(() => { })
                                    return
                                }
                                if (reactions.find(findreaction => findreaction.reaction === button.customId).function(number) > urls.length || reactions.find(findreaction => findreaction.reaction === button.customId).function(number) < 1) {
                                    button.deferUpdate().catch(() => { })
                                    return
                                }
                                number = reactions.find(findreaction => findreaction.reaction === button.customId).function(number)
                                var thumbresponse = await axios.request(urls[number - 1].thumb.replace('hqdefault', 'hq720')).catch(() => { })
                                imgEmbed = {
                                    "title": "YouTube Video Search Results For " + search,
                                    "description": `[${urls[number - 1].title}](${urls[number - 1].url})`,
                                    "color": 0x472604,
                                    "footer": {
                                        "text": "Video " + number + "/" + urls.length
                                    },
                                    "image": {
                                        "url": thumbresponse ? (thumbresponse.status >= 200 && thumbresponse.status < 300) ? urls[number - 1].thumb.replace('hqdefault', 'hq720') : urls[number - 1].thumb : urls[number - 1].thumb
                                    },
                                    "author": {
                                        "name": msg.author.tag,
                                        "icon_url": msg.author.displayAvatarURL({ dynamic: true, size: 1024, format: 'png' })
                                    }
                                };
                                imgMessage.edit({
                                    embeds: [imgEmbed],
                                    components: [buttonRow, buttonRow2]
                                }).catch(() => { })
                                button.deferUpdate().catch(() => { })
                                var youtubeurl = await youtubedl(urls[number - 1].url, {
                                    format: '18',
                                    'get-url': ''
                                }).catch(() => { })
                                if (youtubeurl) {
                                    data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl2'] = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl']
                                    data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] = youtubeurl
                                    var lastUrls = [youtubeurl].concat(data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrls'])
                                    lastUrls.splice(100)
                                    data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrls'] = lastUrls
                                }
                            }
                            for (var i in data2[msg.guild.id][msg.author.id]['promises']) {
                                if (data2[msg.guild.id][msg.author.id]['promises'][i]) {
                                    data2[msg.guild.id][msg.author.id]['promises'][i]['active'] = false
                                }
                            }
                            var p = imgMessage.awaitMessageComponent({ componentType: 'BUTTON', time: 600000, filter }).then(() => {
                                for (var i in data2[msg.guild.id][msg.author.id]['promises']) {
                                    if (data2[msg.guild.id][msg.author.id]['promises'][i] == p) {
                                        data2[msg.guild.id][msg.author.id]['promises'][i] = undefined
                                        break
                                    }
                                }
                                if (!imgMessage.edit) return
                                imgMessage.edit({
                                    embeds: [imgEmbed],
                                    components: []
                                }).catch(() => { })
                            })
                                .catch((err) => {
                                    if (err.message.endsWith('reason: time')) {
                                        imgMessage.edit({
                                            embeds: [imgEmbed],
                                            components: []
                                        }).catch(() => { })
                                    }
                                })
                            data2[msg.guild.id][msg.author.id]['promises'].push({ promise: p, active: true })
                            var youtubeurl = await youtubedl(urls[number - 1].url, {
                                format: '18',
                                'get-url': ''
                            }).catch(() => { })
                            if (youtubeurl) {
                                data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl2'] = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl']
                                data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] = youtubeurl
                                var lastUrls = [youtubeurl].concat(data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrls'])
                                lastUrls.splice(100)
                                data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrls'] = lastUrls
                            }
                        } else {
                            var thumbresponse = await axios.request(urls[number - 1].thumb.replace('hqdefault', 'hq720')).catch(() => { })
                            var imgEmbed = {
                                "title": "YouTube Video Search Results For: " + search,
                                "description": `[${urls[number - 1].title}](${urls[number - 1].url})`,
                                "color": 0x472604,
                                "footer": {
                                    "text": "Video " + number + "/" + urls.length
                                },
                                "image": {
                                    "url": thumbresponse ? (thumbresponse.status >= 200 && thumbresponse.status < 300) ? urls[number - 1].thumb.replace('hqdefault', 'hq720') : urls[number - 1].thumb : urls[number - 1].thumb
                                },
                                "author": {
                                    "name": msg.author.tag,
                                    "icon_url": msg.author.displayAvatarURL({ dynamic: true, size: 1024, format: 'png' })
                                }
                            };
                            var reactions = [
                                {
                                    reaction: "861253229723123762",
                                    function: () => {
                                        return 1
                                    },
                                },
                                {
                                    reaction: "861253229726793728",
                                    function: (number) => {
                                        return number - 1
                                    },
                                },
                                {
                                    reaction: "861253230070988860",
                                    function: () => {
                                        return Math.floor(Math.random() * urls.length) + 1
                                    },
                                },
                                {
                                    reaction: "861253229798621205",
                                    function: (number) => {
                                        return number + 1
                                    },
                                },
                                {
                                    reaction: "861253229740556308",
                                    function: () => {
                                        return urls.length
                                    },
                                },
                            ]
                            var buttonRow = new Discord.MessageActionRow()
                            reactions.forEach(reaction => {
                                var button = new Discord.MessageButton()
                                    .setStyle('PRIMARY')
                                    .setEmoji(reaction.reaction)
                                    .setCustomId(reaction.reaction)
                                buttonRow.addComponents([button])
                            })
                            var buttonRow2 = new Discord.MessageActionRow()
                            var benson = new Discord.MessageButton()
                                .setStyle('DANGER')
                                .setEmoji('874406183933444156')
                                .setCustomId('delete')
                            buttonRow2.addComponents([benson])

                            var imgMessage = await msg.channel.send({
                                embeds: [imgEmbed],
                                components: [buttonRow, buttonRow2]
                            }).catch(() => { })
                            msg.channel.sendTyping().catch(() => { })
                            var filter = async (button) => {
                                if (data2[msg.guild.id][msg.author.id]['promises'].find(promise => promise.promise === p).active === false) return
                                if (!(button.user.id === msg.author.id && button.user.id !== bot.user.id && !button.user.bot)) {
                                    button.deferUpdate().catch(() => { })
                                    return
                                }
                                if (button.customId === 'delete') {
                                    button.deferUpdate().catch(() => { })
                                    imgMessage.delete().catch(() => { })
                                    return
                                }
                                if (reactions.find(findreaction => findreaction.reaction === button.customId).function(number) > urls.length || reactions.find(findreaction => findreaction.reaction === button.customId).function(number) < 1) {
                                    button.deferUpdate().catch(() => { })
                                    return
                                }
                                number = reactions.find(findreaction => findreaction.reaction === button.customId).function(number)
                                var thumbresponse = await axios.request(urls[number - 1].thumb.replace('hqdefault', 'hq720')).catch(() => { })
                                imgEmbed = {
                                    "title": "YouTube Video Search Results For: " + search,
                                    "description": `[${urls[number - 1].title}](${urls[number - 1].url})`,
                                    "color": 0x472604,
                                    "footer": {
                                        "text": "Video " + number + "/" + urls.length
                                    },
                                    "image": {
                                        "url": thumbresponse ? (thumbresponse.status >= 200 && thumbresponse.status < 300) ? urls[number - 1].thumb.replace('hqdefault', 'hq720') : urls[number - 1].thumb : urls[number - 1].thumb
                                    },
                                    "author": {
                                        "name": msg.author.tag,
                                        "icon_url": msg.author.displayAvatarURL({ dynamic: true, size: 1024, format: 'png' })
                                    }
                                };
                                imgMessage.edit({
                                    embeds: [imgEmbed],
                                    components: [buttonRow, buttonRow2]
                                }).catch(() => { })
                                button.deferUpdate().catch(() => { })
                                var youtubeurl = await youtubedl(urls[number - 1].url, {
                                    format: '18',
                                    'get-url': ''
                                }).catch(() => { })
                                if (youtubeurl) {
                                    data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl2'] = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl']
                                    data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] = youtubeurl
                                    var lastUrls = [youtubeurl].concat(data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrls'])
                                    lastUrls.splice(100)
                                    data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrls'] = lastUrls
                                }
                            }
                            for (var i in data2[msg.guild.id][msg.author.id]['promises']) {
                                if (data2[msg.guild.id][msg.author.id]['promises'][i]) {
                                    data2[msg.guild.id][msg.author.id]['promises'][i]['active'] = false
                                }
                            }
                            var p = imgMessage.awaitMessageComponent({ componentType: 'BUTTON', time: 600000, filter }).then(() => {
                                for (var i in data2[msg.guild.id][msg.author.id]['promises']) {
                                    if (data2[msg.guild.id][msg.author.id]['promises'][i] == p) {
                                        data2[msg.guild.id][msg.author.id]['promises'][i] = undefined
                                        break
                                    }
                                }
                                if (!imgMessage.edit) return
                                imgMessage.edit({
                                    embeds: [imgEmbed],
                                    components: []
                                }).catch(() => { })
                            })
                                .catch((err) => {
                                    if (err.message.endsWith('reason: time')) {
                                        imgMessage.edit({
                                            embeds: [imgEmbed],
                                            components: []
                                        }).catch(() => { })
                                    }
                                })
                            data2[msg.guild.id][msg.author.id]['promises'].push({ promise: p, active: true })
                            var youtubeurl = await youtubedl(urls[number - 1].url, {
                                format: '18',
                                'get-url': ''
                            }).catch(() => { })
                            if (youtubeurl) {
                                data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl2'] = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl']
                                data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] = youtubeurl
                                var lastUrls = [youtubeurl].concat(data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrls'])
                                lastUrls.splice(100)
                                data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrls'] = lastUrls
                            }
                        }
                    });
                }

                msg.channel.sendTyping().catch(() => { })
                if (args[1] === undefined) {
                    msg.channel.send('What do I search for?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                }

                video(msg, args)
            },
            help: {
                "name": "youtube/yt/video <query> [-page <number>]",
                "value": "Search for a random video in YouTube."
            },
            cooldown: 2500,
            type: "Fetching"
        },

        {
            name: ["ocr", "recognizetext"],
            execute: async function (msg, args) {
                async function ocr(msg, url) {
                    var options = {
                        method: 'POST',
                        url: 'https://microsoft-computer-vision3.p.rapidapi.com/ocr',
                        params: { detectOrientation: 'true', language: 'unk' },
                        headers: {
                            'content-type': 'application/json',
                            'x-rapidapi-host': 'microsoft-computer-vision3.p.rapidapi.com',
                            'x-rapidapi-key': randomKey('RAPIDAPIKEY')
                        },
                        data: {
                            url: url
                        }
                    }

                    var response = await axios.request(options).catch(async () => {
                        await msg.channel.send('Error.').catch(() => { })
                    })

                    if (!response) return

                    if (!(response.status >= 200 && response.status < 300)) {
                        await msg.channel.send(`${response.status} ${response.statusText}`).catch(() => { })
                        return
                    }

                    var body = response.data
                    var regions = body.regions

                    if (regions.length <= 0) {
                        await msg.channel.send(`No text detected.`).catch(() => { })
                        return
                    }

                    var result = regions.map(region => region.lines.map(line => line.words.map(word => word.text).join(' ')).join('\n')).join('\n\n')

                    await msg.channel.send({
                        content: `Language: \`${body.language}\`\n\`\`\`\n${result}\n\`\`\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(async () => {
                        var currentcount = filecount
                        filecount++
                        var filepath = `temp/file${currentcount}`
                        fs.mkdirSync(`${filepath}`)
                        fs.writeFileSync(`${filepath}/ocr.txt`, result)
                        await msg.channel.send({
                            content: `Language: \`${body.language}\``,
                            files: [new Discord.MessageAttachment(`${filepath}/ocr.txt`)]
                        }).catch(() => { })
                        fs.rmSync(`${filepath}`, { force: true, recursive: true })
                    })
                }

                await msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                    await msg.channel.send('What is the file to recognize?!').catch(() => { })
                    await msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
                var fileinfo = await validateFile(currenturl).catch(async error => {
                    await msg.channel.send(error)
                    await msg.channel.sendTyping().catch(() => { })
                    return;
                })

                if (!fileinfo) return
                var type = fileinfo.type

                if (type.mime.startsWith('image')) {
                    await ocr(msg, currenturl).catch(() => { })
                } /*else if (type.mime.startsWith('video')) {
                    var currentcount = filecount
                    filecount++
                    var filepath = `temp/file${currentcount}`
                    fs.mkdirSync(`${filepath}`)
                    await execPromise(`ffmpeg -i "${currenturl}" -vframes 1 ${filepath}/output.png`)
                    await ocr(msg, `${filepath}/output.png`, `${filepath}`)
                }*/ else {
                    await msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    await msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "ocr/recognizetext <file>",
                "value": "Recognizes text within an image with Microsoft's Computer Vision."
            },
            cooldown: 2500,
            type: "Text"
        },

        {
            name: ["ascii", "braille"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                    msg.channel.send('What is the image to asciify?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
                var saidMessage = args.join(' ').substring(args[0].length + 1)
                var negative = false
                if (saidMessage.includes('-negative')) negative = true
                var fileinfo = await validateFile(currenturl).catch(async error => {
                    await msg.channel.send(error)
                    await msg.channel.sendTyping().catch(() => { })
                    return;
                })

                if (!fileinfo) return
                var type = fileinfo.type

                if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                    var brailleText = await braille(currenturl, negative)
                    await msg.channel.send({
                        content: brailleText,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(async () => {
                        var currentcount = filecount
                        filecount++
                        var filepath = `temp/file${currentcount}`
                        fs.mkdirSync(`${filepath}`)
                        fs.writeFileSync(`${filepath}/ascii.txt`, brailleText)
                        await msg.channel.send({
                            files: [new Discord.MessageAttachment(`${filepath}/ascii.txt`)]
                        }).catch(() => { })
                        fs.rmSync(`${filepath}`, { force: true, recursive: true })
                    })
                    msg.channel.sendTyping().catch(() => { })
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "ascii/braille [-negative] <image>",
                "value": "Converts the image to ASCII.\nExample usage: p:ascii -negative https://cdn.discordapp.com/emojis/827634704722165783.png"
            },
            cooldown: 2500,
            type: "Text"
        },

        {
            name: ["addtojson"],
            execute: async function (msg, args) {
                var jsonid = ownerids.find(id => id == msg.author.id) || jsoning.find(id => id == msg.author.id);
                if (jsonid === undefined) {
                    msg.channel.send('json club only').catch(() => { })
                    return
                } else {
                    var types = ['psfiles', 'pspasta', 'funnygif', 'poop', 'dmphrases']

                    if (args[1] === undefined) {
                        msg.channel.send(`What is the JSON to update?! (Available: ${types.map(t => `**${t}**`).join(', ')})`).catch(() => { })
                        return;
                    } else if (args[2] === undefined) {
                        msg.channel.send('What is the value?!').catch(() => { })
                        return;
                    }

                    var type

                    if (types.find(t => t === args[1].toLowerCase())) {
                        type = args[1].toLowerCase()
                    } else {
                        msg.channel.send('Not a JSON type.').catch(() => { })
                        return
                    }
                    var saidMessage = args.join(' ').substring(args[0].length + args[1].length + 2)

                    if (data()[mongodatabase]['bot-data']['bot'][type].find(v => v === saidMessage)) {
                        msg.channel.send('Already exists.').catch(() => { })
                        return
                    }

                    data()[mongodatabase]['bot-data']['bot'][type].push(saidMessage)

                    msg.channel.send({
                        content: '‚úÖ Added ' + saidMessage,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })

                    psFiles = data()[mongodatabase]['bot-data']['bot']['psfiles']
                    psPasta = data()[mongodatabase]['bot-data']['bot']['pspasta']
                    funnygifs = data()[mongodatabase]['bot-data']['bot']['funnygif']
                    poopPhrases = data()[mongodatabase]['bot-data']['bot']['poop']
                    dmPhrases = data()[mongodatabase]['bot-data']['bot']['dmphrases']
                };
            },
            help: {
                "name": "addtojson <json (psfiles, pspasta, funnygif, poop, dmphrases)> <value>",
                "value": "Adds a new value to JSONs like Phexonia Studio's files."
            },
            cooldown: 2500,
            type: "JSON Club"
        },

        {
            name: ["displayjson"],
            execute: async function (msg, args) {
                var jsonid = ownerids.find(id => id == msg.author.id) || jsoning.find(id => id == msg.author.id);
                if (jsonid === undefined) {
                    msg.channel.send('json club only').catch(() => { })
                    return
                } else {
                    var types = ['psfiles', 'pspasta', 'funnygif', 'poop', 'dmphrases']

                    if (args[1] === undefined) {
                        msg.channel.send(`What is the JSON to display?! (Available: ${types.map(t => `**${t}**`).join(', ')})`).catch(() => { })
                        return;
                    }

                    var type

                    if (types.find(t => t === args[1].toLowerCase())) {
                        type = args[1].toLowerCase()
                    } else {
                        msg.channel.send('Not a JSON type.').catch(() => { })
                        return
                    }

                    var currentcount = filecount
                    filecount++
                    var filepath = `temp/file${currentcount}`
                    fs.mkdirSync(filepath)
                    fs.writeFileSync(`${filepath}/jsonlist.txt`, data()[mongodatabase]['bot-data']['bot'][type].join('\n\n-----------------------------------------------\n\n') || 'lmao theres nothing')
                    await msg.channel.send({
                        files: [new Discord.MessageAttachment(`${filepath}/jsonlist.txt`)]
                    }).catch(() => { })
                    fs.rmSync(`${filepath}`, { force: true, recursive: true })
                };
            },
            help: {
                "name": "displayjson <json (psfiles, pspasta, funnygif, poop, dmphrases)>",
                "value": "Displays the values of a JSON like Phexonia Studio's files."
            },
            cooldown: 2500,
            type: "JSON Club"
        },

        {
            name: ["removefromjson"],
            execute: async function (msg, args) {
                var jsonid = ownerids.find(id => id == msg.author.id) || jsoning.find(id => id == msg.author.id);
                if (jsonid === undefined) {
                    msg.channel.send('json club only').catch(() => { })
                    return
                } else {
                    var types = ['psfiles', 'pspasta', 'funnygif', 'poop', 'dmphrases']

                    if (args[1] === undefined) {
                        msg.channel.send(`What is the JSON to update?! (Available: ${types.map(t => `**${t}**`).join(', ')})`).catch(() => { })
                        return;
                    } else if (args[2] === undefined) {
                        msg.channel.send('What is the value?!').catch(() => { })
                        return;
                    }

                    var type

                    if (types.find(t => t === args[1].toLowerCase())) {
                        type = args[1].toLowerCase()
                    } else {
                        msg.channel.send('Not a JSON type.').catch(() => { })
                        return
                    }
                    var saidMessage = args.join(' ').substring(args[0].length + args[1].length + 2)

                    if (!data()[mongodatabase]['bot-data']['bot'][type].find(v => v === saidMessage)) {
                        msg.channel.send('Does not exist.').catch(() => { })
                        return
                    }

                    data()[mongodatabase]['bot-data']['bot'][type].splice(data()[mongodatabase]['bot-data']['bot'][type].findIndex(v => v === saidMessage), 1)

                    msg.channel.send({
                        content: '‚úÖ Removed.',
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })

                    psFiles = data()[mongodatabase]['bot-data']['bot']['psfiles']
                    psPasta = data()[mongodatabase]['bot-data']['bot']['pspasta']
                    funnygifs = data()[mongodatabase]['bot-data']['bot']['funnygif']
                    poopPhrases = data()[mongodatabase]['bot-data']['bot']['poop']
                    dmPhrases = data()[mongodatabase]['bot-data']['bot']['dmphrases']
                };
            },
            help: {
                "name": "removefromjson <json (psfiles, pspasta, funnygif, poop, dmphrases)> <value>",
                "value": "Removes a value from JSONs like Phexonia Studio's files."
            },
            cooldown: 2500,
            type: "JSON Club"
        },

        {
            name: ["setstatus", "ss"],
            execute: async function (msg, args) {
                var ownerid = ownerids.find(id => id == msg.author.id);
                if (ownerid === undefined) {
                    msg.channel.send('Owner only!').catch(() => { })
                    return
                }
                else {
                    if (args[1] === undefined && args[2] === undefined && args[3] === undefined) {
                        msg.channel.send('Where are the arguments?!').catch(() => { })
                        return;
                    }
                    else if (args[2] === undefined && args[3] === undefined) {
                        msg.channel.send('What is the status type?! (Available: **PLAYING**, **LISTENING**, **WATCHING**, **STREAMING**, **COMPETING**)').catch(() => { })
                        return;
                    }
                    else if (args[3] === undefined) {
                        msg.channel.send('What is the status message?!').catch(() => { })
                        return;
                    }
                    if (args[1] === 'false' || args[1] === 'true') {
                        if (args[2] === 'PLAYING' || args[2] === 'LISTENING' || args[2] === 'WATCHING' || args[2] === 'STREAMING' || args[2] === 'COMPETING') {
                            var saidMessage = args.join(' ').substring(args[0].length + args[1].length + args[2].length + 3)
                            msg.channel.sendTyping().catch(() => { })
                            infoPost(`Status changed to ${args[2].toLowerCase() + ' ' + ((args[2] === "COMPETING" && 'in ') || (args[2] === "LISTENING" && 'to ') || '') + saidMessage}`)
                            bot.user.setPresence({
                                status: 'online',
                                activities: [
                                    {
                                        name: saidMessage + ` | ${testing ? '2' : ''}p:help`,
                                        type: args[2],
                                        url: 'https://www.youtube.com/watch?v=LDQO0ALm0gE'
                                    }
                                ],
                            });
                            statusChanges = args[1];
                            msg.channel.send({
                                content: 'Poopy\'s status set to: **' + saidMessage + ' (' + args[2] + ')**',
                                allowedMentions: {
                                    parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            }).catch(() => { })
                            msg.channel.sendTyping().catch(() => { })
                        }
                        else {
                            msg.channel.send({
                                content: 'Invalid status type: **' + args[2] + '** (Available: **PLAYING**, **LISTENING**, **WATCHING**, **STREAMING**, **COMPETING**)',
                                allowedMentions: {
                                    parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            }).catch(() => { })
                            msg.channel.sendTyping().catch(() => { })
                        }
                    }
                    else {
                        msg.channel.send('Specify a valid value! (**false** or **true**)').catch(() => { })
                        return;
                    }
                };
            },
            help: {
                "name": "setstatus/ss <changes? (false or true)> <type (STREAMING, WATCHING, PLAYING, LISTENING or COMPETING)> <statusMessage>",
                "value": "Allows Poopy to have a custom status.\nExample usage: p:setstatus false STREAMING you, idiot."
            },
            cooldown: 2500,
            type: "Owner"
        },

        {
            name: ["chew"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
                var chewings = []
                var chewnumber = Math.floor(Math.random() * 11) + 20
                for (var i = 0; i < chewnumber; i++) {
                    chewings.push({
                        maskpos: { x: Math.floor(Math.random() * 101) / 100, y: Math.floor(Math.random() * 101) / 100 },
                        masksize: { x: Math.floor(Math.random() * 9) + 2, y: Math.floor(Math.random() * 9) + 2 },
                        maskangle: Math.floor(Math.random() * 361) - 180,
                        chewoffset: { x: Math.floor(Math.random() * 61) - 30, y: Math.floor(Math.random() * 61) - 30 },
                        repetitions: Math.floor(Math.random() * 9) + 1,
                        chew: async (frame, maskpos, masksize, maskangle, chewoffset) => {
                            var patchmask = await Jimp.read(`templates/chewmask.png`)
                            var black = await Jimp.read(`templates/black.png`)
                            frame2 = frame.clone()
                            patchmask.resize(frame2.bitmap.width / masksize.x, frame2.bitmap.height / masksize.y)
                            patchmask.rotate(maskangle)
                            black.resize(frame2.bitmap.width, frame2.bitmap.height)
                            black.composite(patchmask, black.bitmap.width * maskpos.x - patchmask.bitmap.width / 2, black.bitmap.height * maskpos.y - patchmask.bitmap.height / 2)
                            frame2.mask(black, 0, 0)
                            frame.composite(frame2, chewoffset.x * (frame.bitmap.width / 250), chewoffset.y * (frame.bitmap.height / 250))
                        }
                    })
                }
                var fileinfo = await validateFile(currenturl).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })

                if (!fileinfo) return
                var type = fileinfo.type

                if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                    var currentcount = filecount
                    filecount++
                    var filepath = `temp/file${currentcount}`
                    fs.mkdirSync(`${filepath}`)
                    var frame = await Jimp.read(currenturl)
                    for (var i = 0; i < chewings.length; i++) {
                        var origoffset = chewings[i].chewoffset
                        var offset = chewings[i].chewoffset
                        for (var j = 0; j < chewings[i].repetitions; j++) {
                            await chewings[i].chew(frame, chewings[i].maskpos, chewings[i].masksize, chewings[i].maskangle, offset)
                            offset.x += (origoffset.x * (frame.bitmap.width / 250)) * chewings[i].repetitions
                            offset.y += (origoffset.y * (frame.bitmap.height / 250)) * chewings[i].repetitions
                        }
                    }
                    await frame.writeAsync(`${filepath}/output.png`);
                    await sendFile(msg, filepath, `output.png`)
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "chew <image>",
                "value": "Literally chews the image."
            },
            cooldown: 2500,
            type: "Effects"
        },

        {
            name: ["srlogo", "sr", "soupremastered"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
                var fileinfo = await validateFile(currenturl).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })

                if (!fileinfo) return
                var type = fileinfo.type

                if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                    var filepath = await downloadFile(currenturl, `input.png`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.png`
                    var width = fileinfo.info.width

                    await execPromise(`ffmpeg -i ${filepath}/${filename} -i templates/soupremastered.png -filter_complex "[1:v]scale=${width}/3:-1[soup];[0:v][soup]overlay=x=0:y=H-h:format=auto[out]" -map "[out]" -preset ${findpreset(args)} ${filepath}/output.png`)
                    await sendFile(msg, filepath, `output.png`)
                } else if (type.mime.startsWith('video')) {
                    var filepath = await downloadFile(currenturl, `input.mp4`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp4`
                    var width = fileinfo.info.width

                    await execPromise(`ffmpeg -i ${filepath}/${filename} -i templates/soupremastered.png -map 0:a? -filter_complex "[1:v]scale=${width}/3:-1[soup];[0:v][soup]overlay=x=0:y=H-h:format=auto,scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ${findpreset(args)} -c:v libx264 -pix_fmt yuv420p ${filepath}/output.mp4`)
                    await sendFile(msg, filepath, `output.mp4`)
                } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                    var filepath = await downloadFile(currenturl, `input.gif`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.gif`
                    var width = fileinfo.info.width

                    await execPromise(`ffmpeg -i ${filepath}/${filename} -i templates/soupremastered.png -filter_complex "[1:v]scale=${width}/3:-1[soup];[0:v][soup]overlay=x=0:y=H-h:format=auto[oout];[oout]split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ${findpreset(args)} -gifflags -offsetting ${filepath}/output.gif`)
                    await sendFile(msg, filepath, `output.gif`)
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "srlogo/sr/soupremastered <file>",
                "value": "Applies the Soup Remastered Logo to the file."
            },
            cooldown: 2500,
            type: "Inside Joke"
        },

        {
            name: ["allaboutme", "mynameis"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var overlays = [
                    [82, 55, 68, 17],
                    [205, 56, 33, 17],
                    [87, 78, 65, 14],
                    [203, 78, 15, 12],
                    [264, 78, 14, 12],
                    [213, 120, 95, 13],
                    [14, 114, 150, 146],
                    [181, 169, 154, 95],
                    [48, 296, 54, 12],
                    [183, 370, 56, 56],
                    [18, 353, 137, 81],
                    [251, 289, 86, 68]
                ]
                var i = 1
                var osplit = overlays.map(() => `[in${i++}]`)
                i = 1
                var oover = overlays.map(xywh => `[in${i}]scale=${xywh[2]}:${xywh[3]}[ou${i}];[${i !== 1 ? `white${i - 1}` : 'w'}][ou${i}]overlay=x=${xywh[0]}:y=${xywh[1]}:format=auto[${i === overlays.length ? `whitest` : `white${i++}`}]`)
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
                var fileinfo = await validateFile(currenturl).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })

                if (!fileinfo) return
                var type = fileinfo.type

                if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                    var filepath = await downloadFile(currenturl, `input.png`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.png`

                    await execPromise(`ffmpeg -i ${filepath}/${filename} -i templates/allaboutme.png -i templates/white.png -filter_complex "[2:v][1:v]scale2ref[w][allabout];[0:v]split=${overlays.length}${osplit.join('')};${oover.join(';')};[whitest][allabout]overlay=x=0:y=0:format=auto[out]" -map "[out]" -vframes 1 -aspect 350:453 -preset ${findpreset(args)} ${filepath}/output.png`)
                    await sendFile(msg, filepath, `output.png`)
                } else if (type.mime.startsWith('video')) {
                    var filepath = await downloadFile(currenturl, `input.mp4`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp4`
                    var duration = fileinfo.info.duration

                    await execPromise(`ffmpeg -i ${filepath}/${filename} -i templates/allaboutme.png -i templates/white.png -map 0:a? -filter_complex "[2:v][1:v]scale2ref[w][allabout];[0:v]split=${overlays.length}${osplit.join('')};${oover.join(';')};[whitest][allabout]overlay=x=0:y=0:format=auto,scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -t ${duration} -aspect 350:453  -preset ${findpreset(args)} -c:v libx264 -pix_fmt yuv420p ${filepath}/output.mp4`)
                    await sendFile(msg, filepath, `output.mp4`)
                } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                    var filepath = await downloadFile(currenturl, `input.gif`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.gif`
                    var duration = fileinfo.info.duration

                    await execPromise(`ffmpeg -i ${filepath}/${filename} -i templates/allaboutme.png -i templates/white.png -filter_complex "[2:v][1:v]scale2ref[w][allabout];[0:v]split=${overlays.length}${osplit.join('')};${oover.join(';')};[whitest][allabout]overlay=x=0:y=0:format=auto,split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -t ${duration} -aspect 350:453 -preset ${findpreset(args)} -gifflags -offsetting ${filepath}/output.gif`)
                    await sendFile(msg, filepath, `output.gif`)
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "allaboutme/mynameis <file>",
                "value": "there is no jojo reference"
            },
            cooldown: 2500,
            type: "Memes"
        },

        {
            name: ["pillow", "bodypillow"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
                var fileinfo = await validateFile(currenturl).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })

                if (!fileinfo) return
                var type = fileinfo.type

                if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                    var filepath = await downloadFile(currenturl, `input.png`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.png`
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -i templates/pillow.png -i templates/pillowmask.png -i templates/white.png -filter_complex "[1:v][0:v]scale2ref[pillow][image];[2:v][image]scale2ref[pillowmask][iimage];[3:v][iimage]scale2ref=w=iw*1.25:h=ih+(ow-iw)[white][iiimage];[iiimage][pillowmask]overlay=x=0:y=0:format=auto[imagemask];[imagemask][pillow]overlay=x=0:y=0:format=auto[pillow];[white][pillow]overlay=x=(W-w)/2:y=(H-h)/2:format=auto[out]" -map "[out]" -preset ${findpreset(args)} ${filepath}/output.png`)
                    await sendFile(msg, filepath, `output.png`)
                } else if (type.mime.startsWith('video')) {
                    var filepath = await downloadFile(currenturl, `input.mp4`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp4`
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -i templates/pillow.png -i templates/pillowmask.png -i templates/white.png -map 0:a? -filter_complex "[1:v][0:v]scale2ref[pillow][image];[2:v][image]scale2ref[pillowmask][iimage];[3:v][iimage]scale2ref=w=iw*1.25:h=ih+(ow-iw)[white][iiimage];[iiimage][pillowmask]overlay=x=0:y=0:format=auto[imagemask];[imagemask][pillow]overlay=x=0:y=0:format=auto[pillow];[white][pillow]overlay=x=(W-w)/2:y=(H-h)/2:format=auto[oout];[oout]scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ${findpreset(args)} -c:v libx264 -pix_fmt yuv420p ${filepath}/output.mp4`)
                    await sendFile(msg, filepath, `output.mp4`)
                } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                    var filepath = await downloadFile(currenturl, `input.gif`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.gif`
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -i templates/pillow.png -i templates/pillowmask.png -i templates/white.png -filter_complex "[1:v][0:v]scale2ref[pillow][image];[2:v][image]scale2ref[pillowmask][iimage];[3:v][iimage]scale2ref=w=iw*1.25:h=ih+(ow-iw)[white][iiimage];[iiimage][pillowmask]overlay=x=0:y=0:format=auto[imagemask];[imagemask][pillow]overlay=x=0:y=0:format=auto[pillow];[white][pillow]overlay=x=(W-w)/2:y=(H-h)/2:format=auto[oout];[oout]split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ${findpreset(args)} -gifflags -offsetting ${filepath}/output.gif`)
                    await sendFile(msg, filepath, `output.gif`)
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "pillow/bodypillow <file>",
                "value": "Creates a pillow with the file."
            },
            cooldown: 2500,
            type: "Memes"
        },

        {
            name: ["tshirt", "shirt"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
                var fileinfo = await validateFile(currenturl).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })

                if (!fileinfo) return
                var type = fileinfo.type

                if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                    var filepath = await downloadFile(currenturl, `input.png`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.png`
                    var width = fileinfo.info.width
                    var height = fileinfo.info.height

                    var squareS = { value: ((height === width) && width) || ((height > width) && height) || width, constraint: ((height === width) && 'both') || ((height > width) && 'height') || 'width' }

                    await execPromise(`ffmpeg -i ${filepath}/${filename} -i templates/tshirt.png -i templates/tshirtmask.png -i templates/white.png -filter_complex "${squareS.constraint !== 'both' ? `[0:v]crop=x=${squareS.constraint === 'height' ? 0 : 'iw/2-ih/2'}:y=${squareS.constraint === 'width' ? 0 : 'ih/2-iw/2'}:w=${squareS.constraint === 'width' ? 'ih' : 'iw'}:h=${squareS.constraint === 'height' ? 'iw' : 'ih'}[cframe];` : ''}[${squareS.constraint !== 'both' ? 'cframe' : '0:v'}][1:v]scale2ref[image][shirt];[3:v][shirt]scale2ref=w=iw*1.25:h=ih+(ow-iw)[white][tshirt];[image][2:v]overlay=x=0:y=0:format=auto[imagemask];[imagemask][tshirt]overlay=x=0:y=0:format=auto[imagetshirt];[white][imagetshirt]overlay=x=(W-w)/2:y=(H-h)/2:format=auto[out]" -map "[out]" -preset ${findpreset(args)} ${filepath}/output.png`)
                    await sendFile(msg, filepath, `output.png`)
                } else if (type.mime.startsWith('video')) {
                    var filepath = await downloadFile(currenturl, `input.mp4`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp4`
                    var width = fileinfo.info.width
                    var height = fileinfo.info.height

                    var squareS = { value: ((height === width) && width) || ((height > width) && height) || width, constraint: ((height === width) && 'both') || ((height > width) && 'height') || 'width' }

                    await execPromise(`ffmpeg -i ${filepath}/${filename} -i templates/tshirt.png -i templates/tshirtmask.png -i templates/white.png -map 0:a? -filter_complex "${squareS.constraint !== 'both' ? `[0:v]crop=x=${squareS.constraint === 'height' ? 0 : 'iw/2-ih/2'}:y=${squareS.constraint === 'width' ? 0 : 'ih/2-iw/2'}:w=${squareS.constraint === 'width' ? 'ih' : 'iw'}:h=${squareS.constraint === 'height' ? 'iw' : 'ih'}[cframe];` : ''}[${squareS.constraint !== 'both' ? 'cframe' : '0:v'}][1:v]scale2ref[image][shirt];[3:v][shirt]scale2ref=w=iw*1.25:h=ih+(ow-iw)[white][tshirt];[image][2:v]overlay=x=0:y=0:format=auto[imagemask];[imagemask][tshirt]overlay=x=0:y=0:format=auto[imagetshirt];[white][imagetshirt]overlay=x=(W-w)/2:y=(H-h)/2:format=auto[oout];[oout]scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ${findpreset(args)} -c:v libx264 -pix_fmt yuv420p ${filepath}/output.mp4`)
                    await sendFile(msg, filepath, `output.mp4`)
                } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                    var filepath = await downloadFile(currenturl, `input.gif`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.gif`
                    var width = fileinfo.info.width
                    var height = fileinfo.info.height

                    var squareS = { value: ((height === width) && width) || ((height > width) && height) || width, constraint: ((height === width) && 'both') || ((height > width) && 'height') || 'width' }

                    await execPromise(`ffmpeg -i ${filepath}/${filename} -i templates/tshirt.png -i templates/tshirtmask.png -i templates/white.png -filter_complex "${squareS.constraint !== 'both' ? `[0:v]crop=x=${squareS.constraint === 'height' ? 0 : 'iw/2-ih/2'}:y=${squareS.constraint === 'width' ? 0 : 'ih/2-iw/2'}:w=${squareS.constraint === 'width' ? 'ih' : 'iw'}:h=${squareS.constraint === 'height' ? 'iw' : 'ih'}[cframe];` : ''}[${squareS.constraint !== 'both' ? 'cframe' : '0:v'}][1:v]scale2ref[image][shirt];[3:v][shirt]scale2ref=w=iw*1.25:h=ih+(ow-iw)[white][tshirt];[image][2:v]overlay=x=0:y=0:format=auto[imagemask];[imagemask][tshirt]overlay=x=0:y=0:format=auto[imagetshirt];[white][imagetshirt]overlay=x=(W-w)/2:y=(H-h)/2:format=auto[oout];[oout]split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ${findpreset(args)} -gifflags -offsetting ${filepath}/output.gif`)
                    await sendFile(msg, filepath, `output.gif`)
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "tshirt/shirt <file>",
                "value": "Creates a T-Shirt the file."
            },
            cooldown: 2500,
            type: "Memes"
        },

        {
            name: ["reverse"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
                var fileinfo = await validateFile(currenturl).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })

                if (!fileinfo) return
                var type = fileinfo.type

                if (type.mime.startsWith('video')) {
                    var filepath = await downloadFile(currenturl, `input.mp4`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp4`

                    var audio = fileinfo.info.audio
                    if (audio) {
                        await execPromise(`ffmpeg -i ${filepath}/${filename} -filter_complex "[0:v]reverse,scale=ceil(iw/2)*2:ceil(ih/2)*2[v];[0:a]areverse[a]" -map "[v]" -map "[a]" -preset ${findpreset(args)} -c:v libx264 -pix_fmt yuv420p ${filepath}/output.mp4`)
                        await sendFile(msg, filepath, `output.mp4`)
                    } else {
                        await execPromise(`ffmpeg -i ${filepath}/${filename} -filter_complex "[0:v]reverse,scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ${findpreset(args)} -c:v libx264 -pix_fmt yuv420p ${filepath}/output.mp4`)
                        await sendFile(msg, filepath, `output.mp4`)
                    }
                } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                    var filepath = await downloadFile(currenturl, `input.gif`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.gif`
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -filter_complex "[0:v]reverse,split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ${findpreset(args)} -gifflags -offsetting ${filepath}/output.gif`)
                    await sendFile(msg, filepath, `output.gif`)
                } else if (type.mime.startsWith('audio')) {
                    var filepath = await downloadFile(currenturl, `input.mp3`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp3`
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -filter_complex "[0:a]areverse[out]" -map "[out]" -preset ${findpreset(args)} ${filepath}/output.mp3`)
                    await sendFile(msg, filepath, `output.mp3`)
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "reverse <file>",
                "value": "Reverses the file."
            },
            cooldown: 2500,
            type: "Effects"
        },

        {
            name: ["melt", "trippy"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var decay = 95
                var decayindex = args.indexOf('-decay')
                if (decayindex > -1) {
                    decay = isNaN(Number(args[decayindex + 1])) ? 95 : Number(args[decayindex + 1]) <= 0 ? 0 : Number(args[decayindex + 1]) >= 100 ? 100 : Number(args[decayindex + 1]) ?? 95
                }
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
                var fileinfo = await validateFile(currenturl).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })

                if (!fileinfo) return
                var type = fileinfo.type

                if (type.mime.startsWith('video')) {
                    var filepath = await downloadFile(currenturl, `input.mp4`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp4`
                    var iduration = Number(fileinfo.info.duration.includes('N/A') ? '0' : fileinfo.info.duration)

                    await execPromise(args.indexOf('-loop') > -1 ? `ffmpeg -stream_loop 1 -i ${filepath}/${filename} -map 0:a? -filter_complex "[0:v]lagfun=decay=${decay / 100},scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ${findpreset(args)} -c:v libx264 -pix_fmt yuv420p -ss ${iduration} ${filepath}/output.mp4` : `ffmpeg -i ${filepath}/${filename} -map 0:a? -filter_complex "[0:v]lagfun=decay=${decay / 100},scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ${findpreset(args)} -c:v libx264 -pix_fmt yuv420p ${filepath}/output.mp4`)
                    await sendFile(msg, filepath, `output.mp4`)
                } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                    var filepath = await downloadFile(currenturl, `input.gif`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.gif`
                    var iduration = Number(fileinfo.info.duration.includes('N/A') ? '0' : fileinfo.info.duration)

                    await execPromise(args.indexOf('-loop') > -1 ? `ffmpeg -stream_loop 1 -i ${filepath}/${filename} -i templates/black.png -filter_complex "[1:v][0:v]scale2ref[black][gif];[black]split[blackw][blackn];[gif]hue=b=10[white];[blackw][white]overlay=x=0:y=0:format=auto,lagfun=decay=${decay / 100}[meltalpha];[blackn][0:v]overlay=x=0:y=0:format=auto,lagfun=decay=${decay / 100}[melt];[melt][meltalpha]alphamerge,split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ${findpreset(args)} -gifflags -offsetting -ss ${iduration} ${filepath}/output.gif` : `ffmpeg -i ${filepath}/${filename} -i templates/black.png -filter_complex "[1:v][0:v]scale2ref[black][gif];[black]split[blackw][blackn];[gif]hue=b=10[white];[blackw][white]overlay=x=0:y=0:format=auto,lagfun=decay=${decay / 100}[meltalpha];[blackn][0:v]overlay=x=0:y=0:format=auto,lagfun=decay=${decay / 100}[melt];[melt][meltalpha]alphamerge,split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ${findpreset(args)} -gifflags -offsetting ${filepath}/output.gif`)
                    await sendFile(msg, filepath, `output.gif`)
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "melt/trippy <file> [-decay <percentage>] [-loop]",
                "value": "Adds a trippy melting effect to the file. Default decay is 95."
            },
            cooldown: 2500,
            type: "Effects"
        },

        {
            name: ["ytp"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var filterslist = {
                    video: [
                        `[v]reverse[2v]`,
                        `[v]negate[2v]`,
                        `[v]negate,reverse[2v]`,
                        `[v]fps=fps=vfps*2,setpts=0.5*PTS[2v]`,
                        `[v]fps=fps=vfps/2,setpts=2*PTS[2v]`,
                        `[v]hue=s=0[2v]`,
                        `[v]hue=s=0,negate[2v]`,
                        `[v]hue=s=-1[2v]`,
                        `[v]hue=s=10[2v]`,
                        `[v]hue=h=180[2v]`,
                        `[v]hue=s=0,curves=r='0/0 1/rrgb':g='0/0 1/rrgb':b='0/0 1/rrgb'[2v]`,
                        `[v]hflip[2v]`,
                        `[v]vflip[2v]`,
                        `[v]rotate=180*PI/180[2v]`,
                        `[v]split[vstack][vstack2];[vstack][vstack2]vstack,split[vvstack][vvstack2];[vvstack][vvstack2]hstack,scale=iw/2:ih/2[2v]`,
                        `[v]split[left][right];[left]hflip,hflip,crop=iw/2:ih:0:0[leftside];[right]hflip,crop=iw/2:ih:iw/2:0[rightside];[leftside][rightside]hstack[2v]`,
                        `[v]split[left][right];[left]hflip,crop=iw/2:ih:0:0[leftside];[right]hflip,hflip,crop=iw/2:ih:iw/2:0[rightside];[leftside][rightside]hstack[2v]`,
                        `[v]split[top][bottom];[top]vflip,vflip,crop=iw:ih/2:0:0[topside];[bottom]vflip,crop=iw:ih/2:0:ih/2[bottomside];[topside][bottomside]vstack[2v]`,
                        `[v]split[top][bottom];[top]vflip,crop=iw:ih/2:0:0[topside];[bottom]vflip,vflip,crop=iw:ih/2:0:ih/2[bottomside];[topside][bottomside]vstack[2v]`
                    ],

                    audio: [
                        `[a]areverse[2a]`,
                        `[a]aresample=44100,asetrate=44100/2,aresample=44100,atempo=2[2a]`,
                        `[a]aresample=44100,asetrate=44100*2,aresample=44100,atempo=0.5[2a]`,
                        `[a]atempo=2[2a]`,
                        `[a]atempo=0.5[2a]`,
                        `[a]acrusher=.1:1:64:0:log[2a]`,
                        `[a][1:a]afir=dry=10:wet=10[2a]`,
                        `[a]aecho=1:1:1000:1[2a]`,
                        `[a]aecho=1:1:1000:1,aecho=1:1:1000:1,aecho=1:1:1000:1,aecho=1:1:1000:1,aecho=1:1:1000:1,aecho=1:1:1000:1,aecho=1:1:1000:1,aecho=1:1:1000:1,aecho=1:1:1000:1,aecho=1:1:1000:1,aecho=1:1:1000:1,aecho=1:1:1000:1,aecho=1:1:1000:1,aecho=1:1:1000:1,aecho=1:1:1000:1[2a]`,
                        `[a]aecho=1:1:1:1,aecho=1:1:1:1,aecho=1:1:1:1,aecho=1:1:1:1,aecho=1:1:1:1,aecho=1:1:1:1,aecho=1:1:1:1,aecho=1:1:1:1,aecho=1:1:1:1,aecho=1:1:1:1,aecho=1:1:1:1,aecho=1:1:1:1,aecho=1:1:1:1,aecho=1:1:1:1,aecho=1:1:1:1[2a]`
                    ],
                }
                var clips = 10
                var clipsindex = args.indexOf('-clips')
                if (clipsindex > -1) {
                    clips = isNaN(Number(args[clipsindex + 1])) ? 10 : Number(args[clipsindex + 1]) <= 1 ? 1 : Number(args[clipsindex + 1]) >= 200 ? 200 : Math.round(Number(args[clipsindex + 1])) || 10
                }
                var repetitions = 1
                var repindex = args.indexOf('-repetitions')
                if (repindex > -1) {
                    repetitions = isNaN(Number(args[repindex + 1])) ? 1 : Number(args[repindex + 1]) <= 1 ? 1 : Number(args[repindex + 1]) >= 10 ? 10 : Math.round(Number(args[repindex + 1])) || 1
                }

                if (clips * repetitions > 250) {
                    msg.channel.send('The number of clips must be smaller or equal to 250.')
                    msg.channel.sendTyping().catch(() => { })
                    return;
                }

                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
                var fileinfo = await validateFile(currenturl).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })

                if (!fileinfo) return
                var type = fileinfo.type

                if (type.mime.startsWith('video')) {
                    var filepath = await downloadFile(currenturl, `input.mp4`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp4`
                    fs.mkdirSync(`${filepath}/clips`)
                    var audio = fileinfo.info.audio

                    if (audio) {
                        var fps = fileinfo.info.fps
                        var duration = Number(fileinfo.info.duration)

                        var clipduration = duration / clips
                        var clipsmade = 0
                        var clipfiles = []

                        var clipsmessage = await msg.channel.send(`Processing clip 0 out of ${clips * repetitions}.`).catch(() => { })

                        for (var i = 1; i <= (clips * repetitions); i++) {
                            clipfiles.push(`file '${i}.mp4'`)
                        }

                        fs.writeFileSync(`${filepath}/clips/list.txt`, args.indexOf('-norandomize') > -1 ? clipfiles.join('\n') : clipfiles.sort(() => {
                            return Math.random() - 0.5
                        }).join('\n'))

                        var clipeditinterval = setInterval(() => {
                            clipsmessage.edit(`Processing clip ${clipsmade + 1} out of ${clips * repetitions}.`).catch(() => { })
                        }, 5000)

                        for (var h = 0; h < repetitions; h++) {
                            for (var i = 0; i < clips; i++) {
                                var vid = 0
                                var audio = 0
                                var vidfilters = []
                                var audiofilters = []

                                for (var j = 0; j < Math.floor(Math.random() * 4); j++) {
                                    var vidfilter = filterslist.video[Math.floor(Math.random() * filterslist.video.length)]
                                        .replace(/vfps/g, fps)
                                        .replace(/rrgb/g, Math.floor(Math.random() * 256) / 255)
                                        .replace(/\[v\]/g, vid ? `[v${vid}]` : '[0:v]')
                                        .replace(/\[2v\]/g, `[v${vid + 1}]`)

                                    if (vidfilter.includes('[v]fps=fps=vfps*2,setpts=0.5*PTS[2v]'
                                        .replace(/vfps/g, fps)
                                        .replace(/rrgb/g, Math.floor(Math.random() * 256) / 255)
                                        .replace(/\[v\]/g, vid ? `[v${vid}]` : '[0:v]')
                                        .replace(/\[2v\]/g, `[v${vid + 1}]`))) {
                                        var audiofilter = '[a]atempo=2[2a]'
                                            .replace(/\[a\]/g, audio ? `[a${audio}]` : '[0:a]')
                                            .replace(/\[2a\]/g, `[a${audio + 1}]`)

                                        audiofilters.push(audiofilter)
                                        audio++
                                    }

                                    if (vidfilter.includes('[v]fps=fps=vfps/2,setpts=2*PTS[2v]'
                                        .replace(/vfps/g, fps)
                                        .replace(/rrgb/g, Math.floor(Math.random() * 256) / 255)
                                        .replace(/\[v\]/g, vid ? `[v${vid}]` : '[0:v]')
                                        .replace(/\[2v\]/g, `[v${vid + 1}]`))) {
                                        var audiofilter = '[a]atempo=0.5[2a]'
                                            .replace(/\[a\]/g, audio ? `[a${audio}]` : '[0:a]')
                                            .replace(/\[2a\]/g, `[a${audio + 1}]`)

                                        audiofilters.push(audiofilter)
                                        audio++
                                    }

                                    vidfilters.push(vidfilter)
                                    vid += 1
                                }

                                for (var j = 0; j < Math.floor(Math.random() * 4); j++) {
                                    var audiofilter = filterslist.audio[Math.floor(Math.random() * filterslist.audio.length)]
                                        .replace(/\[a\]/g, audio ? `[a${audio}]` : '[0:a]')
                                        .replace(/\[2a\]/g, `[a${audio + 1}]`)

                                    if (audiofilter.includes('[a]atempo=2[2a]'
                                        .replace(/\[a\]/g, audio ? `[a${audio}]` : '[0:a]')
                                        .replace(/\[2a\]/g, `[a${audio + 1}]`))) {
                                        var vidfilter = '[v]fps=fps=vfps*2,setpts=0.5*PTS[2v]'
                                            .replace(/vfps/g, fps)
                                            .replace(/rrgb/g, Math.floor(Math.random() * 256) / 255)
                                            .replace(/\[v\]/g, vid ? `[v${vid}]` : '[0:v]')
                                            .replace(/\[2v\]/g, `[v${vid + 1}]`)

                                        vidfilters.push(vidfilter)
                                        vid++
                                    }

                                    if (audiofilter.includes('[a]atempo=0.5[2a]'
                                        .replace(/\[a\]/g, audio ? `[a${audio}]` : '[0:a]')
                                        .replace(/\[2a\]/g, `[a${audio + 1}]`))) {
                                        var vidfilter = '[v]fps=fps=vfps/2,setpts=2*PTS[2v]'
                                            .replace(/vfps/g, fps)
                                            .replace(/rrgb/g, Math.floor(Math.random() * 256) / 255)
                                            .replace(/\[v\]/g, vid ? `[v${vid}]` : '[0:v]')
                                            .replace(/\[2v\]/g, `[v${vid + 1}]`)

                                        vidfilters.push(vidfilter)
                                        vid++
                                    }

                                    audiofilters.push(audiofilter)
                                    audio += 1
                                }

                                var vidfilter = vidfilters.join(';')
                                var audiofilter = audiofilters.join(';')

                                await execPromise(`ffmpeg -i ${filepath}/${filename} ${audiofilter.includes('afir') ? '-i templates/church.mp3 ' : ''}-t ${clipduration} -ss ${clipduration * i} -filter_complex "${vidfilter}${vidfilter ? `;[v${vid}]` : '[0:v]'}scale=ceil(iw/2)*2:ceil(ih/2)*2[out]${audiofilter ? `;${audiofilter}` : ''}" -map "[out]" -map ${audiofilter ? `"[a${audio}]"` : '0:a'} -preset ${findpreset(args)} -c:v libx264 -pix_fmt yuv420p ${filepath}/clips/${clipsmade + 1}.mp4`)

                                clipsmade++
                            }
                        }

                        clearInterval(clipeditinterval)
                        clipsmessage.edit(`Concatenating clips.`).catch(() => { })

                        await execPromise(`ffmpeg -f concat -i ${filepath}/clips/list.txt -preset ${findpreset(args)} -c:v libx264 -pix_fmt yuv420p ${filepath}/output.mp4`)
                        clipsmessage.delete().catch(() => { })
                        await sendFile(msg, filepath, `output.mp4`)
                    } else {
                        var fps = fileinfo.info.fps
                        var duration = Number(fileinfo.info.duration)

                        var clipduration = duration / clips
                        var clipsmade = 0
                        var clipfiles = []

                        var clipsmessage = await msg.channel.send(`Processing clip 0 out of ${clips * repetitions}.`).catch(() => { })

                        for (var i = 1; i <= (clips * repetitions); i++) {
                            clipfiles.push(`file '${i}.mp4'`)
                        }

                        fs.writeFileSync(`${filepath}/clips/list.txt`, args.indexOf('-norandomize') > -1 ? clipfiles.join('\n') : clipfiles.sort(() => {
                            return Math.random() - 0.5
                        }).join('\n'))

                        var clipeditinterval = setInterval(() => {
                            clipsmessage.edit(`Processing clip ${clipsmade + 1} out of ${clips * repetitions}.`).catch(() => { })
                        }, 5000)

                        for (var h = 0; h < repetitions; h++) {
                            for (var i = 0; i < clips; i++) {
                                var vid = 0
                                var vidfilters = []

                                for (var j = 0; j < Math.floor(Math.random() * 4); j++) {
                                    var vidfilter = filterslist.video[Math.floor(Math.random() * filterslist.video.length)]
                                        .replace(/vfps/g, fps)
                                        .replace(/rrgb/g, Math.floor(Math.random() * 256) / 255)
                                        .replace(/\[v\]/g, vid ? `[v${vid}]` : '[0:v]')
                                        .replace(/\[2v\]/g, `[v${vid + 1}]`)

                                    vidfilters.push(vidfilter)
                                    vid += 1
                                }

                                var vidfilter = vidfilters.join(';')

                                await execPromise(`ffmpeg -i ${filepath}/${filename} -t ${clipduration} -ss ${clipduration * i} -filter_complex "${vidfilter}${vidfilter ? `;[v${vid}]` : '[0:v]'}scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ${findpreset(args)} -c:v libx264 -pix_fmt yuv420p ${filepath}/clips/${clipsmade + 1}.mp4`)

                                clipsmade++
                            }
                        }

                        clearInterval(clipeditinterval)
                        clipsmessage.edit(`Concatenating clips.`).catch(() => { })

                        await execPromise(`ffmpeg -f concat -i ${filepath}/clips/list.txt -preset ${findpreset(args)} -c:v libx264 -pix_fmt yuv420p ${filepath}/output.mp4`)
                        clipsmessage.delete().catch(() => { })
                        await sendFile(msg, filepath, `output.mp4`)
                    }
                } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                    var filepath = await downloadFile(currenturl, `input.gif`)
                    var filename = `input.gif`
                    fs.mkdirSync(`${filepath}/clips`)

                    var fps = fileinfo.info.fps
                    var duration = Number(fileinfo.info.duration)

                    var clipduration = duration / clips
                    var clipsmade = 0
                    var clipfiles = []

                    var clipsmessage = await msg.channel.send(`Processing clip 0 out of ${clips * repetitions}.`).catch(() => { })

                    for (var i = 1; i <= (clips * repetitions); i++) {
                        clipfiles.push(`file '${i}.gif'`)
                    }

                    fs.writeFileSync(`${filepath}/clips/list.txt`, args.indexOf('-norandomize') > -1 ? clipfiles.join('\n') : clipfiles.sort(() => {
                        return Math.random() - 0.5
                    }).join('\n'))

                    var clipeditinterval = setInterval(() => {
                        clipsmessage.edit(`Processing clip ${clipsmade + 1} out of ${clips * repetitions}.`).catch(() => { })
                    }, 5000)

                    for (var h = 0; h < repetitions; h++) {
                        for (var i = 0; i < clips; i++) {
                            var vid = 0
                            var vidfilters = []

                            for (var j = 0; j < Math.floor(Math.random() * 4); j++) {
                                var vidfilter = filterslist.video[Math.floor(Math.random() * filterslist.video.length)]
                                    .replace(/vfps/g, fps)
                                    .replace(/rrgb/g, Math.floor(Math.random() * 256) / 255)
                                    .replace(/\[v\]/g, vid ? `[v${vid}]` : '[0:v]')
                                    .replace(/\[2v\]/g, `[v${vid + 1}]`)

                                vidfilters.push(vidfilter)
                                vid += 1
                            }

                            var vidfilter = vidfilters.join(';')

                            await execPromise(`ffmpeg -i ${filepath}/${filename} -t ${clipduration} -ss ${clipduration * i} -filter_complex "${vidfilter}${vidfilter ? `;[v${vid}]` : '[0:v]'}split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ${findpreset(args)} -gifflags -offsetting ${filepath}/clips/${clipsmade + 1}.gif`)

                            clipsmade++
                        }
                    }

                    clearInterval(clipeditinterval)
                    clipsmessage.edit(`Concatenating clips.`).catch(() => { })

                    await execPromise(`ffmpeg -f concat -i ${filepath}/clips/list.txt -filter_complex "[0:v]split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ${findpreset(args)} -gifflags -offsetting ${filepath}/output.gif`)
                    clipsmessage.delete().catch(() => { })
                    await sendFile(msg, filepath, `output.gif`)
                } else if (type.mime.startsWith('audio')) {
                    var filepath = await downloadFile(currenturl, `input.mp3`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp3`
                    fs.mkdirSync(`${filepath}/clips`)
                    var duration = Number(fileinfo.info.duration)

                    var clipduration = duration / clips
                    var clipsmade = 0
                    var clipfiles = []

                    var clipsmessage = await msg.channel.send(`Processing clip 0 out of ${clips * repetitions}.`).catch(() => { })

                    for (var i = 1; i <= (clips * repetitions); i++) {
                        clipfiles.push(`file '${i}.mp3'`)
                    }

                    fs.writeFileSync(`${filepath}/clips/list.txt`, args.indexOf('-norandomize') > -1 ? clipfiles.join('\n') : clipfiles.sort(() => {
                        return Math.random() - 0.5
                    }).join('\n'))

                    var clipeditinterval = setInterval(() => {
                        clipsmessage.edit(`Processing clip ${clipsmade + 1} out of ${clips * repetitions}.`).catch(() => { })
                    }, 5000)

                    for (var h = 0; h < repetitions; h++) {
                        for (var i = 0; i < clips; i++) {
                            var audio = 0
                            var audiofilters = []

                            for (var j = 0; j < Math.floor(Math.random() * 4); j++) {
                                var audiofilter = filterslist.audio[Math.floor(Math.random() * filterslist.audio.length)]
                                    .replace(/\[a\]/g, audio ? `[a${audio}]` : '[0:a]')
                                    .replace(/\[2a\]/g, `[a${audio + 1}]`)

                                audiofilters.push(audiofilter)
                                audio += 1
                            }

                            var audiofilter = audiofilters.join(';')

                            await execPromise(`ffmpeg -i ${filepath}/${filename} ${audiofilter.includes('afir') ? '-i templates/church.mp3 ' : ''}-t ${clipduration} -ss ${clipduration * i} ${audiofilter ? `-filter_complex ${audiofilter} -map "[a${audio}]" ` : ''}-preset ${findpreset(args)} ${filepath}/clips/${clipsmade + 1}.mp3`)

                            clipsmade++
                        }
                    }

                    clearInterval(clipeditinterval)
                    clipsmessage.edit(`Concatenating clips.`).catch(() => { })

                    await execPromise(`ffmpeg -f concat -i ${filepath}/clips/list.txt -preset ${findpreset(args)} ${filepath}/output.mp3`)
                    clipsmessage.delete().catch(() => { })
                    await sendFile(msg, filepath, `output.mp3`)
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "ytp <file> [-clips <number (max 200)>] [-repetitions <number (max 10)>] [-norandomize]",
                "value": "Turns the file into a YTP. Default clips is 10 and repetitions is 1."
            },
            cooldown: 2500,
            type: "Effects"
        },

        {
            name: ["boomerang"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
                var fileinfo = await validateFile(currenturl).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })

                if (!fileinfo) return
                var type = fileinfo.type

                if (type.mime.startsWith('video')) {
                    var filepath = await downloadFile(currenturl, `input.mp4`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp4`
                    var audio = fileinfo.info.audio

                    if (audio) {
                        await execPromise(`ffmpeg -i ${filepath}/${filename} -filter_complex "[0:v]reverse,scale=ceil(iw/2)*2:ceil(ih/2)*2[v];[0:a]areverse[a];[0:v][0:a][v][a]concat=n=2:v=1:a=1:unsafe=1[out]" -map "[out]" -preset ${findpreset(args)} -c:v libx264 -pix_fmt yuv420p ${filepath}/output.mp4`)
                        await sendFile(msg, filepath, `output.mp4`)
                    } else {
                        await execPromise(`ffmpeg -i ${filepath}/${filename} -filter_complex "[0:v]reverse[r];[0:v][r]concat,scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ${findpreset(args)} -c:v libx264 -pix_fmt yuv420p ${filepath}/output.mp4`)
                        await sendFile(msg, filepath, `output.mp4`)
                    }
                } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                    var filepath = await downloadFile(currenturl, `input.gif`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.gif`
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -filter_complex "[0:v]reverse[r];[0:v][r]concat,split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ${findpreset(args)} -gifflags -offsetting ${filepath}/output.gif`)
                    await sendFile(msg, filepath, `output.gif`)
                } else if (type.mime.startsWith('audio')) {
                    var filepath = await downloadFile(currenturl, `input.mp3`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp3`
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -filter_complex "[0:a]areverse[r];[0:a][r]concat=v=0:a=1[out]" -map "[out]" -preset ${findpreset(args)} ${filepath}/output.mp3`)
                    await sendFile(msg, filepath, `output.mp3`)
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "boomerang <file>",
                "value": "Plays the file until the end and reverses it back to the start."
            },
            cooldown: 2500,
            type: "Effects"
        },

        {
            name: ["reverseboomerang", "rboomerang"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
                var fileinfo = await validateFile(currenturl).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })

                if (!fileinfo) return
                var type = fileinfo.type

                if (type.mime.startsWith('video')) {
                    var filepath = await downloadFile(currenturl, `input.mp4`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp4`
                    var audio = fileinfo.info.audio

                    if (audio) {
                        await execPromise(`ffmpeg -i ${filepath}/${filename} -filter_complex "[0:v]reverse,scale=ceil(iw/2)*2:ceil(ih/2)*2[v];[0:a]areverse[a];[v][a][0:v][0:a]concat=n=2:v=1:a=1:unsafe=1[out]" -map "[v]" -map "[a]" -preset ${findpreset(args)} -c:v libx264 -pix_fmt yuv420p ${filepath}/output.mp4`)
                        await sendFile(msg, filepath, `output.mp4`)
                    } else {
                        await execPromise(`ffmpeg -i ${filepath}/${filename} -filter_complex "[0:v]reverse[r];[r][0:v]concat,scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ${findpreset(args)} -c:v libx264 -pix_fmt yuv420p ${filepath}/output.mp4`)
                        await sendFile(msg, filepath, `output.mp4`)
                    }
                } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                    var filepath = await downloadFile(currenturl, `input.gif`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.gif`
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -filter_complex "[0:v]reverse[r];[r][0:v]concat,split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ${findpreset(args)} -gifflags -offsetting ${filepath}/output.gif`)
                    await sendFile(msg, filepath, `output.gif`)
                } else if (type.mime.startsWith('audio')) {
                    var filepath = await downloadFile(currenturl, `input.mp3`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp3`
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -filter_complex "[0:a]areverse[r];[r][0:a]concat=v=0:a=1[out]" -map "[out]" -preset ${findpreset(args)} ${filepath}/output.mp3`)
                    await sendFile(msg, filepath, `output.mp3`)
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "reverseboomerang/rboomerang <file>",
                "value": "Reverses the file back to the start and plays it until the end."
            },
            cooldown: 2500,
            type: "Effects"
        },

        {
            name: ["hsl", "hsv"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[4] === undefined) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl']
                var hue = isNaN(Number(String(args[1]).replace(/,/g, ''))) ? 0 : Number(String(args[1]).replace(/,/g, '')) <= -360 ? -360 : Number(String(args[1]).replace(/,/g, '')) >= 360 ? 360 : Number(String(args[1]).replace(/,/g, '')) || 0
                var saturation = isNaN(Number(String(args[2]).replace(/,/g, ''))) ? 1 : Number(String(args[2]).replace(/,/g, '')) <= -10 ? -10 : Number(String(args[2]).replace(/,/g, '')) >= 10 ? 10 : Number(String(args[2]).replace(/,/g, '')) ?? 1
                var lightness = isNaN(Number(String(args[3]).replace(/,/g, ''))) ? 0 : Number(String(args[3]).replace(/,/g, '')) <= -10 ? -10 : Number(String(args[3]).replace(/,/g, '')) >= 10 ? 10 : Number(String(args[3]).replace(/,/g, '')) || 0
                var fileinfo = await validateFile(currenturl).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })

                if (!fileinfo) return
                var type = fileinfo.type

                if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                    var filepath = await downloadFile(currenturl, `input.png`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.png`
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -filter_complex "[0:v]hue=h=${hue}:s=${saturation}:b=${lightness}[out]" -map "[out]" -preset ${findpreset(args)} ${filepath}/output.png`)
                    await sendFile(msg, filepath, `output.png`)
                } else if (type.mime.startsWith('video')) {
                    var filepath = await downloadFile(currenturl, `input.mp4`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp4`
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -map 0:a? -filter_complex "[0:v]hue=h=${hue}:s=${saturation}:b=${lightness},scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ${findpreset(args)} -c:v libx264 -pix_fmt yuv420p ${filepath}/output.mp4`)
                    await sendFile(msg, filepath, `output.mp4`)
                } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                    var filepath = await downloadFile(currenturl, `input.gif`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.gif`
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -filter_complex "[0:v]hue=h=${hue}:s=${saturation}:b=${lightness},split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ${findpreset(args)} -gifflags -offsetting ${filepath}/output.gif`)
                    await sendFile(msg, filepath, `output.gif`)
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "hsl/hsv [hue (from -360 to 360)] [saturation (from -10 to 10)] [lightness (from -10 to 10)] <file>",
                "value": "Changes the file's hue, saturation and lightness values."
            },
            cooldown: 2500,
            type: "Color"
        },

        {
            name: ["brightcontrast", "brightness", "contrast"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[4] === undefined) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl']
                var brightness = (isNaN(Number(String(args[1]).replace(/,/g, ''))) ? 0 : Number(String(args[1]).replace(/,/g, '')) <= -10 ? -10 : Number(String(args[1]).replace(/,/g, '')) >= 10 ? 10 : Number(String(args[1]).replace(/,/g, '')) || 0) / 10
                var contrast = isNaN(Number(String(args[2]).replace(/,/g, ''))) ? 1 : Number(String(args[2]).replace(/,/g, '')) <= -10 ? -10 : Number(String(args[2]).replace(/,/g, '')) >= 10 ? 10 : Number(String(args[2]).replace(/,/g, '')) ?? 1
                var contrastreductions = 0
                var contrastfilters = []
                var c = contrast

                while (c > 2) {
                    c -= 2
                    contrastreductions++
                }

                for (var i = 0; i < contrastreductions; i++) {
                    contrastfilters.push(`eq=contrast=2`)
                }

                contrastfilters.push(`eq=contrast=${c}`)

                var fileinfo = await validateFile(currenturl).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })

                if (!fileinfo) return
                var type = fileinfo.type

                if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                    var filepath = await downloadFile(currenturl, `input.png`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.png`
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -filter_complex "[0:v]split[normal][extract];[extract]alphaextract[mask];[normal]eq=brightness=${brightness},${contrastfilters.join(',')}[bc];[bc][mask]alphamerge[out]" -map "[out]" -preset ${findpreset(args)} ${filepath}/output.png`)
                    await sendFile(msg, filepath, `output.png`)
                } else if (type.mime.startsWith('video')) {
                    var filepath = await downloadFile(currenturl, `input.mp4`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp4`
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -map 0:a? -filter_complex "[0:v]eq=brightness=${brightness},${contrastfilters.join(',')},scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ${findpreset(args)} -c:v libx264 -pix_fmt yuv420p ${filepath}/output.mp4`)
                    await sendFile(msg, filepath, `output.mp4`)
                } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                    var filepath = await downloadFile(currenturl, `input.gif`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.gif`
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -filter_complex "[0:v]split[normal][extract];[extract]alphaextract[mask];[normal]eq=brightness=${brightness},${contrastfilters.join(',')}[bc];[bc][mask]alphamerge,split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ${findpreset(args)} -gifflags -offsetting ${filepath}/output.gif`)
                    await sendFile(msg, filepath, `output.gif`)
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "brightcontrast/brightness/contrast [brightness (from -10 to 10)] [contrast (from -10 to 10)] <file>",
                "value": "Changes the file's brightness and contrast values."
            },
            cooldown: 2500,
            type: "Color"
        },

        {
            name: ["color"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[4] === undefined) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl']
                var r = isNaN(Number(String(args[1]).replace(/,/g, ''))) ? 0 : Number(String(args[1]).replace(/,/g, '')) <= 0 ? 0 : Number(String(args[1]).replace(/,/g, '')) >= 255 ? 255 : Number(String(args[1]).replace(/,/g, '')) || 0
                var g = isNaN(Number(String(args[2]).replace(/,/g, ''))) ? 0 : Number(String(args[2]).replace(/,/g, '')) <= 0 ? 0 : Number(String(args[2]).replace(/,/g, '')) >= 255 ? 255 : Number(String(args[2]).replace(/,/g, '')) || 0
                var b = isNaN(Number(String(args[3]).replace(/,/g, ''))) ? 0 : Number(String(args[3]).replace(/,/g, '')) <= 0 ? 0 : Number(String(args[3]).replace(/,/g, '')) >= 255 ? 255 : Number(String(args[3]).replace(/,/g, '')) || 0
                var fileinfo = await validateFile(currenturl).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })

                if (!fileinfo) return
                var type = fileinfo.type

                if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                    var filepath = await downloadFile(currenturl, `input.png`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.png`
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -filter_complex "[0:v]hue=s=0,curves=r='0/${r / 255} 1/1':g='0/${g / 255} 1/1':b='0/${b / 255} 1/1'[out]" -map "[out]" -preset ${findpreset(args)} ${filepath}/output.png`)
                    await sendFile(msg, filepath, `output.png`)
                } else if (type.mime.startsWith('video')) {
                    var filepath = await downloadFile(currenturl, `input.mp4`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp4`
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -map 0:a? -filter_complex "[0:v]hue=s=0,curves=r='0/${r / 255} 1/1':g='0/${g / 255} 1/1':b='0/${b / 255} 1/1',scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ${findpreset(args)} -c:v libx264 -pix_fmt yuv420p ${filepath}/output.mp4`)
                    await sendFile(msg, filepath, `output.mp4`)
                } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                    var filepath = await downloadFile(currenturl, `input.gif`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.gif`
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -filter_complex "[0:v]hue=s=0,curves=r='0/${r / 255} 1/1':g='0/${g / 255} 1/1':b='0/${b / 255} 1/1',split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ${findpreset(args)} -gifflags -offsetting ${filepath}/output.gif`)
                    await sendFile(msg, filepath, `output.gif`)
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "color [r] [g] [b] <file>",
                "value": "Gives the file a new color depending on the RGB values, focusing more on lighter tones."
            },
            cooldown: 2500,
            type: "Color"
        },

        {
            name: ["color2"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[4] === undefined) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl']
                var r = isNaN(Number(String(args[1]).replace(/,/g, ''))) ? 0 : Number(String(args[1]).replace(/,/g, '')) <= 0 ? 0 : Number(String(args[1]).replace(/,/g, '')) >= 255 ? 255 : Number(String(args[1]).replace(/,/g, '')) || 0
                var g = isNaN(Number(String(args[2]).replace(/,/g, ''))) ? 0 : Number(String(args[2]).replace(/,/g, '')) <= 0 ? 0 : Number(String(args[2]).replace(/,/g, '')) >= 255 ? 255 : Number(String(args[2]).replace(/,/g, '')) || 0
                var b = isNaN(Number(String(args[3]).replace(/,/g, ''))) ? 0 : Number(String(args[3]).replace(/,/g, '')) <= 0 ? 0 : Number(String(args[3]).replace(/,/g, '')) >= 255 ? 255 : Number(String(args[3]).replace(/,/g, '')) || 0
                var fileinfo = await validateFile(currenturl).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })

                if (!fileinfo) return
                var type = fileinfo.type

                if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                    var filepath = await downloadFile(currenturl, `input.png`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.png`
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -filter_complex "[0:v]hue=s=0,curves=r='0/0 1/${r / 255}':g='0/0 1/${g / 255}':b='0/0 1/${b / 255}'[out]" -map "[out]" -preset ${findpreset(args)} ${filepath}/output.png`)
                    await sendFile(msg, filepath, `output.png`)
                } else if (type.mime.startsWith('video')) {
                    var filepath = await downloadFile(currenturl, `input.mp4`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp4`
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -map 0:a? -filter_complex "[0:v]hue=s=0,curves=r='0/0 1/${r / 255}':g='0/0 1/${g / 255}':b='0/0 1/${b / 255}',scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ${findpreset(args)} -c:v libx264 -pix_fmt yuv420p ${filepath}/output.mp4`)
                    await sendFile(msg, filepath, `output.mp4`)
                } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                    var filepath = await downloadFile(currenturl, `input.gif`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.gif`
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -filter_complex "[0:v]hue=s=0,curves=r='0/0 1/${r / 255}':g='0/0 1/${g / 255}':b='0/0 1/${b / 255}',split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ${findpreset(args)} -gifflags -offsetting ${filepath}/output.gif`)
                    await sendFile(msg, filepath, `output.gif`)
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "color2 [r] [g] [b] <file>",
                "value": "Gives the file a new color depending on the RGB values, focusing more on darker tones."
            },
            cooldown: 2500,
            type: "Color"
        },

        {
            name: ["curves"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[4] === undefined) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var saidMessage = args.join(' ').substring(args[0].length + 1)
                symbolreplacements.forEach(symbolReplacement => {
                    symbolReplacement.target.forEach(target => {
                        saidMessage = saidMessage.replace(new RegExp(target, 'ig'), symbolReplacement.replacement)
                    })
                })
                var dft = ['"0/0 255/255"', '"0/0 255/255"', '"0/0 255/255"']
                var curvesregexg = /\b(1?[0-9]{1,2}|2[0-4][0-9]|25[0-5])\b\/\b(1?[0-9]{1,2}|2[0-4][0-9]|25[0-5])\b/g
                var matchedTextes = saidMessage.match(/"([\s\S]*?)"/g)
                if (!matchedTextes) {
                    matchedTextes = dft
                } else {
                    for (var i in dft) {
                        var dfttext = dft[i]
                        var text = matchedTextes[i]
                        if (!text || !(text.match(curvesregexg) ? text.match(curvesregexg).length >= 2 : false)) {
                            matchedTextes[i] = dfttext
                        }
                    }
                }
                var matchfunc = (match) => {
                    match = match.split('/')
                    for (var i in match) {
                        match[i] /= 255
                    }
                    return match.join('/')
                }
                var rcurves = matchedTextes[0].substring(1, matchedTextes[0].length - 1).match(curvesregexg).map(curves => curves.replace(curvesregexg, matchfunc))
                var gcurves = matchedTextes[1].substring(1, matchedTextes[1].length - 1).match(curvesregexg).map(curves => curves.replace(curvesregexg, matchfunc))
                var bcurves = matchedTextes[2].substring(1, matchedTextes[2].length - 1).match(curvesregexg).map(curves => curves.replace(curvesregexg, matchfunc))

                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl']
                var fileinfo = await validateFile(currenturl).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })

                if (!fileinfo) return
                var type = fileinfo.type

                if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                    var filepath = await downloadFile(currenturl, `input.png`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.png`
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -filter_complex "[0:v]curves=r='${rcurves.join(' ')}':g='${gcurves.join(' ')}':b='${bcurves.join(' ')}'[out]" -map "[out]" -preset ${findpreset(args)} ${filepath}/output.png`)
                    await sendFile(msg, filepath, `output.png`)
                } else if (type.mime.startsWith('video')) {
                    var filepath = await downloadFile(currenturl, `input.mp4`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp4`
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -map 0:a? -filter_complex "[0:v]curves=r='${rcurves.join(' ')}':g='${gcurves.join(' ')}':b='${bcurves.join(' ')}',scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ${findpreset(args)} -c:v libx264 -pix_fmt yuv420p ${filepath}/output.mp4`)
                    await sendFile(msg, filepath, `output.mp4`)
                } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                    var filepath = await downloadFile(currenturl, `input.gif`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.gif`
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -filter_complex "[0:v]curves=r='${rcurves.join(' ')}':g='${gcurves.join(' ')}':b='${bcurves.join(' ')}',split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ${findpreset(args)} -gifflags -offsetting ${filepath}/output.gif`)
                    await sendFile(msg, filepath, `output.gif`)
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "curves \"[rcurves]\" \"[gcurves]\" \"[bcurves]\" <file>",
                "value": "Gives the file a new color depending on the curve points specified.\nExample usage: p:curves \"0/0 215/47 255/255\" \"0/0 215/47 255/255\" \"0/0 215/47 255/255\" https://cdn.discordapp.com/attachments/682052452740104223/944611349848264795/output.png"
            },
            cooldown: 2500,
            type: "Color"
        },

        {
            name: ["convolution"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[4] === undefined) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var saidMessage = args.join(' ').substring(args[0].length + 1).replace(/‚Äô/g, '\'')
                symbolreplacements.forEach(symbolReplacement => {
                    symbolReplacement.target.forEach(target => {
                        saidMessage = saidMessage.replace(new RegExp(target, 'ig'), symbolReplacement.replacement)
                    })
                })
                var matchedTextes = saidMessage.match(/"([\s\S]*?)"/g)
                if (!matchedTextes) {
                    matchedTextes = ['""']
                }
                var convolution = matchedTextes[0].substring(1, matchedTextes[0].length - 1).replace(/[^\d- :/]/g, '')
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl']
                var fileinfo = await validateFile(currenturl).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })

                if (!fileinfo) return
                var type = fileinfo.type

                if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                    var filepath = await downloadFile(currenturl, `input.png`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.png`
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -filter_complex "[0:v]convolution='${convolution}'[out]" -map "[out]" -preset ${findpreset(args)} ${filepath}/output.png`)
                    await sendFile(msg, filepath, `output.png`)
                } else if (type.mime.startsWith('video')) {
                    var filepath = await downloadFile(currenturl, `input.mp4`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp4`
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -map 0:a? -filter_complex "[0:v]convolution='${convolution}',scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ${findpreset(args)} -c:v libx264 -pix_fmt yuv420p ${filepath}/output.mp4`)
                    await sendFile(msg, filepath, `output.mp4`)
                } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                    var filepath = await downloadFile(currenturl, `input.gif`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.gif`
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -filter_complex "[0:v]convolution='${convolution}',split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ${findpreset(args)} -gifflags -offsetting ${filepath}/output.gif`)
                    await sendFile(msg, filepath, `output.gif`)
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "<:newpoopy:839191885310066729> convolution \"{matrix}\" <file>",
                "value": "Apply convolution of 3x3, 5x5, 7x7 or horizontal/vertical up to 49 elements to the file. More info found at https://ffmpeg.org/ffmpeg-filters.html#convolution and https://docs.gimp.org/2.6/en/plug-in-convmatrix.html including some examples.\nExample usage: p:convolution \"-2 -1 0 -1 1 1 0 1 2\" https://cdn.discordapp.com/attachments/835974556610592788/962072284112244826/a_294be0ac79572cee7c49b119c356444e.gif (apply emboss)"
            },
            cooldown: 2500,
            type: "Effects"
        },

        {
            name: ["pseudocolor"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[4] === undefined) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl']
                var presets = [
                    'magma',
                    'inferno',
                    'plasma',
                    'viridis',
                    'turbo',
                    'cividis',
                    'range1',
                    'range2',
                    'shadows',
                    'highlights',
                    'solar',
                    'nominal',
                    'preferred',
                    'total'
                ]
                var preset = 'turbo'
                var presetindex = args.indexOf('-preset')
                if (presetindex > -1) {
                    if (presets.find(preset => preset === args[presetindex + 1].toLowerCase())) {
                        preset = args[presetindex + 1].toLowerCase()
                    } else {
                        msg.channel.send('Not a supported preset.').catch(() => { })
                        return
                    }
                }
                var fileinfo = await validateFile(currenturl).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })

                if (!fileinfo) return
                var type = fileinfo.type

                if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                    var filepath = await downloadFile(currenturl, `input.png`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.png`
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -filter_complex "[0:v]pseudocolor=preset=${preset}[out]" -map "[out]" -preset ${findpreset(args)} ${filepath}/output.png`)
                    await sendFile(msg, filepath, `output.png`)
                } else if (type.mime.startsWith('video')) {
                    var filepath = await downloadFile(currenturl, `input.mp4`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp4`
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -map 0:a? -filter_complex "[0:v]pseudocolor=preset=${preset},scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ${findpreset(args)} -c:v libx264 -pix_fmt yuv420p ${filepath}/output.mp4`)
                    await sendFile(msg, filepath, `output.mp4`)
                } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                    var filepath = await downloadFile(currenturl, `input.gif`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.gif`
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -filter_complex "[0:v]pseudocolor=preset=${preset},split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ${findpreset(args)} -gifflags -offsetting ${filepath}/output.gif`)
                    await sendFile(msg, filepath, `output.gif`)
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "pseudocolor <file> [-preset <preset>]",
                "value": "Gives the file a new color, depending on the specified preset. A list of presets can be found at https://ffmpeg.org/ffmpeg-filters.html#pseudocolor"
            },
            cooldown: 2500,
            type: "Color"
        },

        {
            name: ["tint"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[4] === undefined) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl']
                var r = (isNaN(Number(String(args[1]).replace(/,/g, ''))) ? 0 : Number(String(args[1]).replace(/,/g, '')) <= 0 ? 0 : Number(String(args[1]).replace(/,/g, '')) >= 255 ? 255 : Number(String(args[1]).replace(/,/g, '')) || 0).toString(16).padStart(2, '0')
                var g = (isNaN(Number(String(args[2]).replace(/,/g, ''))) ? 0 : Number(String(args[2]).replace(/,/g, '')) <= 0 ? 0 : Number(String(args[2]).replace(/,/g, '')) >= 255 ? 255 : Number(String(args[2]).replace(/,/g, '')) || 0).toString(16).padStart(2, '0')
                var b = (isNaN(Number(String(args[3]).replace(/,/g, ''))) ? 0 : Number(String(args[3]).replace(/,/g, '')) <= 0 ? 0 : Number(String(args[3]).replace(/,/g, '')) >= 255 ? 255 : Number(String(args[3]).replace(/,/g, '')) || 0).toString(16).padStart(2, '0')
                var a = isNaN(Number(String(args[4]).replace(/,/g, ''))) ? 179 : Number(String(args[4]).replace(/,/g, '')) <= 0 ? 0 : Number(String(args[4]).replace(/,/g, '')) >= 255 ? 255 : Number(String(args[4]).replace(/,/g, '')) ?? 179
                var fileinfo = await validateFile(currenturl).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })

                if (!fileinfo) return
                var type = fileinfo.type

                if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                    var filepath = await downloadFile(currenturl, `input.png`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.png`
                    var width = fileinfo.info.width
                    var height = fileinfo.info.height

                    await execPromise(`ffmpeg -i ${filepath}/${filename} -f lavfi -i "color=0x${r}${g}${b}:s=${width}x${height},format=rgba" -filter_complex "[0:v][1:v]blend=shortest=1:all_mode=overlay:all_opacity=${a / 255}[out]" -map "[out]" -preset ${findpreset(args)} ${filepath}/output.png`)
                    await sendFile(msg, filepath, `output.png`)
                } else if (type.mime.startsWith('video')) {
                    var filepath = await downloadFile(currenturl, `input.mp4`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp4`
                    var width = fileinfo.info.width
                    var height = fileinfo.info.height

                    await execPromise(`ffmpeg -i ${filepath}/${filename} -f lavfi -i "color=0x${r}${g}${b}:s=${width}x${height},format=rgba" -map 0:a? -filter_complex "[0:v][1:v]blend=shortest=1:all_mode=overlay:all_opacity=${a / 255},scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ${findpreset(args)} -c:v libx264 -pix_fmt yuv420p ${filepath}/output.mp4`)
                    await sendFile(msg, filepath, `output.mp4`)
                } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                    var filepath = await downloadFile(currenturl, `input.gif`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.gif`
                    var width = fileinfo.info.width
                    var height = fileinfo.info.height

                    await execPromise(`ffmpeg -i ${filepath}/${filename} -f lavfi -i "color=0x${r}${g}${b}:s=${width}x${height},format=rgba" -filter_complex "[0:v][1:v]blend=shortest=1:all_mode=overlay:all_opacity=${a / 255},split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ${findpreset(args)} -gifflags -offsetting ${filepath}/output.gif`)
                    await sendFile(msg, filepath, `output.gif`)
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "tint [r] [g] [b] [a] <file>",
                "value": "Tints the file with the new color depending on the RGBA values."
            },
            cooldown: 2500,
            type: "Color"
        },

        {
            name: ["newimage", "makeimage"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (args.length < 6) {
                    msg.channel.send('Where are all the required arguments?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                }

                var width = isNaN(Number(String(args[1]).replace(/,/g, ''))) ? 500 : Number(String(args[1]).replace(/,/g, '')) <= 1 ? 1 : Number(String(args[1]).replace(/,/g, '')) >= 2000 ? 2000 : Number(String(args[1]).replace(/,/g, '')) || 500
                var height = isNaN(Number(String(args[2]).replace(/,/g, ''))) ? 500 : Number(String(args[2]).replace(/,/g, '')) <= 1 ? 1 : Number(String(args[2]).replace(/,/g, '')) >= 2000 ? 2000 : Number(String(args[2]).replace(/,/g, '')) || 500
                var r = (isNaN(Number(String(args[3]).replace(/,/g, ''))) ? 0 : Number(String(args[3]).replace(/,/g, '')) <= 0 ? 0 : Number(String(args[3]).replace(/,/g, '')) >= 255 ? 255 : Number(String(args[3]).replace(/,/g, '')) || 0).toString(16).padStart(2, '0')
                var g = (isNaN(Number(String(args[4]).replace(/,/g, ''))) ? 0 : Number(String(args[4]).replace(/,/g, '')) <= 0 ? 0 : Number(String(args[4]).replace(/,/g, '')) >= 255 ? 255 : Number(String(args[4]).replace(/,/g, '')) || 0).toString(16).padStart(2, '0')
                var b = (isNaN(Number(String(args[5]).replace(/,/g, ''))) ? 0 : Number(String(args[5]).replace(/,/g, '')) <= 0 ? 0 : Number(String(args[5]).replace(/,/g, '')) >= 255 ? 255 : Number(String(args[5]).replace(/,/g, '')) || 0).toString(16).padStart(2, '0')
                var a = (isNaN(Number(String(args[6]).replace(/,/g, ''))) ? 255 : Number(String(args[6]).replace(/,/g, '')) <= 0 ? 0 : Number(String(args[6]).replace(/,/g, '')) >= 255 ? 255 : Number(String(args[6]).replace(/,/g, '')) ?? 255).toString(16).padStart(2, '0')

                var currentcount = filecount
                filecount++
                var filepath = `temp/file${currentcount}`
                fs.mkdirSync(`${filepath}`)

                await execPromise(`ffmpeg -f lavfi -i "color=0x${r}${g}${b}${a}:s=${width}x${height},format=rgba" ${filepath}/output.png`)
                await sendFile(msg, filepath, `output.png`)
            },
            help: {
                "name": "newimage/makeimage <width (max 2000)> <height (max 2000)> <r> <g> <b> [a]",
                "value": "Creates a new image from the specified dimensions and colors."
            },
            cooldown: 2500,
            type: "Generation"
        },

        {
            name: ["newtext", "newcaption"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                var fonts = fs.readdirSync('templates/fonts')
                if (!args[1]) {
                    msg.channel.send(`No font specified. A valid list of fonts is ${fonts.join(', ')}`).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                }

                var font
                if (fonts.find(font => font.toLowerCase() === args[1].toLowerCase())) {
                    font = fonts.find(font => font.toLowerCase() === args[1].toLowerCase())
                } else {
                    msg.channel.send(`Not a supported font. A valid list of fonts are:\n${fonts.map(font => `\`${font}\``).join(', ')}`).catch(() => { })
                    return
                }

                var maxwidth
                var maxwidthindex = args.indexOf('-maxwidth')
                if (maxwidthindex > -1) {
                    maxwidth = isNaN(Number(args[maxwidthindex + 1])) ? undefined : Number(args[maxwidthindex + 1]) <= 1 ? 1 : Number(args[maxwidthindex + 1]) >= 2000 ? 2000 : Math.round(Number(args[maxwidthindex + 1])) || undefined
                }

                var rgb = {
                    r: 255,
                    g: 255,
                    b: 255
                }
                var colorindex = args.indexOf('-color')
                if (colorindex > -1) {
                    var r = args[colorindex + 1]
                    var g = args[colorindex + 2]
                    var b = args[colorindex + 3]
                    rgb.r = isNaN(Number(String(r).replace(/,/g, ''))) ? 0 : Number(String(r).replace(/,/g, '')) <= 0 ? 0 : Number(String(r).replace(/,/g, '')) >= 255 ? 255 : Number(String(r).replace(/,/g, '')) || 0
                    rgb.g = isNaN(Number(String(g).replace(/,/g, ''))) ? 0 : Number(String(g).replace(/,/g, '')) <= 0 ? 0 : Number(String(g).replace(/,/g, '')) >= 255 ? 255 : Number(String(g).replace(/,/g, '')) || 0
                    rgb.b = isNaN(Number(String(b).replace(/,/g, ''))) ? 0 : Number(String(b).replace(/,/g, '')) <= 0 ? 0 : Number(String(b).replace(/,/g, '')) >= 255 ? 255 : Number(String(b).replace(/,/g, '')) || 0
                }

                var rgba = {
                    r: 0,
                    g: 0,
                    b: 0,
                    a: 0
                }
                var bgcolorindex = args.indexOf('-bgcolor')
                if (bgcolorindex > -1) {
                    var r = args[bgcolorindex + 1]
                    var g = args[bgcolorindex + 2]
                    var b = args[bgcolorindex + 3]
                    var a = args[bgcolorindex + 4]
                    rgba.r = isNaN(Number(String(r).replace(/,/g, ''))) ? 0 : Number(String(r).replace(/,/g, '')) <= 0 ? 0 : Number(String(r).replace(/,/g, '')) >= 255 ? 255 : Number(String(r).replace(/,/g, '')) || 0
                    rgba.g = isNaN(Number(String(g).replace(/,/g, ''))) ? 0 : Number(String(g).replace(/,/g, '')) <= 0 ? 0 : Number(String(g).replace(/,/g, '')) >= 255 ? 255 : Number(String(g).replace(/,/g, '')) || 0
                    rgba.b = isNaN(Number(String(b).replace(/,/g, ''))) ? 0 : Number(String(b).replace(/,/g, '')) <= 0 ? 0 : Number(String(b).replace(/,/g, '')) >= 255 ? 255 : Number(String(b).replace(/,/g, '')) || 0
                    rgba.a = isNaN(Number(String(a).replace(/,/g, ''))) ? 0 : Number(String(a).replace(/,/g, '')) <= 0 ? 0 : Number(String(a).replace(/,/g, '')) >= 255 ? 255 : Number(String(a).replace(/,/g, '')) || 0
                }

                var padding = {
                    top: 0,
                    bottom: 0,
                    left: 0,
                    right: 0
                }
                var paddingindex = args.indexOf('-padding')
                if (paddingindex > -1) {
                    var top = args[paddingindex + 1]
                    var bottom = args[paddingindex + 2]
                    var left = args[paddingindex + 3]
                    var right = args[paddingindex + 4]
                    padding.top = isNaN(Number(String(top).replace(/,/g, ''))) ? 0 : Number(String(top).replace(/,/g, '')) <= 0 ? 0 : Number(String(top).replace(/,/g, '')) >= 2000 ? 2000 : Number(String(top).replace(/,/g, '')) || 0
                    padding.bottom = isNaN(Number(String(bottom).replace(/,/g, ''))) ? 0 : Number(String(bottom).replace(/,/g, '')) <= 0 ? 0 : Number(String(bottom).replace(/,/g, '')) >= 2000 ? 2000 : Number(String(bottom).replace(/,/g, '')) || 0
                    padding.left = isNaN(Number(String(left).replace(/,/g, ''))) ? 0 : Number(String(left).replace(/,/g, '')) <= 0 ? 0 : Number(String(left).replace(/,/g, '')) >= 2000 ? 2000 : Number(String(left).replace(/,/g, '')) || 0
                    padding.right = isNaN(Number(String(right).replace(/,/g, ''))) ? 0 : Number(String(right).replace(/,/g, '')) <= 0 ? 0 : Number(String(right).replace(/,/g, '')) >= 2000 ? 2000 : Number(String(right).replace(/,/g, '')) || 0
                }

                var origins = {
                    x: {
                        left: Jimp.HORIZONTAL_ALIGN_LEFT,
                        center: Jimp.HORIZONTAL_ALIGN_CENTER,
                        right: Jimp.HORIZONTAL_ALIGN_RIGHT
                    },

                    y: {
                        top: Jimp.VERTICAL_ALIGN_TOP,
                        middle: Jimp.VERTICAL_ALIGN_MIDDLE,
                        bottom: Jimp.VERTICAL_ALIGN_BOTTOM
                    },
                }
                var originx = Jimp.HORIZONTAL_ALIGN_CENTER
                var originy = Jimp.VERTICAL_ALIGN_MIDDLE
                var originindex = args.indexOf('-origin')
                if (originindex > -1) {
                    originx = origins.x[args[originindex + 1]] || Jimp.HORIZONTAL_ALIGN_CENTER
                    originy = origins.y[args[originindex + 2]] || Jimp.VERTICAL_ALIGN_MIDDLE
                }

                var saidMessage = args.join(' ').substring(args[0].length + 1).replace(/‚Äô/g, '\'')
                symbolreplacements.forEach(symbolReplacement => {
                    symbolReplacement.target.forEach(target => {
                        saidMessage = saidMessage.replace(new RegExp(target, 'ig'), symbolReplacement.replacement)
                    })
                })
                var matchedTextes = saidMessage.match(/"([\s\S]*?)"/g)
                if (!matchedTextes) {
                    matchedTextes = ['""']
                }
                var text = matchedTextes[0].substring(1, matchedTextes[0].length - 1)

                var currentcount = filecount
                filecount++
                var filepath = `temp/file${currentcount}`
                fs.mkdirSync(`${filepath}`)

                var transparent = await Jimp.read('templates/transparent.png')
                var loadedfont = await Jimp.loadFont(`templates/fonts/${font}/${font}.fnt`)
                var defaultheight = loadedfont.common.lineHeight
                var textwidth = maxwidth || Jimp.measureText(loadedfont, text)
                var textheight = Jimp.measureTextHeight(loadedfont, text, maxwidth || textwidth)
                var width = textwidth + padding.left + padding.right
                var height = textheight + padding.top + padding.bottom
                transparent.resize(width, height)
                await transparent.print(loadedfont, padding.left, padding.top, { text: Discord.Util.cleanContent(text, msg), alignmentX: originx, alignmentY: originy }, textwidth, textheight)
                if (args.find(arg => arg === '-resetcolor')) {
                    transparent.color([
                        {
                            apply: 'red',
                            params: [255]
                        },
                        {
                            apply: 'green',
                            params: [255]
                        },
                        {
                            apply: 'blue',
                            params: [255]
                        }
                    ])
                }
                transparent.color([
                    {
                        apply: 'red',
                        params: [-255 + rgb.r]
                    },
                    {
                        apply: 'green',
                        params: [-255 + rgb.g]
                    },
                    {
                        apply: 'blue',
                        params: [-255 + rgb.b]
                    }
                ])
                await transparent.writeAsync(`${filepath}/caption.png`)

                await execPromise(`ffmpeg -i ${filepath}/caption.png -f lavfi -i "color=0x${rgba.r.toString(16).padStart(2, '0')}${rgba.g.toString(16).padStart(2, '0')}${rgba.b.toString(16).padStart(2, '0')}${rgba.a.toString(16).padStart(2, '0')}:s=${width}x${height},format=rgba" -filter_complex "[1:v][0:v]overlay=x=0:y=0:format=auto[out]" -map "[out]" ${filepath}/output.png`)
                await sendFile(msg, filepath, `output.png`, {
                    content: `Font Height: **${defaultheight} pixels**`
                })
            },
            help: {
                "name": "newtext/newcaption <font> \"{text}\" [-maxwidth <pixels>] [(-color | -bgcolor) <r> <g> <b> <a>] [-resetcolor] [-padding <top> <bottom> <left> <right>] [-origin <x (left/center/right)> <y (top/middle/bottom)>]",
                "value": "Creates a new caption from the specified options and colors.\nPro Tip: Using \"<Img={url}>\" allows you to use custom emojis in your captions!"
            },
            cooldown: 2500,
            type: "Captions"
        },

        {
            name: ["fileinfo"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[4] === undefined) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl']
                var fileinfo = await validateFile(currenturl, 'very true').catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })

                if (!fileinfo) return
                var type = fileinfo.type

                var jsoninfo = {}
                var formattedSize = prettyBytes(fileinfo.info.realsize)
                var size = `${formattedSize}${formattedSize.endsWith(' B') ? '' : ` (${fileinfo.info.realsize} B)`}`
                var params = [
                    `**File Size**: ${size}`,
                    `**Format**: ${type.ext}`,
                    `**Mime**: ${type.mime}`
                ]
                var paramFunctions

                var json = await execPromise(`ffprobe -of json -show_streams -show_format "${currenturl}"`)
                if (json) {
                    jsoninfo = JSON.parse(json)
                }

                if (jsoninfo["streams"]) {
                    if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                        var videoStream = jsoninfo["streams"].find(stream => stream["codec_type"] === 'video')

                        if (videoStream) {
                            paramFunctions = [
                                function () {
                                    if (videoStream["width"] && videoStream["height"]) {
                                        params.push(`**Scale**: ${videoStream["width"]}x${videoStream["height"]}`)
                                    }
                                },
                                function () {
                                    if (videoStream["sample_aspect_ratio"]) {
                                        params.push(`**Sample Aspect Ratio**: ${videoStream["sample_aspect_ratio"]}`)
                                    }
                                },
                                function () {
                                    if (videoStream["display_aspect_ratio"]) {
                                        params.push(`**Display Aspect Ratio**: ${videoStream["display_aspect_ratio"]}`)
                                    }
                                },
                                function () {
                                    if (videoStream["codec_name"] && videoStream["codec_long_name"]) {
                                        params.push(`**Codec**: ${videoStream["codec_name"]} (${videoStream["codec_long_name"]})`)
                                    }
                                },
                                function () {
                                    if (videoStream["pix_fmt"]) {
                                        params.push(`**Pixel Format**: ${videoStream["pix_fmt"]}`)
                                    }
                                }
                            ]
                        }
                    } else if (type.mime.startsWith('video')) {
                        var videoStream = jsoninfo["streams"].find(stream => stream["codec_type"] === 'video')
                        var audioStream = jsoninfo["streams"].find(stream => stream["codec_type"] === 'audio')

                        if (videoStream) {
                            paramFunctions = [
                                function () {
                                    if (videoStream["width"] && videoStream["height"]) {
                                        params.push(`**Scale**: ${videoStream["width"]}x${videoStream["height"]}`)
                                    }
                                },
                                function () {
                                    if (videoStream["sample_aspect_ratio"]) {
                                        params.push(`**Sample Aspect Ratio**: ${videoStream["sample_aspect_ratio"]}`)
                                    }
                                },
                                function () {
                                    if (videoStream["display_aspect_ratio"]) {
                                        params.push(`**Display Aspect Ratio**: ${videoStream["display_aspect_ratio"]}`)
                                    }
                                },
                                function () {
                                    if (videoStream["duration"]) {
                                        var totalSeconds = videoStream["duration"]
                                        var days = Math.floor(totalSeconds / 86400);
                                        totalSeconds %= 86400;
                                        var hours = Math.floor(totalSeconds / 3600);
                                        totalSeconds %= 3600;
                                        var minutes = Math.floor(totalSeconds / 60);
                                        var seconds = totalSeconds % 60
                                        var times = []

                                        if (days) times.push(days)
                                        if (hours) times.push(hours)
                                        if (minutes) times.push(minutes)
                                        if (seconds) times.push(seconds)

                                        params.push(`**Video Duration**: ${times.join(':')}`)
                                    }
                                },
                                function () {
                                    if (audioStream) {
                                        if (audioStream["duration"]) {
                                            var totalSeconds = audioStream["duration"]
                                            var days = Math.floor(totalSeconds / 86400);
                                            totalSeconds %= 86400;
                                            var hours = Math.floor(totalSeconds / 3600);
                                            totalSeconds %= 3600;
                                            var minutes = Math.floor(totalSeconds / 60);
                                            var seconds = totalSeconds % 60
                                            var times = []

                                            if (days) times.push(days)
                                            if (hours) times.push(hours)
                                            if (minutes) times.push(minutes)
                                            if (seconds) times.push(seconds)

                                            params.push(`**Audio Duration**: ${times.join(':')}`)
                                        }
                                    }
                                },
                                function () {
                                    if (videoStream["nb_frames"]) {
                                        params.push(`**Frames**: ${videoStream["nb_frames"]}`)
                                    }
                                },
                                function () {
                                    if (videoStream["r_frame_rate"]) {
                                        params.push(`**Framerate**: ${videoStream["r_frame_rate"]}`)
                                    }
                                },
                                function () {
                                    if (audioStream) {
                                        if (audioStream["sample_rate"]) {
                                            params.push(`**Audio Rate**: ${audioStream["sample_rate"]}`)
                                        }
                                    }
                                },
                                function () {
                                    if (videoStream["codec_name"] && videoStream["codec_long_name"]) {
                                        params.push(`**Video Codec**: ${videoStream["codec_name"]} (${videoStream["codec_long_name"]})`)
                                    }
                                },
                                function () {
                                    if (audioStream) {
                                        if (audioStream["codec_name"] && audioStream["codec_long_name"]) {
                                            params.push(`**Audio Codec**: ${audioStream["codec_name"]} (${audioStream["codec_long_name"]})`)
                                        }
                                    }
                                },
                                function () {
                                    if (videoStream["bit_rate"]) {
                                        params.push(`**Video Bitrate**: ${videoStream["bit_rate"]}`)
                                    }
                                },
                                function () {
                                    if (audioStream) {
                                        if (audioStream["bit_rate"]) {
                                            params.push(`**Audio Bitrate**: ${audioStream["bit_rate"]}`)
                                        }
                                    }
                                },
                                function () {
                                    if (videoStream["pix_fmt"]) {
                                        params.push(`**Pixel Format**: ${videoStream["pix_fmt"]}`)
                                    }
                                }
                            ]
                        }
                    } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                        var videoStream = jsoninfo["streams"].find(stream => stream["codec_type"] === 'video')

                        if (videoStream) {
                            paramFunctions = [
                                function () {
                                    if (videoStream["width"] && videoStream["height"]) {
                                        params.push(`**Scale**: ${videoStream["width"]}x${videoStream["height"]}`)
                                    }
                                },
                                function () {
                                    if (videoStream["sample_aspect_ratio"]) {
                                        params.push(`**Sample Aspect Ratio**: ${videoStream["sample_aspect_ratio"]}`)
                                    }
                                },
                                function () {
                                    if (videoStream["display_aspect_ratio"]) {
                                        params.push(`**Display Aspect Ratio**: ${videoStream["display_aspect_ratio"]}`)
                                    }
                                },
                                function () {
                                    if (videoStream["duration"]) {
                                        var totalSeconds = videoStream["duration"]
                                        var days = Math.floor(totalSeconds / 86400);
                                        totalSeconds %= 86400;
                                        var hours = Math.floor(totalSeconds / 3600);
                                        totalSeconds %= 3600;
                                        var minutes = Math.floor(totalSeconds / 60);
                                        var seconds = totalSeconds % 60
                                        var times = []

                                        if (days) times.push(days)
                                        if (hours) times.push(hours)
                                        if (minutes) times.push(minutes)
                                        if (seconds) times.push(seconds)

                                        params.push(`**Duration**: ${times.join(':')}`)
                                    }
                                },
                                function () {
                                    if (videoStream["nb_frames"]) {
                                        params.push(`**Frames**: ${videoStream["nb_frames"]}`)
                                    }
                                },
                                function () {
                                    if (videoStream["r_frame_rate"]) {
                                        params.push(`**Framerate**: ${videoStream["r_frame_rate"]}`)
                                    }
                                },
                                function () {
                                    if (videoStream["codec_name"] && videoStream["codec_long_name"]) {
                                        params.push(`**Codec**: ${videoStream["codec_name"]} (${videoStream["codec_long_name"]})`)
                                    }
                                },
                                function () {
                                    if (videoStream["pix_fmt"]) {
                                        params.push(`**Pixel Format**: ${videoStream["pix_fmt"]}`)
                                    }
                                }
                            ]
                        }
                    } else if (type.mime.startsWith('audio')) {
                        var audioStream = jsoninfo["streams"].find(stream => stream["codec_type"] === 'audio')

                        if (audioStream) {
                            paramFunctions = [
                                function () {
                                    if (audioStream["duration"]) {
                                        var totalSeconds = audioStream["duration"]
                                        var days = Math.floor(totalSeconds / 86400);
                                        totalSeconds %= 86400;
                                        var hours = Math.floor(totalSeconds / 3600);
                                        totalSeconds %= 3600;
                                        var minutes = Math.floor(totalSeconds / 60);
                                        var seconds = totalSeconds % 60
                                        var times = []

                                        if (days) times.push(days)
                                        if (hours) times.push(hours)
                                        if (minutes) times.push(minutes)
                                        if (seconds) times.push(seconds)

                                        params.push(`**Duration**: ${times.join(':')}`)
                                    }
                                },
                                function () {
                                    if (audioStream["sample_rate"]) {
                                        params.push(`**Rate**: ${audioStream["sample_rate"]}`)
                                    }
                                },
                                function () {
                                    if (audioStream["codec_name"] && audioStream["codec_long_name"]) {
                                        params.push(`**Codec**: ${audioStream["codec_name"]} (${audioStream["codec_long_name"]})`)
                                    }
                                },
                                function () {
                                    if (audioStream["bit_rate"]) {
                                        params.push(`**Bitrate**: ${audioStream["bit_rate"]}`)
                                    }
                                }
                            ]
                        }
                    }
                }

                for (var i in paramFunctions) {
                    paramFunctions[i]()
                }

                var embed = {
                    "title": fileinfo.name,
                    "description": params.join('\n'),
                    "url": currenturl,
                    "color": 0x472604,
                    "footer": {
                        "icon_url": bot.user.displayAvatarURL({ dynamic: true, size: 1024, format: 'png' }),
                        "text": bot.user.username
                    },
                    "thumbnail": {
                        "url": currenturl
                    }
                }

                msg.channel.send({
                    embeds: [embed]
                }).catch(() => { })
            },
            help: {
                "name": "fileinfo <file>",
                "value": "Get info on a file."
            },
            cooldown: 2500,
            type: "Main"
        },

        {
            name: ["rotate", "rot"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[2] === undefined) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl']
                var degrees = isNaN(Number(args[1])) ? 0 : Number(args[1]) <= -360 ? -360 : Number(args[1]) >= 360 ? 360 : Number(args[1]) || 0
                var fileinfo = await validateFile(currenturl).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })

                if (!fileinfo) return
                var type = fileinfo.type

                if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                    var filepath = await downloadFile(currenturl, `input.png`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.png`
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -filter_complex "[0:v]rotate=${degrees}*PI/180${!(args.find(arg => arg === '-cut')) ? `:ow=rotw(${degrees}*PI/180):oh=roth(${degrees}*PI/180)` : ''}:c=0x00000000[out]" -map "[out]" -preset ${findpreset(args)} ${filepath}/output.png`)
                    await sendFile(msg, filepath, `output.png`)
                } else if (type.mime.startsWith('video')) {
                    var filepath = await downloadFile(currenturl, `input.mp4`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp4`
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -map 0:a? -filter_complex "[0:v]rotate=${degrees}*PI/180${!(args.find(arg => arg === '-cut')) ? `:ow=rotw(${degrees}*PI/180):oh=roth(${degrees}*PI/180)` : ''}:c=0x00000000,scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ${findpreset(args)} -c:v libx264 -pix_fmt yuv420p ${filepath}/output.mp4`)
                    await sendFile(msg, filepath, `output.mp4`)
                } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                    var filepath = await downloadFile(currenturl, `input.gif`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.gif`
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -filter_complex "[0:v]rotate=${degrees}*PI/180${!(args.find(arg => arg === '-cut')) ? `:ow=rotw(${degrees}*PI/180):oh=roth(${degrees}*PI/180)` : ''}:c=0x00000000,split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ${findpreset(args)} -gifflags -offsetting ${filepath}/output.gif`)
                    await sendFile(msg, filepath, `output.gif`)
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "rotate/rot {degrees (from -360 to 360)} <file> [-cut]",
                "value": "Rotates the file by the degrees specified."
            },
            cooldown: 2500,
            type: "Effects"
        },

        {
            name: ["opacity"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[2] === undefined) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl']
                var opacity = isNaN(Number(args[1])) ? 0 : Number(args[1]) <= 0 ? 0 : Number(args[1]) >= 255 ? 255 : Math.round(Number(args[1])) || 0
                var fileinfo = await validateFile(currenturl).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })

                if (!fileinfo) return
                var type = fileinfo.type

                if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                    var filepath = await downloadFile(currenturl, `input.png`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.png`
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -filter_complex "[0:v]geq=r='r(X,Y)':a='${opacity / 255}*alpha(X,Y)'[out]" -map "[out]" -preset ${findpreset(args)} ${filepath}/output.png`)
                    await sendFile(msg, filepath, `output.png`)
                } else if (type.mime.startsWith('video') || type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                    msg.channel.send(`you can go to montenegro`).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "opacity {alpha (from 0 to 255)} <image>",
                "value": "Sets the image's opacity to the alpha specified."
            },
            cooldown: 2500,
            type: "Color"
        },

        {
            name: ["spin"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[2] === undefined) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var duration = 1
                var durationindex = args.indexOf('-duration')
                if (durationindex > -1) {
                    duration = isNaN(Number(args[durationindex + 1])) ? 1 : Number(args[durationindex + 1]) <= 0.1 ? 0.1 : Number(args[durationindex + 1]) >= 10 ? 10 : Number(args[durationindex + 1]) || 1
                }
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl']
                var fileinfo = await validateFile(currenturl).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })

                if (!fileinfo) return
                var type = fileinfo.type

                if (type.mime.startsWith('image') || type.mime.startsWith('video')) {
                    var filepath = await downloadFile(currenturl, `input.gif`)
                    var filename = `input.gif`
                    await execPromise(`ffmpeg -r 50 -stream_loop -1 -t ${duration} -i ${filepath}/${filename} -filter_complex "[0:v]scale='min(400,iw)':min'(400,ih)':force_original_aspect_ratio=decrease,rotate=t/${duration}*360*PI/180:ow='max(iw,ih)':oh=max'(iw,ih)':c=0x00000000,split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ${findpreset(args)} -gifflags -offsetting -r 50 -t ${duration} ${filepath}/output.gif`)
                    await sendFile(msg, filepath, `output.gif`)
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "spin <file> [-duration <seconds (max 10)>]",
                "value": "Continuously spins the file."
            },
            cooldown: 2500,
            type: "Animation"
        },

        {
            name: ["volume"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[2] === undefined) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl']
                var volume = isNaN(Number(args[1])) ? 100 : Number(args[1]) || 0
                var fileinfo = await validateFile(currenturl).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })

                if (!fileinfo) return
                var type = fileinfo.type

                if (type.mime.startsWith('video')) {
                    var filepath = await downloadFile(currenturl, `input.mp4`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp4`
                    var audio = fileinfo.info.audio

                    if (audio) {
                        await execPromise(`ffmpeg -i ${filepath}/${filename} -filter:a "volume=${volume / 100}" -filter:v "scale=ceil(iw/2)*2:ceil(ih/2)*2" -c:v libx264 -pix_fmt yuv420p ${filepath}/output.mp4`)
                        await sendFile(msg, filepath, `output.mp4`)
                    } else {
                        await msg.channel.send('No audio stream detected.').catch(() => { })
                        msg.channel.sendTyping().catch(() => { })
                        fs.rmSync(`${filepath}`, { force: true, recursive: true })
                    }
                } else if (type.mime.startsWith('audio')) {
                    var filepath = await downloadFile(currenturl, `input.mp3`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp3`
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -filter:a "volume=${volume / 100}" ${filepath}/output.mp3`)
                    await sendFile(msg, filepath, `output.mp3`)
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "volume {volume (by percentage)} <video/audio>",
                "value": "Increases the file's volume by {volume}%."
            },
            cooldown: 2500,
            type: "Audio"
        },

        {
            name: ["distort", "earrape", "bassboost"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[2] === undefined) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl']
                var volume = isNaN(Number(args[1])) ? 100 : Number(args[1]) <= 0 ? 0 : Number(args[1]) >= 100 ? 100 : Number(args[1]) ?? 100
                var fileinfo = await validateFile(currenturl).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })

                if (!fileinfo) return
                var type = fileinfo.type

                if (type.mime.startsWith('video')) {
                    var filepath = await downloadFile(currenturl, `input.mp4`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp4`
                    var audio = fileinfo.info.audio

                    if (audio) {
                        await execPromise(`ffmpeg -i ${filepath}/${filename} -filter:a "acrusher=.1:1:64:${1 - volume / 100}:log" -filter:v "scale=ceil(iw/2)*2:ceil(ih/2)*2" -c:v libx264 -pix_fmt yuv420p ${filepath}/output.mp4`)
                        await sendFile(msg, filepath, `output.mp4`)
                    } else {
                        await msg.channel.send('No audio stream detected.').catch(() => { })
                        msg.channel.sendTyping().catch(() => { })
                        fs.rmSync(`${filepath}`, { force: true, recursive: true })
                    }
                } else if (type.mime.startsWith('audio')) {
                    var filepath = await downloadFile(currenturl, `input.mp3`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp3`
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -filter:a "acrusher=.1:1:64:${1 - volume / 100}:log" ${filepath}/output.mp3`)
                    await sendFile(msg, filepath, `output.mp3`)
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "distort/earrape/bassboost {distort (from 0 to 100)} <video/audio>",
                "value": "Distorts the audio by {distort}."
            },
            cooldown: 2500,
            type: "Audio"
        },

        {
            name: ["reverb"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[2] === undefined) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl']
                var fileinfo = await validateFile(currenturl).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })

                if (!fileinfo) return
                var type = fileinfo.type

                if (type.mime.startsWith('video')) {
                    var filepath = await downloadFile(currenturl, `input.mp4`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp4`
                    var audio = fileinfo.info.audio

                    if (audio) {
                        await execPromise(`ffmpeg -i ${filepath}/${filename} -i templates/church.mp3 -filter_complex "[0:a][1]afir=dry=10:wet=10[audio];[0:v]scale=ceil(iw/2)*2:ceil(ih/2)*2[video]" -map "[video]" -map "[audio]" -c:v libx264 -pix_fmt yuv420p ${filepath}/output.mp4`)
                        await sendFile(msg, filepath, `output.mp4`)
                    } else {
                        await msg.channel.send('No audio stream detected.').catch(() => { })
                        msg.channel.sendTyping().catch(() => { })
                        fs.rmSync(`${filepath}`, { force: true, recursive: true })
                    }
                } else if (type.mime.startsWith('audio')) {
                    var filepath = await downloadFile(currenturl, `input.mp3`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp3`
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -i templates/church.mp3 -filter_complex "[0:a][1]afir=dry=10:wet=10[audio]" -map "[audio]" ${filepath}/output.mp3`)
                    await sendFile(msg, filepath, `output.mp3`)
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "reverb <video/audio>",
                "value": "Adds a reverb effect to the video."
            },
            cooldown: 2500,
            type: "Audio"
        },

        {
            name: ["echo"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[2] === undefined) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var delay = 1
                var delayindex = args.indexOf('-delay')
                if (delayindex > -1) {
                    delay = isNaN(Number(args[delayindex + 1])) ? 1 : Number(args[delayindex + 1]) <= 0 ? 0 : Number(args[delayindex + 1]) >= 90 ? 90 : Number(args[delayindex + 1]) ?? 1
                }
                var decay = 50
                var decayindex = args.indexOf('-decay')
                if (decayindex > -1) {
                    decay = isNaN(Number(args[decayindex + 1])) ? 50 : Number(args[decayindex + 1]) <= 0 ? 0 : Number(args[decayindex + 1]) >= 100 ? 100 : Number(args[decayindex + 1]) ?? 50
                }
                var echoes = 1
                var echoesindex = args.indexOf('-echoes')
                if (echoesindex > -1) {
                    echoes = isNaN(Number(args[echoesindex + 1])) ? 1 : Number(args[echoesindex + 1]) <= 1 ? 1 : Number(args[echoesindex + 1]) >= 99 ? 99 : Number(args[echoesindex + 1]) || 1
                }
                var echocode = `aecho=1:1:${delay * 1000}:${decay / 100}`
                var echocodes = []
                for (var i = 0; i < echoes; i++) echocodes.push(echocode)
                var echoescode = echocodes.join(',')
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl']
                var fileinfo = await validateFile(currenturl).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })

                if (!fileinfo) return
                var type = fileinfo.type

                if (type.mime.startsWith('video')) {
                    var filepath = await downloadFile(currenturl, `input.mp4`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp4`
                    var audio = fileinfo.info.audio

                    if (audio) {
                        var duration = Number(fileinfo.info.duration)

                        await execPromise(`ffmpeg -i ${filepath}/${filename} -filter_complex "[0:a]${echoescode}[audio];[0:v]scale=ceil(iw/2)*2:ceil(ih/2)*2[video]" -map "[video]" -map "[audio]" -t ${duration} -c:v libx264 -pix_fmt yuv420p ${filepath}/output.mp4`)
                        await sendFile(msg, filepath, `output.mp4`)
                    } else {
                        await msg.channel.send('No audio stream detected.').catch(() => { })
                        msg.channel.sendTyping().catch(() => { })
                        fs.rmSync(`${filepath}`, { force: true, recursive: true })
                    }
                } else if (type.mime.startsWith('audio')) {
                    var filepath = await downloadFile(currenturl, `input.mp3`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp3`
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -filter_complex "[0:a]${echoescode}[audio]" -map "[audio]" ${filepath}/output.mp3`)
                    await sendFile(msg, filepath, `output.mp3`)
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "echo <video/audio> [-delay <seconds (max 90)>] [-decay <loudness (from 0 to 100)>] [-echoes <number (from 1 to 99)>]",
                "value": "Adds an echo effect to the video."
            },
            cooldown: 2500,
            type: "Audio"
        },

        {
            name: ["glow", "holy"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl']
                var fileinfo = await validateFile(currenturl).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })

                if (!fileinfo) return
                var type = fileinfo.type

                if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                    var filepath = await downloadFile(currenturl, `input.png`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.png`
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -filter_complex "[0:v]inflate,inflate,inflate,inflate,inflate,inflate,inflate,inflate[out]" -map "[out]" -preset ${findpreset(args)} ${filepath}/output.png`)
                    await sendFile(msg, filepath, `output.png`)
                } else if (type.mime.startsWith('video')) {
                    var filepath = await downloadFile(currenturl, `input.mp4`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp4`
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -map 0:a? -filter_complex "[0:v]inflate,inflate,inflate,inflate,inflate,inflate,inflate,inflate[oout];[oout]scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ${findpreset(args)} -c:v libx264 -pix_fmt yuv420p ${filepath}/output.mp4`)
                    await sendFile(msg, filepath, `output.mp4`)
                } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                    var filepath = await downloadFile(currenturl, `input.gif`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.gif`
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -filter_complex "[0:v]inflate,inflate,inflate,inflate,inflate,inflate,inflate,inflate[oout];[oout]split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ${findpreset(args)} -gifflags -offsetting ${filepath}/output.gif`)
                    await sendFile(msg, filepath, `output.gif`)
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "glow/holy <file>",
                "value": "Adds a glow effect to the file."
            },
            cooldown: 2500,
            type: "Effects"
        },

        {
            name: ["dizzy"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl']
                var distance = 5
                var distanceindex = args.indexOf('-distance')
                if (distanceindex > -1) {
                    distance = isNaN(Number(args[distanceindex + 1])) ? 15 : Number(args[distanceindex + 1]) ?? 15
                }
                var fileinfo = await validateFile(currenturl).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })

                if (!fileinfo) return
                var type = fileinfo.type

                if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                    var filepath = await downloadFile(currenturl, `input.png`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.png`
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -filter_complex "[0]rgbashift=rh=${distance}:bv=${distance}:gh=${-distance},format=rgba[in2];[in2][0]scale2ref[in2][in1];[in1][in2]blend=overlay[out]" -map "[out]" -preset ${findpreset(args)} ${filepath}/output.png`)
                    await sendFile(msg, filepath, `output.png`)
                } else if (type.mime.startsWith('video')) {
                    var filepath = await downloadFile(currenturl, `input.mp4`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp4`
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -map 0:a? -filter_complex "[0]rgbashift=rh=${distance}:bv=${distance}:gh=${-distance},format=rgba[in2];[in2][0]scale2ref[in2][in1];[in1][in2]blend=overlay[oout];[oout]scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ${findpreset(args)} -c:v libx264 -pix_fmt yuv420p ${filepath}/output.mp4`)
                    await sendFile(msg, filepath, `output.mp4`)
                } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                    var filepath = await downloadFile(currenturl, `input.gif`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.gif`
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -filter_complex "[0]rgbashift=rh=${distance}:bv=${distance}:gh=${-distance},format=rgba[in2];[in2][0]scale2ref[in2][in1];[in1][in2]blend=overlay[oout];[oout]split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ${findpreset(args)} -gifflags -offsetting ${filepath}/output.gif`)
                    await sendFile(msg, filepath, `output.gif`)
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "dizzy <file> [-distance <distance>]",
                "value": "Adds a dizzy effect to the file."
            },
            cooldown: 2500,
            type: "Effects"
        },

        {
            name: ["hflip"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl']
                var fileinfo = await validateFile(currenturl).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })

                if (!fileinfo) return
                var type = fileinfo.type

                if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                    var filepath = await downloadFile(currenturl, `input.png`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.png`
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -filter_complex "[0:v]hflip[out]" -map "[out]" -preset ${findpreset(args)} ${filepath}/output.png`)
                    await sendFile(msg, filepath, `output.png`)
                } else if (type.mime.startsWith('video')) {
                    var filepath = await downloadFile(currenturl, `input.mp4`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp4`
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -map 0:a? -filter_complex "[0:v]hflip,scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ${findpreset(args)} -c:v libx264 -pix_fmt yuv420p ${filepath}/output.mp4`)
                    await sendFile(msg, filepath, `output.mp4`)
                } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                    var filepath = await downloadFile(currenturl, `input.gif`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.gif`
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -filter_complex "[0:v]hflip,split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ${findpreset(args)} -gifflags -offsetting ${filepath}/output.gif`)
                    await sendFile(msg, filepath, `output.gif`)
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "hflip <file>",
                "value": "Flips the file horizontally."
            },
            cooldown: 2500,
            type: "Mirroring"
        },

        {
            name: ["vflip"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl']
                var fileinfo = await validateFile(currenturl).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })

                if (!fileinfo) return
                var type = fileinfo.type

                if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                    var filepath = await downloadFile(currenturl, `input.png`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.png`
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -filter_complex "[0:v]vflip[out]" -map "[out]" -preset ${findpreset(args)} ${filepath}/output.png`)
                    await sendFile(msg, filepath, `output.png`)
                } else if (type.mime.startsWith('video')) {
                    var filepath = await downloadFile(currenturl, `input.mp4`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp4`
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -map 0:a? -filter_complex "[0:v]vflip,scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ${findpreset(args)} -c:v libx264 -pix_fmt yuv420p ${filepath}/output.mp4`)
                    await sendFile(msg, filepath, `output.mp4`)
                } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                    var filepath = await downloadFile(currenturl, `input.gif`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.gif`
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -filter_complex "[0:v]vflip,split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ${findpreset(args)} -gifflags -offsetting ${filepath}/output.gif`)
                    await sendFile(msg, filepath, `output.gif`)
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "vflip <file>",
                "value": "Flips the file vertically."
            },
            cooldown: 2500,
            type: "Mirroring"
        },

        {
            name: ["invert", "negate", "negative"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl']
                var fileinfo = await validateFile(currenturl).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })

                if (!fileinfo) return
                var type = fileinfo.type

                if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                    var filepath = await downloadFile(currenturl, `input.png`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.png`
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -filter_complex "[0:v]negate[out]" -map "[out]" -preset ${findpreset(args)} ${filepath}/output.png`)
                    await sendFile(msg, filepath, `output.png`)
                } else if (type.mime.startsWith('video')) {
                    var filepath = await downloadFile(currenturl, `input.mp4`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp4`
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -map 0:a? -filter_complex "[0:v]negate,scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ${findpreset(args)} -c:v libx264 -pix_fmt yuv420p ${filepath}/output.mp4`)
                    await sendFile(msg, filepath, `output.mp4`)
                } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                    var filepath = await downloadFile(currenturl, `input.gif`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.gif`
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -filter_complex "[0:v]negate,split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ${findpreset(args)} -gifflags -offsetting ${filepath}/output.gif`)
                    await sendFile(msg, filepath, `output.gif`)
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "invert/negate/negative <file>",
                "value": "Inverts the file's colors."
            },
            cooldown: 2500,
            type: "Effects"
        },

        {
            name: ["erode", "corrode"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var strength = 1
                var strengthindex = args.indexOf('-strength')
                if (strengthindex > -1) {
                    strength = isNaN(Number(args[strengthindex + 1])) ? 1 : Number(args[strengthindex + 1]) <= 1 ? 1 : Number(args[strengthindex + 1]) >= 100 ? 100 : Math.round(Number(args[strengthindex + 1])) || 1
                }
                var erosioncode = `erosion`
                var erosioncodes = []
                for (var i = 0; i < strength; i++) erosioncodes.push(erosioncode)
                var erosionscode = erosioncodes.join(',')
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl']
                var fileinfo = await validateFile(currenturl).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })

                if (!fileinfo) return
                var type = fileinfo.type

                if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                    var filepath = await downloadFile(currenturl, `input.png`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.png`
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -filter_complex "[0:v]${erosionscode}[out]" -map "[out]" -preset ${findpreset(args)} ${filepath}/output.png`)
                    await sendFile(msg, filepath, `output.png`)
                } else if (type.mime.startsWith('video')) {
                    var filepath = await downloadFile(currenturl, `input.mp4`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp4`
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -map 0:a? -filter_complex "[0:v]${erosionscode},scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ${findpreset(args)} -c:v libx264 -pix_fmt yuv420p ${filepath}/output.mp4`)
                    await sendFile(msg, filepath, `output.mp4`)
                } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                    var filepath = await downloadFile(currenturl, `input.gif`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.gif`
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -filter_complex "[0:v]${erosionscode},split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ${findpreset(args)} -gifflags -offsetting ${filepath}/output.gif`)
                    await sendFile(msg, filepath, `output.gif`)
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "erode/corrode <file> [-strength <number (max 100)>]",
                "value": "Erodes the file's colors. Default strength is 1."
            },
            cooldown: 2500,
            type: "Effects"
        },

        {
            name: ["dilate"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var strength = 1
                var strengthindex = args.indexOf('-strength')
                if (strengthindex > -1) {
                    strength = isNaN(Number(args[strengthindex + 1])) ? 1 : Number(args[strengthindex + 1]) <= 1 ? 1 : Number(args[strengthindex + 1]) >= 100 ? 100 : Math.round(Number(args[strengthindex + 1])) || 1
                }
                var dilationcode = `dilation`
                var dilationcodes = []
                for (var i = 0; i < strength; i++) dilationcodes.push(dilationcode)
                var dilationscode = dilationcodes.join(',')
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl']
                var fileinfo = await validateFile(currenturl).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })

                if (!fileinfo) return
                var type = fileinfo.type

                if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                    var filepath = await downloadFile(currenturl, `input.png`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.png`
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -filter_complex "[0:v]${dilationscode}[out]" -map "[out]" -preset ${findpreset(args)} ${filepath}/output.png`)
                    await sendFile(msg, filepath, `output.png`)
                } else if (type.mime.startsWith('video')) {
                    var filepath = await downloadFile(currenturl, `input.mp4`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp4`
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -map 0:a? -filter_complex "[0:v]${dilationscode},scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ${findpreset(args)} -c:v libx264 -pix_fmt yuv420p ${filepath}/output.mp4`)
                    await sendFile(msg, filepath, `output.mp4`)
                } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                    var filepath = await downloadFile(currenturl, `input.gif`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.gif`
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -filter_complex "[0:v]${dilationscode},split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ${findpreset(args)} -gifflags -offsetting ${filepath}/output.gif`)
                    await sendFile(msg, filepath, `output.gif`)
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "dilate <file> [-strength <number (max 100)>]",
                "value": "Dilates the file's colors. Default strength is 1."
            },
            cooldown: 2500,
            type: "Effects"
        },

        {
            name: ["lmirror", "mirrorl", "leftmirror", "mirrorleft"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl']
                var fileinfo = await validateFile(currenturl).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })

                if (!fileinfo) return
                var type = fileinfo.type

                if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                    var filepath = await downloadFile(currenturl, `input.png`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.png`
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -filter_complex "[0:v]split[left][right];[left]hflip,hflip,crop=iw/2:ih:0:0[leftside];[right]hflip,crop=iw/2:ih:iw/2:0[rightside];[leftside][rightside]hstack[out]" -map "[out]" -preset ${findpreset(args)} ${filepath}/output.png`)
                    await sendFile(msg, filepath, `output.png`)
                } else if (type.mime.startsWith('video')) {
                    var filepath = await downloadFile(currenturl, `input.mp4`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp4`
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -map 0:a? -filter_complex "[0:v]split[left][right];[left]hflip,hflip,crop=iw/2:ih:0:0[leftside];[right]hflip,crop=iw/2:ih:iw/2:0[rightside];[leftside][rightside]hstack[oout];[oout]scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ${findpreset(args)} -c:v libx264 -pix_fmt yuv420p ${filepath}/output.mp4`)
                    await sendFile(msg, filepath, `output.mp4`)
                } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                    var filepath = await downloadFile(currenturl, `input.gif`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.gif`
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -filter_complex "[0:v]split[left][right];[left]hflip,hflip,crop=iw/2:ih:0:0[leftside];[right]hflip,crop=iw/2:ih:iw/2:0[rightside];[leftside][rightside]hstack[oout];[oout]split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ${findpreset(args)} -gifflags -offsetting ${filepath}/output.gif`)
                    await sendFile(msg, filepath, `output.gif`)
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "leftmirror/mirrorleft/lmirror/mirrorl <file>",
                "value": "Mirrors the left side of the file."
            },
            cooldown: 2500,
            type: "Mirroring"
        },

        {
            name: ["rightmirror", "mirrorright", "rmirror", "mirrorr"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl']
                var fileinfo = await validateFile(currenturl).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })

                if (!fileinfo) return
                var type = fileinfo.type

                if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                    var filepath = await downloadFile(currenturl, `input.png`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.png`
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -filter_complex "[0:v]split[left][right];[left]hflip,crop=iw/2:ih:0:0[leftside];[right]hflip,hflip,crop=iw/2:ih:iw/2:0[rightside];[leftside][rightside]hstack[out]" -map "[out]" -preset ${findpreset(args)} ${filepath}/output.png`)
                    await sendFile(msg, filepath, `output.png`)
                } else if (type.mime.startsWith('video')) {
                    var filepath = await downloadFile(currenturl, `input.mp4`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp4`
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -map 0:a? -filter_complex "[0:v]split[left][right];[left]hflip,crop=iw/2:ih:0:0[leftside];[right]hflip,hflip,crop=iw/2:ih:iw/2:0[rightside];[leftside][rightside]hstack[oout];[oout]scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ${findpreset(args)} -c:v libx264 -pix_fmt yuv420p ${filepath}/output.mp4`)
                    await sendFile(msg, filepath, `output.mp4`)
                } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                    var filepath = await downloadFile(currenturl, `input.gif`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.gif`
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -filter_complex "[0:v]split[left][right];[left]hflip,crop=iw/2:ih:0:0[leftside];[right]hflip,hflip,crop=iw/2:ih:iw/2:0[rightside];[leftside][rightside]hstack[oout];[oout]split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ${findpreset(args)} -gifflags -offsetting ${filepath}/output.gif`)
                    await sendFile(msg, filepath, `output.gif`)
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "rightmirror/mirrorright/rmirror/mirrorr <file>",
                "value": "Mirrors the right side of the file."
            },
            cooldown: 2500,
            type: "Mirroring"
        },

        {
            name: ["topmirror", "mirrortop", "tmirror", "mirrort"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl']
                var fileinfo = await validateFile(currenturl).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })

                if (!fileinfo) return
                var type = fileinfo.type

                if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                    var filepath = await downloadFile(currenturl, `input.png`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.png`
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -filter_complex "[0:v]split[top][bottom];[top]vflip,vflip,crop=iw:ih/2:0:0[topside];[bottom]vflip,crop=iw:ih/2:0:ih/2[bottomside];[topside][bottomside]vstack[out]" -map "[out]" -preset ${findpreset(args)} ${filepath}/output.png`)
                    await sendFile(msg, filepath, `output.png`)
                } else if (type.mime.startsWith('video')) {
                    var filepath = await downloadFile(currenturl, `input.mp4`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp4`
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -map 0:a? -filter_complex "[0:v]split[top][bottom];[top]vflip,vflip,crop=iw:ih/2:0:0[topside];[bottom]vflip,crop=iw:ih/2:0:ih/2[bottomside];[topside][bottomside]vstack[oout];[oout]scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ${findpreset(args)} -c:v libx264 -pix_fmt yuv420p ${filepath}/output.mp4`)
                    await sendFile(msg, filepath, `output.mp4`)
                } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                    var filepath = await downloadFile(currenturl, `input.gif`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.gif`
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -filter_complex "[0:v]split[top][bottom];[top]vflip,vflip,crop=iw:ih/2:0:0[topside];[bottom]vflip,crop=iw:ih/2:0:ih/2[bottomside];[topside][bottomside]vstack[oout];[oout]split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ${findpreset(args)} -gifflags -offsetting ${filepath}/output.gif`)
                    await sendFile(msg, filepath, `output.gif`)
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "topmirror/mirrortop/tmirror/mirrort <file>",
                "value": "Mirrors the top side of the file."
            },
            cooldown: 2500,
            type: "Mirroring"
        },

        {
            name: ["bottommirror", "mirrorbottom", "bmirror", "mirrorb"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl']
                var fileinfo = await validateFile(currenturl).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })

                if (!fileinfo) return
                var type = fileinfo.type

                if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                    var filepath = await downloadFile(currenturl, `input.png`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.png`
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -filter_complex "[0:v]split[top][bottom];[top]vflip,crop=iw:ih/2:0:0[topside];[bottom]vflip,vflip,crop=iw:ih/2:0:ih/2[bottomside];[topside][bottomside]vstack[out]" -map "[out]" -preset ${findpreset(args)} ${filepath}/output.png`)
                    await sendFile(msg, filepath, `output.png`)
                } else if (type.mime.startsWith('video')) {
                    var filepath = await downloadFile(currenturl, `input.mp4`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp4`
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -map 0:a? -filter_complex "[0:v]split[top][bottom];[top]vflip,crop=iw:ih/2:0:0[topside];[bottom]vflip,vflip,crop=iw:ih/2:0:ih/2[bottomside];[topside][bottomside]vstack[oout];[oout]scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ${findpreset(args)} -c:v libx264 -pix_fmt yuv420p ${filepath}/output.mp4`)
                    await sendFile(msg, filepath, `output.mp4`)
                } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                    var filepath = await downloadFile(currenturl, `input.gif`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.gif`
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -filter_complex "[0:v]split[top][bottom];[top]vflip,crop=iw:ih/2:0:0[topside];[bottom]vflip,vflip,crop=iw:ih/2:0:ih/2[bottomside];[topside][bottomside]vstack[oout];[oout]split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ${findpreset(args)} -gifflags -offsetting ${filepath}/output.gif`)
                    await sendFile(msg, filepath, `output.gif`)
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "bottommirror/mirrorbottom/bmirror/mirrorb <file>",
                "value": "Mirrors the bottom side of the file."
            },
            cooldown: 2500,
            type: "Mirroring"
        },

        {
            name: ["rainbow", "disco"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var duration = 1
                var durationindex = args.indexOf('-duration')
                if (durationindex > -1) {
                    duration = isNaN(Number(args[durationindex + 1])) ? 1 : Number(args[durationindex + 1]) <= 0.1 ? 0.1 : Number(args[durationindex + 1]) >= 10 ? 10 : Number(args[durationindex + 1]) || 1
                }
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl']
                var fileinfo = await validateFile(currenturl).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })

                if (!fileinfo) return
                var type = fileinfo.type

                if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                    var filepath = await downloadFile(currenturl, `input.png`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.png`
                    await execPromise(`ffmpeg -stream_loop -1 -t ${duration} -r 50 -i ${filepath}/${filename} -filter_complex "[0:v]hue=s=0,negate,curves=r='0/0 1/1':g='0/0 1/0':b='0/0 1/0',hue=H=(PI*2)*(t/${duration}-0.5),negate,scale='min(400,iw)':min'(400,ih)':force_original_aspect_ratio=decrease,split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ${findpreset(args)} -gifflags -offsetting ${filepath}/output.gif`)
                    await sendFile(msg, filepath, `output.gif`)
                } else if (type.mime.startsWith('video')) {
                    var filepath = await downloadFile(currenturl, `input.mp4`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp4`
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -map 0:a? -filter_complex "[0:v]hue=s=0,negate,curves=r='0/0 1/1':g='0/0 1/0':b='0/0 1/0',hue=H=(PI*2)*(t/${duration}-0.5),negate,scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ${findpreset(args)} -c:v libx264 -pix_fmt yuv420p ${filepath}/output.mp4`)
                    await sendFile(msg, filepath, `output.mp4`)
                } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                    var filepath = await downloadFile(currenturl, `input.gif`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.gif`
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -filter_complex "[0:v]hue=s=0,negate,curves=r='0/0 1/1':g='0/0 1/0':b='0/0 1/0',hue=H=(PI*2)*(t/${duration}-0.5),negate,split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ${findpreset(args)} -gifflags -offsetting ${filepath}/output.gif`)
                    await sendFile(msg, filepath, `output.gif`)
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "rainbow/disco <file> [-duration <seconds (max 10)>]",
                "value": "Adds a rainbow effect to the file."
            },
            cooldown: 2500,
            type: "Color"
        },

        {
            name: ["enlarge"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl']
                var multiplier = isNaN(Number(args[1])) ? 2 : Number(args[1]) <= 1 ? 1 : Number(args[1]) >= 6 ? 6 : Number(args[1]) || 2
                var flags = [
                    'fast_bilinear',
                    'bilinear',
                    'bicubic',
                    'experimental',
                    'neighbor',
                    'area',
                    'bicublin',
                    'gauss',
                    'sinc',
                    'lanczos',
                    'spline',
                    'print_info',
                    'accurate_rnd',
                    'full_chroma_int',
                    'full_chroma_inp',
                    'bitexact'
                ]
                var flag = undefined
                var flagsindex = args.indexOf('-flags')
                if (flagsindex > -1) {
                    if (flags.find(flag => flag === args[flagsindex + 1].toLowerCase())) {
                        flag = args[flagsindex + 1]
                    } else {
                        msg.channel.send('Not a supported flag.').catch(() => { })
                        return
                    }
                }
                var fileinfo = await validateFile(currenturl).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })

                if (!fileinfo) return
                var type = fileinfo.type

                if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                    var filepath = await downloadFile(currenturl, `input.png`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.png`
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -filter_complex "[0:v]scale=round(iw*${multiplier}):round(ih*${multiplier})${flag ? `:flags=${flag}` : ''}[out]" -map "[out]" -preset ${findpreset(args)} ${filepath}/output.png`)
                    await sendFile(msg, filepath, `output.png`)
                } else if (type.mime.startsWith('video')) {
                    var filepath = await downloadFile(currenturl, `input.mp4`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp4`
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -map 0:a? -filter_complex "[0:v]scale=round(iw*${multiplier}):round(ih*${multiplier})${flag ? `:flags=${flag}` : ''},scale=ceil(iw/2)*2:ceil(ih/2)*2${flag ? `:flags=${flag}` : ''}[out]" -map "[out]" -preset ${findpreset(args)} -c:v libx264 -pix_fmt yuv420p ${filepath}/output.mp4`)
                    await sendFile(msg, filepath, `output.mp4`)
                } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                    var filepath = await downloadFile(currenturl, `input.gif`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.gif`
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -filter_complex "[0:v]scale=round(iw*${multiplier}):round(ih*${multiplier})${flag ? `:flags=${flag}` : ''},split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ${findpreset(args)} -gifflags -offsetting ${filepath}/output.gif`)
                    await sendFile(msg, filepath, `output.gif`)
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "enlarge [multiplier (from 1 to 6)] <file> [-flags <algorithm>]",
                "value": "Enlarges the file. A list of flags can be found at https://ffmpeg.org/ffmpeg-scaler.html#Scaler-Options"
            },
            cooldown: 2500,
            type: "Resizing"
        },

        {
            name: ["shrink"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl']
                var multiplier = isNaN(Number(args[1])) ? 2 : Number(args[1]) <= 1 ? 1 : Number(args[1]) >= 6 ? 6 : Number(args[1]) || 2
                var flags = [
                    'fast_bilinear',
                    'bilinear',
                    'bicubic',
                    'experimental',
                    'neighbor',
                    'area',
                    'bicublin',
                    'gauss',
                    'sinc',
                    'lanczos',
                    'spline',
                    'print_info',
                    'accurate_rnd',
                    'full_chroma_int',
                    'full_chroma_inp',
                    'bitexact'
                ]
                var flag = undefined
                var flagsindex = args.indexOf('-flags')
                if (flagsindex > -1) {
                    if (flags.find(flag => flag === args[flagsindex + 1].toLowerCase())) {
                        flag = args[flagsindex + 1]
                    } else {
                        msg.channel.send('Not a supported flag.').catch(() => { })
                        return
                    }
                }
                var fileinfo = await validateFile(currenturl, true).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })

                if (!fileinfo) return
                var type = fileinfo.type

                if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                    var filepath = await downloadFile(currenturl, `input.png`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.png`
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -filter_complex "[0:v]scale=round(iw/${multiplier}):round(ih/${multiplier})${flag ? `:flags=${flag}` : ''}[out]" -map "[out]" -preset ${findpreset(args)} ${filepath}/output.png`)
                    await sendFile(msg, filepath, `output.png`)
                } else if (type.mime.startsWith('video')) {
                    var filepath = await downloadFile(currenturl, `input.mp4`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp4`
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -map 0:a? -filter_complex "[0:v]scale=round(iw/${multiplier}):round(ih/${multiplier})${flag ? `:flags=${flag}` : ''},scale=ceil(iw/2)*2:ceil(ih/2)*2${flag ? `:flags=${flag}` : ''}[out]" -map "[out]" -preset ${findpreset(args)} -c:v libx264 -pix_fmt yuv420p ${filepath}/output.mp4`)
                    await sendFile(msg, filepath, `output.mp4`)
                } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                    var filepath = await downloadFile(currenturl, `input.gif`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.gif`
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -filter_complex "[0:v]scale=round(iw/${multiplier}):round(ih/${multiplier})${flag ? `:flags=${flag}` : ''},split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ${findpreset(args)} -gifflags -offsetting ${filepath}/output.gif`)
                    await sendFile(msg, filepath, `output.gif`)
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "shrink [multiplier (from 1 to 6)] <file> [-flags <algorithm>]",
                "value": "Shrinks the file. A list of flags can be found at https://ffmpeg.org/ffmpeg-scaler.html#Scaler-Options"
            },
            cooldown: 2500,
            type: "Resizing"
        },

        {
            name: ["perspective"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl']
                var fileinfo = await validateFile(currenturl, true).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })

                if (!fileinfo) return
                var type = fileinfo.type

                if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                    var filepath = await downloadFile(currenturl, `input.png`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.png`
                    var width = fileinfo.info.width
                    var height = fileinfo.info.height

                    var points = {
                        tl: [0, 0],
                        tr: [width, 0],
                        bl: [0, height],
                        br: [width, height]
                    }

                    for (var i in points) {
                        var pointindex = args.indexOf(`-${i}`)
                        if (pointindex > -1) {
                            var xpercentage = String(args[pointindex + 1]).endsWith('%')
                            if (xpercentage) {
                                args[pointindex + 1] = args[pointindex + 1].substring(0, args[pointindex + 1].length - 1)
                            }
                            points[i][0] = (xpercentage ? width : 1) * ((isNaN(Number(args[pointindex + 1])) ? points[i][0] : Number(args[pointindex + 1]) || points[i][0]) / (xpercentage ? 100 : 1))

                            var ypercentage = String(args[pointindex + 2]).endsWith('%')
                            if (ypercentage) {
                                args[pointindex + 2] = args[pointindex + 2].substring(0, args[pointindex + 2].length - 1)
                            }
                            points[i][1] = (ypercentage ? height : 1) * ((isNaN(Number(args[pointindex + 2])) ? points[i][1] : Number(args[pointindex + 2]) || points[i][1]) / (ypercentage ? 100 : 1))
                        }
                    }

                    await execPromise(`ffmpeg -i ${filepath}/${filename} -filter_complex "[0:v]perspective=${points['tl'][0]}:${points['tl'][1]}:${points['tr'][0]}:${points['tr'][1]}:${points['bl'][0]}:${points['bl'][1]}:${points['br'][0]}:${points['br'][1]}[out]" -map "[out]" -preset ${findpreset(args)} ${filepath}/output.png`)
                    await sendFile(msg, filepath, `output.png`)
                } else if (type.mime.startsWith('video')) {
                    var filepath = await downloadFile(currenturl, `input.mp4`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp4`
                    var width = fileinfo.info.width
                    var height = fileinfo.info.height

                    var points = {
                        tl: [0, 0],
                        tr: [width, 0],
                        bl: [0, height],
                        br: [width, height]
                    }

                    for (var i in points) {
                        var pointindex = args.indexOf(`-${i}`)
                        if (pointindex > -1) {
                            var xpercentage = String(args[pointindex + 1]).endsWith('%')
                            if (xpercentage) {
                                args[pointindex + 1] = args[pointindex + 1].substring(0, args[pointindex + 1].length - 1)
                            }
                            points[i][0] = (xpercentage ? width : 1) * ((isNaN(Number(args[pointindex + 1])) ? points[i][0] : Number(args[pointindex + 1]) || points[i][0]) / (xpercentage ? 100 : 1))

                            var ypercentage = String(args[pointindex + 2]).endsWith('%')
                            if (ypercentage) {
                                args[pointindex + 2] = args[pointindex + 2].substring(0, args[pointindex + 2].length - 1)
                            }
                            points[i][1] = (ypercentage ? height : 1) * ((isNaN(Number(args[pointindex + 2])) ? points[i][1] : Number(args[pointindex + 2]) || points[i][1]) / (ypercentage ? 100 : 1))
                        }
                    }

                    await execPromise(`ffmpeg -i ${filepath}/${filename} -map 0:a? -filter_complex "[0:v]perspective=${points['tl'][0]}:${points['tl'][1]}:${points['tr'][0]}:${points['tr'][1]}:${points['bl'][0]}:${points['bl'][1]}:${points['br'][0]}:${points['br'][1]},scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ${findpreset(args)} -c:v libx264 -pix_fmt yuv420p ${filepath}/output.mp4`)
                    await sendFile(msg, filepath, `output.mp4`)
                } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                    var filepath = await downloadFile(currenturl, `input.gif`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.gif`
                    var width = fileinfo.info.width
                    var height = fileinfo.info.height

                    var points = {
                        tl: [0, 0],
                        tr: [width, 0],
                        bl: [0, height],
                        br: [width, height]
                    }

                    for (var i in points) {
                        var pointindex = args.indexOf(`-${i}`)
                        if (pointindex > -1) {
                            var xpercentage = String(args[pointindex + 1]).endsWith('%')
                            if (xpercentage) {
                                args[pointindex + 1] = args[pointindex + 1].substring(0, args[pointindex + 1].length - 1)
                            }
                            points[i][0] = (xpercentage ? width : 1) * ((isNaN(Number(args[pointindex + 1])) ? points[i][0] : Number(args[pointindex + 1]) || points[i][0]) / (xpercentage ? 100 : 1))

                            var ypercentage = String(args[pointindex + 2]).endsWith('%')
                            if (ypercentage) {
                                args[pointindex + 2] = args[pointindex + 2].substring(0, args[pointindex + 2].length - 1)
                            }
                            points[i][1] = (ypercentage ? height : 1) * ((isNaN(Number(args[pointindex + 2])) ? points[i][1] : Number(args[pointindex + 2]) || points[i][1]) / (ypercentage ? 100 : 1))
                        }
                    }

                    await execPromise(`ffmpeg -i ${filepath}/${filename} -filter_complex "[0:v]perspective=${points['tl'][0]}:${points['tl'][1]}:${points['tr'][0]}:${points['tr'][1]}:${points['bl'][0]}:${points['bl'][1]}:${points['br'][0]}:${points['br'][1]},split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ${findpreset(args)} -gifflags -offsetting ${filepath}/output.gif`)
                    await sendFile(msg, filepath, `output.gif`)
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "perspective <file> [-tl <x> <y> (pixels or percentage)] [-tr <x> <y> (pixels or percentage)] [-bl <x> <y> (pixels or percentage)] [-br <x> <y> (pixels or percentage)]",
                "value": "Changes the perspective of the file depending on the coordinates specified for each point."
            },
            cooldown: 2500,
            type: "Resizing"
        },

        {
            name: ["zoomout"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl']
                var multiplier = isNaN(Number(args[1])) ? 2 : Number(args[1]) <= 1 ? 1 : Number(args[1]) >= 6 ? 6 : Number(args[1]) || 2
                var flags = [
                    'fast_bilinear',
                    'bilinear',
                    'bicubic',
                    'experimental',
                    'neighbor',
                    'area',
                    'bicublin',
                    'gauss',
                    'sinc',
                    'lanczos',
                    'spline',
                    'print_info',
                    'accurate_rnd',
                    'full_chroma_int',
                    'full_chroma_inp',
                    'bitexact'
                ]
                var flag = undefined
                var flagsindex = args.indexOf('-flags')
                if (flagsindex > -1) {
                    if (flags.find(flag => flag === args[flagsindex + 1].toLowerCase())) {
                        flag = args[flagsindex + 1]
                    } else {
                        msg.channel.send('Not a supported flag.').catch(() => { })
                        return
                    }
                }
                var origins = {
                    x: {
                        left: '0',
                        center: '(W-w)/2',
                        right: '(W-w)'
                    },

                    y: {
                        top: '0',
                        middle: '(H-h)/2',
                        bottom: '(H-h)'
                    },
                }
                var originx = '(W-w)/2'
                var originy = '(H-h)/2'
                var originindex = args.indexOf('-origin')
                if (originindex > -1) {
                    originx = origins.x[args[originindex + 1]] || '(W-w)/2'
                    originy = origins.y[args[originindex + 2]] || '(H-h)/2'
                }
                var fileinfo = await validateFile(currenturl, true).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })

                if (!fileinfo) return
                var type = fileinfo.type

                if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                    var filepath = await downloadFile(currenturl, `input.png`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.png`
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -i templates/transparent.png -filter_complex "[1:v][0:v]scale2ref[background][input];[input]scale=round(iw/${multiplier}):round(ih/${multiplier})${flag ? `:flags=${flag}` : ''}[overlay];[background][overlay]overlay=x=${originx}:y=${originy}:format=auto[out]" -map "[out]" -preset ${findpreset(args)} -aspect ${fileinfo.info.width}:${fileinfo.info.height} ${filepath}/output.png`)
                    await sendFile(msg, filepath, `output.png`)
                } else if (type.mime.startsWith('video')) {
                    var filepath = await downloadFile(currenturl, `input.mp4`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp4`
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -i templates/transparent.png -map 0:a? -filter_complex "[1:v][0:v]scale2ref[background][input];[input]scale=round(iw/${multiplier}):round(ih/${multiplier})${flag ? `:flags=${flag}` : ''}[overlay];[background][overlay]overlay=x=${originx}:y=${originy}:format=auto,scale=ceil(iw/2)*2:ceil(ih/2)*2${flag ? `:flags=${flag}` : ''}[out]" -map "[out]" -preset ${findpreset(args)} -aspect ${fileinfo.info.width}:${fileinfo.info.height} -c:v libx264 -pix_fmt yuv420p ${filepath}/output.mp4`)
                    await sendFile(msg, filepath, `output.mp4`)
                } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                    var filepath = await downloadFile(currenturl, `input.gif`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.gif`
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -i templates/transparent.png -filter_complex "[1:v][0:v]scale2ref[background][input];[input]scale=round(iw/${multiplier}):round(ih/${multiplier})${flag ? `:flags=${flag}` : ''}[overlay];[background][overlay]overlay=x=${originx}:y=${originy}:format=auto,split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ${findpreset(args)} -aspect ${fileinfo.info.width}:${fileinfo.info.height} -gifflags -offsetting ${filepath}/output.gif`)
                    await sendFile(msg, filepath, `output.gif`)
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "zoomout [multiplier (from 1 to 6)] <file> [-origin <x (left/center/right)> <y (top/middle/bottom)>] [-flags <algorithm>]",
                "value": "Zooms the file out. A list of flags can be found at https://ffmpeg.org/ffmpeg-scaler.html#Scaler-Options"
            },
            cooldown: 2500,
            type: "Resizing"
        },

        {
            name: ["hzoomout"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl']
                var multiplier = isNaN(Number(args[1])) ? 2 : Number(args[1]) <= 1 ? 1 : Number(args[1]) >= 6 ? 6 : Number(args[1]) || 2
                var flags = [
                    'fast_bilinear',
                    'bilinear',
                    'bicubic',
                    'experimental',
                    'neighbor',
                    'area',
                    'bicublin',
                    'gauss',
                    'sinc',
                    'lanczos',
                    'spline',
                    'print_info',
                    'accurate_rnd',
                    'full_chroma_int',
                    'full_chroma_inp',
                    'bitexact'
                ]
                var flag = undefined
                var flagsindex = args.indexOf('-flags')
                if (flagsindex > -1) {
                    if (flags.find(flag => flag === args[flagsindex + 1].toLowerCase())) {
                        flag = args[flagsindex + 1]
                    } else {
                        msg.channel.send('Not a supported flag.').catch(() => { })
                        return
                    }
                }
                var origins = {
                    x: {
                        left: '0',
                        center: '(W-w)/2',
                        right: '(W-w)'
                    },

                    y: {
                        top: '0',
                        middle: '(H-h)/2',
                        bottom: '(H-h)'
                    },
                }
                var originx = '(W-w)/2'
                var originy = '(H-h)/2'
                var originindex = args.indexOf('-origin')
                if (originindex > -1) {
                    originx = origins.x[args[originindex + 1]] || '(W-w)/2'
                    originy = origins.y[args[originindex + 2]] || '(H-h)/2'
                }
                var fileinfo = await validateFile(currenturl, true).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })

                if (!fileinfo) return
                var type = fileinfo.type

                if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                    var filepath = await downloadFile(currenturl, `input.png`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.png`
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -i templates/transparent.png -filter_complex "[1:v][0:v]scale2ref[background][input];[input]scale=round(iw/${multiplier}):ih${flag ? `:flags=${flag}` : ''}[overlay];[background][overlay]overlay=x=${originx}:y=${originy}:format=auto[out]" -map "[out]" -preset ${findpreset(args)} -aspect ${fileinfo.info.width}:${fileinfo.info.height} ${filepath}/output.png`)
                    await sendFile(msg, filepath, `output.png`)
                } else if (type.mime.startsWith('video')) {
                    var filepath = await downloadFile(currenturl, `input.mp4`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp4`
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -i templates/transparent.png -map 0:a? -filter_complex "[1:v][0:v]scale2ref[background][input];[input]scale=round(iw/${multiplier}):ih${flag ? `:flags=${flag}` : ''}[overlay];[background][overlay]overlay=x=${originx}:y=${originy}:format=auto,scale=ceil(iw/2)*2:ceil(ih/2)*2${flag ? `:flags=${flag}` : ''}[out]" -map "[out]" -preset ${findpreset(args)} -aspect ${fileinfo.info.width}:${fileinfo.info.height} -c:v libx264 -pix_fmt yuv420p ${filepath}/output.mp4`)
                    await sendFile(msg, filepath, `output.mp4`)
                } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                    var filepath = await downloadFile(currenturl, `input.gif`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.gif`
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -i templates/transparent.png -filter_complex "[1:v][0:v]scale2ref[background][input];[input]scale=round(iw/${multiplier}):ih${flag ? `:flags=${flag}` : ''}[overlay];[background][overlay]overlay=x=${originx}:y=${originy}:format=auto,split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ${findpreset(args)} -aspect ${fileinfo.info.width}:${fileinfo.info.height} -gifflags -offsetting ${filepath}/output.gif`)
                    await sendFile(msg, filepath, `output.gif`)
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "hzoomout [multiplier (from 1 to 6)] <file> [-origin <x (left/center/right)> <y (top/middle/bottom)>]",
                "value": "Zooms the file out horizontally. A list of flags can be found at https://ffmpeg.org/ffmpeg-scaler.html#Scaler-Options"
            },
            cooldown: 2500,
            type: "Resizing"
        },

        {
            name: ["vzoomout"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl']
                var multiplier = isNaN(Number(args[1])) ? 2 : Number(args[1]) <= 1 ? 1 : Number(args[1]) >= 6 ? 6 : Number(args[1]) || 2
                var flags = [
                    'fast_bilinear',
                    'bilinear',
                    'bicubic',
                    'experimental',
                    'neighbor',
                    'area',
                    'bicublin',
                    'gauss',
                    'sinc',
                    'lanczos',
                    'spline',
                    'print_info',
                    'accurate_rnd',
                    'full_chroma_int',
                    'full_chroma_inp',
                    'bitexact'
                ]
                var flag = undefined
                var flagsindex = args.indexOf('-flags')
                if (flagsindex > -1) {
                    if (flags.find(flag => flag === args[flagsindex + 1].toLowerCase())) {
                        flag = args[flagsindex + 1]
                    } else {
                        msg.channel.send('Not a supported flag.').catch(() => { })
                        return
                    }
                }
                var origins = {
                    x: {
                        left: '0',
                        center: '(W-w)/2',
                        right: '(W-w)'
                    },

                    y: {
                        top: '0',
                        middle: '(H-h)/2',
                        bottom: '(H-h)'
                    },
                }
                var originx = '(W-w)/2'
                var originy = '(H-h)/2'
                var originindex = args.indexOf('-origin')
                if (originindex > -1) {
                    originx = origins.x[args[originindex + 1]] || '(W-w)/2'
                    originy = origins.y[args[originindex + 2]] || '(H-h)/2'
                }
                var fileinfo = await validateFile(currenturl, true).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })

                if (!fileinfo) return
                var type = fileinfo.type

                if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                    var filepath = await downloadFile(currenturl, `input.png`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.png`
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -i templates/transparent.png -filter_complex "[1:v][0:v]scale2ref[background][input];[input]scale=iw:round(ih/${multiplier})${flag ? `:flags=${flag}` : ''}[overlay];[background][overlay]overlay=x=${originx}:y=${originy}:format=auto[out]" -map "[out]" -preset ${findpreset(args)} -aspect ${fileinfo.info.width}:${fileinfo.info.height} ${filepath}/output.png`)
                    await sendFile(msg, filepath, `output.png`)
                } else if (type.mime.startsWith('video')) {
                    var filepath = await downloadFile(currenturl, `input.mp4`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp4`
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -i templates/transparent.png -map 0:a? -filter_complex "[1:v][0:v]scale2ref[background][input];[input]scale=iw:round(ih/${multiplier})${flag ? `:flags=${flag}` : ''}[overlay];[background][overlay]overlay=x=${originx}:y=${originy}:format=auto,scale=ceil(iw/2)*2:ceil(ih/2)*2${flag ? `:flags=${flag}` : ''}[out]" -map "[out]" -preset ${findpreset(args)} -aspect ${fileinfo.info.width}:${fileinfo.info.height} -c:v libx264 -pix_fmt yuv420p ${filepath}/output.mp4`)
                    await sendFile(msg, filepath, `output.mp4`)
                } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                    var filepath = await downloadFile(currenturl, `input.gif`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.gif`
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -i templates/transparent.png -filter_complex "[1:v][0:v]scale2ref[background][input];[input]scale=iw:round(ih/${multiplier})${flag ? `:flags=${flag}` : ''}[overlay];[background][overlay]overlay=x=${originx}:y=${originy}:format=auto,split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ${findpreset(args)} -aspect ${fileinfo.info.width}:${fileinfo.info.height} -gifflags -offsetting ${filepath}/output.gif`)
                    await sendFile(msg, filepath, `output.gif`)
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "vzoomout [multiplier (from 1 to 6)] <file> [-origin <x (left/center/right)> <y (top/middle/bottom)>] [-flags <algorithm>]",
                "value": "Zooms the file out vertically. A list of flags can be found at https://ffmpeg.org/ffmpeg-scaler.html#Scaler-Options"
            },
            cooldown: 2500,
            type: "Resizing"
        },

        {
            name: ["zoomin"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl']
                var multiplier = isNaN(Number(args[1])) ? 2 : Number(args[1]) <= 1 ? 1 : Number(args[1]) >= 6 ? 6 : Number(args[1]) || 2
                var flags = [
                    'fast_bilinear',
                    'bilinear',
                    'bicubic',
                    'experimental',
                    'neighbor',
                    'area',
                    'bicublin',
                    'gauss',
                    'sinc',
                    'lanczos',
                    'spline',
                    'print_info',
                    'accurate_rnd',
                    'full_chroma_int',
                    'full_chroma_inp',
                    'bitexact'
                ]
                var flag = undefined
                var flagsindex = args.indexOf('-flags')
                if (flagsindex > -1) {
                    if (flags.find(flag => flag === args[flagsindex + 1].toLowerCase())) {
                        flag = args[flagsindex + 1]
                    } else {
                        msg.channel.send('Not a supported flag.').catch(() => { })
                        return
                    }
                }
                var origins = {
                    x: {
                        left: '0',
                        center: '(W-w)/2',
                        right: '(W-w)'
                    },

                    y: {
                        top: '0',
                        middle: '(H-h)/2',
                        bottom: '(H-h)'
                    },
                }
                var originx = '(W-w)/2'
                var originy = '(H-h)/2'
                var originindex = args.indexOf('-origin')
                if (originindex > -1) {
                    originx = origins.x[args[originindex + 1]] || '(W-w)/2'
                    originy = origins.y[args[originindex + 2]] || '(H-h)/2'
                }
                var fileinfo = await validateFile(currenturl, true).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })

                if (!fileinfo) return
                var type = fileinfo.type

                if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                    var filepath = await downloadFile(currenturl, `input.png`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.png`
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -i templates/transparent.png -filter_complex "[1:v][0:v]scale2ref[background][input];[input]scale=round(iw*${multiplier}):round(ih*${multiplier})${flag ? `:flags=${flag}` : ''}[overlay];[background][overlay]overlay=x=${originx}:y=${originy}:format=auto[out]" -map "[out]" -preset ${findpreset(args)} -aspect ${fileinfo.info.width}:${fileinfo.info.height} ${filepath}/output.png`)
                    await sendFile(msg, filepath, `output.png`)
                } else if (type.mime.startsWith('video')) {
                    var filepath = await downloadFile(currenturl, `input.mp4`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp4`
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -i templates/transparent.png -map 0:a? -filter_complex "[1:v][0:v]scale2ref[background][input];[input]scale=round(iw*${multiplier}):round(ih*${multiplier})${flag ? `:flags=${flag}` : ''}[overlay];[background][overlay]overlay=x=${originx}:y=${originy}:format=auto,scale=ceil(iw/2)*2:ceil(ih/2)*2${flag ? `:flags=${flag}` : ''}[out]" -map "[out]" -preset ${findpreset(args)} -aspect ${fileinfo.info.width}:${fileinfo.info.height} -c:v libx264 -pix_fmt yuv420p ${filepath}/output.mp4`)
                    await sendFile(msg, filepath, `output.mp4`)
                } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                    var filepath = await downloadFile(currenturl, `input.gif`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.gif`
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -i templates/transparent.png -filter_complex "[1:v][0:v]scale2ref[background][input];[input]scale=round(iw*${multiplier}):round(ih*${multiplier})${flag ? `:flags=${flag}` : ''}[overlay];[background][overlay]overlay=x=${originx}:y=${originy}:format=auto,split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ${findpreset(args)} -aspect ${fileinfo.info.width}:${fileinfo.info.height} -gifflags -offsetting ${filepath}/output.gif`)
                    await sendFile(msg, filepath, `output.gif`)
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "zoomin [multiplier (from 1 to 6)] <file> [-origin <x (left/center/right)> <y (top/middle/bottom)>] [-flags <algorithm>]",
                "value": "Zooms the file in. A list of flags can be found at https://ffmpeg.org/ffmpeg-scaler.html#Scaler-Options"
            },
            cooldown: 2500,
            type: "Resizing"
        },

        {
            name: ["hzoomin"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl']
                var multiplier = isNaN(Number(args[1])) ? 2 : Number(args[1]) <= 1 ? 1 : Number(args[1]) >= 6 ? 6 : Number(args[1]) || 2
                var flags = [
                    'fast_bilinear',
                    'bilinear',
                    'bicubic',
                    'experimental',
                    'neighbor',
                    'area',
                    'bicublin',
                    'gauss',
                    'sinc',
                    'lanczos',
                    'spline',
                    'print_info',
                    'accurate_rnd',
                    'full_chroma_int',
                    'full_chroma_inp',
                    'bitexact'
                ]
                var flag = undefined
                var flagsindex = args.indexOf('-flags')
                if (flagsindex > -1) {
                    if (flags.find(flag => flag === args[flagsindex + 1].toLowerCase())) {
                        flag = args[flagsindex + 1]
                    } else {
                        msg.channel.send('Not a supported flag.').catch(() => { })
                        return
                    }
                }
                var origins = {
                    x: {
                        left: '0',
                        center: '(W-w)/2',
                        right: '(W-w)'
                    },

                    y: {
                        top: '0',
                        middle: '(H-h)/2',
                        bottom: '(H-h)'
                    },
                }
                var originx = '(W-w)/2'
                var originy = '(H-h)/2'
                var originindex = args.indexOf('-origin')
                if (originindex > -1) {
                    originx = origins.x[args[originindex + 1]] || '(W-w)/2'
                    originy = origins.y[args[originindex + 2]] || '(H-h)/2'
                }
                var fileinfo = await validateFile(currenturl, true).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })

                if (!fileinfo) return
                var type = fileinfo.type

                if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                    var filepath = await downloadFile(currenturl, `input.png`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.png`
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -i templates/transparent.png -filter_complex "[1:v][0:v]scale2ref[background][input];[input]scale=round(iw*${multiplier}):ih${flag ? `:flags=${flag}` : ''}[overlay];[background][overlay]overlay=x=${originx}:y=${originy}:format=auto[out]" -map "[out]" -preset ${findpreset(args)} -aspect ${fileinfo.info.width}:${fileinfo.info.height} ${filepath}/output.png`)
                    await sendFile(msg, filepath, `output.png`)
                } else if (type.mime.startsWith('video')) {
                    var filepath = await downloadFile(currenturl, `input.mp4`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp4`
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -i templates/transparent.png -map 0:a? -filter_complex "[1:v][0:v]scale2ref[background][input];[input]scale=round(iw*${multiplier}):ih${flag ? `:flags=${flag}` : ''}[overlay];[background][overlay]overlay=x=${originx}:y=${originy}:format=auto,scale=ceil(iw/2)*2:ceil(ih/2)*2${flag ? `:flags=${flag}` : ''}[out]" -map "[out]" -preset ${findpreset(args)} -aspect ${fileinfo.info.width}:${fileinfo.info.height} -c:v libx264 -pix_fmt yuv420p ${filepath}/output.mp4`)
                    await sendFile(msg, filepath, `output.mp4`)
                } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                    var filepath = await downloadFile(currenturl, `input.gif`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.gif`
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -i templates/transparent.png -filter_complex "[1:v][0:v]scale2ref[background][input];[input]scale=round(iw*${multiplier}):ih${flag ? `:flags=${flag}` : ''}[overlay];[background][overlay]overlay=x=${originx}:y=${originy}:format=auto,split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ${findpreset(args)} -aspect ${fileinfo.info.width}:${fileinfo.info.height} -gifflags -offsetting ${filepath}/output.gif`)
                    await sendFile(msg, filepath, `output.gif`)
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "hzoomin [multiplier (from 1 to 6)] <file> [-origin <x (left/center/right)> <y (top/middle/bottom)>] [-flags <algorithm>]",
                "value": "Zooms the file in horizontally. A list of flags can be found at https://ffmpeg.org/ffmpeg-scaler.html#Scaler-Options"
            },
            cooldown: 2500,
            type: "Resizing"
        },

        {
            name: ["vzoomin"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl']
                var multiplier = isNaN(Number(args[1])) ? 2 : Number(args[1]) <= 1 ? 1 : Number(args[1]) >= 6 ? 6 : Number(args[1]) || 2
                var flags = [
                    'fast_bilinear',
                    'bilinear',
                    'bicubic',
                    'experimental',
                    'neighbor',
                    'area',
                    'bicublin',
                    'gauss',
                    'sinc',
                    'lanczos',
                    'spline',
                    'print_info',
                    'accurate_rnd',
                    'full_chroma_int',
                    'full_chroma_inp',
                    'bitexact'
                ]
                var flag = undefined
                var flagsindex = args.indexOf('-flags')
                if (flagsindex > -1) {
                    if (flags.find(flag => flag === args[flagsindex + 1].toLowerCase())) {
                        flag = args[flagsindex + 1]
                    } else {
                        msg.channel.send('Not a supported flag.').catch(() => { })
                        return
                    }
                }
                var origins = {
                    x: {
                        left: '0',
                        center: '(W-w)/2',
                        right: '(W-w)'
                    },

                    y: {
                        top: '0',
                        middle: '(H-h)/2',
                        bottom: '(H-h)'
                    },
                }
                var originx = '(W-w)/2'
                var originy = '(H-h)/2'
                var originindex = args.indexOf('-origin')
                if (originindex > -1) {
                    originx = origins.x[args[originindex + 1]] || '(W-w)/2'
                    originy = origins.y[args[originindex + 2]] || '(H-h)/2'
                }
                var fileinfo = await validateFile(currenturl, true).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })

                if (!fileinfo) return
                var type = fileinfo.type

                if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                    var filepath = await downloadFile(currenturl, `input.png`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.png`
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -i templates/transparent.png -filter_complex "[1:v][0:v]scale2ref[background][input];[input]scale=iw:round(ih*${multiplier})${flag ? `:flags=${flag}` : ''}[overlay];[background][overlay]overlay=x=${originx}:y=${originy}:format=auto[out]" -map "[out]" -preset ${findpreset(args)} -aspect ${fileinfo.info.width}:${fileinfo.info.height} ${filepath}/output.png`)
                    await sendFile(msg, filepath, `output.png`)
                } else if (type.mime.startsWith('video')) {
                    var filepath = await downloadFile(currenturl, `input.mp4`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp4`
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -i templates/transparent.png -map 0:a? -filter_complex "[1:v][0:v]scale2ref[background][input];[input]scale=iw:round(ih*${multiplier})${flag ? `:flags=${flag}` : ''}[overlay];[background][overlay]overlay=x=${originx}:y=${originy}:format=auto,scale=ceil(iw/2)*2:ceil(ih/2)*2${flag ? `:flags=${flag}` : ''}[out]" -map "[out]" -preset ${findpreset(args)} -aspect ${fileinfo.info.width}:${fileinfo.info.height} -c:v libx264 -pix_fmt yuv420p ${filepath}/output.mp4`)
                    await sendFile(msg, filepath, `output.mp4`)
                } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                    var filepath = await downloadFile(currenturl, `input.gif`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.gif`
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -i templates/transparent.png -filter_complex "[1:v][0:v]scale2ref[background][input];[input]scale=iw:round(ih*${multiplier})${flag ? `:flags=${flag}` : ''}[overlay];[background][overlay]overlay=x=${originx}:y=${originy}:format=auto,split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ${findpreset(args)} -aspect ${fileinfo.info.width}:${fileinfo.info.height} -gifflags -offsetting ${filepath}/output.gif`)
                    await sendFile(msg, filepath, `output.gif`)
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "vzoomin [multiplier (from 1 to 6)] <file> [-origin <x (left/center/right)> <y (top/middle/bottom)>] [-flags <algorithm>]",
                "value": "Zooms the file in vertically. A list of flags can be found at https://ffmpeg.org/ffmpeg-scaler.html#Scaler-Options"
            },
            cooldown: 2500,
            type: "Resizing"
        },

        {
            name: ["hstretch"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl']
                var multiplier = isNaN(Number(args[1])) ? 2 : Number(args[1]) <= 1 ? 1 : Number(args[1]) >= 6 ? 6 : Number(args[1]) || 2
                var flags = [
                    'fast_bilinear',
                    'bilinear',
                    'bicubic',
                    'experimental',
                    'neighbor',
                    'area',
                    'bicublin',
                    'gauss',
                    'sinc',
                    'lanczos',
                    'spline',
                    'print_info',
                    'accurate_rnd',
                    'full_chroma_int',
                    'full_chroma_inp',
                    'bitexact'
                ]
                var flag = undefined
                var flagsindex = args.indexOf('-flags')
                if (flagsindex > -1) {
                    if (flags.find(flag => flag === args[flagsindex + 1].toLowerCase())) {
                        flag = args[flagsindex + 1]
                    } else {
                        msg.channel.send('Not a supported flag.').catch(() => { })
                        return
                    }
                }
                var fileinfo = await validateFile(currenturl).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })

                if (!fileinfo) return
                var type = fileinfo.type

                if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                    var filepath = await downloadFile(currenturl, `input.png`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.png`
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -filter_complex "[0:v]scale=round(iw*${multiplier}):ih${flag ? `:flags=${flag}` : ''}[out]" -map "[out]" -preset ${findpreset(args)} ${filepath}/output.png`)
                    await sendFile(msg, filepath, `output.png`)
                } else if (type.mime.startsWith('video')) {
                    var filepath = await downloadFile(currenturl, `input.mp4`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp4`
                    var width = fileinfo.info.width
                    var height = fileinfo.info.height

                    await execPromise(`ffmpeg -i ${filepath}/${filename} -map 0:a? -filter_complex "[0:v]scale=round(iw*${multiplier}):ih${flag ? `:flags=${flag}` : ''},scale=ceil(iw/2)*2:ceil(ih/2)*2${flag ? `:flags=${flag}` : ''}[out]" -map "[out]" -preset ${findpreset(args)} -aspect ${Math.round(width * multiplier)}:${height} -c:v libx264 -pix_fmt yuv420p ${filepath}/output.mp4`)
                    await sendFile(msg, filepath, `output.mp4`)
                } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                    var filepath = await downloadFile(currenturl, `input.gif`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.gif`
                    var width = fileinfo.info.width
                    var height = fileinfo.info.height

                    await execPromise(`ffmpeg -i ${filepath}/${filename} -filter_complex "[0:v]scale=round(iw*${multiplier}):ih${flag ? `:flags=${flag}` : ''},split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ${findpreset(args)} -aspect ${Math.round(width * multiplier)}:${height} -gifflags -offsetting ${filepath}/output.gif`)
                    await sendFile(msg, filepath, `output.gif`)
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "hstretch [multiplier (from 1 to 6)] <file> [-flags <algorithm>]",
                "value": "Stretches the file horizontally. A list of flags can be found at https://ffmpeg.org/ffmpeg-scaler.html#Scaler-Options"
            },
            cooldown: 2500,
            type: "Resizing"
        },

        {
            name: ["vstretch"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl']
                var multiplier = isNaN(Number(args[1])) ? 2 : Number(args[1]) <= 1 ? 1 : Number(args[1]) >= 6 ? 6 : Number(args[1]) || 2
                var flags = [
                    'fast_bilinear',
                    'bilinear',
                    'bicubic',
                    'experimental',
                    'neighbor',
                    'area',
                    'bicublin',
                    'gauss',
                    'sinc',
                    'lanczos',
                    'spline',
                    'print_info',
                    'accurate_rnd',
                    'full_chroma_int',
                    'full_chroma_inp',
                    'bitexact'
                ]
                var flag = undefined
                var flagsindex = args.indexOf('-flags')
                if (flagsindex > -1) {
                    if (flags.find(flag => flag === args[flagsindex + 1].toLowerCase())) {
                        flag = args[flagsindex + 1]
                    } else {
                        msg.channel.send('Not a supported flag.').catch(() => { })
                        return
                    }
                }
                var fileinfo = await validateFile(currenturl).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })

                if (!fileinfo) return
                var type = fileinfo.type

                if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                    var filepath = await downloadFile(currenturl, `input.png`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.png`
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -filter_complex "[0:v]scale=iw:round(ih*${multiplier})${flag ? `:flags=${flag}` : ''}[out]" -map "[out]" -preset ${findpreset(args)} ${filepath}/output.png`)
                    await sendFile(msg, filepath, `output.png`)
                } else if (type.mime.startsWith('video')) {
                    var filepath = await downloadFile(currenturl, `input.mp4`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp4`
                    var width = fileinfo.info.width
                    var height = fileinfo.info.height

                    await execPromise(`ffmpeg -i ${filepath}/${filename} -map 0:a? -filter_complex "[0:v]scale=iw:round(ih*${multiplier})${flag ? `:flags=${flag}` : ''},scale=ceil(iw/2)*2:ceil(ih/2)*2${flag ? `:flags=${flag}` : ''}[out]" -map "[out]" -preset ${findpreset(args)} -aspect ${width}:${Math.round(height * multiplier)} -c:v libx264 -pix_fmt yuv420p ${filepath}/output.mp4`)
                    await sendFile(msg, filepath, `output.mp4`)
                } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                    var filepath = await downloadFile(currenturl, `input.gif`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.gif`
                    var width = fileinfo.info.width
                    var height = fileinfo.info.height

                    await execPromise(`ffmpeg -i ${filepath}/${filename} -filter_complex "[0:v]scale=iw:round(ih*${multiplier})${flag ? `:flags=${flag}` : ''},split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ${findpreset(args)} -aspect ${width}:${Math.round(height * multiplier)} -gifflags -offsetting ${filepath}/output.gif`)
                    await sendFile(msg, filepath, `output.gif`)
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "vstretch [multiplier (from 1 to 6)] <file> [-flags <algorithm>]",
                "value": "Stretches the file vertically. A list of flags can be found at https://ffmpeg.org/ffmpeg-scaler.html#Scaler-Options"
            },
            cooldown: 2500,
            type: "Resizing"
        },

        {
            name: ["vshrink"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl']
                var multiplier = isNaN(Number(args[1])) ? 2 : Number(args[1]) <= 1 ? 1 : Number(args[1]) >= 6 ? 6 : Number(args[1]) || 2
                var flags = [
                    'fast_bilinear',
                    'bilinear',
                    'bicubic',
                    'experimental',
                    'neighbor',
                    'area',
                    'bicublin',
                    'gauss',
                    'sinc',
                    'lanczos',
                    'spline',
                    'print_info',
                    'accurate_rnd',
                    'full_chroma_int',
                    'full_chroma_inp',
                    'bitexact'
                ]
                var flag = undefined
                var flagsindex = args.indexOf('-flags')
                if (flagsindex > -1) {
                    if (flags.find(flag => flag === args[flagsindex + 1].toLowerCase())) {
                        flag = args[flagsindex + 1]
                    } else {
                        msg.channel.send('Not a supported flag.').catch(() => { })
                        return
                    }
                }
                var fileinfo = await validateFile(currenturl, true).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })

                if (!fileinfo) return
                var type = fileinfo.type

                if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                    var filepath = await downloadFile(currenturl, `input.png`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.png`
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -filter_complex "[0:v]scale=iw:round(ih/${multiplier})${flag ? `:flags=${flag}` : ''}[out]" -map "[out]" -preset ${findpreset(args)} ${filepath}/output.png`)
                    await sendFile(msg, filepath, `output.png`)
                } else if (type.mime.startsWith('video')) {
                    var filepath = await downloadFile(currenturl, `input.mp4`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp4`
                    var width = fileinfo.info.width
                    var height = fileinfo.info.height

                    await execPromise(`ffmpeg -i ${filepath}/${filename} -map 0:a? -filter_complex "[0:v]scale=iw:round(ih/${multiplier})${flag ? `:flags=${flag}` : ''},scale=ceil(iw/2)*2:ceil(ih/2)*2${flag ? `:flags=${flag}` : ''}[out]" -map "[out]" -preset ${findpreset(args)} -aspect ${width}:${Math.round(height / multiplier)} -c:v libx264 -pix_fmt yuv420p ${filepath}/output.mp4`)
                    await sendFile(msg, filepath, `output.mp4`)
                } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                    var filepath = await downloadFile(currenturl, `input.gif`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.gif`
                    var width = fileinfo.info.width
                    var height = fileinfo.info.height

                    await execPromise(`ffmpeg -i ${filepath}/${filename} -filter_complex "[0:v]scale=iw:round(ih/${multiplier})${flag ? `:flags=${flag}` : ''},split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ${findpreset(args)} -aspect ${width}:${Math.round(height / multiplier)} -gifflags -offsetting ${filepath}/output.gif`)
                    await sendFile(msg, filepath, `output.gif`)
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "vshrink [multiplier (from 1 to 6)] <file> [-flags <algorithm>]",
                "value": "Shrinks the file vertically. A list of flags can be found at https://ffmpeg.org/ffmpeg-scaler.html#Scaler-Options"
            },
            cooldown: 2500,
            type: "Resizing"
        },

        {
            name: ["hshrink"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl']
                var multiplier = isNaN(Number(args[1])) ? 2 : Number(args[1]) <= 1 ? 1 : Number(args[1]) >= 6 ? 6 : Number(args[1]) || 2
                var flags = [
                    'fast_bilinear',
                    'bilinear',
                    'bicubic',
                    'experimental',
                    'neighbor',
                    'area',
                    'bicublin',
                    'gauss',
                    'sinc',
                    'lanczos',
                    'spline',
                    'print_info',
                    'accurate_rnd',
                    'full_chroma_int',
                    'full_chroma_inp',
                    'bitexact'
                ]
                var flag = undefined
                var flagsindex = args.indexOf('-flags')
                if (flagsindex > -1) {
                    if (flags.find(flag => flag === args[flagsindex + 1].toLowerCase())) {
                        flag = args[flagsindex + 1]
                    } else {
                        msg.channel.send('Not a supported flag.').catch(() => { })
                        return
                    }
                }
                var fileinfo = await validateFile(currenturl, true).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })

                if (!fileinfo) return
                var type = fileinfo.type

                if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                    var filepath = await downloadFile(currenturl, `input.png`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.png`
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -filter_complex "[0:v]scale=round(iw/${multiplier}):ih${flag ? `:flags=${flag}` : ''}[out]" -map "[out]" -preset ${findpreset(args)} ${filepath}/output.png`)
                    await sendFile(msg, filepath, `output.png`)
                } else if (type.mime.startsWith('video')) {
                    var filepath = await downloadFile(currenturl, `input.mp4`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp4`
                    var width = fileinfo.info.width
                    var height = fileinfo.info.height

                    await execPromise(`ffmpeg -i ${filepath}/${filename} -map 0:a? -filter_complex "[0:v]scale=round(iw/${multiplier}):ih${flag ? `:flags=${flag}` : ''},scale=ceil(iw/2)*2:ceil(ih/2)*2${flag ? `:flags=${flag}` : ''}[out]" -map "[out]" -preset ${findpreset(args)} -aspect ${Math.round(width / multiplier)}:${height} -c:v libx264 -pix_fmt yuv420p ${filepath}/output.mp4`)
                    await sendFile(msg, filepath, `output.mp4`)
                } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                    var filepath = await downloadFile(currenturl, `input.gif`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.gif`
                    var width = fileinfo.info.width
                    var height = fileinfo.info.height

                    await execPromise(`ffmpeg -i ${filepath}/${filename} -filter_complex "[0:v]scale=round(iw/${multiplier}):ih${flag ? `:flags=${flag}` : ''},split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ${findpreset(args)} -aspect ${Math.round(width / multiplier)}:${height} -gifflags -offsetting ${filepath}/output.gif`)
                    await sendFile(msg, filepath, `output.gif`)
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "hshrink [multiplier (from 1 to 6)] <file> [-flags <algorithm>]",
                "value": "Shrinks the file horizontally. A list of flags can be found at https://ffmpeg.org/ffmpeg-scaler.html#Scaler-Options"
            },
            cooldown: 2500,
            type: "Resizing"
        },

        {
            name: ["hstack"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var stack = 1
                var stackindex = args.indexOf('-stack')
                if (stackindex > -1) {
                    stack = isNaN(Number(args[stackindex + 1])) ? 1 : Number(args[stackindex + 1]) <= 1 ? 1 : Number(args[stackindex + 1]) >= 10 ? 10 : Math.round(Number(args[stackindex + 1])) || 1
                }
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl']
                var fileinfo = await validateFile(currenturl).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })

                if (!fileinfo) return
                var type = fileinfo.type

                if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                    var filepath = await downloadFile(currenturl, `input.png`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.png`
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -filter_complex "[0:v]${'[0:v]'.repeat(stack)}hstack=inputs=${stack + 1}[out]" -map "[out]" -preset ${findpreset(args)} ${filepath}/output.png`)
                    await sendFile(msg, filepath, `output.png`)
                } else if (type.mime.startsWith('video')) {
                    var filepath = await downloadFile(currenturl, `input.mp4`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp4`
                    var width = fileinfo.info.width
                    var height = fileinfo.info.height

                    await execPromise(`ffmpeg -i ${filepath}/${filename} -map 0:a? -filter_complex "[0:v]${'[0:v]'.repeat(stack)}hstack=inputs=${stack + 1}[oout];[oout]scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ${findpreset(args)} -aspect ${width * (stack + 1)}:${height} -c:v libx264 -pix_fmt yuv420p ${filepath}/output.mp4`)
                    await sendFile(msg, filepath, `output.mp4`)
                } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                    var filepath = await downloadFile(currenturl, `input.gif`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.gif`
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -filter_complex "[0:v]${'[0:v]'.repeat(stack)}hstack=inputs=${stack + 1}[oout];[oout]split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ${findpreset(args)} -gifflags -offsetting ${filepath}/output.gif`)
                    await sendFile(msg, filepath, `output.gif`)
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "hstack <file> [-stack <number (from 1 to 10)>]",
                "value": "Stacks the file horizontally."
            },
            cooldown: 2500,
            type: "Overlaying"
        },

        {
            name: ["vstack"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var stack = 1
                var stackindex = args.indexOf('-stack')
                if (stackindex > -1) {
                    stack = isNaN(Number(args[stackindex + 1])) ? 1 : Number(args[stackindex + 1]) <= 1 ? 1 : Number(args[stackindex + 1]) >= 10 ? 10 : Math.round(Number(args[stackindex + 1])) || 1
                }
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl']
                var fileinfo = await validateFile(currenturl).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })

                if (!fileinfo) return
                var type = fileinfo.type

                if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                    var filepath = await downloadFile(currenturl, `input.png`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.png`
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -filter_complex "[0:v]${'[0:v]'.repeat(stack)}vstack=inputs=${stack + 1}[out]" -map "[out]" -preset ${findpreset(args)} ${filepath}/output.png`)
                    await sendFile(msg, filepath, `output.png`)
                } else if (type.mime.startsWith('video')) {
                    var filepath = await downloadFile(currenturl, `input.mp4`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp4`
                    var width = fileinfo.info.width
                    var height = fileinfo.info.height

                    await execPromise(`ffmpeg -i ${filepath}/${filename} -map 0:a? -filter_complex "[0:v]${'[0:v]'.repeat(stack)}vstack=inputs=${stack + 1}[oout];[oout]scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ${findpreset(args)} -aspect ${width}:${height * (stack + 1)} -c:v libx264 -pix_fmt yuv420p ${filepath}/output.mp4`)
                    await sendFile(msg, filepath, `output.mp4`)
                } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                    var filepath = await downloadFile(currenturl, `input.gif`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.gif`
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -filter_complex "[0:v]${'[0:v]'.repeat(stack)}vstack=inputs=${stack + 1}[oout];[oout]split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ${findpreset(args)} -gifflags -offsetting ${filepath}/output.gif`)
                    await sendFile(msg, filepath, `output.gif`)
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "vstack <file> [-stack <number (from 1 to 10)>]",
                "value": "Stacks the file vertically."
            },
            cooldown: 2500,
            type: "Overlaying"
        },

        {
            name: ["hd"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl']
                var hmult = Math.floor(Math.random() * 16) + 10
                var vmult = Math.floor(Math.random() * 16) + 10
                var flags = [
                    'fast_bilinear',
                    'bilinear',
                    'bicubic',
                    'experimental',
                    'neighbor',
                    'area',
                    'bicublin',
                    'gauss',
                    'sinc',
                    'lanczos',
                    'spline',
                    'print_info',
                    'accurate_rnd',
                    'full_chroma_int',
                    'full_chroma_inp',
                    'bitexact'
                ]
                var flag = undefined
                var flagsindex = args.indexOf('-flags')
                if (flagsindex > -1) {
                    if (flags.find(flag => flag === args[flagsindex + 1].toLowerCase())) {
                        flag = args[flagsindex + 1]
                    } else {
                        msg.channel.send('Not a supported flag.').catch(() => { })
                        return
                    }
                }
                var fileinfo = await validateFile(currenturl, true).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })

                if (!fileinfo) return
                var type = fileinfo.type

                if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                    var filepath = await downloadFile(currenturl, `input.png`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.png`
                    var width = fileinfo.info.width
                    var height = fileinfo.info.height

                    var squareS = { value: ((height === width) && width) || ((height > width) && height) || width, constraint: ((height === width) && 'both') || ((height > width) && 'height') || 'width' }
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -filter_complex "[0:v]scale=${squareS.constraint === 'width' || squareS.constraint === 'both' ? 400 : -1}:${squareS.constraint === 'height' || squareS.constraint === 'both' ? 400 : -1}${flag ? `:flags=${flag}` : ''},scale=iw/${hmult}:ih/${vmult}${flag ? `:flags=${flag}` : ''},scale=${width}:${height}${flag ? `:flags=${flag}` : ''}[out]" -map "[out]" -preset ${findpreset(args)} ${filepath}/output.png`)
                    await sendFile(msg, filepath, `output.png`)
                } else if (type.mime.startsWith('video')) {
                    var filepath = await downloadFile(currenturl, `input.mp4`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp4`
                    var width = fileinfo.info.width
                    var height = fileinfo.info.height

                    var squareS = { value: ((height === width) && width) || ((height > width) && height) || width, constraint: ((height === width) && 'both') || ((height > width) && 'height') || 'width' }
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -map 0:a? -b:a 10k -filter_complex "[0:v]scale=${squareS.constraint === 'width' || squareS.constraint === 'both' ? 400 : -1}:${squareS.constraint === 'height' || squareS.constraint === 'both' ? 400 : -1}${flag ? `:flags=${flag}` : ''},scale=iw/${hmult}:ih/${vmult}${flag ? `:flags=${flag}` : ''},scale=${width}:${height}${flag ? `:flags=${flag}` : ''},scale=ceil(iw/2)*2:ceil(ih/2)*2${flag ? `:flags=${flag}` : ''}[out]" -map "[out]" -preset ${findpreset(args)} -c:v libx264 -pix_fmt yuv420p ${filepath}/output.mp4`)
                    await sendFile(msg, filepath, `output.mp4`)
                } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                    var filepath = await downloadFile(currenturl, `input.gif`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.gif`
                    var width = fileinfo.info.width
                    var height = fileinfo.info.height

                    var squareS = { value: ((height === width) && width) || ((height > width) && height) || width, constraint: ((height === width) && 'both') || ((height > width) && 'height') || 'width' }
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -filter_complex "[0:v]scale=${squareS.constraint === 'width' || squareS.constraint === 'both' ? 400 : -1}:${squareS.constraint === 'height' || squareS.constraint === 'both' ? 400 : -1}${flag ? `:flags=${flag}` : ''},scale=iw/${hmult}:ih/${vmult}${flag ? `:flags=${flag}` : ''},scale=${width}:${height}${flag ? `:flags=${flag}` : ''},split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ${findpreset(args)} -gifflags -offsetting ${filepath}/output.gif`)
                    await sendFile(msg, filepath, `output.gif`)
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "hd <file> [-flags <algorithm>]",
                "value": "Makes the file Ultra HD 4k 2160p Blu-ray. A list of flags can be found at https://ffmpeg.org/ffmpeg-scaler.html#Scaler-Options"
            },
            cooldown: 2500,
            type: "Effects"
        },

        {
            name: ["pixelate"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var size = 2
                var sizeindex = args.indexOf('-size')
                if (sizeindex > -1) {
                    size = isNaN(Number(args[sizeindex + 1])) ? 2 : Number(args[sizeindex + 1]) <= 1 ? 1 : Number(args[sizeindex + 1]) || 2
                }
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl']
                var fileinfo = await validateFile(currenturl, true).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })

                if (!fileinfo) return
                var type = fileinfo.type

                if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                    var filepath = await downloadFile(currenturl, `input.png`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.png`

                    await execPromise(`ffmpeg -i ${filepath}/${filename} -filter_complex "[0:v]scale=iw/${size}:ih/${size}:flags=neighbor,scale=iw*${size}:ih*${size}:flags=neighbor[out]" -map "[out]" -preset ${findpreset(args)} ${filepath}/output.png`)
                    await sendFile(msg, filepath, `output.png`)
                } else if (type.mime.startsWith('video')) {
                    var filepath = await downloadFile(currenturl, `input.mp4`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp4`

                    await execPromise(`ffmpeg -i ${filepath}/${filename} -map 0:a? -b:a 10k -filter_complex "[0:v]scale=iw/${size}:ih/${size}:flags=neighbor,scale=iw*${size}:ih*${size}:flags=neighbor,scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ${findpreset(args)} -c:v libx264 -pix_fmt yuv420p ${filepath}/output.mp4`)
                    await sendFile(msg, filepath, `output.mp4`)
                } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                    var filepath = await downloadFile(currenturl, `input.gif`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.gif`

                    await execPromise(`ffmpeg -i ${filepath}/${filename} -filter_complex "[0:v]scale=iw/${size}:ih/${size}:flags=neighbor,scale=iw*${size}:ih*${size}:flags=neighbor,split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ${findpreset(args)} -gifflags -offsetting ${filepath}/output.gif`)
                    await sendFile(msg, filepath, `output.gif`)
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "pixelate <file> [-size <pixels>]",
                "value": "Pixelates the file."
            },
            cooldown: 2500,
            type: "Effects"
        },

        {
            name: ["blur"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var power = 2
                var powerindex = args.indexOf('-power')
                if (powerindex > -1) {
                    power = isNaN(Number(args[powerindex + 1])) ? 2 : Number(args[powerindex + 1]) <= 0 ? 0 : Math.round(Number(args[powerindex + 1])) ?? 2
                }
                var radius = 2
                var radiusindex = args.indexOf('-radius')
                if (radiusindex > -1) {
                    radius = isNaN(Number(args[radiusindex + 1])) ? 2 : Number(args[radiusindex + 1]) <= 0 ? 0 : Number(args[radiusindex + 1]) ?? 2
                }
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl']
                var fileinfo = await validateFile(currenturl, true).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })

                if (!fileinfo) return
                var type = fileinfo.type

                if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                    var filepath = await downloadFile(currenturl, `input.png`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.png`

                    await execPromise(`ffmpeg -i ${filepath}/${filename} -filter_complex "[0:v]boxblur=luma_radius=${radius}:luma_power=${power}:chroma_radius=${radius}:chroma_power=${power}:alpha_radius=${radius}:alpha_power=${power}[out]" -map "[out]" -preset ${findpreset(args)} ${filepath}/output.png`)
                    await sendFile(msg, filepath, `output.png`)
                } else if (type.mime.startsWith('video')) {
                    var filepath = await downloadFile(currenturl, `input.mp4`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp4`

                    await execPromise(`ffmpeg -i ${filepath}/${filename} -map 0:a? -b:a 10k -filter_complex "[0:v]boxblur=luma_radius=${radius}:luma_power=${power}:chroma_radius=${radius}:chroma_power=${power}:alpha_radius=${radius}:alpha_power=${power},scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ${findpreset(args)} -c:v libx264 -pix_fmt yuv420p ${filepath}/output.mp4`)
                    await sendFile(msg, filepath, `output.mp4`)
                } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                    var filepath = await downloadFile(currenturl, `input.gif`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.gif`

                    await execPromise(`ffmpeg -i ${filepath}/${filename} -filter_complex "[0:v]boxblur=luma_radius=${radius}:luma_power=${power}:chroma_radius=${radius}:chroma_power=${power}:alpha_radius=${radius}:alpha_power=${power},split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ${findpreset(args)} -gifflags -offsetting ${filepath}/output.gif`)
                    await sendFile(msg, filepath, `output.gif`)
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "blur <file> [-radius <pixels>] [-power <number>]",
                "value": "Blurs the file."
            },
            cooldown: 2500,
            type: "Effects"
        },

        {
            name: ["outline", "border"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var power = 2
                var powerindex = args.indexOf('-power')
                if (powerindex > -1) {
                    power = isNaN(Number(args[powerindex + 1])) ? 2 : Number(args[powerindex + 1]) <= 0 ? 0 : Math.round(Number(args[powerindex + 1])) ?? 2
                }
                var radius = 2
                var radiusindex = args.indexOf('-radius')
                if (radiusindex > -1) {
                    radius = isNaN(Number(args[radiusindex + 1])) ? 2 : Number(args[radiusindex + 1]) <= 0 ? 0 : Number(args[radiusindex + 1]) ?? 2
                }
                var bordersplit = []
                var overlays = []
                var overlayrepeat = 10
                var repeatindex = args.indexOf('-repeat')
                if (repeatindex > -1) {
                    overlayrepeat = isNaN(Number(args[repeatindex + 1])) ? 10 : Number(args[repeatindex + 1]) <= 1 ? 1 : Number(args[repeatindex + 1]) >= 100 ? 100 : Math.round(Number(args[repeatindex + 1])) || 10
                }
                for (var i = 1; i <= overlayrepeat; i++) {
                    bordersplit.push(`[border${i}]`)
                    if (i !== overlayrepeat) {
                        overlays.push(`[${i !== 1 ? 'o' : ''}border${i}][border${i + 1}]overlay=x=0:y=0:format=auto${i !== overlayrepeat - 1 ? `[oborder${i + 1}]` : ''}`)
                    }
                }

                var rgb = {
                    r: 255,
                    g: 255,
                    b: 255,
                }
                var colorindex = args.indexOf('-color')
                if (colorindex > -1) {
                    var r = args[colorindex + 1]
                    var g = args[colorindex + 2]
                    var b = args[colorindex + 3]
                    rgb.r = isNaN(Number(String(r).replace(/,/g, ''))) ? 0 : Number(String(r).replace(/,/g, '')) <= 0 ? 0 : Number(String(r).replace(/,/g, '')) >= 255 ? 255 : Number(String(r).replace(/,/g, '')) || 0
                    rgb.g = isNaN(Number(String(g).replace(/,/g, ''))) ? 0 : Number(String(g).replace(/,/g, '')) <= 0 ? 0 : Number(String(g).replace(/,/g, '')) >= 255 ? 255 : Number(String(g).replace(/,/g, '')) || 0
                    rgb.b = isNaN(Number(String(b).replace(/,/g, ''))) ? 0 : Number(String(b).replace(/,/g, '')) <= 0 ? 0 : Number(String(b).replace(/,/g, '')) >= 255 ? 255 : Number(String(b).replace(/,/g, '')) || 0
                }

                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl']
                var fileinfo = await validateFile(currenturl, true).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })

                if (!fileinfo) return
                var type = fileinfo.type

                if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                    var filepath = await downloadFile(currenturl, `input.png`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.png`

                    await execPromise(`ffmpeg -i ${filepath}/${filename} -filter_complex "[0:v]split[input][blur];[blur]boxblur=luma_radius=${radius}:luma_power=${power}:chroma_radius=${radius}:chroma_power=${power}:alpha_radius=${radius}:alpha_power=${power},curves=r='0/1 1/1':g='0/1 1/1':b='0/1 1/1',curves=r='0/0 1/${rgb.r / 255}':g='0/0 1/${rgb.g / 255}':b='0/0 1/${rgb.b / 255}',split=${overlayrepeat}${bordersplit.join('')};${overlays.join(';')}[greatborder];[greatborder][input]overlay=x=0:y=0:format=auto[out]" -map "[out]" -preset ${findpreset(args)} ${filepath}/output.png`)
                    await sendFile(msg, filepath, `output.png`)
                } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                    var filepath = await downloadFile(currenturl, `input.gif`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.gif`

                    await execPromise(`ffmpeg -i ${filepath}/${filename} -filter_complex "[0:v]split[input][blur];[blur]boxblur=luma_radius=${radius}:luma_power=${power}:chroma_radius=${radius}:chroma_power=${power}:alpha_radius=${radius}:alpha_power=${power},curves=r='0/1 1/1':g='0/1 1/1':b='0/1 1/1',curves=r='0/0 1/${rgb.r / 255}':g='0/0 1/${rgb.g / 255}':b='0/0 1/${rgb.b / 255}',split=${overlayrepeat}${bordersplit.join('')};${overlays.join(';')}[greatborder];[greatborder][input]overlay=x=0:y=0:format=auto,split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ${findpreset(args)} -gifflags -offsetting ${filepath}/output.gif`)
                    await sendFile(msg, filepath, `output.gif`)
                } else if (type.mime.startsWith('video')) {
                    msg.channel.send(`videos have no alpha channel + cry about it + stay mad + get real + L + mald seethe cope harder + don't care + didn't ask + hoes mad + basic + skill issue + ratio + you fell off + the audacity + triggered + any askers + redpilled + get a life + ok and? + cringe + touch grass + donowalled + not based + your're a (insert stereotype) + not funny didn't laugh + you're* + grammar issue + go outside + get good + reported + ad hominem + GG! + ur mom`).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "outline/border <file> [-radius <pixels>] [-power <number>] [-color <r> <g> <b>] [-repeat <number (max 100)>]",
                "value": "Adds an outline to the file, only works with transparent ones."
            },
            cooldown: 2500,
            type: "Effects"
        },

        {
            name: ["playbutton", "play", "pb"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
                var fileinfo = await validateFile(currenturl).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })

                if (!fileinfo) return
                var type = fileinfo.type

                if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                    var filepath = await downloadFile(currenturl, `input.png`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.png`
                    var width = fileinfo.info.width
                    var height = fileinfo.info.height

                    await execPromise(`ffmpeg -i ${filepath}/${filename} -i templates/play.png -filter_complex "[1:v]scale=-1:${height > 300 ? Math.round(48 * (height / 300)) : 48}[button];[0:v][button]overlay=x=W/2-w/2:y=H/2-h/2:format=auto[out]" -map "[out]" -preset ${findpreset(args)} ${filepath}/output.png`)
                    await sendFile(msg, filepath, `output.png`)
                } else if (type.mime.startsWith('video')) {
                    var filepath = await downloadFile(currenturl, `input.mp4`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp4`
                    var width = fileinfo.info.width
                    var height = fileinfo.info.height

                    await execPromise(`ffmpeg -i ${filepath}/${filename} -i templates/play.png -map 0:a? -filter_complex "[1:v]scale=-1:${height > 300 ? Math.round(48 * (height / 300)) : 48}[button];[0:v][button]overlay=x=W/2-w/2:y=H/2-h/2:format=auto[oout];[oout]scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ${findpreset(args)} -c:v libx264 -pix_fmt yuv420p ${filepath}/output.mp4`)
                    await sendFile(msg, filepath, `output.mp4`)
                } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                    var filepath = await downloadFile(currenturl, `input.gif`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.gif`
                    var width = fileinfo.info.width
                    var height = fileinfo.info.height

                    await execPromise(`ffmpeg -i ${filepath}/${filename} -i templates/play.png -filter_complex "[1:v]scale=-1:${height > 300 ? Math.round(48 * (height / 300)) : 48}[button];[0:v][button]overlay=x=W/2-w/2:y=H/2-h/2:format=auto[oout];[oout]split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ${findpreset(args)} -gifflags -offsetting ${filepath}/output.gif`)
                    await sendFile(msg, filepath, `output.gif`)
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "playbutton/play/pb <file>",
                "value": "Adds a play button to the file for epic pranks!!!"
            },
            cooldown: 2500,
            type: "Memes"
        },

        {
            name: ["fail", "norris"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
                var fileinfo = await validateFile(currenturl).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })

                if (!fileinfo) return
                var type = fileinfo.type

                if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                    var filepath = await downloadFile(currenturl, `input.png`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.png`
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -i templates/norris.png -filter_complex "[0:v]scale=508:257[frame];[1:v][frame]overlay=x=7:y=306:format=auto[out]" -map "[out]" -preset ${findpreset(args)} ${filepath}/output.png`)
                    await sendFile(msg, filepath, `output.png`)
                } else if (type.mime.startsWith('video')) {
                    var filepath = await downloadFile(currenturl, `input.mp4`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp4`
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -i templates/norris.png -map 0:a? -filter_complex "[0:v]scale=508:257[frame];[1:v][frame]overlay=x=7:y=306:format=auto[oout];[oout]scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ${findpreset(args)} -c:v libx264 -pix_fmt yuv420p ${filepath}/output.mp4`)
                    await sendFile(msg, filepath, `output.mp4`)
                } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                    var filepath = await downloadFile(currenturl, `input.gif`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.gif`
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -i templates/norris.png -filter_complex "[0:v]scale=508:257[frame];[1:v][frame]overlay=x=7:y=306:format=auto[oout];[oout]split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ${findpreset(args)} -gifflags -offsetting ${filepath}/output.gif`)
                    await sendFile(msg, filepath, `output.gif`)
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "fail/norris <file>",
                "value": "FAIL"
            },
            cooldown: 2500,
            type: "Memes"
        },

        {
            name: ["countdown", "annoyingorange"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var saidMessage = args.join(' ').substring(args[0].length + 1)
                symbolreplacements.forEach(symbolReplacement => {
                    symbolReplacement.target.forEach(target => {
                        saidMessage = saidMessage.replace(new RegExp(target, 'ig'), symbolReplacement.replacement)
                    })
                })
                var matchedTextes = saidMessage.match(/"([\s\S]*?)"/)
                if (!matchedTextes) {
                    matchedTextes = ['""', '']
                }
                var text = matchedTextes[1]
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
                var fileinfo = await validateFile(currenturl).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })

                if (!fileinfo) return
                var type = fileinfo.type

                if (type.mime.startsWith('video')) {
                    var filepath = await downloadFile(currenturl, `input.mp4`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp4`
                    var transparent = await Jimp.read(`templates/transparent.png`)
                    var novecento = await Jimp.loadFont(`templates/fonts/Novecento/Novecento.fnt`)
                    transparent.resize(101, 28)
                    await transparent.print(novecento, 0, 0, { text: Discord.Util.cleanContent(text, msg), alignmentX: Jimp.HORIZONTAL_ALIGN_CENTER, alignmentY: Jimp.VERTICAL_ALIGN_MIDDLE }, 101, 28)
                    await transparent.writeAsync(`${filepath}/caption.png`)

                    await execPromise(`ffmpeg -i ${filepath}/${filename} -vf "scale=66:66" -preset ${findpreset(args)} -c:v libx264 -pix_fmt yuv420p ${filepath}/scaled.mp4`)
                    await execPromise(`ffmpeg -stream_loop -1 -i ${filepath}/scaled.mp4 -i ${filepath}/caption.png -i templates/countdown.mp4 -filter_complex "[2:v][0:v]overlay=shortest=1:x=2:y=3:format=auto[image];[image][1:v]overlay=x=89:y=4:format=auto[oout];[oout]scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ${findpreset(args)} -c:v libx264 -pix_fmt yuv420p ${filepath}/output.mp4`)
                    await sendFile(msg, filepath, `output.mp4`)
                } else if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                    var filepath = await downloadFile(currenturl, `input.png`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.png`
                    var transparent = await Jimp.read(`templates/transparent.png`)
                    var novecento = await Jimp.loadFont(`templates/fonts/Novecento/Novecento.fnt`)
                    transparent.resize(101, 28)
                    await transparent.print(novecento, 0, 0, { text: Discord.Util.cleanContent(text, msg), alignmentX: Jimp.HORIZONTAL_ALIGN_CENTER, alignmentY: Jimp.VERTICAL_ALIGN_MIDDLE }, 101, 28)
                    await transparent.writeAsync(`${filepath}/caption.png`)

                    await execPromise(`ffmpeg -i ${filepath}/${filename} -vf "scale=66:66" -preset ${findpreset(args)} ${filepath}/scaled.png`)
                    await execPromise(`ffmpeg -stream_loop -1 -i ${filepath}/scaled.png -i ${filepath}/caption.png -i templates/countdown.mp4 -filter_complex "[2:v][0:v]overlay=shortest=1:x=2:y=3:format=auto[image];[image][1:v]overlay=x=89:y=4:format=auto[oout];[oout]scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ${findpreset(args)} -c:v libx264 -pix_fmt yuv420p ${filepath}/output.mp4`)
                    await sendFile(msg, filepath, `output.mp4`)
                } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                    var filepath = await downloadFile(currenturl, `input.gif`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.gif`
                    var transparent = await Jimp.read(`templates/transparent.png`)
                    var novecento = await Jimp.loadFont(`templates/fonts/Novecento/Novecento.fnt`)
                    transparent.resize(101, 28)
                    await transparent.print(novecento, 0, 0, { text: Discord.Util.cleanContent(text, msg), alignmentX: Jimp.HORIZONTAL_ALIGN_CENTER, alignmentY: Jimp.VERTICAL_ALIGN_MIDDLE }, 101, 28)
                    await transparent.writeAsync(`${filepath}/caption.png`)

                    await execPromise(`ffmpeg -i ${filepath}/${filename} -filter_complex "[0:v]scale=66:66,split[gnout][gpout];[gpout]palettegen=reserve_transparent=1[palette];[gnout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ${findpreset(args)} -gifflags -offsetting ${filepath}/scaled.gif`)
                    await execPromise(`ffmpeg -stream_loop -1 -i ${filepath}/scaled.gif -i ${filepath}/caption.png -i templates/countdown.mp4 -filter_complex "[2:v][0:v]overlay=shortest=1:x=2:y=3:format=auto[image];[image][1:v]overlay=x=89:y=4:format=auto[oout];[oout]scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ${findpreset(args)} -c:v libx264 -pix_fmt yuv420p ${filepath}/output.mp4`)
                    await sendFile(msg, filepath, `output.mp4`)
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "countdown/annoyingorange \"{name}\" <file>",
                "value": "oh no"
            },
            cooldown: 2500,
            type: "Memes"
        },

        {
            name: ["frames", "extractframes", "getframes"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
                var fileinfo = await validateFile(currenturl).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })

                if (!fileinfo) return
                var type = fileinfo.type

                if (type.mime.startsWith('video') || (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext))) {
                    var filepath = await downloadFile(currenturl, `input.${fileinfo.shortext}`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.${fileinfo.shortext}`
                    fs.mkdirSync(`${filepath}/frames`)

                    await execPromise(`ffmpeg -i ${filepath}/${filename} ${filepath}/frames/frame_%04d.png`)
                    var output = fs.createWriteStream(`${filepath}/output.zip`)
                    var archive = archiver('zip')
                    output.on('finish', async () => {
                        var number = 1
                        var frames = fs.readdirSync(`${filepath}/frames`)
                        var catboxframes = {}
                        var frameurl = await Catbox.upload(`${filepath}/frames/${frames[number - 1]}`).catch(() => { }) ?? ''
                        catboxframes[frames[number - 1]] = frameurl
                        var frameEmbed = {
                            "color": 0x472604,
                            "image": {
                                "url": catboxframes[frames[number - 1]]
                            },
                            "footer": {
                                "icon_url": bot.user.displayAvatarURL({ dynamic: true, size: 1024, format: 'png' }),
                                "text": `Frame ${number}/${frames.length}`
                            },
                        }
                        var reactions = [
                            {
                                reaction: "861253229723123762",
                                function: () => {
                                    return 1
                                },
                            },
                            {
                                reaction: "861253229726793728",
                                function: (number) => {
                                    return number - 1
                                },
                            },
                            {
                                reaction: "861253230070988860",
                                function: () => {
                                    return Math.floor(Math.random() * frames.length) + 1
                                },
                            },
                            {
                                reaction: "861253229798621205",
                                function: (number) => {
                                    return number + 1
                                },
                            },
                            {
                                reaction: "861253229740556308",
                                function: () => {
                                    return frames.length
                                },
                            },
                        ]
                        var buttonRow = new Discord.MessageActionRow()
                        reactions.forEach(reaction => {
                            var button = new Discord.MessageButton()
                                .setStyle('PRIMARY')
                                .setEmoji(reaction.reaction)
                                .setCustomId(reaction.reaction)
                            buttonRow.addComponents([button])
                        })
                        var zipRow = new Discord.MessageActionRow()
                        var zip = new Discord.MessageButton()
                            .setStyle('PRIMARY')
                            .setEmoji('939523064658526278')
                            .setCustomId('zip')
                        zipRow.addComponents([zip])

                        msg.channel.send({
                            embeds: [frameEmbed],
                            components: [buttonRow, zipRow]
                        }).then(async sentMessage => {
                            var frameMessage = sentMessage
                            var filter = async (button) => {
                                if (data2[msg.author.id]['promises'].find(promise => promise.promise === p).active === false) return
                                if (!(button.user.id === msg.author.id && button.user.id !== bot.user.id && !button.user.bot)) {
                                    button.deferUpdate().catch(() => { })
                                    return
                                }
                                if (button.customId === zip.customId) {
                                    frameMessage.delete().catch(() => { })
                                    await sendFile(msg, filepath, `output.zip`)
                                    return
                                }
                                if (reactions.find(findreaction => findreaction.reaction === button.customId).function(number) > frames.length || reactions.find(findreaction => findreaction.reaction === button.customId).function(number) < 1) {
                                    button.deferUpdate().catch(() => { })
                                    return
                                }
                                number = reactions.find(findreaction => findreaction.reaction === button.customId).function(number)
                                if (!catboxframes[frames[number - 1]]) {
                                    var frameurl = await Catbox.upload(`${filepath}/frames/${frames[number - 1]}`).catch(() => { }) ?? ''
                                    catboxframes[frames[number - 1]] = frameurl
                                }
                                frameEmbed = {
                                    "color": 0x472604,
                                    "image": {
                                        "url": catboxframes[frames[number - 1]]
                                    },
                                    "footer": {
                                        "icon_url": bot.user.displayAvatarURL({ dynamic: true, size: 1024, format: 'png' }),
                                        "text": `Frame ${number}/${frames.length}`
                                    },
                                }
                                frameMessage.edit({
                                    embeds: [frameEmbed],
                                    components: [buttonRow, zipRow]
                                }).catch(() => { })
                                button.deferUpdate().catch(() => { })
                            }
                            for (var i in data2[msg.author.id]['promises']) {
                                if (data2[msg.author.id]['promises'][i]) {
                                    data2[msg.author.id]['promises'][i]['active'] = false
                                }
                            }
                            var p = frameMessage.awaitMessageComponent({ componentType: 'BUTTON', time: 600000, filter }).then(() => {
                                for (var i in data2[msg.author.id]['promises']) {
                                    if (data2[msg.author.id]['promises'][i] == p) {
                                        data2[msg.author.id]['promises'][i] = undefined
                                        break
                                    }
                                }
                                if (!frameMessage.edit) return
                                frameMessage.edit({
                                    embeds: [frameEmbed],
                                    components: []
                                }).catch(() => { })
                                try {
                                    fs.rmSync(filepath, { force: true, recursive: true })
                                } catch (_) { }
                            })
                                .catch((err) => {
                                    if (err.message.endsWith('reason: time')) {
                                        frameMessage.edit({
                                            embeds: [frameEmbed],
                                            components: []
                                        }).catch(() => { })
                                        try {
                                            fs.rmSync(filepath, { force: true, recursive: true })
                                        } catch (_) { }
                                    }
                                })
                            data2[msg.author.id]['promises'].push({ promise: p, active: true })
                        })
                            .catch(() => { })
                    });

                    archive.pipe(output)
                    archive.directory(`${filepath}/frames`, false);
                    archive.finalize()
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "frames/extractframes/getframes <video/gif>",
                "value": "Extracts all of the frames in the video/GIF and archives them in a ZIP file."
            },
            cooldown: 2500,
            type: "Conversion"
        },

        {
            name: ["canyoufind", "find"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl2'] === undefined && args[2] === undefined) {
                    msg.channel.send('What are the files?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var size = 150
                var sizeindex = args.indexOf('-size')
                if (sizeindex > -1) {
                    size = isNaN(Number(args[sizeindex + 1])) ? 1 : Number(args[sizeindex + 1]) <= 1 ? 1 : Number(args[sizeindex + 1]) || 1
                }
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
                var currenturl2 = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl2'] || args[2]
                var urls = await getUrls(msg).catch(() => { }) ?? []
                if (urls.length < 2) {
                    var c = currenturl
                    currenturl = currenturl2
                    currenturl2 = c
                }
                var errors = {}
                var fileinfo = await validateFile(currenturl, false, {
                    size: `the first file exceeds the size limit of {param} mb hahahaha (try to use the shrink, setfps, trim or crunch commands)`,
                    frames: `the frames of the first file exceed the limit of {param} hahahaha (try to use the setfps or the trim commands)`,
                    width: `the width of the first file exceeds the limit of {param} hahahaha (try to use the shrink command)`,
                    height: `the height of the first file exceeds the limit of {param} hahahaha (try to use the shrink command)`
                }).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })
                if (!fileinfo) return
                var filetype = fileinfo.type
                var fileinfo2 = await validateFile(currenturl2, false, {
                    size: `the second file exceeds the size limit of {param} mb hahahaha (try to use the shrink, setfps, trim or crunch commands)`,
                    frames: `the frames of the second file exceed the limit of {param} hahahaha (try to use the setfps or the trim commands)`,
                    width: `the width of the second file exceeds the limit of {param} hahahaha (try to use the shrink command)`,
                    height: `the height of the second file exceeds the limit of {param} hahahaha (try to use the shrink command)`
                }).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })
                if (!fileinfo2) return
                var filetype2 = fileinfo2.type
                var filetypes = [filetype, filetype2]
                for (var i in errors) {
                    var error = errors[i]
                    if (error) {
                        msg.channel.send({
                            content: error,
                            allowedMentions: {
                                parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                            }
                        }).catch(() => { })
                        msg.channel.sendTyping().catch(() => { })
                        return
                    }
                }
                for (var i in filetypes) {
                    var type = filetypes[i]
                    if (!(type.mime.startsWith('image') || type.mime.startsWith('video'))) {
                        msg.channel.send({
                            content: 'Unsupported file types.',
                            allowedMentions: {
                                parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                            }
                        }).catch(() => { })
                        msg.channel.sendTyping().catch(() => { })
                        return
                    }
                }
                var currentcount = filecount
                filecount++
                var filepath = `temp/file${currentcount}`
                fs.mkdirSync(`${filepath}`)
                var frame = await Jimp.read(currenturl)
                var frame2 = await Jimp.read(currenturl2)
                var canyoufind = await Jimp.read(`templates/canyoufind.png`)
                var transparent = await Jimp.read(`templates/transparent.png`)
                var squareS = { value: ((frame.bitmap.height === frame.bitmap.width) && frame.bitmap.width) || ((frame.bitmap.height > frame.bitmap.width) && frame.bitmap.height) || frame.bitmap.width, constraint: ((frame.bitmap.height === frame.bitmap.width) && 'both') || ((frame.bitmap.height > frame.bitmap.width) && 'height') || 'width' }
                frame2.resize(squareS.constraint === 'width' || squareS.constraint === 'both' ? size : Jimp.AUTO, squareS.constraint === 'height' || squareS.constraint === 'both' ? size : Jimp.AUTO)
                var frame2stretched = frame2.clone()
                frame2stretched.resize(227, 53)
                canyoufind.composite(frame2stretched, 347, 8)
                frame.resize(canyoufind.bitmap.width, Jimp.AUTO)
                frame.composite(frame2, (Math.floor(Math.random() * (frame.bitmap.width + 1)) - 1) - frame2.bitmap.width / 2, (Math.floor(Math.random() * (frame.bitmap.height + 1)) - 1) - frame2.bitmap.height / 2)
                transparent.resize(frame.bitmap.width, frame.bitmap.height + canyoufind.bitmap.height)
                transparent.composite(canyoufind, 0, 0)
                transparent.composite(frame, 0, canyoufind.bitmap.height)
                await transparent.writeAsync(`${filepath}/output.png`);
                await sendFile(msg, filepath, `output.png`)
            },
            help: {
                "name": "canyoufind/find <background> <tofind> [-size <pixels>]",
                "value": "Can you find mario (only works with static images though)\nExample usage: p:find https://images.herzindagi.info/image/2020/Jun/chocolate-parle-g-ice-cream.jpg https://pbs.twimg.com/media/BOgwprmCEAAvjq3.jpg -size 50"
            },
            cooldown: 2500,
            type: "Memes"
        },

        {
            name: ["mixaudio", "mixsound", "mixmusic"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl2'] === undefined && args[2] === undefined) {
                    msg.channel.send('What are the files?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
                var currenturl2 = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl2'] || args[2]
                var urls = await getUrls(msg).catch(() => { }) ?? []
                if (urls.length < 2) {
                    var c = currenturl
                    currenturl = currenturl2
                    currenturl2 = c
                }
                var errors = {}
                var fileinfo = await validateFile(currenturl, false, {
                    size: `the first file exceeds the size limit of {param} mb hahahaha (try to use the shrink, setfps, trim or crunch commands)`,
                    frames: `the frames of the first file exceed the limit of {param} hahahaha (try to use the setfps or the trim commands)`,
                    width: `the width of the first file exceeds the limit of {param} hahahaha (try to use the shrink command)`,
                    height: `the height of the first file exceeds the limit of {param} hahahaha (try to use the shrink command)`
                }).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })
                if (!fileinfo) return
                var filetype = fileinfo.type
                var fileinfo2 = await validateFile(currenturl2, true, {
                    size: `the second file exceeds the exception size limit of {param} mb hahahaha there's nothing you can do`,
                    frames: `the frames of the second file exceed the exception limit of {param} hahahaha there's nothing you can do`,
                    width: `the width of the second file exceeds the exception limit of {param} hahahaha there's nothing you can do`,
                    height: `the height of the second file exceeds the exception limit of {param} hahahaha there's nothing you can do`
                }).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })
                if (!fileinfo2) return
                var filetype2 = fileinfo2.type
                var filetypes = [filetype, filetype2]
                for (var i in errors) {
                    var error = errors[i]
                    if (error) {
                        msg.channel.send({
                            content: error,
                            allowedMentions: {
                                parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                            }
                        }).catch(() => { })
                        msg.channel.sendTyping().catch(() => { })
                        return
                    }
                }
                for (var i in filetypes) {
                    var type = filetypes[i]
                    if (!(type.mime.startsWith('image') || type.mime.startsWith('video') || type.mime.startsWith('audio'))) {
                        msg.channel.send({
                            content: 'Unsupported file types.',
                            allowedMentions: {
                                parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                            }
                        }).catch(() => { })
                        msg.channel.sendTyping().catch(() => { })
                        return
                    }
                }
                var filepath = await downloadFile(currenturl, `input.${fileinfo.shortext}`, {
                    fileinfo: fileinfo
                })
                var filename = `input.${fileinfo.shortext}`
                await downloadFile(currenturl2, `input2.${fileinfo2.shortext}`, {
                    fileinfo: fileinfo2,
                    filepath: filepath
                })
                var filename2 = `input2.${fileinfo2.shortext}`

                var duration = fileinfo.info.duration
                var duration2 = fileinfo2.info.duration
                var audio = fileinfo.info.audio
                var audio2 = fileinfo2.info.audio

                if (audio2) {
                    duration = Number(duration)
                    duration2 = Number(duration2)

                    var offset = 0
                    var offsetindex = args.indexOf('-offset')
                    if (offsetindex > -1) {
                        var offsetstamp = args[offsetindex + 1]
                        if (offsetstamp !== undefined) {
                            var total = 0
                            offsetstamp = offsetstamp.split(':').reverse()
                            offsetstamp.splice(3)
                            for (var i = 0; i < offsetstamp.length; i++) {
                                offsetstamp[i] = isNaN(Number(offsetstamp[i])) ? 0 : Number(offsetstamp[i]) <= 0 ? 0 : Number(offsetstamp[i]) * (Math.pow(60, i)) || 0
                                total += offsetstamp[i]
                            }
                            offset = total >= duration ? duration : total
                        }
                    }

                    await execPromise(filetype.mime.startsWith('image') ? `ffmpeg -stream_loop -1 -i ${filepath}/${filename} -itsoffset ${offset} -i ${filepath}/${filename2} -filter_complex "[0:v]scale=ceil(iw/2)*2:ceil(ih/2)*2[v]" -map "[v]" -map 1:a -preset ${findpreset(args)} -c:v libx264 -tune stillimage -c:a aac -pix_fmt yuv420p -shortest -t ${duration2 + offset} ${filepath}/output.mp4` : !audio ? `ffmpeg -i ${filepath}/${filename} -itsoffset ${offset} -i ${filepath}/${filename2} -filter_complex "[0:v]scale=ceil(iw/2)*2:ceil(ih/2)*2[v]" -map "[v]" -map 1:a -c:v libx264 -tune stillimage -c:a aac -pix_fmt yuv420p -shortest -t ${duration} ${filepath}/output.mp4` : `ffmpeg -y -i ${filepath}/${filename} -itsoffset ${offset} -i ${filepath}/${filename2} -filter_complex "[0:a][1:a]amix=inputs=2:duration=longest[a]" ${!(filetype.mime.startsWith('audio')) ? '-map 0:v ' : ''}-map "[a]" -preset ${findpreset(args)} ${!(filetype.mime.startsWith('audio')) ? '-c:v libx264 -pix_fmt yuv420p ' : ''} -shortest -t ${duration} ${filepath}/output.${!(filetype.mime.startsWith('audio')) ? 'mp4' : 'mp3'}`)
                    await sendFile(msg, filepath, `output.${!(filetype.mime.startsWith('audio')) ? 'mp4' : 'mp3'}`)
                } else {
                    await msg.channel.send('No audio stream detected.').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    fs.rmSync(`${filepath}`, { force: true, recursive: true })
                }
            },
            help: {
                "name": "mixaudio/mixsound/mixmusic <file> <audio> [-offset <seconds (you can use hh:mm:ss)>]",
                "value": "Mixes the first file's audio with the second file's audio."
            },
            cooldown: 2500,
            type: "Audio"
        },

        {
            name: ["addaudio", "addsound", "addmusic"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl2'] === undefined && args[2] === undefined) {
                    msg.channel.send('What are the files?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
                var currenturl2 = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl2'] || args[2]
                var urls = await getUrls(msg).catch(() => { }) ?? []
                if (urls.length < 2) {
                    var c = currenturl
                    currenturl = currenturl2
                    currenturl2 = c
                }
                var errors = {}
                var fileinfo = await validateFile(currenturl, false, {
                    size: `the first file exceeds the size limit of {param} mb hahahaha (try to use the shrink, setfps, trim or crunch commands)`,
                    frames: `the frames of the first file exceed the limit of {param} hahahaha (try to use the setfps or the trim commands)`,
                    width: `the width of the first file exceeds the limit of {param} hahahaha (try to use the shrink command)`,
                    height: `the height of the first file exceeds the limit of {param} hahahaha (try to use the shrink command)`
                }).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })
                if (!fileinfo) return
                var filetype = fileinfo.type
                var fileinfo2 = await validateFile(currenturl2, true, {
                    size: `the second file exceeds the exception size limit of {param} mb hahahaha there's nothing you can do`,
                    frames: `the frames of the second file exceed the exception limit of {param} hahahaha there's nothing you can do`,
                    width: `the width of the second file exceeds the exception limit of {param} hahahaha there's nothing you can do`,
                    height: `the height of the second file exceeds the exception limit of {param} hahahaha there's nothing you can do`
                }).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })
                if (!fileinfo2) return
                var filetype2 = fileinfo2.type
                var filetypes = [filetype, filetype2]
                for (var i in errors) {
                    var error = errors[i]
                    if (error) {
                        msg.channel.send({
                            content: error,
                            allowedMentions: {
                                parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                            }
                        }).catch(() => { })
                        msg.channel.sendTyping().catch(() => { })
                        return
                    }
                }
                for (var i in filetypes) {
                    var type = filetypes[i]
                    if (!(type.mime.startsWith('image') || type.mime.startsWith('video') || type.mime.startsWith('audio'))) {
                        msg.channel.send({
                            content: 'Unsupported file types.',
                            allowedMentions: {
                                parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                            }
                        }).catch(() => { })
                        msg.channel.sendTyping().catch(() => { })
                        return
                    }
                }
                var filepath = await downloadFile(currenturl, `input.${fileinfo.shortext}`, {
                    fileinfo: fileinfo
                })
                var filename = `input.${fileinfo.shortext}`
                await downloadFile(currenturl2, `input2.${fileinfo2.shortext}`, {
                    fileinfo: fileinfo2,
                    filepath: filepath
                })
                var filename2 = `input2.${fileinfo2.shortext}`

                var duration = fileinfo.info.duration
                var duration2 = fileinfo2.info.duration
                var audio = fileinfo.info.audio
                var audio2 = fileinfo2.info.audio

                if (audio2) {
                    duration = Number(duration)
                    duration2 = Number(duration2)

                    var offset = 0
                    var offsetindex = args.indexOf('-offset')
                    if (offsetindex > -1) {
                        var offsetstamp = args[offsetindex + 1]
                        if (offsetstamp !== undefined) {
                            var total = 0
                            offsetstamp = offsetstamp.split(':').reverse()
                            offsetstamp.splice(3)
                            for (var i = 0; i < offsetstamp.length; i++) {
                                offsetstamp[i] = isNaN(Number(offsetstamp[i])) ? 0 : Number(offsetstamp[i]) <= 0 ? 0 : Number(offsetstamp[i]) * (Math.pow(60, i)) || 0
                                total += offsetstamp[i]
                            }
                            offset = total >= duration ? duration : total
                        }
                    }

                    await execPromise(filetype.mime.startsWith('video') ? `ffmpeg -i ${filepath}/${filename} ${audio ? `-t ${duration - offset}` : `-itsoffset ${offset}`} -i ${filepath}/${filename2} ${offset ? `-t ${offset} -i ${filepath}/${filename} ` : ''}-filter_complex "[0:v]scale=ceil(iw/2)*2:ceil(ih/2)*2[v]${(offset && audio) ? `;[2:a][1:a]concat=v=0:a=1[a]` : ''}" -map "[v]" ${(offset && audio) ? '-map "[a]"' : '-map 1:a'} -c:v libx264 -pix_fmt yuv420p -t ${(duration2 + offset <= duration) && !(args.find(arg => arg === '-waituntilend')) ? duration2 + offset : duration} ${filepath}/output.mp4` : `ffmpeg -stream_loop -1 -i ${filepath}/${filename} -itsoffset ${offset} -i ${filepath}/${filename2} -filter_complex "[0:v]scale=ceil(iw/2)*2:ceil(ih/2)*2[v]" -map "[v]" -map 1:a -c:v libx264 -tune stillimage -c:a aac -pix_fmt yuv420p -shortest -t ${duration2 + offset} ${filepath}/output.mp4`)
                    await sendFile(msg, filepath, `output.mp4`)
                } else {
                    await msg.channel.send('No audio stream detected.').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    fs.rmSync(`${filepath}`, { force: true, recursive: true })
                }
            },
            help: {
                "name": "addaudio/addsound/addmusic <file> <audio> [-offset <seconds (you can use hh:mm:ss)>] [-waituntilend]",
                "value": "Adds the second file's audio to the first file."
            },
            cooldown: 2500,
            type: "Audio"
        },

        {
            name: ["chromakey", "chroma"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl2'] === undefined && args[2] === undefined) {
                    msg.channel.send('What are the files?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var rgb = {
                    r: 0,
                    g: 255,
                    b: 0,
                }
                var colorindex = args.indexOf('-color')
                if (colorindex > -1) {
                    var r = args[colorindex + 1]
                    var g = args[colorindex + 2]
                    var b = args[colorindex + 3]
                    rgb.r = isNaN(Number(String(r).replace(/,/g, ''))) ? 0 : Number(String(r).replace(/,/g, '')) <= 0 ? 0 : Number(String(r).replace(/,/g, '')) >= 255 ? 255 : Number(String(r).replace(/,/g, '')) || 0
                    rgb.g = isNaN(Number(String(g).replace(/,/g, ''))) ? 0 : Number(String(g).replace(/,/g, '')) <= 0 ? 0 : Number(String(g).replace(/,/g, '')) >= 255 ? 255 : Number(String(g).replace(/,/g, '')) || 0
                    rgb.b = isNaN(Number(String(b).replace(/,/g, ''))) ? 0 : Number(String(b).replace(/,/g, '')) <= 0 ? 0 : Number(String(b).replace(/,/g, '')) >= 255 ? 255 : Number(String(b).replace(/,/g, '')) || 0
                }
                var rgbhex = `0x${rgb.r.toString(16).padStart(2, '0').toUpperCase()}${rgb.g.toString(16).padStart(2, '0').toUpperCase()}${rgb.b.toString(16).padStart(2, '0').toUpperCase()}`
                var similarity = 30
                var similarityindex = args.indexOf('-similarity')
                if (similarityindex > -1) {
                    similarity = isNaN(Number(args[similarityindex + 1])) ? 30 : Number(args[similarityindex + 1]) <= 0 ? 0 : Number(args[similarityindex + 1]) >= 100 ? 100 : Number(args[similarityindex + 1]) ?? 30
                }
                var blend = 30
                var blendindex = args.indexOf('-blend')
                if (blendindex > -1) {
                    blend = isNaN(Number(args[blendindex + 1])) ? 30 : Number(args[blendindex + 1]) <= 0 ? 0 : Number(args[blendindex + 1]) >= 100 ? 100 : Number(args[blendindex + 1]) ?? 30
                }
                var keepaspectratio
                var origins = {
                    x: {
                        left: '0',
                        center: '(W-w)/2',
                        right: '(W-w)'
                    },

                    y: {
                        top: '0',
                        middle: '(H-h)/2',
                        bottom: '(H-h)'
                    },
                }
                var originx = '(W-w)/2'
                var originy = '(H-h)/2'
                var originindex = args.indexOf('-origin')
                if (originindex > -1) {
                    originx = origins.x[args[originindex + 1]] || '(W-w)/2'
                    originy = origins.y[args[originindex + 2]] || '(H-h)/2'
                }
                var ratioindex = args.indexOf('-keepaspectratio')
                if (ratioindex > -1) {
                    if (args[ratioindex + 1] == 'increase' || args[ratioindex + 1] == 'decrease') {
                        keepaspectratio = args[ratioindex + 1]
                    }
                }
                var ox = 0
                var oy = 0
                var offsetindex = args.indexOf('-offsetpos')
                if (offsetindex > -1) {
                    ox = isNaN(Number(String(args[offsetindex + 1]).replace(/,/g, ''))) ? 0 : Number(String(args[offsetindex + 1]).replace(/,/g, '')) || 0
                    oy = isNaN(Number(String(args[offsetindex + 2]).replace(/,/g, ''))) ? 0 : Number(String(args[offsetindex + 2]).replace(/,/g, '')) || 0
                }
                var size = 0
                var sizeindex = args.indexOf('-size')
                if (sizeindex > -1) {
                    size = isNaN(Number(args[sizeindex + 1])) ? 0 : Number(args[sizeindex + 1]) <= 1 ? 1 : Number(args[sizeindex + 1]) || 0
                }
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
                var currenturl2 = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl2'] || args[2]
                var urls = await getUrls(msg).catch(() => { }) ?? []
                if (urls.length < 2) {
                    var c = currenturl
                    currenturl = currenturl2
                    currenturl2 = c
                }
                var errors = {}
                var fileinfo = await validateFile(currenturl, false, {
                    size: `the first file exceeds the size limit of {param} mb hahahaha (try to use the shrink, setfps, trim or crunch commands)`,
                    frames: `the frames of the first file exceed the limit of {param} hahahaha (try to use the setfps or the trim commands)`,
                    width: `the width of the first file exceeds the limit of {param} hahahaha (try to use the shrink command)`,
                    height: `the height of the first file exceeds the limit of {param} hahahaha (try to use the shrink command)`
                }).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })
                if (!fileinfo) return
                var filetype = fileinfo.type
                var fileinfo2 = await validateFile(currenturl2, false, {
                    size: `the second file exceeds the size limit of {param} mb hahahaha (try to use the shrink, setfps, trim or crunch commands)`,
                    frames: `the frames of the second file exceed the limit of {param} hahahaha (try to use the setfps or the trim commands)`,
                    width: `the width of the second file exceeds the limit of {param} hahahaha (try to use the shrink command)`,
                    height: `the height of the second file exceeds the limit of {param} hahahaha (try to use the shrink command)`
                }).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })
                if (!fileinfo2) return
                var filetype2 = fileinfo2.type
                var filetypes = [filetype, filetype2]
                for (var i in errors) {
                    var error = errors[i]
                    if (error) {
                        msg.channel.send({
                            content: error,
                            allowedMentions: {
                                parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                            }
                        }).catch(() => { })
                        msg.channel.sendTyping().catch(() => { })
                        return
                    }
                }
                for (var i in filetypes) {
                    var type = filetypes[i]
                    if (!(type.mime.startsWith('image') || type.mime.startsWith('video'))) {
                        msg.channel.send({
                            content: 'Unsupported file types.',
                            allowedMentions: {
                                parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                            }
                        }).catch(() => { })
                        msg.channel.sendTyping().catch(() => { })
                        return
                    }
                }
                var filepath = await downloadFile(currenturl, `input.${fileinfo.shortext}`, {
                    fileinfo: fileinfo,
                })
                var filename = `input.${fileinfo.shortext}`
                await downloadFile(currenturl2, `input2.${fileinfo2.shortext}`, {
                    fileinfo: fileinfo2,
                    filepath: filepath
                })
                var filename2 = `input2.${fileinfo2.shortext}`

                var width = fileinfo.info.width
                var height = fileinfo.info.height

                var size = [-1, height]

                var widthindex = args.indexOf('-width')
                if (widthindex > -1) {
                    var percentage = String(args[widthindex + 1]).endsWith('%')
                    if (percentage) {
                        args[widthindex + 1] = args[widthindex + 1].substring(0, args[widthindex + 1].length - 1)
                    }
                    size[0] = (percentage ? width : 1) * ((isNaN(Number(args[widthindex + 1])) ? 0 : Number(args[widthindex + 1]) <= 0 ? 0 : Number(args[widthindex + 1]) || 0) / (percentage ? 100 : 1))
                    size[1] = -1
                }

                var heightindex = args.indexOf('-height')
                if (heightindex > -1) {
                    var percentage = String(args[heightindex + 1]).endsWith('%')
                    if (percentage) {
                        args[heightindex + 1] = args[heightindex + 1].substring(0, args[heightindex + 1].length - 1)
                    }
                    size[1] = (percentage ? height : 1) * ((isNaN(Number(args[heightindex + 1])) ? 0 : Number(args[heightindex + 1]) <= 0 ? 0 : Number(args[heightindex + 1]) || 0) / (percentage ? 100 : 1))
                } z

                if ((filetype.mime.startsWith('image') && !(gifFormats.find(f => f === filetype.ext))) && (filetype2.mime.startsWith('image') && !(gifFormats.find(f => f === filetype2.ext)))) {
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -i ${filepath}/${filename2} -filter_complex "[1:v]colorkey=${rgbhex}:${similarity / 100}:${blend / 100},scale=${size[0]}:${size[1]}${keepaspectratio ? `:force_original_aspect_ratio=${keepaspectratio}` : ''}[chroma];[0:v][chroma]overlay=shortest=1:x=${originx}+${Math.round(ox)}:y=${originy}+${Math.round(oy)}:format=auto[out]" -map "[out]" -preset ${findpreset(args)} ${filepath}/output.png`)
                    await sendFile(msg, filepath, `output.png`)
                } else if ((filetype.mime.startsWith('image') && !(gifFormats.find(f => f === filetype.ext))) && ((filetype2.mime.startsWith('image') && gifFormats.find(f => f === filetype2.ext)))) {
                    await execPromise(`ffmpeg -stream_loop -1 -i ${filepath}/${filename} -i ${filepath}/${filename2} -filter_complex "[1:v]colorkey=${rgbhex}:${similarity / 100}:${blend / 100},scale=-1:${size[0]}:${size[1]}${keepaspectratio ? `:force_original_aspect_ratio=${keepaspectratio}` : ''}[chroma];[0:v][chroma]overlay=shortest=1:x=${originx}+${Math.round(ox)}:y=${originy}+${Math.round(oy)}:format=auto[qout];[qout]scale='min(400,iw)':min'(400,ih)':force_original_aspect_ratio=decrease[rout];[rout]split[gnout][gpout];[gpout]palettegen=reserve_transparent=1[palette];[gnout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ${findpreset(args)} -gifflags -offsetting ${filepath}/output.gif`)
                    await sendFile(msg, filepath, `output.gif`)
                } else if ((filetype.mime.startsWith('image') && gifFormats.find(f => f === filetype.ext)) && (filetype2.mime.startsWith('image') && !(gifFormats.find(f => f === filetype2.ext)))) {
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -stream_loop -1 -i ${filepath}/${filename2} -filter_complex "[1:v]colorkey=${rgbhex}:${similarity / 100}:${blend / 100},scale=-1:${size[0]}:${size[1]}${keepaspectratio ? `:force_original_aspect_ratio=${keepaspectratio}` : ''}[chroma];[0:v][chroma]overlay=shortest=1:x=${originx}+${Math.round(ox)}:y=${originy}+${Math.round(oy)}:format=auto[sout];[sout]split[gnout][gpout];[gpout]palettegen=reserve_transparent=1[palette];[gnout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ${findpreset(args)} -gifflags -offsetting ${filepath}/output.gif`)
                    await sendFile(msg, filepath, `output.gif`)
                } else if (filetype.mime.startsWith('video') || filetype2.mime.startsWith('video')) {
                    await execPromise(`ffmpeg ${(filetype2.mime.startsWith('video') && !(filetype.mime.startsWith('video'))) ? '-stream_loop -1 ' : ''}-i ${filepath}/${filename} ${(filetype.mime.startsWith('video') && !(filetype2.mime.startsWith('video'))) ? '-stream_loop -1 ' : ''}-i ${filepath}/${filename2} -map ${filetype.mime.startsWith('video') ? '0' : '1'}:a? -filter_complex "[1:v]colorkey=${rgbhex}:${similarity / 100}:${blend / 100},scale=-1:${size[0]}:${size[1]}${keepaspectratio ? `:force_original_aspect_ratio=${keepaspectratio}` : ''}[chroma];[0:v][chroma]overlay=shortest=1:x=${originx}+${Math.round(ox)}:y=${originy}+${Math.round(oy)}:format=auto[sout];[sout]scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ${findpreset(args)} -c:v libx264 -pix_fmt yuv420p ${filepath}/output.mp4`)
                    await sendFile(msg, filepath, `output.mp4`)
                } else {
                    await execPromise(`ffmpeg -stream_loop -1 -i ${filepath}/${filename} -i ${filepath}/${filename2} -filter_complex "[1:v]colorkey=${rgbhex}:${similarity / 100}:${blend / 100},scale=-1:${size[0]}:${size[1]}${keepaspectratio ? `:force_original_aspect_ratio=${keepaspectratio}` : ''}[chroma];[0:v][chroma]overlay=shortest=1:x=${originx}+${Math.round(ox)}:y=${originy}+${Math.round(oy)}:format=auto[rout];[rout]split[gnout][gpout];[gpout]palettegen=reserve_transparent=1[palette];[gnout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ${findpreset(args)} -gifflags -offsetting ${filepath}/output.gif`)
                    await sendFile(msg, filepath, `output.gif`)
                }
            },
            help: {
                "name": "chromakey/chroma <file> <chromakey> [-color <r> <g> <b>] [-similarity (from 0 to 100)] [-blend (from 0 to 100)] [-origin <x (left/center/right)> <y (top/middle/bottom)>] [-offsetpos <x> <y>] [-size <pixels>]",
                "value": "Adds the specified chroma key to the file. Default similarity and blend are 30."
            },
            cooldown: 2500,
            type: "Overlaying"
        },

        {
            name: ["chromakeybg", "chromabg"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var rgb = {
                    r: 0,
                    g: 255,
                    b: 0,
                }
                var colorindex = args.indexOf('-color')
                if (colorindex > -1) {
                    var r = args[colorindex + 1]
                    var g = args[colorindex + 2]
                    var b = args[colorindex + 3]
                    rgb.r = isNaN(Number(String(r).replace(/,/g, ''))) ? 0 : Number(String(r).replace(/,/g, '')) <= 0 ? 0 : Number(String(r).replace(/,/g, '')) >= 255 ? 255 : Number(String(r).replace(/,/g, '')) || 0
                    rgb.g = isNaN(Number(String(g).replace(/,/g, ''))) ? 0 : Number(String(g).replace(/,/g, '')) <= 0 ? 0 : Number(String(g).replace(/,/g, '')) >= 255 ? 255 : Number(String(g).replace(/,/g, '')) || 0
                    rgb.b = isNaN(Number(String(b).replace(/,/g, ''))) ? 0 : Number(String(b).replace(/,/g, '')) <= 0 ? 0 : Number(String(b).replace(/,/g, '')) >= 255 ? 255 : Number(String(b).replace(/,/g, '')) || 0
                }
                var rgbhex = `0x${rgb.r.toString(16).padStart(2, '0').toUpperCase()}${rgb.g.toString(16).padStart(2, '0').toUpperCase()}${rgb.b.toString(16).padStart(2, '0').toUpperCase()}`
                var similarity = 30
                var similarityindex = args.indexOf('-similarity')
                if (similarityindex > -1) {
                    similarity = isNaN(Number(args[similarityindex + 1])) ? 30 : Number(args[similarityindex + 1]) <= 0 ? 0 : Number(args[similarityindex + 1]) >= 100 ? 100 : Number(args[similarityindex + 1]) ?? 30
                }
                var blend = 30
                var blendindex = args.indexOf('-blend')
                if (blendindex > -1) {
                    blend = isNaN(Number(args[blendindex + 1])) ? 30 : Number(args[blendindex + 1]) <= 0 ? 0 : Number(args[blendindex + 1]) >= 100 ? 100 : Number(args[blendindex + 1]) ?? 30
                }
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
                var fileinfo = await validateFile(currenturl).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })

                if (!fileinfo) return
                var type = fileinfo.type

                if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                    var filepath = await downloadFile(currenturl, `input.png`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.png`
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -filter_complex "[0:v]colorkey=${rgbhex}:${similarity / 100}:${blend / 100}[out]" -map "[out]" -preset ${findpreset(args)} ${filepath}/output.png`)
                    await sendFile(msg, filepath, `output.png`)
                } else if (type.mime.startsWith('video')) {
                    var filepath = await downloadFile(currenturl, `input.mp4`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp4`
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -i templates/billboard.png -map 0:a? -filter_complex "[0:v]colorkey=${rgbhex}:${similarity / 100}:${blend / 100}[oout];[oout]scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ${findpreset(args)} -c:v libx264 -pix_fmt yuv420p ${filepath}/output.mp4`)
                    await sendFile(msg, filepath, `output.mp4`)
                } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                    var filepath = await downloadFile(currenturl, `input.gif`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.gif`
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -i templates/billboard.png -filter_complex "[0:v]colorkey=${rgbhex}:${similarity / 100}:${blend / 100}[oout];[oout]split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ${findpreset(args)} -gifflags -offsetting ${filepath}/output.gif`)
                    await sendFile(msg, filepath, `output.gif`)
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "chromakeybg/chromabg <file> [-color <r> <g> <b>] [-similarity (from 0 to 100)] [-blend (from 0 to 100)]",
                "value": "Tries to remove the file's background with chroma key."
            },
            cooldown: 2500,
            type: "Effects"
        },

        {
            name: ["8bit", "reducecolors"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var colors = 30
                var colorsindex = args.indexOf('-colors')
                if (colorsindex > -1) {
                    colors = isNaN(Number(args[colorsindex + 1])) ? 30 : Number(args[colorsindex + 1]) <= 1 ? 1 : Number(args[colorsindex + 1]) >= 255 ? 255 : Math.round(Number(args[colorsindex + 1])) ?? 30
                }
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
                var fileinfo = await validateFile(currenturl, true).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })

                if (!fileinfo) return
                var type = fileinfo.type

                if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                    var filepath = await downloadFile(currenturl, `input.png`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.png`
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -filter_complex "[0:v]split[pout][ppout];[ppout]palettegen=max_colors=${colors}:reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ${findpreset(args)} ${filepath}/output.png`)
                    await sendFile(msg, filepath, `output.png`)
                } else if (type.mime.startsWith('video')) {
                    var filepath = await downloadFile(currenturl, `input.mp4`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp4`
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -i templates/billboard.png -map 0:a? -filter_complex "[0:v]split[pout][ppout];[ppout]palettegen=max_colors=${colors}[palette];[pout][palette]paletteuse=alpha_threshold=128,scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ${findpreset(args)} -c:v libx264 -pix_fmt yuv420p ${filepath}/output.mp4`)
                    await sendFile(msg, filepath, `output.mp4`)
                } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                    var filepath = await downloadFile(currenturl, `input.gif`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.gif`
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -i templates/billboard.png -filter_complex "[0:v]split[pout][ppout];[ppout]palettegen=max_colors=${colors}:reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ${findpreset(args)} -gifflags -offsetting ${filepath}/output.gif`)
                    await sendFile(msg, filepath, `output.gif`)
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "<:newpoopy:839191885310066729> 8bit/reducecolors <file> [-colors <number (from 1 to 255)>]",
                "value": "Reduces the color range within the file, being able to produce some 8-bit-ish effect when low."
            },
            cooldown: 2500,
            type: "Compression"
        },

        {
            name: ["alphaextract", "createmask"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
                var fileinfo = await validateFile(currenturl).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })

                if (!fileinfo) return
                var type = fileinfo.type

                if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                    var filepath = await downloadFile(currenturl, `input.png`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.png`
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -filter_complex "[0:v]alphaextract[out]" -map "[out]" -preset ${findpreset(args)} ${filepath}/output.png`)
                    await sendFile(msg, filepath, `output.png`)
                } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                    var filepath = await downloadFile(currenturl, `input.gif`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.gif`
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -i templates/billboard.png -filter_complex "[0:v]alphaextract,split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ${findpreset(args)} -gifflags -offsetting ${filepath}/output.gif`)
                    await sendFile(msg, filepath, `output.gif`)
                } else if (type.mime.startsWith('video')) {
                    msg.channel.send(`videos have no alpha channel + cry about it + stay mad + get real + L + mald seethe cope harder + don't care + didn't ask + hoes mad + basic + skill issue + ratio + you fell off + the audacity + triggered + any askers + redpilled + get a life + ok and? + cringe + touch grass + donowalled + not based + your're a (insert stereotype) + not funny didn't laugh + you're* + grammar issue + go outside + get good + reported + ad hominem + GG! + ur mom`).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "<:newpoopy:839191885310066729> alphaextract/createmask <image/gif>",
                "value": "Extracts the alpha from the file."
            },
            cooldown: 2500,
            type: "Effects"
        },

        {
            name: ["overlay"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl2'] === undefined && args[2] === undefined) {
                    msg.channel.send('What are the files?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                }
                var keepaspectratio
                var origins = {
                    x: {
                        left: '0',
                        center: '(W-w)/2',
                        right: '(W-w)'
                    },

                    y: {
                        top: '0',
                        middle: '(H-h)/2',
                        bottom: '(H-h)'
                    },
                }
                var originx = '(W-w)/2'
                var originy = '(H-h)/2'
                var originindex = args.indexOf('-origin')
                if (originindex > -1) {
                    originx = origins.x[args[originindex + 1]] || '(W-w)/2'
                    originy = origins.y[args[originindex + 2]] || '(H-h)/2'
                }
                var ox = 0
                var oy = 0
                var offsetindex = args.indexOf('-offsetpos')
                if (offsetindex > -1) {
                    ox = isNaN(Number(String(args[offsetindex + 1]).replace(/,/g, ''))) ? 0 : Number(String(args[offsetindex + 1]).replace(/,/g, '')) || 0
                    oy = isNaN(Number(String(args[offsetindex + 2]).replace(/,/g, ''))) ? 0 : Number(String(args[offsetindex + 2]).replace(/,/g, '')) || 0
                }
                var ratioindex = args.indexOf('-keepaspectratio')
                if (ratioindex > -1) {
                    if (args[ratioindex + 1] == 'increase' || args[ratioindex + 1] == 'decrease') {
                        keepaspectratio = args[ratioindex + 1]
                    }
                }
                var currenturl = args.find(arg => arg === '-localcmd') ? args[1] : (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1])
                var currenturl2 = args.find(arg => arg === '-localcmd') ? args[2] : (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl2'] || args[2])
                var urls = await getUrls(msg).catch(() => { }) ?? []
                if (urls.length < 2) {
                    var c = currenturl
                    currenturl = currenturl2
                    currenturl2 = c
                }
                var errors = {}
                var fileinfo = await validateFile(currenturl, false, {
                    size: `the first file exceeds the size limit of {param} mb hahahaha (try to use the shrink, setfps, trim or crunch commands)`,
                    frames: `the frames of the first file exceed the limit of {param} hahahaha (try to use the setfps or the trim commands)`,
                    width: `the width of the first file exceeds the limit of {param} hahahaha (try to use the shrink command)`,
                    height: `the height of the first file exceeds the limit of {param} hahahaha (try to use the shrink command)`
                }).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })
                if (!fileinfo) return
                var filetype = fileinfo.type
                var fileinfo2 = await validateFile(currenturl2, false, {
                    size: `the second file exceeds the size limit of {param} mb hahahaha (try to use the shrink, setfps, trim or crunch commands)`,
                    frames: `the frames of the second file exceed the limit of {param} hahahaha (try to use the setfps or the trim commands)`,
                    width: `the width of the second file exceeds the limit of {param} hahahaha (try to use the shrink command)`,
                    height: `the height of the second file exceeds the limit of {param} hahahaha (try to use the shrink command)`
                }).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })
                if (!fileinfo2) return
                var filetype2 = fileinfo2.type
                var filetypes = [filetype, filetype2]
                for (var i in errors) {
                    var error = errors[i]
                    if (error) {
                        msg.channel.send({
                            content: error,
                            allowedMentions: {
                                parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                            }
                        }).catch(() => { })
                        msg.channel.sendTyping().catch(() => { })
                        return
                    }
                }
                for (var i in filetypes) {
                    var type = filetypes[i]
                    if (!(type.mime.startsWith('image') || type.mime.startsWith('video'))) {
                        msg.channel.send({
                            content: 'Unsupported file types.',
                            allowedMentions: {
                                parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                            }
                        }).catch(() => { })
                        msg.channel.sendTyping().catch(() => { })
                        return
                    }
                }
                var filepath = await downloadFile(currenturl, `input.${fileinfo.shortext}`, {
                    fileinfo: fileinfo,
                })
                var filename = `input.${fileinfo.shortext}`
                await downloadFile(currenturl2, `input2.${fileinfo2.shortext}`, {
                    fileinfo: fileinfo2,
                    filepath: filepath
                })
                var filename2 = `input2.${fileinfo2.shortext}`

                var width = fileinfo.info.width
                var height = fileinfo.info.height

                var size = [-1, height]

                var widthindex = args.indexOf('-width')
                if (widthindex > -1) {
                    var percentage = String(args[widthindex + 1]).endsWith('%')
                    if (percentage) {
                        args[widthindex + 1] = args[widthindex + 1].substring(0, args[widthindex + 1].length - 1)
                    }
                    size[0] = (percentage ? width : 1) * ((isNaN(Number(args[widthindex + 1])) ? 0 : Number(args[widthindex + 1]) <= 0 ? 0 : Number(args[widthindex + 1]) || 0) / (percentage ? 100 : 1))
                    size[1] = -1
                }

                var heightindex = args.indexOf('-height')
                if (heightindex > -1) {
                    var percentage = String(args[heightindex + 1]).endsWith('%')
                    if (percentage) {
                        args[heightindex + 1] = args[heightindex + 1].substring(0, args[heightindex + 1].length - 1)
                    }
                    size[1] = (percentage ? height : 1) * ((isNaN(Number(args[heightindex + 1])) ? 0 : Number(args[heightindex + 1]) <= 0 ? 0 : Number(args[heightindex + 1]) || 0) / (percentage ? 100 : 1))
                }

                if ((filetype.mime.startsWith('image') && !(gifFormats.find(f => f === filetype.ext))) && (filetype2.mime.startsWith('image') && !(gifFormats.find(f => f === filetype2.ext)))) {
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -i ${filepath}/${filename2} -filter_complex "[1:v]scale=${size[0]}:${size[1]}${keepaspectratio ? `:force_original_aspect_ratio=${keepaspectratio}` : ''}[overlay];[0:v][overlay]overlay=shortest=1:x=${originx}+${Math.round(ox)}:y=${originy}+${Math.round(oy)}:format=auto[out]" -map "[out]" -preset ${findpreset(args)} ${filepath}/output.png`)
                    await sendFile(msg, filepath, `output.png`)
                } else if ((filetype.mime.startsWith('image') && !(gifFormats.find(f => f === filetype.ext))) && ((filetype2.mime.startsWith('image') && gifFormats.find(f => f === filetype2.ext)))) {
                    await execPromise(`ffmpeg -stream_loop -1 -i ${filepath}/${filename} -i ${filepath}/${filename2} -filter_complex "[1:v]scale=${size[0]}:${size[1]}${keepaspectratio ? `:force_original_aspect_ratio=${keepaspectratio}` : ''}[overlay];[0:v][overlay]overlay=shortest=1:x=${originx}+${Math.round(ox)}:y=${originy}+${Math.round(oy)}:format=auto[qout];[qout]scale='min(400,iw)':min'(400,ih)':force_original_aspect_ratio=decrease[rout];[rout]split[gnout][gpout];[gpout]palettegen=reserve_transparent=1[palette];[gnout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ${findpreset(args)} -gifflags -offsetting ${filepath}/output.gif`)
                    await sendFile(msg, filepath, `output.gif`)
                } else if ((filetype.mime.startsWith('image') && gifFormats.find(f => f === filetype.ext)) && (filetype2.mime.startsWith('image') && !(gifFormats.find(f => f === filetype2.ext)))) {
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -stream_loop -1 -i ${filepath}/${filename2} -filter_complex "[1:v]scale=${size[0]}:${size[1]}${keepaspectratio ? `:force_original_aspect_ratio=${keepaspectratio}` : ''}[overlay];[0:v][overlay]overlay=shortest=1:x=${originx}+${Math.round(ox)}:y=${originy}+${Math.round(oy)}:format=auto[sout];[sout]split[gnout][gpout];[gpout]palettegen=reserve_transparent=1[palette];[gnout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ${findpreset(args)} -gifflags -offsetting ${filepath}/output.gif`)
                    await sendFile(msg, filepath, `output.gif`)
                } else if (filetype.mime.startsWith('video') || filetype2.mime.startsWith('video')) {
                    await execPromise(`ffmpeg ${(filetype2.mime.startsWith('video') && !(filetype.mime.startsWith('video'))) ? '-stream_loop -1 ' : ''}-i ${filepath}/${filename} ${(filetype.mime.startsWith('video') && !(filetype2.mime.startsWith('video'))) ? '-stream_loop -1 ' : ''}-i ${filepath}/${filename2} -map ${filetype.mime.startsWith('video') ? '0' : '1'}:a? -filter_complex "[1:v]scale=${size[0]}:${size[1]}${keepaspectratio ? `:force_original_aspect_ratio=${keepaspectratio}` : ''}[overlay];[0:v][overlay]overlay=shortest=1:x=${originx}+${Math.round(ox)}:y=${originy}+${Math.round(oy)}:format=auto[sout];[sout]scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ${findpreset(args)} -c:v libx264 -pix_fmt yuv420p ${filepath}/output.mp4`)
                    await sendFile(msg, filepath, `output.mp4`)
                } else {
                    await execPromise(`ffmpeg -stream_loop -1 -i ${filepath}/${filename} -i ${filepath}/${filename2} -filter_complex "[1:v]scale=${size[0]}:${size[1]}${keepaspectratio ? `:force_original_aspect_ratio=${keepaspectratio}` : ''}[overlay];[0:v][overlay]overlay=shortest=1:x=${originx}+${Math.round(ox)}:y=${originy}+${Math.round(oy)}:format=auto[rout];[rout]split[gnout][gpout];[gpout]palettegen=reserve_transparent=1[palette];[gnout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ${findpreset(args)} -gifflags -offsetting ${filepath}/output.gif`)
                    await sendFile(msg, filepath, `output.gif`)
                }
            },
            help: {
                "name": "overlay <file> <overlay> [-origin <x (left/center/right)> <y (top/middle/bottom)>] [-offsetpos <x> <y>] [-width <pixels or percentage>] [-height <pixels or percentage>] [-keepaspectratio <mode (increase or decrease)>]",
                "value": "Adds the specified overlay to the file."
            },
            cooldown: 2500,
            type: "Overlaying"
        },

        {
            name: ["blend"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl2'] === undefined && args[2] === undefined) {
                    msg.channel.send('What are the files?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                }
                var keepaspectratio
                var origins = {
                    x: {
                        left: '0',
                        center: '(W-w)/2',
                        right: '(W-w)'
                    },

                    y: {
                        top: '0',
                        middle: '(H-h)/2',
                        bottom: '(H-h)'
                    },
                }
                var modes = [
                    'addition',
                    'grainmerge',
                    'and',
                    'average',
                    'burn',
                    'bleach',
                    'darken',
                    'difference',
                    'grainextract',
                    'divide',
                    'dodge',
                    'freeze',
                    'exclusion',
                    'extremity',
                    'geometric',
                    'glow',
                    'hardlight',
                    'hardoverlay',
                    'interpolate',
                    'hardmix',
                    'heat',
                    'lighten',
                    'linearlight',
                    'multiply',
                    'multiply128',
                    'negation',
                    'normal',
                    'or',
                    'overlay',
                    'phoenix',
                    'pinlight',
                    'reflect',
                    'screen',
                    'stain',
                    'softlight',
                    'softdifference',
                    'subtract',
                    'vividlight',
                    'xor'
                ]
                var originx = '(W-w)/2'
                var originy = '(H-h)/2'
                var originindex = args.indexOf('-origin')
                if (originindex > -1) {
                    originx = origins.x[args[originindex + 1]] || '(W-w)/2'
                    originy = origins.y[args[originindex + 2]] || '(H-h)/2'
                }
                var ox = 0
                var oy = 0
                var offsetindex = args.indexOf('-offsetpos')
                if (offsetindex > -1) {
                    ox = isNaN(Number(String(args[offsetindex + 1]).replace(/,/g, ''))) ? 0 : Number(String(args[offsetindex + 1]).replace(/,/g, '')) || 0
                    oy = isNaN(Number(String(args[offsetindex + 2]).replace(/,/g, ''))) ? 0 : Number(String(args[offsetindex + 2]).replace(/,/g, '')) || 0
                }
                var ratioindex = args.indexOf('-keepaspectratio')
                if (ratioindex > -1) {
                    if (args[ratioindex + 1] == 'increase' || args[ratioindex + 1] == 'decrease') {
                        keepaspectratio = args[ratioindex + 1]
                    }
                }
                var mode = 'addition'
                var modeindex = args.indexOf('-mode')
                if (modeindex > -1) {
                    if (modes.find(mode => mode === args[modeindex + 1].toLowerCase())) {
                        mode = args[modeindex + 1]
                    } else {
                        msg.channel.send('Not a supported mode.').catch(() => { })
                        return
                    }
                }
                var currenturl = args.find(arg => arg === '-localcmd') ? args[1] : (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1])
                var currenturl2 = args.find(arg => arg === '-localcmd') ? args[2] : (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl2'] || args[2])
                var urls = await getUrls(msg).catch(() => { }) ?? []
                if (urls.length < 2) {
                    var c = currenturl
                    currenturl = currenturl2
                    currenturl2 = c
                }
                var errors = {}
                var fileinfo = await validateFile(currenturl, false, {
                    size: `the first file exceeds the size limit of {param} mb hahahaha (try to use the shrink, setfps, trim or crunch commands)`,
                    frames: `the frames of the first file exceed the limit of {param} hahahaha (try to use the setfps or the trim commands)`,
                    width: `the width of the first file exceeds the limit of {param} hahahaha (try to use the shrink command)`,
                    height: `the height of the first file exceeds the limit of {param} hahahaha (try to use the shrink command)`
                }).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })
                if (!fileinfo) return
                var filetype = fileinfo.type
                var fileinfo2 = await validateFile(currenturl2, false, {
                    size: `the second file exceeds the size limit of {param} mb hahahaha (try to use the shrink, setfps, trim or crunch commands)`,
                    frames: `the frames of the second file exceed the limit of {param} hahahaha (try to use the setfps or the trim commands)`,
                    width: `the width of the second file exceeds the limit of {param} hahahaha (try to use the shrink command)`,
                    height: `the height of the second file exceeds the limit of {param} hahahaha (try to use the shrink command)`
                }).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })
                if (!fileinfo2) return
                var filetype2 = fileinfo2.type
                var filetypes = [filetype, filetype2]
                for (var i in errors) {
                    var error = errors[i]
                    if (error) {
                        msg.channel.send({
                            content: error,
                            allowedMentions: {
                                parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                            }
                        }).catch(() => { })
                        msg.channel.sendTyping().catch(() => { })
                        return
                    }
                }
                for (var i in filetypes) {
                    var type = filetypes[i]
                    if (!(type.mime.startsWith('image') || type.mime.startsWith('video'))) {
                        msg.channel.send({
                            content: 'Unsupported file types.',
                            allowedMentions: {
                                parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                            }
                        }).catch(() => { })
                        msg.channel.sendTyping().catch(() => { })
                        return
                    }
                }
                var filepath = await downloadFile(currenturl, `input.${fileinfo.shortext}`, {
                    fileinfo: fileinfo,
                })
                var filename = `input.${fileinfo.shortext}`
                await downloadFile(currenturl2, `input2.${fileinfo2.shortext}`, {
                    fileinfo: fileinfo2,
                    filepath: filepath
                })
                var filename2 = `input2.${fileinfo2.shortext}`

                var width = fileinfo.info.width
                var height = fileinfo.info.height

                var size = [-1, height]

                var widthindex = args.indexOf('-width')
                if (widthindex > -1) {
                    var percentage = String(args[widthindex + 1]).endsWith('%')
                    if (percentage) {
                        args[widthindex + 1] = args[widthindex + 1].substring(0, args[widthindex + 1].length - 1)
                    }
                    size[0] = (percentage ? width : 1) * ((isNaN(Number(args[widthindex + 1])) ? 0 : Number(args[widthindex + 1]) <= 0 ? 0 : Number(args[widthindex + 1]) || 0) / (percentage ? 100 : 1))
                    size[1] = -1
                }

                var heightindex = args.indexOf('-height')
                if (heightindex > -1) {
                    var percentage = String(args[heightindex + 1]).endsWith('%')
                    if (percentage) {
                        args[heightindex + 1] = args[heightindex + 1].substring(0, args[heightindex + 1].length - 1)
                    }
                    size[1] = (percentage ? height : 1) * ((isNaN(Number(args[heightindex + 1])) ? 0 : Number(args[heightindex + 1]) <= 0 ? 0 : Number(args[heightindex + 1]) || 0) / (percentage ? 100 : 1))
                }

                if ((filetype.mime.startsWith('image') && !(gifFormats.find(f => f === filetype.ext))) && (filetype2.mime.startsWith('image') && !(gifFormats.find(f => f === filetype2.ext)))) {
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -i ${filepath}/${filename2} -f lavfi -i "color=0x00000000:s=${width}x${height},format=rgba" -filter_complex "[1:v]scale=${size[0]}:${size[1]}${keepaspectratio ? `:force_original_aspect_ratio=${keepaspectratio}` : ''}[overlay];[2:v][overlay]overlay=x=${originx}+${Math.round(ox)}:y=${originy}+${Math.round(oy)}:format=auto[blend];[0:v][blend]blend=all_mode=${mode}[out]" -map "[out]" -preset ${findpreset(args)} ${filepath}/output.png`)
                    await sendFile(msg, filepath, `output.png`)
                } else if ((filetype.mime.startsWith('image') && !(gifFormats.find(f => f === filetype.ext))) && ((filetype2.mime.startsWith('image') && gifFormats.find(f => f === filetype2.ext)))) {
                    await execPromise(`ffmpeg -stream_loop -1 -i ${filepath}/${filename} -i ${filepath}/${filename2} -f lavfi -i "color=0x00000000:s=${width}x${height},format=rgba" -filter_complex "[1:v]scale=${size[0]}:${size[1]}${keepaspectratio ? `:force_original_aspect_ratio=${keepaspectratio}` : ''}[overlay];[2:v][overlay]overlay=x=${originx}+${Math.round(ox)}:y=${originy}+${Math.round(oy)}:format=auto[blend];[0:v][blend]blend=shortest=1:all_mode=${mode},scale='min(400,iw)':min'(400,ih)':force_original_aspect_ratio=decrease,split[gnout][gpout];[gpout]palettegen=reserve_transparent=1[palette];[gnout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ${findpreset(args)} -gifflags -offsetting ${filepath}/output.gif`)
                    await sendFile(msg, filepath, `output.gif`)
                } else if ((filetype.mime.startsWith('image') && gifFormats.find(f => f === filetype.ext)) && (filetype2.mime.startsWith('image') && !(gifFormats.find(f => f === filetype2.ext)))) {
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -stream_loop -1 -i ${filepath}/${filename2} -f lavfi -i "color=0x00000000:s=${width}x${height},format=rgba" -filter_complex "[1:v]scale=${size[0]}:${size[1]}${keepaspectratio ? `:force_original_aspect_ratio=${keepaspectratio}` : ''}[overlay];[2:v][overlay]overlay=x=${originx}+${Math.round(ox)}:y=${originy}+${Math.round(oy)}:format=auto[blend];[0:v][blend]blend=shortest=1:all_mode=${mode},split[gnout][gpout];[gpout]palettegen=reserve_transparent=1[palette];[gnout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ${findpreset(args)} -gifflags -offsetting ${filepath}/output.gif`)
                    await sendFile(msg, filepath, `output.gif`)
                } else if (filetype.mime.startsWith('video') || filetype2.mime.startsWith('video')) {
                    await execPromise(`ffmpeg ${(filetype2.mime.startsWith('video') && !(filetype.mime.startsWith('video'))) ? '-stream_loop -1 ' : ''}-i ${filepath}/${filename} ${(filetype.mime.startsWith('video') && !(filetype2.mime.startsWith('video'))) ? '-stream_loop -1 ' : ''}-i ${filepath}/${filename2} -f lavfi -i "color=0x00000000:s=${width}x${height},format=rgba" -map ${filetype.mime.startsWith('video') ? '0' : '1'}:a? -filter_complex "[1:v]scale=${size[0]}:${size[1]}${keepaspectratio ? `:force_original_aspect_ratio=${keepaspectratio}` : ''}[overlay];[2:v][overlay]overlay=x=${originx}+${Math.round(ox)}:y=${originy}+${Math.round(oy)}:format=auto[blend];[0:v][blend]blend=shortest=1:all_mode=${mode},scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ${findpreset(args)} -c:v libx264 -pix_fmt yuv420p ${filepath}/output.mp4`)
                    await sendFile(msg, filepath, `output.mp4`)
                } else {
                    await execPromise(`ffmpeg -stream_loop -1 -i ${filepath}/${filename} -i ${filepath}/${filename2} -f lavfi -i "color=0x00000000:s=${width}x${height},format=rgba" -filter_complex "[1:v]scale=${size[0]}:${size[1]}${keepaspectratio ? `:force_original_aspect_ratio=${keepaspectratio}` : ''}[overlay];[2:v][overlay]overlay=x=${originx}+${Math.round(ox)}:y=${originy}+${Math.round(oy)}:format=auto[blend];[0:v][blend]blend=shortest=1:all_mode=${mode},split[gnout][gpout];[gpout]palettegen=reserve_transparent=1[palette];[gnout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ${findpreset(args)} -gifflags -offsetting ${filepath}/output.gif`)
                    await sendFile(msg, filepath, `output.gif`)
                }
            },
            help: {
                "name": "blend <file> <blend> [-mode <mode>] [overlay options]",
                "value": "Blends the first file to the second. A list of modes can be found at https://trac.ffmpeg.org/wiki/Blend"
            },
            cooldown: 2500,
            type: "Overlaying"
        },

        {
            name: ["mask"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl2'] === undefined && args[2] === undefined) {
                    msg.channel.send('What are the files?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                }
                var keepaspectratio
                var origins = {
                    x: {
                        left: '0',
                        center: '(W-w)/2',
                        right: '(W-w)'
                    },

                    y: {
                        top: '0',
                        middle: '(H-h)/2',
                        bottom: '(H-h)'
                    },
                }
                var originx = '(W-w)/2'
                var originy = '(H-h)/2'
                var originindex = args.indexOf('-origin')
                if (originindex > -1) {
                    originx = origins.x[args[originindex + 1]] || '(W-w)/2'
                    originy = origins.y[args[originindex + 2]] || '(H-h)/2'
                }
                var ox = 0
                var oy = 0
                var offsetindex = args.indexOf('-offsetpos')
                if (offsetindex > -1) {
                    ox = isNaN(Number(String(args[offsetindex + 1]).replace(/,/g, ''))) ? 0 : Number(String(args[offsetindex + 1]).replace(/,/g, '')) || 0
                    oy = isNaN(Number(String(args[offsetindex + 2]).replace(/,/g, ''))) ? 0 : Number(String(args[offsetindex + 2]).replace(/,/g, '')) || 0
                }
                var ratioindex = args.indexOf('-keepaspectratio')
                if (ratioindex > -1) {
                    if (args[ratioindex + 1] == 'increase' || args[ratioindex + 1] == 'decrease') {
                        keepaspectratio = args[ratioindex + 1]
                    }
                }
                var currenturl = args.find(arg => arg === '-localcmd') ? args[1] : (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1])
                var currenturl2 = args.find(arg => arg === '-localcmd') ? args[2] : (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl2'] || args[2])
                var urls = await getUrls(msg).catch(() => { }) ?? []
                if (urls.length < 2) {
                    var c = currenturl
                    currenturl = currenturl2
                    currenturl2 = c
                }
                var errors = {}
                var fileinfo = await validateFile(currenturl, false, {
                    size: `the first file exceeds the size limit of {param} mb hahahaha (try to use the shrink, setfps, trim or crunch commands)`,
                    frames: `the frames of the first file exceed the limit of {param} hahahaha (try to use the setfps or the trim commands)`,
                    width: `the width of the first file exceeds the limit of {param} hahahaha (try to use the shrink command)`,
                    height: `the height of the first file exceeds the limit of {param} hahahaha (try to use the shrink command)`
                }).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })
                if (!fileinfo) return
                var filetype = fileinfo.type
                var fileinfo2 = await validateFile(currenturl2, false, {
                    size: `the second file exceeds the size limit of {param} mb hahahaha (try to use the shrink, setfps, trim or crunch commands)`,
                    frames: `the frames of the second file exceed the limit of {param} hahahaha (try to use the setfps or the trim commands)`,
                    width: `the width of the second file exceeds the limit of {param} hahahaha (try to use the shrink command)`,
                    height: `the height of the second file exceeds the limit of {param} hahahaha (try to use the shrink command)`
                }).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })
                if (!fileinfo2) return
                var filetype2 = fileinfo2.type
                var filetypes = [filetype, filetype2]
                for (var i in errors) {
                    var error = errors[i]
                    if (error) {
                        msg.channel.send({
                            content: error,
                            allowedMentions: {
                                parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                            }
                        }).catch(() => { })
                        msg.channel.sendTyping().catch(() => { })
                        return
                    }
                }
                for (var i in filetypes) {
                    var type = filetypes[i]
                    if (!(type.mime.startsWith('image') || type.mime.startsWith('video'))) {
                        msg.channel.send({
                            content: 'Unsupported file types.',
                            allowedMentions: {
                                parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                            }
                        }).catch(() => { })
                        msg.channel.sendTyping().catch(() => { })
                        return
                    }
                }
                var filepath = await downloadFile(currenturl, `input.${fileinfo.shortext}`, {
                    fileinfo: fileinfo,
                })
                var filename = `input.${fileinfo.shortext}`
                await downloadFile(currenturl2, `input2.${fileinfo2.shortext}`, {
                    fileinfo: fileinfo2,
                    filepath: filepath
                })
                var filename2 = `input2.${fileinfo2.shortext}`

                var width = fileinfo.info.width
                var height = fileinfo.info.height

                var size = [-1, height]

                var widthindex = args.indexOf('-width')
                if (widthindex > -1) {
                    var percentage = String(args[widthindex + 1]).endsWith('%')
                    if (percentage) {
                        args[widthindex + 1] = args[widthindex + 1].substring(0, args[widthindex + 1].length - 1)
                    }
                    size[0] = (percentage ? width : 1) * ((isNaN(Number(args[widthindex + 1])) ? 0 : Number(args[widthindex + 1]) <= 0 ? 0 : Number(args[widthindex + 1]) || 0) / (percentage ? 100 : 1))
                    size[1] = -1
                }

                var heightindex = args.indexOf('-height')
                if (heightindex > -1) {
                    var percentage = String(args[heightindex + 1]).endsWith('%')
                    if (percentage) {
                        args[heightindex + 1] = args[heightindex + 1].substring(0, args[heightindex + 1].length - 1)
                    }
                    size[1] = (percentage ? height : 1) * ((isNaN(Number(args[heightindex + 1])) ? 0 : Number(args[heightindex + 1]) <= 0 ? 0 : Number(args[heightindex + 1]) || 0) / (percentage ? 100 : 1))
                }

                if ((filetype.mime.startsWith('image') && !(gifFormats.find(f => f === filetype.ext))) && (filetype2.mime.startsWith('image') && !(gifFormats.find(f => f === filetype2.ext)))) {
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -i ${filepath}/${filename2} -f lavfi -i "color=0x${args.find(arg => arg === '-keep') ? 'FFFFFF' : '000000'}FF:s=${width}x${height},format=rgba" -filter_complex "[1:v]scale=${size[0]}:${size[1]}${keepaspectratio ? `:force_original_aspect_ratio=${keepaspectratio}` : ''},hue=s=0[overlay];[2:v][overlay]overlay=x=${originx}+${Math.round(ox)}:y=${originy}+${Math.round(oy)}:format=auto[mask];[0:v][mask]alphamerge[out]" -map "[out]" -preset ${findpreset(args)} ${filepath}/output.png`)
                    await sendFile(msg, filepath, `output.png`)
                } else if ((filetype.mime.startsWith('image') && !(gifFormats.find(f => f === filetype.ext))) && ((filetype2.mime.startsWith('image') && gifFormats.find(f => f === filetype2.ext)))) {
                    await execPromise(`ffmpeg -stream_loop -1 -i ${filepath}/${filename} -i ${filepath}/${filename2} -f lavfi -i "color=0x${args.find(arg => arg === '-keep') ? 'FFFFFF' : '000000'}FF:s=${width}x${height},format=rgba" -filter_complex "[1:v]scale=${size[0]}:${size[1]}${keepaspectratio ? `:force_original_aspect_ratio=${keepaspectratio}` : ''},hue=s=0[overlay];[2:v][overlay]overlay=x=${originx}+${Math.round(ox)}:y=${originy}+${Math.round(oy)}:format=auto,colorkey=0xFFFFFF:0.01:0,curves=r='0/0 1/0':g='0/0 1/0':b='0/0 1/0'[mask];[0:v][mask]overlay=shortest=1:x=0:y=0:format=auto,colorkey=0x000000:0.01:0,scale='min(400,iw)':min'(400,ih)':force_original_aspect_ratio=decrease,split[gnout][gpout];[gpout]palettegen=reserve_transparent=1[palette];[gnout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ${findpreset(args)} -gifflags -offsetting ${filepath}/output.gif`)
                    await sendFile(msg, filepath, `output.gif`)
                } else if ((filetype.mime.startsWith('image') && gifFormats.find(f => f === filetype.ext)) && (filetype2.mime.startsWith('image') && !(gifFormats.find(f => f === filetype2.ext)))) {
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -stream_loop -1 -i ${filepath}/${filename2} -f lavfi -i "color=0x${args.find(arg => arg === '-keep') ? 'FFFFFF' : '000000'}FF:s=${width}x${height},format=rgba" -filter_complex "[1:v]scale=${size[0]}:${size[1]}${keepaspectratio ? `:force_original_aspect_ratio=${keepaspectratio}` : ''},hue=s=0[overlay];[2:v][overlay]overlay=x=${originx}+${Math.round(ox)}:y=${originy}+${Math.round(oy)}:format=auto,colorkey=0xFFFFFF:0.01:0,curves=r='0/0 1/0':g='0/0 1/0':b='0/0 1/0'[mask];[0:v][mask]overlay=shortest=1:x=0:y=0:format=auto,colorkey=0x000000:0.01:0,split[gnout][gpout];[gpout]palettegen=reserve_transparent=1[palette];[gnout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ${findpreset(args)} -gifflags -offsetting ${filepath}/output.gif`)
                    await sendFile(msg, filepath, `output.gif`)
                } else if (filetype.mime.startsWith('video') || filetype2.mime.startsWith('video')) {
                    await execPromise(`ffmpeg ${(filetype2.mime.startsWith('video') && !(filetype.mime.startsWith('video'))) ? '-stream_loop -1 ' : ''}-i ${filepath}/${filename} ${(filetype.mime.startsWith('video') && !(filetype2.mime.startsWith('video'))) ? '-stream_loop -1 ' : ''}-i ${filepath}/${filename2} -f lavfi -i "color=0x${args.find(arg => arg === '-keep') ? 'FFFFFF' : '000000'}FF:s=${width}x${height},format=rgba" -map ${filetype.mime.startsWith('video') ? '0' : '1'}:a? -filter_complex "[1:v]scale=${size[0]}:${size[1]}${keepaspectratio ? `:force_original_aspect_ratio=${keepaspectratio}` : ''},hue=s=0[overlay];[2:v][overlay]overlay=x=${originx}+${Math.round(ox)}:y=${originy}+${Math.round(oy)}:format=auto,colorkey=0xFFFFFF:0.01:1,curves=r='0/0 1/0':g='0/0 1/0':b='0/0 1/0'[mask];[0:v][mask]overlay=shortest=1:format=auto:x=0:y=0,scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ${findpreset(args)} -c:v libx264 -pix_fmt yuv420p ${filepath}/output.mp4`)
                    await sendFile(msg, filepath, `output.mp4`)
                } else {
                    await execPromise(`ffmpeg -stream_loop -1 -i ${filepath}/${filename} -i ${filepath}/${filename2} -f lavfi -i "color=0x${args.find(arg => arg === '-keep') ? 'FFFFFF' : '000000'}FF:s=${width}x${height},format=rgba" -filter_complex "[1:v]scale=${size[0]}:${size[1]}${keepaspectratio ? `:force_original_aspect_ratio=${keepaspectratio}` : ''},hue=s=0[overlay];[2:v][overlay]overlay=x=${originx}+${Math.round(ox)}:y=${originy}+${Math.round(oy)}:format=auto,colorkey=0xFFFFFF:0.01:0,curves=r='0/0 1/0':g='0/0 1/0':b='0/0 1/0'[mask];[0:v][mask]overlay=shortest=1:x=0:y=0:format=auto,colorkey=0x000000:0.01:0,split[gnout][gpout];[gpout]palettegen=reserve_transparent=1[palette];[gnout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ${findpreset(args)} -gifflags -offsetting ${filepath}/output.gif`)
                    await sendFile(msg, filepath, `output.gif`)
                }
            },
            help: {
                "name": "mask <file> <mask> [-keep] [overlay options]",
                "value": "Uses the specified mask on the file. Might not work well on GIFs though!"
            },
            cooldown: 2500,
            type: "Overlaying"
        },

        {
            name: ["morph", "transform"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl2'] === undefined && args[2] === undefined) {
                    msg.channel.send('What are the files?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
                var currenturl2 = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl2'] || args[2]
                var urls = await getUrls(msg).catch(() => { }) ?? []
                if (urls.length < 2) {
                    var c = currenturl
                    currenturl = currenturl2
                    currenturl2 = c
                }
                var errors = {}
                var fileinfo = await validateFile(currenturl, false, {
                    size: `the first file exceeds the size limit of {param} mb hahahaha (try to use the shrink, setfps, trim or crunch commands)`,
                    frames: `the frames of the first file exceed the limit of {param} hahahaha (try to use the setfps or the trim commands)`,
                    width: `the width of the first file exceeds the limit of {param} hahahaha (try to use the shrink command)`,
                    height: `the height of the first file exceeds the limit of {param} hahahaha (try to use the shrink command)`
                }).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })
                if (!fileinfo) return
                var filetype = fileinfo.type
                var fileinfo2 = await validateFile(currenturl2, false, {
                    size: `the second file exceeds the size limit of {param} mb hahahaha (try to use the shrink, setfps, trim or crunch commands)`,
                    frames: `the frames of the second file exceed the limit of {param} hahahaha (try to use the setfps or the trim commands)`,
                    width: `the width of the second file exceeds the limit of {param} hahahaha (try to use the shrink command)`,
                    height: `the height of the second file exceeds the limit of {param} hahahaha (try to use the shrink command)`
                }).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })
                if (!fileinfo2) return
                var filetype2 = fileinfo2.type
                var filetypes = [filetype, filetype2]
                for (var i in errors) {
                    var error = errors[i]
                    if (error) {
                        msg.channel.send({
                            content: error,
                            allowedMentions: {
                                parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                            }
                        }).catch(() => { })
                        msg.channel.sendTyping().catch(() => { })
                        return
                    }
                }
                for (var i in filetypes) {
                    var type = filetypes[i]
                    if (!(type.mime.startsWith('image') || type.mime.startsWith('video'))) {
                        msg.channel.send({
                            content: 'Unsupported file types.',
                            allowedMentions: {
                                parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                            }
                        }).catch(() => { })
                        msg.channel.sendTyping().catch(() => { })
                        return
                    }
                }
                var filepath = await downloadFile(currenturl, `input.${fileinfo.shortext}`, {
                    fileinfo: fileinfo
                })
                var filename = `input.${fileinfo.shortext}`
                await downloadFile(currenturl2, `input2.${fileinfo2.shortext}`, {
                    fileinfo: fileinfo2,
                    filepath: filepath
                })
                var filename2 = `input2.${fileinfo2.shortext}`

                fs.mkdirSync(`${filepath}/frames`)

                await execPromise(`ffmpeg -i ${filepath}/${filename} -vf "scale='min(400,iw)':min'(400,ih)':force_original_aspect_ratio=decrease" -vframes 1 ${filepath}/static.png`)
                await execPromise(`ffmpeg -i ${filepath}/${filename2} -vf "scale='min(400,iw)':min'(400,ih)':force_original_aspect_ratio=decrease" -vframes 1 ${filepath}/static2.png`)
                await execPromise(`python templates/morph.py ${filepath}`)
                await execPromise(`ffmpeg -i ${filepath}/frames/frame_%06d.png -filter_complex "[0:v]scale='min(400,iw)':min'(400,ih)':force_original_aspect_ratio=decrease,split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ${findpreset(args)} ${filepath}/output.gif`)
                await sendFile(msg, filepath, `output.gif`)
            },
            help: {
                "name": "morph/transform <file> <file2>",
                "value": "Morphs the first file into the second."
            },
            cooldown: 2500,
            type: "Animation"
        },

        {
            name: ["hmerge"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl2'] === undefined && args[2] === undefined) {
                    msg.channel.send('What are the files?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
                var currenturl2 = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl2'] || args[2]
                var urls = await getUrls(msg).catch(() => { }) ?? []
                if (urls.length < 2) {
                    var c = currenturl
                    currenturl = currenturl2
                    currenturl2 = c
                }
                var errors = {}
                var fileinfo = await validateFile(currenturl, false, {
                    size: `the first file exceeds the size limit of {param} mb hahahaha (try to use the shrink, setfps, trim or crunch commands)`,
                    frames: `the frames of the first file exceed the limit of {param} hahahaha (try to use the setfps or the trim commands)`,
                    width: `the width of the first file exceeds the limit of {param} hahahaha (try to use the shrink command)`,
                    height: `the height of the first file exceeds the limit of {param} hahahaha (try to use the shrink command)`
                }).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })
                if (!fileinfo) return
                var filetype = fileinfo.type
                var fileinfo2 = await validateFile(currenturl2, false, {
                    size: `the second file exceeds the size limit of {param} mb hahahaha (try to use the shrink, setfps, trim or crunch commands)`,
                    frames: `the frames of the second file exceed the limit of {param} hahahaha (try to use the setfps or the trim commands)`,
                    width: `the width of the second file exceeds the limit of {param} hahahaha (try to use the shrink command)`,
                    height: `the height of the second file exceeds the limit of {param} hahahaha (try to use the shrink command)`
                }).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })
                if (!fileinfo2) return
                var filetype2 = fileinfo2.type
                var filetypes = [filetype, filetype2]
                for (var i in errors) {
                    var error = errors[i]
                    if (error) {
                        msg.channel.send({
                            content: error,
                            allowedMentions: {
                                parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                            }
                        }).catch(() => { })
                        msg.channel.sendTyping().catch(() => { })
                        return
                    }
                }
                for (var i in filetypes) {
                    var type = filetypes[i]
                    if (!(type.mime.startsWith('image') || type.mime.startsWith('video'))) {
                        msg.channel.send({
                            content: 'Unsupported file types.',
                            allowedMentions: {
                                parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                            }
                        }).catch(() => { })
                        msg.channel.sendTyping().catch(() => { })
                        return
                    }
                }
                var filepath = await downloadFile(currenturl, `input.${fileinfo.shortext}`, {
                    fileinfo: fileinfo
                })
                var filename = `input.${fileinfo.shortext}`
                await downloadFile(currenturl2, `input2.${fileinfo2.shortext}`, {
                    fileinfo: fileinfo2,
                    filepath: filepath
                })
                var filename2 = `input2.${fileinfo2.shortext}`

                var fps = fileinfo.info.fps
                var fps2 = fileinfo2.info.fps
                var height = (args.find(arg => arg === '-swapheight') ? fileinfo2 : fileinfo).info.height

                if ((filetype.mime.startsWith('image') && !(gifFormats.find(f => f === filetype.ext))) && (filetype2.mime.startsWith('image') && !(gifFormats.find(f => f === filetype2.ext)))) {
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -i ${filepath}/${filename2} -filter_complex "[0:v]scale=-1:${height}[file];[1:v]scale=-1:${height}[file2];[file][file2]hstack=shortest=1[out]" -map "[out]" -preset ${findpreset(args)} ${filepath}/output.png`)
                    await sendFile(msg, filepath, `output.png`)
                } else if ((filetype.mime.startsWith('image') && !(gifFormats.find(f => f === filetype.ext))) && ((filetype2.mime.startsWith('image') && gifFormats.find(f => f === filetype2.ext)))) {
                    await execPromise(`ffmpeg -stream_loop -1 -r ${fps2} -i ${filepath}/${filename} -r ${fps2} -i ${filepath}/${filename2} -filter_complex "[0:v]scale=-1:${height}[file];[1:v]scale=-1:${height}[file2];[file][file2]hstack=shortest=1[qout];[qout]scale='min(400,iw)':min'(400,ih)':force_original_aspect_ratio=decrease[rout];[rout]split[gnout][gpout];[gpout]palettegen=reserve_transparent=1[palette];[gnout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ${findpreset(args)} -gifflags -offsetting ${filepath}/output.gif`)
                    await sendFile(msg, filepath, `output.gif`)
                } else if ((filetype.mime.startsWith('image') && gifFormats.find(f => f === filetype.ext)) && (filetype2.mime.startsWith('image') && !(gifFormats.find(f => f === filetype2.ext)))) {
                    await execPromise(`ffmpeg -r ${fps.includes('0/0') ? '50' : fps} -i ${filepath}/${filename} -stream_loop -1 -r ${fps.includes('0/0') ? '50' : fps} -i ${filepath}/${filename2} -filter_complex "[0:v]scale=-1:${height}[file];[1:v]scale=-1:${height}[file2];[file][file2]hstack=shortest=1[sout];[sout]split[gnout][gpout];[gpout]palettegen=reserve_transparent=1[palette];[gnout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ${findpreset(args)} -gifflags -offsetting ${filepath}/output.gif`)
                    await sendFile(msg, filepath, `output.gif`)
                } else if (filetype.mime.startsWith('video') || filetype2.mime.startsWith('video')) {
                    await execPromise(`ffmpeg ${(filetype2.mime.startsWith('video') && !(filetype.mime.startsWith('video'))) ? '-stream_loop -1 ' : ''}-r ${fps.includes('0/0') ? '60' : fps} -i ${filepath}/${filename} ${(filetype.mime.startsWith('video') && !(filetype2.mime.startsWith('video'))) ? '-stream_loop -1 ' : ''}-r ${fps.includes('0/0') ? '60' : fps} -i ${filepath}/${filename2} -map ${filetype.mime.startsWith('video') ? '0' : '1'}:a? -filter_complex "[0:v]scale=-1:${height}[file];[1:v]scale=-1:${height}[file2];[file][file2]hstack=shortest=1[sout];[sout]scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ${findpreset(args)} -c:v libx264 -pix_fmt yuv420p ${filepath}/output.mp4`)
                    await sendFile(msg, filepath, `output.mp4`)
                } else {
                    await execPromise(`ffmpeg -stream_loop -1 -r ${fps.includes('0/0') ? '50' : fps} -i ${filepath}/${filename} -r ${fps.includes('0/0') ? '50' : fps} -i ${filepath}/${filename2} -filter_complex "[0:v]scale=-1:${height}[file];[1:v]scale=-1:${height}[file2];[file][file2]hstack=shortest=1[rout];[rout]split[gnout][gpout];[gpout]palettegen=reserve_transparent=1[palette];[gnout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ${findpreset(args)} -gifflags -offsetting ${filepath}/output.gif`)
                    await sendFile(msg, filepath, `output.gif`)
                }
            },
            help: {
                "name": "hmerge <file> <file2> [-swapheight]",
                "value": "Merges the first file with the second one horizontally."
            },
            cooldown: 2500,
            type: "Overlaying"
        },

        {
            name: ["vmerge"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl2'] === undefined && args[2] === undefined) {
                    msg.channel.send('What are the files?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
                var currenturl2 = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl2'] || args[2]
                var urls = await getUrls(msg).catch(() => { }) ?? []
                if (urls.length < 2) {
                    var c = currenturl
                    currenturl = currenturl2
                    currenturl2 = c
                }
                var errors = {}
                var fileinfo = await validateFile(currenturl, false, {
                    size: `the first file exceeds the size limit of {param} mb hahahaha (try to use the shrink, setfps, trim or crunch commands)`,
                    frames: `the frames of the first file exceed the limit of {param} hahahaha (try to use the setfps or the trim commands)`,
                    width: `the width of the first file exceeds the limit of {param} hahahaha (try to use the shrink command)`,
                    height: `the height of the first file exceeds the limit of {param} hahahaha (try to use the shrink command)`
                }).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })
                if (!fileinfo) return
                var filetype = fileinfo.type
                var fileinfo2 = await validateFile(currenturl2, false, {
                    size: `the second file exceeds the size limit of {param} mb hahahaha (try to use the shrink, setfps, trim or crunch commands)`,
                    frames: `the frames of the second file exceed the limit of {param} hahahaha (try to use the setfps or the trim commands)`,
                    width: `the width of the second file exceeds the limit of {param} hahahaha (try to use the shrink command)`,
                    height: `the height of the second file exceeds the limit of {param} hahahaha (try to use the shrink command)`
                }).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })
                if (!fileinfo2) return
                var filetype2 = fileinfo2.type
                var filetypes = [filetype, filetype2]
                for (var i in errors) {
                    var error = errors[i]
                    if (error) {
                        msg.channel.send({
                            content: error,
                            allowedMentions: {
                                parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                            }
                        }).catch(() => { })
                        msg.channel.sendTyping().catch(() => { })
                        return
                    }
                }
                for (var i in filetypes) {
                    var type = filetypes[i]
                    if (!(type.mime.startsWith('image') || type.mime.startsWith('video'))) {
                        msg.channel.send({
                            content: 'Unsupported file types.',
                            allowedMentions: {
                                parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                            }
                        }).catch(() => { })
                        msg.channel.sendTyping().catch(() => { })
                        return
                    }
                }
                var filepath = await downloadFile(currenturl, `input.${fileinfo.shortext}`, {
                    fileinfo: fileinfo
                })
                var filename = `input.${fileinfo.shortext}`
                await downloadFile(currenturl2, `input2.${fileinfo2.shortext}`, {
                    fileinfo: fileinfo2,
                    filepath: filepath
                })
                var filename2 = `input2.${fileinfo2.shortext}`

                var fps = fileinfo.info.fps
                var fps2 = fileinfo2.info.fps
                var width = (args.find(arg => arg === '-swapwidth') ? fileinfo2 : fileinfo).info.width

                if ((filetype.mime.startsWith('image') && !(gifFormats.find(f => f === filetype.ext))) && (filetype2.mime.startsWith('image') && !(gifFormats.find(f => f === filetype2.ext)))) {
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -i ${filepath}/${filename2} -filter_complex "[0:v]scale=${width}:-1[file];[1:v]scale=${width}:-1[file2];[file][file2]vstack=shortest=1[out]" -map "[out]" -preset ${findpreset(args)} ${filepath}/output.png`)
                    await sendFile(msg, filepath, `output.png`)
                } else if ((filetype.mime.startsWith('image') && !(gifFormats.find(f => f === filetype.ext))) && ((filetype2.mime.startsWith('image') && gifFormats.find(f => f === filetype2.ext)))) {
                    await execPromise(`ffmpeg -stream_loop -1 -r ${fps2} -i ${filepath}/${filename} -r ${fps2} -i ${filepath}/${filename2} -filter_complex "[0:v]scale=${width}:-1[file];[1:v]scale=${width}:-1[file2];[file][file2]vstack=shortest=1[qout];[qout]scale='min(400,iw)':min'(400,ih)':force_original_aspect_ratio=decrease[rout];[rout]split[gnout][gpout];[gpout]palettegen=reserve_transparent=1[palette];[gnout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ${findpreset(args)} -gifflags -offsetting ${filepath}/output.gif`)
                    await sendFile(msg, filepath, `output.gif`)
                } else if ((filetype.mime.startsWith('image') && gifFormats.find(f => f === filetype.ext)) && (filetype2.mime.startsWith('image') && !(gifFormats.find(f => f === filetype2.ext)))) {
                    await execPromise(`ffmpeg -r ${fps.includes('0/0') ? '50' : fps} -i ${filepath}/${filename} -stream_loop -1 -r ${fps.includes('0/0') ? '50' : fps} -i ${filepath}/${filename2} -filter_complex "[0:v]scale=${width}:-1[file];[1:v]scale=${width}:-1[file2];[file][file2]vstack=shortest=1[sout];[sout]split[gnout][gpout];[gpout]palettegen=reserve_transparent=1[palette];[gnout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ${findpreset(args)} -gifflags -offsetting ${filepath}/output.gif`)
                    await sendFile(msg, filepath, `output.gif`)
                } else if (filetype.mime.startsWith('video') || filetype2.mime.startsWith('video')) {
                    await execPromise(`ffmpeg ${(filetype2.mime.startsWith('video') && !(filetype.mime.startsWith('video'))) ? '-stream_loop -1 ' : ''}-r ${fps.includes('0/0') ? '60' : fps} -i ${filepath}/${filename} ${(filetype.mime.startsWith('video') && !(filetype2.mime.startsWith('video'))) ? '-stream_loop -1 ' : ''}-r ${fps.includes('0/0') ? '60' : fps} -i ${filepath}/${filename2} -map ${filetype.mime.startsWith('video') ? '0' : '1'}:a? -filter_complex "[0:v]scale=${width}:-1[file];[1:v]scale=${width}:-1[file2];[file][file2]vstack=shortest=1[sout];[sout]scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ${findpreset(args)} -c:v libx264 -pix_fmt yuv420p ${filepath}/output.mp4`)
                    await sendFile(msg, filepath, `output.mp4`)
                } else {
                    await execPromise(`ffmpeg -stream_loop -1 -r ${fps.includes('0/0') ? '50' : fps} -i ${filepath}/${filename} -r ${fps.includes('0/0') ? '50' : fps} -i ${filepath}/${filename2} -filter_complex "[0:v]scale=${width}:-1[file];[1:v]scale=${width}:-1[file2];[file][file2]vstack=shortest=1[rout];[rout]split[gnout][gpout];[gpout]palettegen=reserve_transparent=1[palette];[gnout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ${findpreset(args)} -gifflags -offsetting ${filepath}/output.gif`)
                    await sendFile(msg, filepath, `output.gif`)
                }
            },
            help: {
                "name": "vmerge <file> <file2> [-swapwidth]",
                "value": "Merges the first file with the second one vertically."
            },
            cooldown: 2500,
            type: "Overlaying"
        },

        {
            name: ["transition"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl2'] === undefined && args[2] === undefined) {
                    msg.channel.send('What are the files?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var transitions = [
                    'fade',
                    'wipeleft',
                    'wiperight',
                    'wipeup',
                    'wipedown',
                    'slideleft',
                    'slideright',
                    'slideup',
                    'slidedown',
                    'circlecrop',
                    'rectcrop',
                    'distance',
                    'fadeblack',
                    'fadewhite',
                    'radial',
                    'smoothleft',
                    'smoothright',
                    'smoothup',
                    'smoothdown',
                    'circleopen',
                    'circleclose',
                    'vertopen',
                    'vertclose',
                    'horzopen',
                    'horzclose',
                    'dissolve',
                    'pixelize',
                    'diagtl',
                    'diagtr',
                    'diagbl',
                    'diagbr',
                    'hlslice',
                    'hrslice',
                    'vuslice',
                    'vdslice'
                ]
                var unsupported = [
                    'hblur',
                    'fadegrays',
                    'wipetl',
                    'wipetr',
                    'wipebl',
                    'wipebr',
                    'squeezev',
                    'squeezeh',
                    'custom'
                ]
                var duration = 1
                var durationindex = args.indexOf('-duration')
                if (durationindex > -1) {
                    duration = isNaN(Number(args[durationindex + 1])) ? 1 : Number(args[durationindex + 1]) <= 0 ? 0 : Number(args[durationindex + 1]) >= 10 ? 10 : Number(args[durationindex + 1]) ?? 1
                }
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
                var currenturl2 = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl2'] || args[2]
                var urls = await getUrls(msg).catch(() => { }) ?? []
                if (urls.length < 2) {
                    var c = currenturl
                    currenturl = currenturl2
                    currenturl2 = c
                }
                var transition = 'fade'
                var targs = args.slice(1, 3)
                for (var i in targs) {
                    var arg = targs[i]

                    if (unsupported.find(t => t === arg.toLowerCase())) {
                        msg.channel.send('Sorry, but that transition isn\'t supported...').catch(() => { })
                        msg.channel.sendTyping().catch(() => { })
                        return
                    }
                    if (arg.toLowerCase() === 'random') {
                        transition = transitions[Math.floor(Math.random() * transitions.length)]
                        break
                    } else if (transitions.find(t => t === arg.toLowerCase())) {
                        transition = arg.toLowerCase()
                        break
                    }
                }
                var errors = {}
                var fileinfo = await validateFile(currenturl, false, {
                    size: `the first file exceeds the size limit of {param} mb hahahaha (try to use the shrink, setfps, trim or crunch commands)`,
                    frames: `the frames of the first file exceed the limit of {param} hahahaha (try to use the setfps or the trim commands)`,
                    width: `the width of the first file exceeds the limit of {param} hahahaha (try to use the shrink command)`,
                    height: `the height of the first file exceeds the limit of {param} hahahaha (try to use the shrink command)`
                }).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })
                if (!fileinfo) return
                var filetype = fileinfo.type
                var fileinfo2 = await validateFile(currenturl2, false, {
                    size: `the second file exceeds the size limit of {param} mb hahahaha (try to use the shrink, setfps, trim or crunch commands)`,
                    frames: `the frames of the second file exceed the limit of {param} hahahaha (try to use the setfps or the trim commands)`,
                    width: `the width of the second file exceeds the limit of {param} hahahaha (try to use the shrink command)`,
                    height: `the height of the second file exceeds the limit of {param} hahahaha (try to use the shrink command)`
                }).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })
                if (!fileinfo2) return
                var filetype2 = fileinfo2.type
                var filetypes = [filetype, filetype2]
                for (var i in errors) {
                    var error = errors[i]
                    if (error) {
                        msg.channel.send({
                            content: error,
                            allowedMentions: {
                                parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                            }
                        }).catch(() => { })
                        msg.channel.sendTyping().catch(() => { })
                        return
                    }
                }
                for (var i in filetypes) {
                    var type = filetypes[i]
                    if (!(type.mime.startsWith('image') || type.mime.startsWith('video'))) {
                        msg.channel.send({
                            content: 'Unsupported file types.',
                            allowedMentions: {
                                parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                            }
                        }).catch(() => { })
                        msg.channel.sendTyping().catch(() => { })
                        return
                    }
                }
                var filepath = await downloadFile(currenturl, `input.${fileinfo.shortext}`, {
                    fileinfo: fileinfo
                })
                var filename = `input.${fileinfo.shortext}`
                await downloadFile(currenturl2, `input2.${fileinfo2.shortext}`, {
                    fileinfo: fileinfo2,
                    filepath: filepath
                })
                var filename2 = `input2.${fileinfo2.shortext}`

                var width = fileinfo.info.width
                var height = fileinfo.info.height

                if (duration > 0) {
                    if ((filetype.mime.startsWith('image') && !(gifFormats.find(f => f === filetype.ext))) && (filetype2.mime.startsWith('image') && !(gifFormats.find(f => f === filetype2.ext)))) {
                        await execPromise(`ffmpeg -stream_loop -1 -t ${duration} -i ${filepath}/${filename} -stream_loop -1 -t ${duration} -i ${filepath}/${filename2} -stream_loop -1 -t ${duration} -i templates/transparent.png -filter_complex "[1:v]scale=-1:${height}[vid];[2:v]scale=${width}:${height}[transparent];[transparent][vid]overlay=x=W/2-w/2:y=H/2-h/2:format=auto[transition];[0:v][transition]xfade=transition=${transition}:duration=${duration},scale='min(400,iw)':min'(400,ih)':force_original_aspect_ratio=decrease,split[gnout][gpout];[gpout]palettegen=reserve_transparent=1[palette];[gnout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ${findpreset(args)} -loop 0 -t ${duration} ${filepath}/output.gif`)
                        await sendFile(msg, filepath, `output.gif`)
                    } else if ((filetype.mime.startsWith('image') && !(gifFormats.find(f => f === filetype.ext))) && ((filetype2.mime.startsWith('image') && gifFormats.find(f => f === filetype2.ext)))) {
                        var fps2 = fileinfo2.info.fps
                        var iduration2 = Number(fileinfo2.info.duration.includes('N/A') ? '0' : fileinfo2.info.duration)

                        await execPromise(`ffmpeg -stream_loop -1 -t ${iduration2} -r ${fps2.includes('0/0') ? '60' : fps2} -i ${filepath}/${filename} -stream_loop -1 -t ${iduration2 + (args.find(arg => arg === '-waituntilend') ? duration : 0)} -r ${fps2.includes('0/0') ? '60' : fps2} -i ${filepath}/${filename2} -stream_loop -1 -t ${iduration2} -r ${fps2.includes('0/0') ? '60' : fps2} -i templates/transparent.png -filter_complex "[1:v]scale=-1:${height}[vid];[2:v]scale=${width}:${height}[transparent];[transparent][vid]overlay=x=W/2-w/2:y=H/2-h/2:format=auto[transition];[0:v][transition]xfade=transition=${transition}:duration=${duration >= iduration2 && !(filetype2.mime.startsWith('image') && !(gifFormats.find(f => f === filetype2.ext))) ? iduration2 : duration},scale='min(400,iw)':min'(400,ih)':force_original_aspect_ratio=decrease,split[gnout][gpout];[gpout]palettegen=reserve_transparent=1[palette];[gnout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ${findpreset(args)} -t ${iduration2} ${filepath}/output.gif`)
                        await sendFile(msg, filepath, `output.gif`)
                    } else if ((filetype.mime.startsWith('image') && gifFormats.find(f => f === filetype.ext)) && (filetype2.mime.startsWith('image') && !(gifFormats.find(f => f === filetype2.ext)))) {
                        var fps = fileinfo.info.fps

                        var iduration = Number(fileinfo.info.duration.includes('N/A') ? '0' : fileinfo.info.duration)

                        await execPromise(`ffmpeg -stream_loop -1 -t ${iduration + (args.find(arg => arg === '-waituntilend') ? duration : 0)} -r ${fps.includes('0/0') ? '50' : fps} -i ${filepath}/${filename} -stream_loop -1 -t ${iduration} -r ${fps.includes('0/0') ? '50' : fps} -i ${filepath}/${filename2} -stream_loop -1 -t ${iduration} -r ${fps.includes('0/0') ? '50' : fps} -i templates/transparent.png -filter_complex "[1:v]scale=-1:${height}[vid];[2:v]scale=${width}:${height}[transparent];[transparent][vid]overlay=x=W/2-w/2:y=H/2-h/2:format=auto[transition];[0:v][transition]xfade=transition=${transition}:duration=${duration}${iduration - duration > duration ? `:offset=${iduration - duration + (args.find(arg => arg === '-waituntilend') ? duration : 0)}` : ''},split[gnout][gpout];[gpout]palettegen=reserve_transparent=1[palette];[gnout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ${findpreset(args)} -t ${iduration} ${filepath}/output.gif`)
                        await sendFile(msg, filepath, `output.gif`)
                    } else if (filetype.mime.startsWith('video') || filetype2.mime.startsWith('video')) {
                        var audio = fileinfo.info.audio
                        var audio2 = fileinfo2.info.audio
                        var fps = filetype.mime.startsWith('video') ? fileinfo.info.fps : fileinfo2.info.fps

                        var iduration = Number(fileinfo.info.duration.includes('N/A') ? '0' : fileinfo.info.duration)
                        var iduration2 = Number(fileinfo2.info.duration.includes('N/A') ? '0' : fileinfo2.info.duration)

                        await execPromise(`ffmpeg -i ${filepath}/${filename} -vf "scale=ceil(iw/2)*2:ceil(ih/2)*2" -c:v libx264 -video_track_timescale 30k -pix_fmt yuv420p -c:a aac -ac 6 -ar 44100 ${filepath}/concat.mp4`)
                        await execPromise(`ffmpeg -i ${filepath}/${filename2} -vf "scale=ceil(iw/2)*2:ceil(ih/2)*2" -c:v libx264 -video_track_timescale 30k -pix_fmt yuv420p -c:a aac -ac 6 -ar 44100 ${filepath}/concat2.mp4`)
                        await execPromise(`ffmpeg -stream_loop -1 -t ${audio ? iduration + (args.find(arg => arg === '-waituntilend') && (filetype.mime.startsWith('image') && !(gifFormats.find(f => f === filetype.ext))) ? duration : 0) : iduration + iduration2 + (args.find(arg => arg === '-waituntilend') && (filetype.mime.startsWith('image') && !(gifFormats.find(f => f === filetype.ext))) ? duration : 0)} -r ${fps.includes('0/0') ? '60' : fps} -i ${filepath}/concat.mp4 -stream_loop -1 -t ${iduration2} -i ${filepath}/concat2.mp4 -stream_loop -1 -t ${iduration2} -r ${fps.includes('0/0') ? '50' : fps} -i templates/transparent.png ${!audio && audio2 ? `-stream_loop -1 -t ${iduration2} -r ${fps.includes('0/0') ? '50' : fps} -itsoffset ${iduration} -i ${filepath}/concat2.mp4 ` : ''}-filter_complex "[1:v]scale=-1:${height},scale=ceil(iw/2)*2:ceil(ih/2)*2[vid];[2:v]scale=${width}:${height},scale=ceil(iw/2)*2:ceil(ih/2)*2[transparent];[transparent][vid]overlay=x=W/2-w/2:y=H/2-h/2:format=auto,fps=${fps.includes('0/0') ? '50' : fps}[transition];[0:v][transition]xfade=transition=${transition}:duration=${duration >= iduration2 && !(filetype2.mime.startsWith('image') && !(gifFormats.find(f => f === filetype2.ext))) ? iduration2 : duration}${iduration - duration > duration ? `:offset=${iduration - duration + (args.find(arg => arg === '-waituntilend') && (filetype.mime.startsWith('image') && !(gifFormats.find(f => f === filetype.ext))) ? duration : 0)}` : ''},scale=ceil(iw/2)*2:ceil(ih/2)*2[out]${audio && audio2 ? `;[0:a][1:a]acrossfade=d=${duration}[aout]` : ''}" -map "[out]" ${(audio && audio2) ? '-map "[aout]" ' : (audio && !audio2) ? '-map 0:a ' : (!audio && audio2) ? '-map 3:a ' : ''}-aspect ${width}:${height} -preset ${findpreset(args)} -c:v libx264 -pix_fmt yuv420p -t ${iduration + iduration2} ${filepath}/output.mp4`)
                        await sendFile(msg, filepath, `output.mp4`)
                    } else {
                        var fps = fileinfo.info.fps

                        var iduration = Number(fileinfo.info.duration.includes('N/A') ? '0' : fileinfo.info.duration)
                        var iduration2 = Number(fileinfo2.info.duration.includes('N/A') ? '0' : fileinfo2.info.duration)

                        await execPromise(`ffmpeg -stream_loop -1 -t ${iduration + (args.find(arg => arg === '-waituntilend') ? duration : 0)} -r ${fps.includes('0/0') ? '50' : fps} -i ${filepath}/${filename} -stream_loop -1 -t ${iduration2} -i ${filepath}/${filename2} -stream_loop -1 -t ${iduration2} -r ${fps.includes('0/0') ? '50' : fps} -i templates/transparent.png -filter_complex "[1:v]scale=-1:${height}[vid];[2:v]scale=${width}:${height}[transparent];[transparent][vid]overlay=x=W/2-w/2:y=H/2-h/2:format=auto,fps=${fps.includes('0/0') ? '50' : fps}[transition];[0:v][transition]xfade=transition=${transition}:duration=${duration >= iduration2 && !(filetype2.mime.startsWith('image') && !(gifFormats.find(f => f === filetype2.ext))) ? iduration2 : duration}${iduration - duration > duration ? `:offset=${iduration - duration + (args.find(arg => arg === '-waituntilend') ? duration : 0)}` : ''},split[gnout][gpout];[gpout]palettegen=reserve_transparent=1[palette];[gnout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ${findpreset(args)} -t ${iduration + iduration2} ${filepath}/output.gif`)
                        await sendFile(msg, filepath, `output.gif`)
                    }
                } else {
                    if ((filetype.mime.startsWith('image') && !(gifFormats.find(f => f === filetype.ext))) && (filetype2.mime.startsWith('image') && !(gifFormats.find(f => f === filetype2.ext)))) {
                        await execPromise(`ffmpeg -i ${filepath}/${filename} -i ${filepath}/${filename2} -i templates/transparent.png -filter_complex "[1:v]scale=-1:${height}[vid];[2:v]scale=${width}:${height}[transparent];[transparent][vid]overlay=x=W/2-w/2:y=H/2-h/2:format=auto,setsar=sar=1,setdar=dar=1[transition2];[0:v]setsar=sar=1,setdar=dar=1[transition];[transition][transition2]concat,scale='min(400,iw)':min'(400,ih)':force_original_aspect_ratio=decrease,split[gnout][gpout];[gpout]palettegen=reserve_transparent=1[palette];[gnout][palette]paletteuse=alpha_threshold=128[out]" -aspect ${width}:${height} -map "[out]" -preset ${findpreset(args)} -loop 0 ${filepath}/output.gif`)
                        await sendFile(msg, filepath, `output.gif`)
                    } else if ((filetype.mime.startsWith('image') && !(gifFormats.find(f => f === filetype.ext))) && ((filetype2.mime.startsWith('image') && gifFormats.find(f => f === filetype2.ext)))) {
                        var fps2 = fileinfo2.info.fps

                        await execPromise(`ffmpeg -r ${fps2.includes('0/0') ? '60' : fps2} -i ${filepath}/${filename} -r ${fps2.includes('0/0') ? '60' : fps2} -i ${filepath}/${filename2} -r ${fps2.includes('0/0') ? '60' : fps2} -i templates/transparent.png -filter_complex "[1:v]scale=-1:${height}[vid];[2:v]scale=${width}:${height}[transparent];[transparent][vid]overlay=x=W/2-w/2:y=H/2-h/2:format=auto,setsar=sar=1,setdar=dar=1[transition2];[0:v]setsar=sar=1,setdar=dar=1[transition];[transition][transition2]concat,scale='min(400,iw)':min'(400,ih)':force_original_aspect_ratio=decrease,split[gnout][gpout];[gpout]palettegen=reserve_transparent=1[palette];[gnout][palette]paletteuse=alpha_threshold=128[out]" -aspect ${width}:${height} -map "[out]" -preset ${findpreset(args)} ${filepath}/output.gif`)
                        await sendFile(msg, filepath, `output.gif`)
                    } else if ((filetype.mime.startsWith('image') && gifFormats.find(f => f === filetype.ext)) && (filetype2.mime.startsWith('image') && !(gifFormats.find(f => f === filetype2.ext)))) {
                        var fps = fileinfo.info.fps

                        await execPromise(`ffmpeg -r ${fps.includes('0/0') ? '50' : fps} -i ${filepath}/${filename} -r ${fps.includes('0/0') ? '50' : fps} -i ${filepath}/${filename2} -r ${fps.includes('0/0') ? '50' : fps} -i templates/transparent.png -filter_complex "[1:v]scale=-1:${height}[vid];[2:v]scale=${width}:${height}[transparent];[transparent][vid]overlay=x=W/2-w/2:y=H/2-h/2:format=auto,setsar=sar=1,setdar=dar=1[transition2];[0:v]setsar=sar=1,setdar=dar=1[transition];[transition][transition2]concat,split[gnout][gpout];[gpout]palettegen=reserve_transparent=1[palette];[gnout][palette]paletteuse=alpha_threshold=128[out]" -aspect ${width}:${height} -map "[out]" -preset ${findpreset(args)} ${filepath}/output.gif`)
                        await sendFile(msg, filepath, `output.gif`)
                    } else if (filetype.mime.startsWith('video') || filetype2.mime.startsWith('video')) {
                        var audio = fileinfo.info.audio
                        var audio2 = fileinfo2.info.audio
                        var fps = filetype.mime.startsWith('video') ? fileinfo.info.fps : fileinfo2.info.fps

                        var iduration = Number(fileinfo.info.duration.includes('N/A') ? '0' : fileinfo.info.duration)

                        await execPromise(`ffmpeg -i ${filepath}/${filename} -vf "scale=ceil(iw/2)*2:ceil(ih/2)*2" -c:v libx264 -video_track_timescale 30k -pix_fmt yuv420p -c:a aac -ac 6 -ar 44100 ${filepath}/concat.mp4`)
                        await execPromise(`ffmpeg -i ${filepath}/${filename2} -vf "scale=ceil(iw/2)*2:ceil(ih/2)*2" -c:v libx264 -video_track_timescale 30k -pix_fmt yuv420p -c:a aac -ac 6 -ar 44100 ${filepath}/concat2.mp4`)
                        await execPromise(`ffmpeg -r ${fps.includes('0/0') ? '60' : fps} -i ${filepath}/concat.mp4 -i ${filepath}/concat2.mp4 -r ${fps.includes('0/0') ? '50' : fps} -i templates/transparent.png ${!audio && audio2 ? `-r ${fps.includes('0/0') ? '50' : fps} -itsoffset ${iduration} -i ${filepath}/concat2.mp4 ` : ''}-filter_complex "[1:v]scale=-1:${height},scale=ceil(iw/2)*2:ceil(ih/2)*2[vid];[2:v]scale=${width}:${height},scale=ceil(iw/2)*2:ceil(ih/2)*2[transparent];[transparent][vid]overlay=x=W/2-w/2:y=H/2-h/2:format=auto,setsar=sar=1,setdar=dar=1,fps=${fps.includes('0/0') ? '50' : fps}[transition2];[0:v]setsar=sar=1,setdar=dar=1[transition];[transition][transition2]concat=v=1:a=0,scale=ceil(iw/2)*2:ceil(ih/2)*2[out]${audio && audio2 ? `;[0:a][1:a]concat=v=0:a=1[aout]` : ''}" -map "[out]" ${(audio && audio2) ? '-map "[aout]" ' : (audio && !audio2) ? '-map 0:a ' : (!audio && audio2) ? '-map 3:a ' : ''}-aspect ${width}:${height} -preset ${findpreset(args)} -c:v libx264 -pix_fmt yuv420p ${filepath}/output.mp4`)
                        await sendFile(msg, filepath, `output.mp4`)
                    } else {
                        var fps = fileinfo.info.fps

                        await execPromise(`ffmpeg -r ${fps.includes('0/0') ? '50' : fps} -i ${filepath}/${filename} -i ${filepath}/${filename2} -r ${fps.includes('0/0') ? '50' : fps} -i templates/transparent.png -filter_complex "[1:v]scale=-1:${height}[vid];[2:v]scale=${width}:${height}[transparent];[transparent][vid]overlay=x=W/2-w/2:y=H/2-h/2:format=auto,setsar=sar=1,setdar=dar=1,fps=${fps.includes('0/0') ? '50' : fps}[transition2];[0:v]setsar=sar=1,setdar=dar=1[transition];[transition][transition2]concat,split[gnout][gpout];[gpout]palettegen=reserve_transparent=1[palette];[gnout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -aspect ${width}:${height} -preset ${findpreset(args)} ${filepath}/output.gif`)
                        await sendFile(msg, filepath, `output.gif`)
                    }
                }
            },
            help: {
                "name": "transition {transition (default is fade)} <file> <file2> [-duration <seconds (max 10)>] [-waituntilend]",
                "value": "Does a transition between the first file and the second one, 0 duration means no transition. A list of transitions can be found here, including random: https://trac.ffmpeg.org/wiki/Xfade"
            },
            cooldown: 2500,
            type: "Animation"
        },

        {
            name: ["iceberg"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl2'] === undefined && args[2] === undefined) {
                    msg.channel.send('What are the files?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var saidMessage = args.join(' ').substring(args[0].length + 1)
                var stages = 10
                var stageindex = args.indexOf('-stages')
                if (stageindex > -1) {
                    stages = isNaN(Number(args[stageindex + 1])) ? 10 : Number(args[stageindex + 1]) <= 1 ? 1 : Number(args[stageindex + 1]) >= 10 ? 10 : Math.round(Number(args[stageindex + 1])) || 10
                }
                var stagewords = {}
                var stageimages = {}
                var stagewrdsdimensions = {
                    stage1: [0, 0, 1263, 266],
                    stage2: [0, 273, 1263, 263],
                    stage3: [0, 543, 1263, 311],
                    stage4: [0, 861, 1263, 277],
                    stage5: [0, 1145, 1263, 282],
                    stage6: [0, 1434, 1263, 251],
                    stage7: [0, 1692, 1263, 269],
                    stage8: [0, 1969, 1263, 270],
                    stage9: [0, 2246, 1263, 292],
                    stage10: [0, 2545, 1263, 270],
                }
                var stageimgdimensions = {
                    stage1: [1287, 0, 293, 266],
                    stage2: [1287, 273, 293, 263],
                    stage3: [1287, 543, 293, 311],
                    stage4: [1287, 861, 293, 277],
                    stage5: [1287, 1145, 293, 282],
                    stage6: [1287, 1434, 293, 251],
                    stage7: [1287, 1692, 293, 269],
                    stage8: [1287, 1969, 293, 270],
                    stage9: [1287, 2246, 293, 292],
                    stage10: [1287, 2545, 293, 270],
                }
                var stagematches = saidMessage.match(/-stage([1-9]|10)(words|image)/g)
                if (stagematches) {
                    for (var i in stagematches) {
                        var stagematch = stagematches[i]
                        var stagematch2 = stagematch.match(/^-stage\d+(words|image)$/)
                        var argIndex = args.indexOf(stagematch)
                        var nextArgs = args.slice(argIndex + 1)
                        var arg = ''
                        for (var j in nextArgs) {
                            var nextArg = nextArgs[j]
                            if (nextArg.match(/^-stage\d+(words|image)$|^-stages$/)) break
                            arg += `${nextArg} `
                        }
                        arg = arg.substring(0, arg.length - 1)
                        var stagenumber = stagematch.substring(6, stagematch.length - stagematch2[1].length)
                        var stagetype = stagematch2[1]
                        if (stagetype === 'words') {
                            var words = arg.split(/ ?\| ?/)
                            stagewords['stage' + stagenumber] = words
                        } else {
                            stageimages['stage' + stagenumber] = arg
                        }
                    }
                }

                var errors = {}
                var filetypes = {}
                var nofiles = true
                var lasturlserror = ''

                if (!(Object.keys(stageimages).length)) {
                    var validfilecount = 0

                    async function inspect(url) {
                        var lasturlerror = false
                        var fileinfo = await validateFile(url, false, {
                            size: `one of the files exceeds the size limit of {param} mb hahahaha (try to use the shrink, setfps, trim or crunch commands)`,
                            frames: `the frames of one of the files exceed the limit of {param} hahahaha (try to use the setfps or the trim commands)`,
                            width: `the width of one of the files exceeds the limit of {param} hahahaha (try to use the shrink command)`,
                            height: `the height of one of the files exceeds the limit of {param} hahahaha (try to use the shrink command)`
                        }).catch(error => {
                            lasturlerror = error
                        })
                        if (lasturlerror || !fileinfo) return
                        var filetype = fileinfo.type
                        if (!filetype || !(filetype.mime.startsWith('image') && !(gifFormats.find(f => f === filetype.ext)))) return
                        stageimages['stage' + (validfilecount + 1)] = url
                        nofiles = false
                        return true
                    }

                    for (var i in data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrls']) {
                        var url = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrls'][i]
                        var success = await inspect(url)
                        if (success) validfilecount += 1
                        if (validfilecount >= 10) break
                    }
                }

                for (var stage in stageimages) {
                    var imageurl = stageimages[stage]
                    var fileinfo = await validateFile(imageurl, false, {
                        size: `one of the files exceeds the size limit of {param} mb hahahaha (try to use the shrink, setfps, trim or crunch commands)`,
                        frames: `the frames of one of the files exceed the limit of {param} hahahaha (try to use the setfps or the trim commands)`,
                        width: `the width of one of the files exceeds the limit of {param} hahahaha (try to use the shrink command)`,
                        height: `the height of one of the files exceeds the limit of {param} hahahaha (try to use the shrink command)`
                    }).catch(error => {
                        errors.validate = error
                    })
                    var filetype = fileinfo.type
                    if (!(filetype.mime.startsWith('image') && !(gifFormats.find(f => f === filetype.ext)))) errors.filetype = `Unsupported file: \`${imageurl}\``
                    filetypes[stage] = filetype
                }

                if (nofiles && lasturlserror) {
                    msg.channel.send({
                        content: lasturlserror,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }

                for (var i in errors) {
                    var error = errors[i]
                    if (error) {
                        msg.channel.send({
                            content: error,
                            allowedMentions: {
                                parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                            }
                        }).catch(() => { })
                        msg.channel.sendTyping().catch(() => { })
                        return
                    }
                }

                for (var i in filetypes) {
                    var type = filetypes[i]
                    if (!(type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext)))) {
                        msg.channel.send({
                            content: 'Unsupported file types.',
                            allowedMentions: {
                                parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                            }
                        }).catch(() => { })
                        msg.channel.sendTyping().catch(() => { })
                        return
                    }
                }

                var currentcount = filecount
                filecount++
                var filepath = `temp/file${currentcount}`
                fs.mkdirSync(`${filepath}`)

                var iceberg = await Jimp.read(`templates/iceberg.png`)
                var arialr = await Jimp.loadFont(`templates/fonts/ArialRed/ArialRed.fnt`)

                iceberg.crop(0, 0, iceberg.bitmap.width, stagewrdsdimensions['stage' + stages][1] + stagewrdsdimensions['stage' + stages][3])

                for (var i in stageimages) {
                    var imageurl = stageimages[i]
                    var filetype = filetypes[i]
                    var dimensions = stageimgdimensions[i]

                    await downloadFile(imageurl, `${i}.png`, {
                        filepath: filepath
                    })
                    var image = await Jimp.read(`${filepath}/${i}.png`)
                    image.resize(dimensions[2], dimensions[3])
                    iceberg.composite(image, dimensions[0], dimensions[1])
                }

                for (var i in stagewords) {
                    var words = stagewords[i]
                    var wordsS = []
                    for (var j in words) {
                        var word = words[j]
                        wordsS.push(word)
                        wordsS.push(' '.repeat(Math.floor((Math.floor(Math.random() * 61) + 30) / words.length / (word.length / 15))))
                    }
                    wordsS.splice(wordsS.length - 1)
                    var text = wordsS.join('')
                    var dimensions = stagewrdsdimensions[i]

                    await iceberg.print(arialr, dimensions[0], dimensions[1], { text: Discord.Util.cleanContent(text, msg), alignmentX: Jimp.HORIZONTAL_ALIGN_CENTER, alignmentY: Jimp.VERTICAL_ALIGN_MIDDLE }, dimensions[2], dimensions[3])
                }

                await iceberg.writeAsync(`${filepath}/output.png`)

                await sendFile(msg, filepath, `output.png`)
            },
            help: {
                "name": "iceberg {-stage<stagenumber>words <word1 | word2 | ...>} {-stage<stagenumber>image <image>} [-stages <stagenumber (from 1 to 10)>]",
                "value": "Makes a conspiracy iceberg by filling in random words and images. (only supports static image files)\nExample usage: p:iceberg -stage1words Stolen Assets | Deinx -stage1image https://cdn.discordapp.com/attachments/760223418968047629/862409703392149554/c85e3e8144c1012764074e60607c5e56.png -stage10words Vordath is Transexual -stage10image https://cdn.discordapp.com/attachments/760223418968047629/862410091814322216/output.png"
            },
            cooldown: 2500,
            type: "Memes"
        },

        {
            name: ["makegif"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (args[1] === undefined && msg.attachments.size <= 0 && !(data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrls'].length)) {
                    msg.channel.send('What are the frames?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var frameurls = []
                var fpsIsLastArg = false
                if (!isNaN(Number(args[args.length - 1])) && args[args.length - 2] !== '-frames') {
                    fpsIsLastArg = true
                }
                var framenumber = 50
                var framesindex = args.indexOf('-frames')
                if (framesindex > -1) {
                    framenumber = isNaN(Number(args[framesindex + 1])) ? 50 : Number(args[framesindex + 1]) <= 1 ? 1 : Number(args[framesindex + 1]) >= 100 ? 100 : Math.round(Number(args[framesindex + 1])) || 50
                    args.splice(framesindex, 2)
                }
                var nofiles = false
                if (msg.attachments.size <= 0 && !(args.find(arg => validUrl.test(arg)))) nofiles = true
                var fps = !fpsIsLastArg ? undefined : Number(args[args.length - 1]) >= 60 ? 60 : Number(args[args.length - 1]) <= 0 ? 0 : Number(args[args.length - 1]) || undefined
                var saidMessage = args.splice(1, fpsIsLastArg ? args.length - 2 : args.length - 1).join(' ')
                var lasturlserror = ''
                if (nofiles) {
                    var validfilecount = 0

                    async function inspect(url) {
                        var lasturlerror = false
                        var fileinfo = await validateFile(url, false, {
                            size: `one of the files exceeds the size limit of {param} mb hahahaha (try to use the shrink, setfps, trim or crunch commands)`,
                            frames: `the frames of one of the files exceed the limit of {param} hahahaha (try to use the setfps or the trim commands)`,
                            width: `the width of one of the files exceeds the limit of {param} hahahaha (try to use the shrink command)`,
                            height: `the height of one of the files exceeds the limit of {param} hahahaha (try to use the shrink command)`
                        }).catch(error => {
                            lasturlerror = error
                        })
                        if (lasturlerror) return
                        var filetype = fileinfo.type
                        if (lasturlerror) return
                        if (!(filetype.mime.startsWith('image') && !(gifFormats.find(f => f === filetype.ext)))) return
                        frameurls.push(url)
                        return true
                    }

                    for (var i in data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrls']) {
                        var url = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrls'][i]
                        var success = await inspect(url).catch(() => { })
                        if (success) validfilecount += 1
                        if (validfilecount >= framenumber) break
                    }
                } else if (msg.attachments.size) {
                    msg.attachments.forEach(attachment => {
                        frameurls.push(attachment.url)
                    })
                } else {
                    frameurls = saidMessage.split(' ')
                }
                var filetypes = []
                var infos = []
                var error = ''

                for (var i in frameurls) {
                    var url = frameurls[i]
                    if (error) break
                    var fileinfo = await validateFile(url, false, {
                        size: `one of the files exceeds the size limit of {param} mb hahahaha (try to use the shrink, setfps, trim or crunch commands)`,
                        frames: `the frames of one of the files exceed the limit of {param} hahahaha (try to use the setfps or the trim commands)`,
                        width: `the width of one of the files exceeds the limit of {param} hahahaha (try to use the shrink command)`,
                        height: `the height of one of the files exceeds the limit of {param} hahahaha (try to use the shrink command)`
                    }).catch(err => {
                        error = err
                    })
                    if (error) break
                    var filetype = fileinfo.type
                    if (!(filetype.mime.startsWith('image') && !(gifFormats.find(f => f === filetype.ext)))) error = `Unsupported file: \`${url}\``
                    if (error) break
                    filetypes.push(filetype)
                    infos.push(fileinfo.info)
                }

                if (nofiles && lasturlserror && !frameurls.length) {
                    msg.channel.send({
                        content: lasturlserror,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }

                if (error) {
                    msg.channel.send({
                        content: error,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }

                for (var i in filetypes) {
                    var type = filetypes[i]
                    if (!(type.mime.startsWith('image') || gifFormats.find(f => f === type.ext))) {
                        msg.channel.send({
                            content: 'Unsupported file types.',
                            allowedMentions: {
                                parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                            }
                        }).catch(() => { })
                        msg.channel.sendTyping().catch(() => { })
                        return
                    }
                }

                var currentcount = filecount
                filecount++
                var filepath = `temp/file${currentcount}`

                fs.mkdirSync(`${filepath}`)
                fs.mkdirSync(`${filepath}/frames`)
                var framesizes
                for (var i = 0; i < frameurls.length; i++) {
                    var frameurl = frameurls[i]
                    if (!framesizes) {
                        framesizes = { x: infos[i].width, y: infos[i].height }
                    }
                    await downloadFile(frameurl, `${i}.png`, {
                        filepath: `${filepath}/frames`,
                        ffmpeg: true,
                        ffmpegstring: `-filter_complex "[0:v]scale=${framesizes.x}:${framesizes.y},scale='min(400,iw)':min'(400,ih)':force_original_aspect_ratio=decrease[out]" -map [out]`
                    })
                }
                await execPromise(`ffmpeg ${fps && `-r ${fps}` || ''} -i ${filepath}/frames/%d.png -filter_complex "[0:v]split[gif][pgif];[pgif]palettegen=reserve_transparent=1[palette];[gif][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ${findpreset(args)} -vsync 0 -gifflags -offsetting ${filepath}/output.gif`)
                await sendFile(msg, filepath, `output.gif`)
            },
            help: {
                "name": "makegif <frames> [-frames <framenumber (max 100)> {fps}",
                "value": "Makes a GIF out of the frames and FPS specified."
            },
            cooldown: 2500,
            type: "Conversion"
        },

        {
            name: ["country", "flag"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
                var fileinfo = await validateFile(currenturl).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })

                if (!fileinfo) return
                var type = fileinfo.type

                if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                    var filepath = await downloadFile(currenturl, `input.png`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.png`
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -i templates/country.png -filter_complex "[0:v]scale=283:168[frame];[1:v][frame]overlay=x=15:y=56:format=auto[out]" -map "[out]" -preset ${findpreset(args)} ${filepath}/output.png`)
                    await sendFile(msg, filepath, `output.png`)
                } else if (type.mime.startsWith('video')) {
                    var filepath = await downloadFile(currenturl, `input.mp4`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp4`
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -i templates/country.png -map 0:a? -filter_complex "[0:v]scale=283:168[frame];[1:v][frame]overlay=x=15:y=56:format=auto[oout];[oout]scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ${findpreset(args)} -c:v libx264 -pix_fmt yuv420p ${filepath}/output.mp4`)
                    await sendFile(msg, filepath, `output.mp4`)
                } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                    var filepath = await downloadFile(currenturl, `input.gif`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.gif`
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -i templates/country.png -filter_complex "[0:v]scale=283:168[frame];[1:v][frame]overlay=x=15:y=56:format=auto[oout];[oout]split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ${findpreset(args)} -gifflags -offsetting ${filepath}/output.gif`)
                    await sendFile(msg, filepath, `output.gif`)
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "country/flag <file>",
                "value": "It's my Mainland!"
            },
            cooldown: 2500,
            type: "Memes"
        },

        {
            name: ["notclickbait", "redcircle"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
                var saidMessage = args.join(' ').substring(args[0].length + 1)
                var random = false
                if (saidMessage.includes('-random')) random = true
                var fileinfo = await validateFile(currenturl).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })

                if (!fileinfo) return
                var type = fileinfo.type

                if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                    var filepath = await downloadFile(currenturl, `input.png`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.png`
                    var width = fileinfo.info.width
                    var height = fileinfo.info.height

                    var squareS = { value: ((height === width) && width) || ((height > width) && height) || width, constraint: ((height === width) && 'both') || ((height > width) && 'height') || 'width' }

                    await execPromise(`ffmpeg -i ${filepath}/${filename} -i templates/redcircle.png -filter_complex "[1:v]scale=${random ? `${(width + height) / 5}:-1` : `${squareS.constraint === 'width' ? -1 : width}:${squareS.constraint === 'height' ? -1 : height}`}[circle];[0:v][circle]overlay=x=${random ? (Math.floor(Math.random() * (width + 1)) - 1) + '-w/2' : 'W/2-w/2'}:y=${random ? (Math.floor(Math.random() * (height + 1)) - 1) + '-h/2' : 'H/2-h/2'}:format=auto[out]" -map "[out]" -preset ${findpreset(args)} ${filepath}/output.png`)
                    await sendFile(msg, filepath, `output.png`)
                } else if (type.mime.startsWith('video')) {
                    var filepath = await downloadFile(currenturl, `input.mp4`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp4`
                    var width = fileinfo.info.width
                    var height = fileinfo.info.height

                    var squareS = { value: ((height === width) && width) || ((height > width) && height) || width, constraint: ((height === width) && 'both') || ((height > width) && 'height') || 'width' }

                    await execPromise(`ffmpeg -i ${filepath}/${filename} -i templates/redcircle.png -map 0:a? -filter_complex "[1:v]scale=${random ? `${(width + height) / 5}:-1` : `${squareS.constraint === 'width' ? -1 : width}:${squareS.constraint === 'height' ? -1 : height}`}[circle];[0:v][circle]overlay=x=${random ? (Math.floor(Math.random() * (width + 1)) - 1) + '-w/2' : 'W/2-w/2'}:y=${random ? (Math.floor(Math.random() * (height + 1)) - 1) + '-h/2' : 'H/2-h/2'}:format=auto[oout];[oout]scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ${findpreset(args)} -c:v libx264 -pix_fmt yuv420p ${filepath}/output.mp4`)
                    await sendFile(msg, filepath, `output.mp4`)
                } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                    var filepath = await downloadFile(currenturl, `input.gif`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.gif`
                    var width = fileinfo.info.width
                    var height = fileinfo.info.height

                    var squareS = { value: ((height === width) && width) || ((height > width) && height) || width, constraint: ((height === width) && 'both') || ((height > width) && 'height') || 'width' }

                    await execPromise(`ffmpeg -i ${filepath}/${filename} -i templates/redcircle.png -filter_complex "[1:v]scale=${random ? `${(width + height) / 5}:-1` : `${squareS.constraint === 'width' ? -1 : width}:${squareS.constraint === 'height' ? -1 : height}`}[circle];[0:v][circle]overlay=x=${random ? (Math.floor(Math.random() * (width + 1)) - 1) + '-w/2' : 'W/2-w/2'}:y=${random ? (Math.floor(Math.random() * (height + 1)) - 1) + '-h/2' : 'H/2-h/2'}:format=auto[oout];[oout]split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ${findpreset(args)} -gifflags -offsetting ${filepath}/output.gif`)
                    await sendFile(msg, filepath, `output.gif`)
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "notclickbait/redcircle [-random] <file>",
                "value": "Real.\nExample usage: p:notclickbait -random https://imagesvc.meredithcorp.io/v3/mm/image?q=85&c=sc&poi=face&w=2000&h=1000&url=https%3A%2F%2Fstatic.onecms.io%2Fwp-content%2Fuploads%2Fsites%2F9%2F2013%2F12%2F06%2F201307-xl-spice-roasted-pork-tenderloin-2000.jpg"
            },
            cooldown: 2500,
            type: "Memes"
        },

        {
            name: ["lefishe", "fishe"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && validUrl.test(args[args.length - 1]) === false) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var saidMessage = args.join(' ').substring(args[0].length + 1)
                symbolreplacements.forEach(symbolReplacement => {
                    symbolReplacement.target.forEach(target => {
                        saidMessage = saidMessage.replace(new RegExp(target, 'ig'), symbolReplacement.replacement)
                    })
                })
                var matchedTextes = saidMessage.match(/"([\s\S]*?)"/)
                if (!matchedTextes) {
                    matchedTextes = ['""', '']
                }
                var text = matchedTextes[1]
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
                var fileinfo = await validateFile(currenturl).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })

                if (!fileinfo) return
                var type = fileinfo.type

                if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                    var filepath = await downloadFile(currenturl, `input.png`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.png`
                    var width = fileinfo.info.width
                    var height = fileinfo.info.height
                    var transparent = await Jimp.read('templates/transparent.png')
                    var brushscript = await Jimp.loadFont('templates/fonts/BrushScript/BrushScript.fnt')
                    transparent.resize(width, height)
                    transparent.resize(500, Jimp.AUTO)
                    await transparent.print(brushscript, 50, 50, { text: Discord.Util.cleanContent(text, msg), alignmentX: Jimp.HORIZONTAL_ALIGN_RIGHT, alignmentY: Jimp.VERTICAL_ALIGN_BOTTOM }, transparent.bitmap.width - 100, transparent.bitmap.height - 100)
                    await transparent.writeAsync(`${filepath}/caption.png`)

                    await execPromise(`ffmpeg -i ${filepath}/${filename} -i ${filepath}/caption.png -filter_complex "[0:v][1:v]overlay=x=0:y=0:format=auto[out]" -map "[out]" -preset ${findpreset(args)} ${filepath}/output.png`)
                    await sendFile(msg, filepath, `output.png`)
                } else if (type.mime.startsWith('video')) {
                    var filepath = await downloadFile(currenturl, `input.mp4`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp4`
                    var width = fileinfo.info.width
                    var height = fileinfo.info.height
                    var transparent = await Jimp.read('templates/transparent.png')
                    var brushscript = await Jimp.loadFont('templates/fonts/BrushScript/BrushScript.fnt')
                    transparent.resize(width, height)
                    transparent.resize(500, Jimp.AUTO)
                    await transparent.print(brushscript, 50, 50, { text: Discord.Util.cleanContent(text, msg), alignmentX: Jimp.HORIZONTAL_ALIGN_RIGHT, alignmentY: Jimp.VERTICAL_ALIGN_BOTTOM }, transparent.bitmap.width - 100, transparent.bitmap.height - 100)
                    await transparent.writeAsync(`${filepath}/caption.png`)

                    await execPromise(`ffmpeg -i ${filepath}/${filename} -i ${filepath}/caption.png -map 0:a? -filter_complex "[0:v][1:v]overlay=x=0:y=0:format=auto[oout];[oout]scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ${findpreset(args)} -c:v libx264 -pix_fmt yuv420p ${filepath}/output.mp4`)
                    await sendFile(msg, filepath, `output.mp4`)
                } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                    var filepath = await downloadFile(currenturl, `input.gif`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.gif`
                    var width = fileinfo.info.width
                    var height = fileinfo.info.height
                    var transparent = await Jimp.read('templates/transparent.png')
                    var brushscript = await Jimp.loadFont('templates/fonts/BrushScript/BrushScript.fnt')
                    transparent.resize(width, height)
                    transparent.resize(500, Jimp.AUTO)
                    await transparent.print(brushscript, 50, 50, { text: Discord.Util.cleanContent(text, msg), alignmentX: Jimp.HORIZONTAL_ALIGN_RIGHT, alignmentY: Jimp.VERTICAL_ALIGN_BOTTOM }, transparent.bitmap.width - 100, transparent.bitmap.height - 100)
                    await transparent.writeAsync(`${filepath}/caption.png`)

                    await execPromise(`ffmpeg -i ${filepath}/${filename} -i ${filepath}/caption.png -filter_complex "[0:v][1:v]overlay=x=0:y=0:format=auto[oout];[oout]split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ${findpreset(args)} -gifflags -offsetting ${filepath}/output.gif`)
                    await sendFile(msg, filepath, `output.gif`)
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "lefishe/fishe \"{name}\" <file>",
                "value": "au chocolat."
            },
            cooldown: 2500,
            type: "Captions"
        },

        {
            name: ["meme4", "tenorcaption"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && validUrl.test(args[args.length - 1]) === false) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var size = 1
                var sizeindex = args.indexOf('-size')
                if (sizeindex > -1) {
                    size = isNaN(Number(args[sizeindex + 1])) ? 1 : Number(args[sizeindex + 1]) <= 0.5 ? 0.5 : Number(args[sizeindex + 1]) >= 5 ? 5 : Number(args[sizeindex + 1]) || 1
                }
                var saidMessage = args.join(' ').substring(args[0].length + 1).replace(/‚Äô/g, '\'')
                symbolreplacements.forEach(symbolReplacement => {
                    symbolReplacement.target.forEach(target => {
                        saidMessage = saidMessage.replace(new RegExp(target, 'ig'), symbolReplacement.replacement)
                    })
                })
                var matchedTextes = saidMessage.match(/"([\s\S]*?)"/g)
                if (!matchedTextes) {
                    matchedTextes = ['""', '""']
                } else if (!matchedTextes[1]) {
                    matchedTextes[1] = '""'
                }
                var text = matchedTextes[0].substring(1, matchedTextes[0].length - 1)
                var text2 = matchedTextes[1].substring(1, matchedTextes[1].length - 1)
                var rgb = {
                    r: 255,
                    g: 255,
                    b: 255,
                }
                var colorindex = args.indexOf('-color')
                if (colorindex > -1) {
                    var r = args[colorindex + 1]
                    var g = args[colorindex + 2]
                    var b = args[colorindex + 3]
                    rgb.r = isNaN(Number(String(r).replace(/,/g, ''))) ? 0 : Number(String(r).replace(/,/g, '')) <= 0 ? 0 : Number(String(r).replace(/,/g, '')) >= 255 ? 255 : Number(String(r).replace(/,/g, '')) || 0
                    rgb.g = isNaN(Number(String(g).replace(/,/g, ''))) ? 0 : Number(String(g).replace(/,/g, '')) <= 0 ? 0 : Number(String(g).replace(/,/g, '')) >= 255 ? 255 : Number(String(g).replace(/,/g, '')) || 0
                    rgb.b = isNaN(Number(String(b).replace(/,/g, ''))) ? 0 : Number(String(b).replace(/,/g, '')) <= 0 ? 0 : Number(String(b).replace(/,/g, '')) >= 255 ? 255 : Number(String(b).replace(/,/g, '')) || 0
                }
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
                var fileinfo = await validateFile(currenturl).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })

                if (!fileinfo) return
                var type = fileinfo.type

                if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                    var filepath = await downloadFile(currenturl, `input.png`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.png`
                    var width = fileinfo.info.width
                    var height = fileinfo.info.height
                    var transparent = await Jimp.read('templates/transparent.png')
                    var ubuntu = await Jimp.loadFont('templates/fonts/Ubuntu/Ubuntu.fnt')
                    transparent.resize(width, height)
                    transparent.resize(Math.round(2000 / size), Jimp.AUTO)
                    var transparent2 = transparent.clone()
                    await transparent.print(ubuntu, 80, 80, { text: Discord.Util.cleanContent(text, msg), alignmentX: Jimp.HORIZONTAL_ALIGN_CENTER, alignmentY: Jimp.VERTICAL_ALIGN_TOP }, transparent.bitmap.width - 160, transparent.bitmap.height - 160)
                    await transparent2.print(ubuntu, 80, 80, { text: Discord.Util.cleanContent(text2, msg), alignmentX: Jimp.HORIZONTAL_ALIGN_CENTER, alignmentY: Jimp.VERTICAL_ALIGN_BOTTOM }, transparent.bitmap.width - 160, transparent.bitmap.height - 160)
                    transparent.resize(width, height)
                    transparent2.resize(width, height)
                    await transparent.writeAsync(`${filepath}/caption.png`)
                    await transparent2.writeAsync(`${filepath}/caption2.png`)

                    await execPromise(`ffmpeg -i ${filepath}/${filename} -i ${filepath}/caption.png -i ${filepath}/caption2.png -filter_complex "[1:v]curves=r='0/0 1/${rgb.r / 255}':g='0/0 1/${rgb.g / 255}':b='0/0 1/${rgb.b / 255}'[top];[2:v]curves=r='0/0 1/${rgb.r / 255}':g='0/0 1/${rgb.g / 255}':b='0/0 1/${rgb.b / 255}'[bottom];[0:v][top]overlay=x=0:y=0:format=auto[caption];[caption][bottom]overlay=x=0:y=0:format=auto[out]" -map "[out]" -preset ${findpreset(args)} ${filepath}/output.png`)
                    await sendFile(msg, filepath, `output.png`)
                } else if (type.mime.startsWith('video')) {
                    var filepath = await downloadFile(currenturl, `input.mp4`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp4`
                    var width = fileinfo.info.width
                    var height = fileinfo.info.height
                    var transparent = await Jimp.read('templates/transparent.png')
                    var ubuntu = await Jimp.loadFont('templates/fonts/Ubuntu/Ubuntu.fnt')
                    transparent.resize(width, height)
                    transparent.resize(Math.round(2000 / size), Jimp.AUTO)
                    var transparent2 = transparent.clone()
                    await transparent.print(ubuntu, 80, 80, { text: Discord.Util.cleanContent(text, msg), alignmentX: Jimp.HORIZONTAL_ALIGN_CENTER, alignmentY: Jimp.VERTICAL_ALIGN_TOP }, transparent.bitmap.width - 160, transparent.bitmap.height - 160)
                    await transparent2.print(ubuntu, 80, 80, { text: Discord.Util.cleanContent(text2, msg), alignmentX: Jimp.HORIZONTAL_ALIGN_CENTER, alignmentY: Jimp.VERTICAL_ALIGN_BOTTOM }, transparent.bitmap.width - 160, transparent.bitmap.height - 160)
                    transparent.resize(width, height)
                    transparent2.resize(width, height)
                    await transparent.writeAsync(`${filepath}/caption.png`)
                    await transparent2.writeAsync(`${filepath}/caption2.png`)

                    await execPromise(`ffmpeg -i ${filepath}/${filename} -i ${filepath}/caption.png -i ${filepath}/caption2.png -map 0:a? -filter_complex "[1:v]curves=r='0/0 1/${rgb.r / 255}':g='0/0 1/${rgb.g / 255}':b='0/0 1/${rgb.b / 255}'[top];[2:v]curves=r='0/0 1/${rgb.r / 255}':g='0/0 1/${rgb.g / 255}':b='0/0 1/${rgb.b / 255}'[bottom];[0:v][top]overlay=x=0:y=0:format=auto[caption];[caption][bottom]overlay=x=0:y=0:format=auto[oout];[oout]scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ${findpreset(args)} -c:v libx264 -pix_fmt yuv420p ${filepath}/output.mp4`)
                    await sendFile(msg, filepath, `output.mp4`)
                } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                    var filepath = await downloadFile(currenturl, `input.gif`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.gif`
                    var width = fileinfo.info.width
                    var height = fileinfo.info.height
                    var transparent = await Jimp.read('templates/transparent.png')
                    var ubuntu = await Jimp.loadFont('templates/fonts/Ubuntu/Ubuntu.fnt')
                    transparent.resize(width, height)
                    transparent.resize(Math.round(2000 / size), Jimp.AUTO)
                    var transparent2 = transparent.clone()
                    await transparent.print(ubuntu, 80, 80, { text: Discord.Util.cleanContent(text, msg), alignmentX: Jimp.HORIZONTAL_ALIGN_CENTER, alignmentY: Jimp.VERTICAL_ALIGN_TOP }, transparent.bitmap.width - 160, transparent.bitmap.height - 160)
                    await transparent2.print(ubuntu, 80, 80, { text: Discord.Util.cleanContent(text2, msg), alignmentX: Jimp.HORIZONTAL_ALIGN_CENTER, alignmentY: Jimp.VERTICAL_ALIGN_BOTTOM }, transparent.bitmap.width - 160, transparent.bitmap.height - 160)
                    transparent.resize(width, height)
                    transparent2.resize(width, height)
                    await transparent.writeAsync(`${filepath}/caption.png`)
                    await transparent2.writeAsync(`${filepath}/caption2.png`)

                    await execPromise(`ffmpeg -i ${filepath}/${filename} -i ${filepath}/caption.png -i ${filepath}/caption2.png -filter_complex "[1:v]curves=r='0/0 1/${rgb.r / 255}':g='0/0 1/${rgb.g / 255}':b='0/0 1/${rgb.b / 255}'[top];[2:v]curves=r='0/0 1/${rgb.r / 255}':g='0/0 1/${rgb.g / 255}':b='0/0 1/${rgb.b / 255}'[bottom];[0:v][top]overlay=x=0:y=0:format=auto[caption];[caption][bottom]overlay=x=0:y=0:format=auto[oout];[oout]split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ${findpreset(args)} -gifflags -offsetting ${filepath}/output.gif`)
                    await sendFile(msg, filepath, `output.gif`)
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "meme4/tenorcaption \"{topText}\" \"[bottomText]\" <file> [-color <r> <g> <b>] [-size <multiplier (from 0.5 to 5)>]",
                "value": "Adds a Tenor GIF caption to the file.\nExample usage: p:tenorcaption \"You putrid fool\" https://cdn.discordapp.com/attachments/691444857108955196/855507735750901831/output.png -color 255 0 0"
            },
            cooldown: 2500,
            type: "Captions"
        },

        {
            name: ["meme5", "inspiration"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && validUrl.test(args[args.length - 1]) === false) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var size = 1
                var sizeindex = args.indexOf('-size')
                if (sizeindex > -1) {
                    size = isNaN(Number(args[sizeindex + 1])) ? 1 : Number(args[sizeindex + 1]) <= 0.5 ? 0.5 : Number(args[sizeindex + 1]) >= 5 ? 5 : Number(args[sizeindex + 1]) || 1
                }
                var saidMessage = args.join(' ').substring(args[0].length + 1).replace(/‚Äô/g, '\'')
                symbolreplacements.forEach(symbolReplacement => {
                    symbolReplacement.target.forEach(target => {
                        saidMessage = saidMessage.replace(new RegExp(target, 'ig'), symbolReplacement.replacement)
                    })
                })
                var matchedTextes = saidMessage.match(/"([\s\S]*?)"/g)
                if (!matchedTextes) {
                    matchedTextes = ['""']
                }
                var text = matchedTextes[0].substring(1, matchedTextes[0].length - 1)
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
                var fileinfo = await validateFile(currenturl).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })

                if (!fileinfo) return
                var type = fileinfo.type

                if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                    var filepath = await downloadFile(currenturl, `input.png`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.png`
                    var width = fileinfo.info.width
                    var height = fileinfo.info.height
                    var transparent = await Jimp.read('templates/transparent.png')
                    var coolvetica = await Jimp.loadFont('templates/fonts/CoolveticaCondensed/CoolveticaCondensed.fnt')
                    transparent.resize(width, height)
                    transparent.resize(Math.round(2000 / size), Jimp.AUTO)
                    await transparent.print(coolvetica, 80, 80, { text: Discord.Util.cleanContent(text, msg), alignmentX: Jimp.HORIZONTAL_ALIGN_CENTER, alignmentY: Jimp.VERTICAL_ALIGN_MIDDLE }, transparent.bitmap.width - 160, transparent.bitmap.height - 160)
                    transparent.resize(width, height)
                    await transparent.writeAsync(`${filepath}/caption.png`)

                    await execPromise(`ffmpeg -i ${filepath}/${filename} -i ${filepath}/caption.png -filter_complex "[0:v][1:v]overlay=x=0:y=0:format=auto[out]" -map "[out]" -preset ${findpreset(args)} ${filepath}/output.png`)
                    await sendFile(msg, filepath, `output.png`)
                } else if (type.mime.startsWith('video')) {
                    var filepath = await downloadFile(currenturl, `input.mp4`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp4`
                    var width = fileinfo.info.width
                    var height = fileinfo.info.height
                    var transparent = await Jimp.read('templates/transparent.png')
                    var coolvetica = await Jimp.loadFont('templates/fonts/CoolveticaCondensed/CoolveticaCondensed.fnt')
                    transparent.resize(width, height)
                    transparent.resize(Math.round(2000 / size), Jimp.AUTO)
                    await transparent.print(coolvetica, 80, 80, { text: Discord.Util.cleanContent(text, msg), alignmentX: Jimp.HORIZONTAL_ALIGN_CENTER, alignmentY: Jimp.VERTICAL_ALIGN_MIDDLE }, transparent.bitmap.width - 160, transparent.bitmap.height - 160)
                    transparent.resize(width, height)
                    await transparent.writeAsync(`${filepath}/caption.png`)

                    await execPromise(`ffmpeg -i ${filepath}/${filename} -i ${filepath}/caption.png -map 0:a? -filter_complex "[0:v][1:v]overlay=x=0:y=0:format=auto,scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ${findpreset(args)} -c:v libx264 -pix_fmt yuv420p ${filepath}/output.mp4`)
                    await sendFile(msg, filepath, `output.mp4`)
                } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                    var filepath = await downloadFile(currenturl, `input.gif`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.gif`
                    var width = fileinfo.info.width
                    var height = fileinfo.info.height
                    var transparent = await Jimp.read('templates/transparent.png')
                    var coolvetica = await Jimp.loadFont('templates/fonts/CoolveticaCondensed/CoolveticaCondensed.fnt')
                    transparent.resize(width, height)
                    transparent.resize(Math.round(2000 / size), Jimp.AUTO)
                    await transparent.print(coolvetica, 80, 80, { text: Discord.Util.cleanContent(text, msg), alignmentX: Jimp.HORIZONTAL_ALIGN_CENTER, alignmentY: Jimp.VERTICAL_ALIGN_MIDDLE }, transparent.bitmap.width - 160, transparent.bitmap.height - 160)
                    transparent.resize(width, height)
                    await transparent.writeAsync(`${filepath}/caption.png`)

                    await execPromise(`ffmpeg -i ${filepath}/${filename} -i ${filepath}/caption.png -filter_complex "[0:v][1:v]overlay=x=0:y=0:format=auto,split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ${findpreset(args)} -gifflags -offsetting ${filepath}/output.gif`)
                    await sendFile(msg, filepath, `output.gif`)
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "meme5/inspiration \"{text}\" <file> [-size <multiplier (from 0.5 to 5)>]",
                "value": "Adds a centered inspirational text to the file."
            },
            cooldown: 2500,
            type: "Captions"
        },

        {
            name: ["tord", "tordenask", "tordenaskwatermark"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
                var fileinfo = await validateFile(currenturl).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })

                if (!fileinfo) return
                var type = fileinfo.type

                if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                    var filepath = await downloadFile(currenturl, `input.png`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.png`
                    var width = fileinfo.info.width
                    var height = fileinfo.info.height

                    await execPromise(`ffmpeg -i ${filepath}/${filename} -i templates/tordenask.png -filter_complex "[1:v]scale=${width}/1.5:-1[tord];[0:v][tord]overlay=x=0:y=H-h:format=auto[out]" -map "[out]" -preset ${findpreset(args)} ${filepath}/output.png`)
                    await sendFile(msg, filepath, `output.png`)
                } else if (type.mime.startsWith('video')) {
                    var filepath = await downloadFile(currenturl, `input.mp4`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp4`
                    var width = fileinfo.info.width
                    var height = fileinfo.info.height

                    await execPromise(`ffmpeg -i ${filepath}/${filename} -i templates/tordenask.png -map 0:a? -filter_complex "[1:v]scale=${width}/1.5:-1[tord];[0:v][tord]overlay=x=0:y=H-h:format=auto[oout];[oout]scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ${findpreset(args)} -c:v libx264 -pix_fmt yuv420p ${filepath}/output.mp4`)
                    await sendFile(msg, filepath, `output.mp4`)
                } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                    var filepath = await downloadFile(currenturl, `input.gif`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.gif`
                    var width = fileinfo.info.width
                    var height = fileinfo.info.height

                    await execPromise(`ffmpeg -i ${filepath}/${filename} -i templates/tordenask.png -filter_complex "[1:v]scale=${width}/1.5:-1[tord];[0:v][tord]overlay=x=0:y=H-h:format=auto[oout];[oout]split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ${findpreset(args)} -gifflags -offsetting ${filepath}/output.gif`)
                    await sendFile(msg, filepath, `output.gif`)
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "tord/tordenask/tordenaskwatermark <file>",
                "value": "Applies the Tordenask Watermark to the file. https://gizmo.moe/profile?user=2"
            },
            cooldown: 2500,
            type: "Inside Joke"
        },

        {
            name: ["idfsgs"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
                var fileinfo = await validateFile(currenturl).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })

                if (!fileinfo) return
                var type = fileinfo.type

                if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                    var filepath = await downloadFile(currenturl, `input.png`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.png`
                    var width = fileinfo.info.width
                    var height = fileinfo.info.height

                    await execPromise(`ffmpeg -i ${filepath}/${filename} -i templates/idfsgs.png -filter_complex "[1:v]scale=${width}/1.5:-1,rotate=-3*PI/180:c=0x00000000[idfsgs];[0:v][idfsgs]overlay=x=0:y=0:format=auto[out]" -map "[out]" -preset ${findpreset(args)} ${filepath}/output.png`)
                    await sendFile(msg, filepath, `output.png`)
                } else if (type.mime.startsWith('video')) {
                    var filepath = await downloadFile(currenturl, `input.mp4`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp4`
                    var width = fileinfo.info.width
                    var height = fileinfo.info.height

                    await execPromise(`ffmpeg -i ${filepath}/${filename} -i templates/idfsgs.png -map 0:a? -filter_complex "[1:v]scale=${width}/1.5:-1,rotate=-3*PI/180:c=0x00000000[idfsgs];[0:v][idfsgs]overlay=x=0:y=0:format=auto[oout];[oout]scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ${findpreset(args)} -c:v libx264 -pix_fmt yuv420p ${filepath}/output.mp4`)
                    await sendFile(msg, filepath, `output.mp4`)
                } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                    var filepath = await downloadFile(currenturl, `input.gif`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.gif`
                    var width = fileinfo.info.width
                    var height = fileinfo.info.height

                    await execPromise(`ffmpeg -i ${filepath}/${filename} -i templates/idfsgs.png -filter_complex "[1:v]scale=${width}/1.5:-1,rotate=-3*PI/180:c=0x00000000[idfsgs];[0:v][idfsgs]overlay=x=0:y=0:format=auto[oout];[oout]split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ${findpreset(args)} -gifflags -offsetting ${filepath}/output.gif`)
                    await sendFile(msg, filepath, `output.gif`)
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "idfsgs <file>",
                "value": "Applies the IDFSGS Logo to the file."
            },
            cooldown: 2500,
            type: "Inside Joke"
        },

        {
            name: ["install", "installnow"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
                var fileinfo = await validateFile(currenturl).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })

                if (!fileinfo) return
                var type = fileinfo.type

                if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                    var filepath = await downloadFile(currenturl, `input.png`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.png`
                    var width = fileinfo.info.width
                    var height = fileinfo.info.height

                    await execPromise(`ffmpeg -i ${filepath}/${filename} -i templates/install.png -i templates/transparent.png -filter_complex "[1:v]scale=${width}:-1[install];[2:v][install]scale2ref=h=ih+${height}[transparent][install2];[transparent][0:v]overlay=x=0:y=0:format=auto[fout];[fout][install2]overlay=x=0:y=${height}:format=auto[out]" -map "[out]" -preset ${findpreset(args)} ${filepath}/output.png`)
                    await sendFile(msg, filepath, `output.png`)
                } else if (type.mime.startsWith('video')) {
                    var filepath = await downloadFile(currenturl, `input.mp4`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp4`
                    var width = fileinfo.info.width
                    var height = fileinfo.info.height

                    await execPromise(`ffmpeg -i templates/install.png -filter_complex "[0:v]scale=${width}:-1[install]" -map "[install]" ${filepath}/install.png`)
                    var bscale = await execPromise(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 ${filepath}/install.png`)
                    bscale = bscale.replace(/\n|\r/g, '').split('x')
                    var bheight = Number(bscale[1])

                    await execPromise(`ffmpeg -i ${filepath}/${filename} -i ${filepath}/install.png -i templates/transparent.png -map 0:a? -filter_complex "[2:v][1:v]scale2ref=h=ih+${height}[transparent][install2];[transparent][0:v]overlay=x=0:y=0:format=auto[fout];[fout][install2]overlay=x=0:y=${height}:format=auto[oout];[oout]scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ${findpreset(args)} -aspect ${width}:${height + bheight} -c:v libx264 -pix_fmt yuv420p ${filepath}/output.mp4`)
                    await sendFile(msg, filepath, `output.mp4`)
                } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                    var filepath = await downloadFile(currenturl, `input.gif`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.gif`
                    var width = fileinfo.info.width
                    var height = fileinfo.info.height

                    await execPromise(`ffmpeg -i templates/install.png -filter_complex "[0:v]scale=${width}:-1[install]" -map "[install]" ${filepath}/install.png`)
                    var bscale = await execPromise(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 ${filepath}/install.png`)
                    bscale = bscale.replace(/\n|\r/g, '').split('x')
                    var bheight = Number(bscale[1])

                    await execPromise(`ffmpeg -i ${filepath}/${filename} -i templates/install.png -i templates/transparent.png -filter_complex "[2:v][1:v]scale2ref=h=ih+${height}[transparent][install2];[transparent][0:v]overlay=x=0:y=0:format=auto[fout];[fout][install2]overlay=x=0:y=${height}:format=auto[oout];[oout]split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ${findpreset(args)} -aspect ${width}:${height + bheight} -gifflags -offsetting ${filepath}/output.gif`)
                    await sendFile(msg, filepath, `output.gif`)
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "install/installnow <file>",
                "value": "Install Now"
            },
            cooldown: 2500,
            type: "Memes"
        },

        {
            name: ["reddit"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var saidMessage = args.join(' ').substring(args[0].length + 1)
                symbolreplacements.forEach(symbolReplacement => {
                    symbolReplacement.target.forEach(target => {
                        saidMessage = saidMessage.replace(new RegExp(target, 'ig'), symbolReplacement.replacement)
                    })
                })
                var matchedTextes = saidMessage.match(/"([\s\S]*?)"/)
                if (!matchedTextes) {
                    matchedTextes = ['""', '']
                }
                var text = matchedTextes[1]
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
                var fileinfo = await validateFile(currenturl).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })

                if (!fileinfo) return
                var type = fileinfo.type

                if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                    var filepath = await downloadFile(currenturl, `input.png`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.png`

                    var reddittop = await Jimp.read(`templates/reddittop.png`)
                    var ibm = await Jimp.loadFont(`templates/fonts/IBMPlexSans/IBMPlexSans.fnt`)
                    await reddittop.print(ibm, 18, 315, { text: Discord.Util.cleanContent(text, msg), alignmentX: Jimp.HORIZONTAL_ALIGN_LEFT, alignmentY: Jimp.VERTICAL_ALIGN_MIDDLE }, 364, 66)
                    await reddittop.writeAsync(`${filepath}/top.png`)

                    await execPromise(`ffmpeg -i ${filepath}/${filename} -filter_complex "[0:v]scale=${reddittop.bitmap.width}:-1[out]" -map "[out]" -preset ${findpreset(args)} ${filepath}/scaled.png`)
                    await execPromise(`ffmpeg -i ${filepath}/top.png -i ${filepath}/scaled.png -i templates/redditbottom.png -i templates/redditbg.png -filter_complex "vstack=inputs=3[transparent];[3:v][transparent]scale2ref[bg][transparent2];[bg][transparent2]overlay=x=0:y=0:format=auto[out]" -map "[out]" -preset ${findpreset(args)} ${filepath}/output.png`)
                    await sendFile(msg, filepath, `output.png`)
                } else if (type.mime.startsWith('video')) {
                    var filepath = await downloadFile(currenturl, `input.mp4`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp4`

                    var reddittop = await Jimp.read(`templates/reddittop.png`)
                    var redditbottom = await Jimp.read(`templates/redditbottom.png`)
                    var ibm = await Jimp.loadFont(`templates/fonts/IBMPlexSans/IBMPlexSans.fnt`)
                    await reddittop.print(ibm, 18, 315, { text: Discord.Util.cleanContent(text, msg), alignmentX: Jimp.HORIZONTAL_ALIGN_LEFT, alignmentY: Jimp.VERTICAL_ALIGN_MIDDLE }, 364, 66)
                    await reddittop.writeAsync(`${filepath}/top.png`)

                    var fps = fileinfo.info.fps

                    await execPromise(`ffmpeg -r ${fps.includes('0/0') ? '50' : fps} -i ${filepath}/${filename} -map 0:a? -filter_complex "[0:v]scale=${reddittop.bitmap.width}:-1,scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ${findpreset(args)} -c:v libx264 -pix_fmt yuv420p ${filepath}/scaled.mp4`)
                    var scale = await execPromise(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 ${filepath}/scaled.mp4`)
                    scale = scale.replace(/\n|\r/g, '').split('x')
                    var width = Number(scale[0])
                    var height = Number(scale[1])

                    await execPromise(`ffmpeg -r ${fps.includes('0/0') ? '50' : fps} -i ${filepath}/top.png -r ${fps.includes('0/0') ? '50' : fps} -i ${filepath}/scaled.mp4 -r ${fps.includes('0/0') ? '50' : fps} -i templates/redditbottom.png -i templates/redditbg.png -map 1:a? -filter_complex "vstack=inputs=3[transparent];[3:v][transparent]scale2ref[bg][transparent2];[bg][transparent2]overlay=x=0:y=0:format=auto[oout];[oout]scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ${findpreset(args)} -aspect ${width}:${reddittop.bitmap.height + height + redditbottom.bitmap.height} -c:v libx264 -pix_fmt yuv420p ${filepath}/output.mp4`)
                    await sendFile(msg, filepath, `output.mp4`)
                } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                    var filepath = await downloadFile(currenturl, `input.gif`)
                    var filename = `input.gif`

                    var reddittop = await Jimp.read(`templates/reddittop.png`)
                    var ibm = await Jimp.loadFont(`templates/fonts/IBMPlexSans/IBMPlexSans.fnt`)
                    await reddittop.print(ibm, 18, 315, { text: Discord.Util.cleanContent(text, msg), alignmentX: Jimp.HORIZONTAL_ALIGN_LEFT, alignmentY: Jimp.VERTICAL_ALIGN_MIDDLE }, 364, 66)
                    await reddittop.writeAsync(`${filepath}/top.png`)

                    var fps = fileinfo.info.fps

                    await execPromise(`ffmpeg -r ${fps.includes('0/0') ? '50' : fps} -i ${filepath}/${filename} -filter_complex "[0:v]scale=${reddittop.bitmap.width}:-1,split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ${findpreset(args)} -gifflags -offsetting ${filepath}/scaled.gif`)
                    var scale = await execPromise(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 ${filepath}/scaled.gif`)
                    scale = scale.replace(/\n|\r/g, '').split('x')
                    var width = Number(scale[0])
                    var height = Number(scale[1])

                    await execPromise(`ffmpeg -r ${fps.includes('0/0') ? '50' : fps} -i ${filepath}/top.png -r ${fps.includes('0/0') ? '50' : fps} -i ${filepath}/scaled.gif -r ${fps.includes('0/0') ? '50' : fps} -i templates/redditbottom.png -i templates/redditbg.png -filter_complex "vstack=inputs=3[transparent];[3:v][transparent]scale2ref[bg][transparent2];[bg][transparent2]overlay=x=0:y=0:format=auto[oout];[oout]split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ${findpreset(args)} -aspect ${width}:${reddittop.bitmap.height + height + redditbottom.bitmap.height} -gifflags -offsetting ${filepath}/output.gif`)
                    await sendFile(msg, filepath, `output.gif`)
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "reddit {name} <file>",
                "value": "The kind stranger has arrived."
            },
            cooldown: 2500,
            type: "Memes"
        },

        {
            name: ["emotegame", "emote"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
                var fileinfo = await validateFile(currenturl).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })

                if (!fileinfo) return
                var type = fileinfo.type

                if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                    var filepath = await downloadFile(currenturl, `input.png`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.png`
                    var width = fileinfo.info.width

                    await execPromise(`ffmpeg -i ${filepath}/${filename} -i templates/emote.png -filter_complex "[1:v]scale=${width}/2.5:-1,rotate=-5*PI/180:ow=rotw(-5*PI/180):oh=roth(-5*PI/180):c=0x00000000[emote];[0:v][emote]overlay=x=w/20:y=h/20:format=auto[out]" -map "[out]" -preset ${findpreset(args)} ${filepath}/output.png`)
                    await sendFile(msg, filepath, `output.png`)
                } else if (type.mime.startsWith('video')) {
                    var filepath = await downloadFile(currenturl, `input.mp4`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp4`
                    var width = fileinfo.info.width

                    await execPromise(`ffmpeg -i ${filepath}/${filename} -i templates/emote.png -map 0:a? -filter_complex "[1:v]scale=${width}/2.5:-1,rotate=-5*PI/180:ow=rotw(-5*PI/180):oh=roth(-5*PI/180):c=0x00000000[emote];[0:v][emote]overlay=x=w/20:y=h/20:format=auto[oout];[oout]scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ${findpreset(args)} -c:v libx264 -pix_fmt yuv420p ${filepath}/output.mp4`)
                    await sendFile(msg, filepath, `output.mp4`)
                } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                    var filepath = await downloadFile(currenturl, `input.gif`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.gif`
                    var width = fileinfo.info.width

                    await execPromise(`ffmpeg -i ${filepath}/${filename} -i templates/emote.png -filter_complex "[1:v]scale=${width}/2.5:-1,rotate=-5*PI/180:ow=rotw(-5*PI/180):oh=roth(-5*PI/180):c=0x00000000[emote];[0:v][emote]overlay=x=w/20:y=h/20:format=auto[oout];[oout]split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ${findpreset(args)} -gifflags -offsetting ${filepath}/output.gif`)
                    await sendFile(msg, filepath, `output.gif`)
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "emotegame/emote <file>",
                "value": "Applies the Emote Game Logo to the file."
            },
            cooldown: 2500,
            type: "Inside Joke"
        },

        /*{
            name: ["removebg", "removebackground"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
                var fileinfo = await validateFile(currenturl).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })
        
                if (!fileinfo) return
                var type = fileinfo.type
        
                if (type.mime.startsWith('image')) {
                    var currentcount = filecount
                    filecount++
                    fs.mkdirSync(`${filepath}`)
        
                    await waitForChromeSessionEnd(msg)
                    var driver = await new Builder().forBrowser('chrome').setChromeOptions(new chrome.Options().setUserPreferences({ "download.default_directory": testing ? `${__dirname}\\temp\\file${currentcount}` : `${__dirname.replace(/\\/g, '/')}/${filepath}` })).build().catch(() => { })
                    chromeWindow = driver
                    await driver.get('https://www.remove.bg/').catch(() => { })
                    await sleep(5000)
                    driver.executeScript(`window.uploadUrl('${currenturl}')`)
                    await sleep(5000)
                    var downloads = await driver.findElements(By.css('.btn-download')).catch(() => { })
                    if (!downloads[0]) {
                        await driver.quit().catch(() => { })
                        chromeWindow = false
                        fs.rmSync(`${filepath}`, { force: true, recursive: true })
                        msg.channel.send('i got owned by the captcha').catch(() => { })
                        await sleep(3000)
                        msg.channel.send('maybe try using removebg2').catch(() => { })
                        msg.channel.sendTyping().catch(() => { })
                        return
                    }
                    await downloads[0].click().catch(() => { })
                    await sleep(5000)
                    await driver.quit().catch(() => { })
                    chromeWindow = false
                    var files = fs.readdirSync(`${filepath}`)
                    var file = files.find(f => f.includes('removebg'))
                    try {
                        fs.renameSync(`${filepath}/${file}`, `${filepath}/output.png`)
                    } catch (_) {
                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                        msg.channel.sendTyping().catch(() => { })
                        fs.rmSync(`${filepath}`, { force: true, recursive: true })
                        return
                    }
                    var fileMsg = await msg.channel.send({
                        files: [new Discord.MessageAttachment(`${filepath}/output.png`)]
                    }).catch(() => { })
                    if (!fileMsg) {
                        await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                        var fileLink = await Catbox.upload(`${filepath}/output.png`).catch(() => { })
                        if (fileLink) {
                            var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                            if (!fileLinkMsg) {
                                await msg.channel.send('Couldn\'t send file.').catch(() => { })
                            }
                        } else {
                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                        }
                    }
                    msg.channel.sendTyping().catch(() => { })
                    fs.rmSync(`${filepath}`, { force: true, recursive: true })
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "removebg/removebackground <image>",
                "value": "Removes an image's background with remove.bg, but with no limits. **THIS MIGHT NOT WORK MOST OF THE TIME.**"
            },
            cooldown: 2500,
            type: "Manipulation"
        },*/

        {
            name: ["removebg", "removebackground"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
                var fileinfo = await validateFile(currenturl).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })

                if (!fileinfo) return
                var type = fileinfo.type

                if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                    /*var res = await axios.request({
                        method: 'GET',
                        url: 'https://api.remove.bg/v1.0/account',
                        headers: {
                            'X-Api-Key': randomKey('REMOVEBGKEY')
                        }
                    })

                    var body = res.data
                    var free_calls = Number(body.data.attributes.api.free_calls)*/

                    var filepath = await downloadFile(currenturl, `input.png`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.png`

                    var response = await execPromise(`cd ${filepath} && removebg --api-key ${randomKey('REMOVEBGKEY')} ${filename}`)
                    var level = response.match(/level=[^ ]+/)[0].substring(6)

                    if (level === 'error') {
                        var m = response.match(/msg="([\s\S]*?)"/)[0].substring(4)
                        m = m.substring(1, m.length - 1)
                        var code = m.match(/\d+/)
                        m = m.replace(/\d+: /, '')

                        msg.channel.send(m + (code == 402 ? '. You can go to https://www.remove.bg/ and upload an image manually though.' : '')).catch(() => { })
                        msg.channel.sendTyping().catch(() => { })
                        fs.rmSync(`${filepath}`, { force: true, recursive: true })
                        return
                    };

                    try {
                        fs.renameSync(`${filepath}/input-removebg.png`, `${filepath}/output.png`)
                    } catch (_) {
                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                        msg.channel.sendTyping().catch(() => { })
                        fs.rmSync(`${filepath}`, { force: true, recursive: true })
                        return
                    }
                    await sendFile(msg, filepath, `output.png`/*, {
                        content: `Available command usages: **${free_calls - 1}**`
                    }*/)
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "removebg/removebackground <image>",
                "value": "Removes an image's background with remove.bg. It has limits though."
            },
            cooldown: 2500,
            type: "Effects"
        },

        {
            name: ["backrooms", "backroom"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
                var fileinfo = await validateFile(currenturl).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })

                if (!fileinfo) return
                var type = fileinfo.type

                if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                    var filepath = await downloadFile(currenturl, `input.png`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.png`

                    var width = fileinfo.info.width
                    var height = fileinfo.info.height
                    var bscale = await execPromise(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 templates/backrooms.png`)
                    bscale = bscale.replace(/\n|\r/g, '').split('x')
                    var bheight = Number(bscale[1])
                    var squareS = { value: ((height === width) && width) || ((height > width) && height) || width, constraint: ((height === width) && 'both') || ((height > width) && 'height') || 'width' }

                    await execPromise(`ffmpeg -i ${filepath}/${filename} -i templates/backrooms.png -filter_complex "[0:v]scale=${squareS.constraint === 'width' || squareS.constraint === 'both' ? bheight / 6 : -1}:${squareS.constraint === 'height' || squareS.constraint === 'both' ? bheight / 6 : -1}[frame];[1:v][frame]overlay=x=68-(w/2):y=203-h:format=auto[out]" -map "[out]" -preset ${findpreset(args)} ${filepath}/output.png`)
                    await sendFile(msg, filepath, `output.png`)
                } else if (type.mime.startsWith('video')) {
                    var filepath = await downloadFile(currenturl, `input.mp4`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp4`

                    var width = fileinfo.info.width
                    var height = fileinfo.info.height
                    var bscale = await execPromise(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 templates/backrooms.png`)
                    bscale = bscale.replace(/\n|\r/g, '').split('x')
                    var bheight = Number(bscale[1])
                    var squareS = { value: ((height === width) && width) || ((height > width) && height) || width, constraint: ((height === width) && 'both') || ((height > width) && 'height') || 'width' }

                    await execPromise(`ffmpeg -i ${filepath}/${filename} -i templates/backrooms.png -map 0:a? -filter_complex "[0:v]scale=${squareS.constraint === 'width' || squareS.constraint === 'both' ? bheight / 6 : -1}:${squareS.constraint === 'height' || squareS.constraint === 'both' ? bheight / 6 : -1}[frame];[1:v][frame]overlay=x=68-(w/2):y=203-h:format=auto[oout];[oout]scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ${findpreset(args)} -c:v libx264 -pix_fmt yuv420p ${filepath}/output.mp4`)
                    await sendFile(msg, filepath, `output.mp4`)
                } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                    var filepath = await downloadFile(currenturl, `input.gif`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.gif`
                    var width = fileinfo.info.width
                    var height = fileinfo.info.height
                    var bscale = await execPromise(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 templates/backrooms.png`)
                    bscale = bscale.replace(/\n|\r/g, '').split('x')
                    var bheight = Number(bscale[1])
                    var squareS = { value: ((height === width) && width) || ((height > width) && height) || width, constraint: ((height === width) && 'both') || ((height > width) && 'height') || 'width' }

                    await execPromise(`ffmpeg -i ${filepath}/${filename} -i templates/backrooms.png -filter_complex "[0:v]scale=${squareS.constraint === 'width' || squareS.constraint === 'both' ? bheight / 6 : -1}:${squareS.constraint === 'height' || squareS.constraint === 'both' ? bheight / 6 : -1}[frame];[1:v][frame]overlay=x=68-(w/2):y=203-h:format=auto[oout];[oout]split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ${findpreset(args)} -gifflags -offsetting ${filepath}/output.gif`)
                    await sendFile(msg, filepath, `output.gif`)
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "backrooms/backroom <file>",
                "value": "the arrival"
            },
            cooldown: 2500,
            type: "Memes"
        },

        {
            name: ["higherpitch", "increasepitch"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[2] === undefined) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl']
                var speed = isNaN(Number(args[1])) ? 2 : Number(args[1]) <= 1 ? 1 : Number(args[1]) >= 6 ? 6 : Number(args[1]) || 2
                var smult = speed
                var speedfilter = []

                while (smult > 2) {
                    smult /= 2
                    speedfilter.push(`atempo=0.5`)
                }

                speedfilter.push(`atempo=(1/${smult})`)

                var fileinfo = await validateFile(currenturl).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })

                if (!fileinfo) return
                var type = fileinfo.type

                if (type.mime.startsWith('video')) {
                    var filepath = await downloadFile(currenturl, `input.mp4`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp4`
                    var audio = fileinfo.info.audio

                    if (audio) {
                        await execPromise(`ffmpeg -i ${filepath}/${filename} -filter_complex "[0:v]scale=ceil(iw/2)*2:ceil(ih/2)*2[v];[0:a]aresample=44100,asetrate=44100*${speed},aresample=44100,${speedfilter.join(',')}[a]" -map "[v]" -map "[a]" -preset ${findpreset(args)} -c:v libx264 -pix_fmt yuv420p ${filepath}/output.mp4`)
                        await sendFile(msg, filepath, `output.mp4`)
                    } else {
                        await msg.channel.send('No audio stream detected.').catch(() => { })
                        msg.channel.sendTyping().catch(() => { })
                        fs.rmSync(`${filepath}`, { force: true, recursive: true })
                    }
                } else if (type.mime.startsWith('audio')) {
                    var filepath = await downloadFile(currenturl, `input.mp3`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp3`
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -filter_complex "[0:a]aresample=44100,asetrate=44100*${speed},aresample=44100,${speedfilter.join(',')}[a]" -map "[a]" -preset ${findpreset(args)} ${filepath}/output.mp3`)
                    await sendFile(msg, filepath, `output.mp3`)
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "higherpitch/increasepitch [multiplier <number (from 1 to 6)>] <video/audio>",
                "value": "Increases the video's pitch. Default is 2."
            },
            cooldown: 2500,
            type: "Audio"
        },

        {
            name: ["speedpitch"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[2] === undefined) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl']
                var speed = isNaN(Number(args[1])) ? 2 : Number(args[1]) <= 1 ? 1 : Number(args[1]) >= 6 ? 6 : Number(args[1]) || 2
                var fileinfo = await validateFile(currenturl, true).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })

                if (!fileinfo) return
                var type = fileinfo.type

                if (type.mime.startsWith('video')) {
                    var audio = fileinfo.info.audio

                    if (audio) {
                        var filepath = await downloadFile(currenturl, `input.mp4`, {
                            fileinfo: fileinfo
                        })
                        var filename = `input.mp4`
                        var fps = fileinfo.info.fps

                        await execPromise(`ffmpeg -i ${filepath}/${filename} -filter_complex "[0:v]fps=fps='min(60,${fps.includes('0/0') ? '60' : fps}*${speed})',setpts=(1/${speed})*PTS,scale=ceil(iw/2)*2:ceil(ih/2)*2[v];[0:a]aresample=44100,asetrate=44100*${speed},aresample=44100[a]" -map "[v]" -map "[a]" -preset ${findpreset(args)} -c:v libx264 -pix_fmt yuv420p ${filepath}/output.mp4`)
                        await sendFile(msg, filepath, `output.mp4`)
                    } else {
                        msg.channel.send({
                            content: `File has no audio stream, maybe you should just use \`speedup\` for that.`,
                            allowedMentions: {
                                parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                            }
                        }).catch(() => { })
                        msg.channel.sendTyping().catch(() => { })
                    }
                } else if (type.mime.startsWith('audio')) {
                    var filepath = await downloadFile(currenturl, `input.mp3`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp3`
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -filter_complex "[0:a]aresample=44100,asetrate=44100*${speed},aresample=44100[a]" -map "[a]" -preset ${findpreset(args)} ${filepath}/output.mp3`)
                    await sendFile(msg, filepath, `output.mp3`)
                } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                    msg.channel.send({
                        content: `Maybe you should just use \`speedup\` for that.`,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "speedpitch [multiplier <number (from 1 to 6)>] <video/audio>",
                "value": "Speeds up the file while also increasing its pitch."
            },
            cooldown: 2500,
            type: "Audio"
        },

        {
            name: ["gradualspeedpitch"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[2] === undefined) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl']
                var speed = isNaN(Number(args[1])) ? 2 : Number(args[1]) <= 1 ? 1 : Number(args[1]) >= 6 ? 6 : Number(args[1]) || 2
                var gradual = []
                var n = 100
                var fileinfo = await validateFile(currenturl, true).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })

                if (!fileinfo) return
                var type = fileinfo.type

                if (type.mime.startsWith('video')) {
                    var audio = fileinfo.info.audio

                    if (audio) {
                        var filepath = await downloadFile(currenturl, `input.mp4`, {
                            fileinfo: fileinfo
                        })
                        var filename = `input.mp4`
                        var fps = fileinfo.info.fps
                        var duration = Number(fileinfo.info.duration.includes('N/A') ? '0' : fileinfo.info.duration)
                        var aduration = Number(fileinfo.info.aduration.includes('N/A') ? '0' : fileinfo.info.aduration)
                        var ratio = aduration / duration
                        var total = 0
                        var f = duration / n
                        var ptsvalue = '{next}'

                        for (var i = 0; i < n; i++) {
                            var a = i / (n - 1)
                            var a2 = i / n
                            var a3 = (i + 1) / n
                            var start = duration * a2
                            var end = start + f
                            total += f / Math.lerp(1, speed, a)
                            gradual.push({
                                audio: `[ga${i + 1}]`,
                                filter: `[0:a]atrim=${start}:${end}${i != 0 ? `,aresample=44100,asetrate='44100*${Math.lerp(1, speed, a)}',aresample=44100` : ''}[ga${i + 1}]`,
                                pts: i == (n - 1) ? speed : `if(lt(T/${duration},${a3}),${Math.lerp(1, speed, a)},{next})`
                            })
                        }

                        for (var i in gradual) {
                            var grad = gradual[i]
                            ptsvalue = ptsvalue.replace('{next}', grad.pts)
                        }

                        await execPromise(`ffmpeg -i ${filepath}/${filename} -filter_complex "[0:v]fps=fps='min(60,${fps.includes('0/0') ? '60' : fps}*${speed})',setpts='(1/lerp(1,${speed},T/${duration}))*PTS'[v];${gradual.map(g => g.filter).join(';')};${gradual.map(g => g.audio).join('')}concat=n=${n}:a=1:v=0,atempo[a]" -map "[v]" -map "[a]" -preset ${findpreset(args)} -c:v libx264 -pix_fmt yuv420p ${filepath}/gradual.mp4`)
                        var gradualinfo = await validateFileFromPath(`${filepath}/gradual.mp4`, 'very true').catch(() => { })
                        if (!gradualinfo) {
                            await msg.channel.send('Error while processing initial effect.').catch(() => { })
                            msg.channel.sendTyping().catch(() => { })
                            fs.rmSync(`${filepath}`, { force: true, recursive: true })
                            return
                        }
                        var gduration = gradualinfo.info.duration
                        var gaduration = gradualinfo.info.aduration
                        await execPromise(`ffmpeg -i ${filepath}/gradual.mp4 -filter_complex "[0:v]setpts=PTS/(${Number(gduration)}/${Number(gaduration)})/${ratio}[v]" -map "[v]" -map 0:a -preset ${findpreset(args)} -c:v libx264 -pix_fmt yuv420p ${filepath}/output.mp4`)
                        await sendFile(msg, filepath, `output.mp4`)
                    } else {
                        msg.channel.send({
                            content: `File has no audio stream, maybe you should just use \`gradualspeedup\` for that.`,
                            allowedMentions: {
                                parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                            }
                        }).catch(() => { })
                        msg.channel.sendTyping().catch(() => { })
                    }
                } else if (type.mime.startsWith('audio')) {
                    var filepath = await downloadFile(currenturl, `input.mp3`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp3`
                    var duration = Number(fileinfo.info.duration.includes('N/A') ? '0' : fileinfo.info.duration)

                    var f = duration / n

                    for (var i = 0; i < n; i++) {
                        var a = i / (n - 1)
                        var a2 = i / n
                        var start = duration * a2
                        var end = start + f
                        gradual.push({
                            audio: `[ga${i + 1}]`,
                            filter: `[0:a]atrim=${start}:${end}${i != 0 ? `,aresample=44100,asetrate='44100*${Math.lerp(1, speed, a)}',aresample=44100` : ''}[ga${i + 1}]`
                        })
                    }

                    await execPromise(`ffmpeg -i ${filepath}/${filename} -filter_complex "${gradual.map(g => g.filter).join(';')};${gradual.map(g => g.audio).join('')}concat=n=${n}:a=1:v=0,atempo[a]" -map "[a]" -preset ${findpreset(args)} ${filepath}/output.mp3`)
                    await sendFile(msg, filepath, `output.mp3`)
                } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                    msg.channel.send({
                        content: `Maybe you should just use \`gradualspeedup\` for that.`,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "gradualspeedpitch [multiplier <number (from 1 to 6)>] <video/audio>",
                "value": "Gradually speeds up the file while also increasing its pitch until the end."
            },
            cooldown: 2500,
            type: "Audio"
        },

        {
            name: ["gradualslowpitch"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[2] === undefined) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl']
                var speed = isNaN(Number(args[1])) ? 2 : Number(args[1]) <= 1 ? 1 : Number(args[1]) >= 6 ? 6 : Number(args[1]) || 2
                var gradual = []
                var n = 100
                var fileinfo = await validateFile(currenturl).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })

                if (!fileinfo) return
                var type = fileinfo.type

                if (type.mime.startsWith('video')) {
                    var audio = fileinfo.info.audio

                    if (audio) {
                        var filepath = await downloadFile(currenturl, `input.mp4`, {
                            fileinfo: fileinfo
                        })
                        var filename = `input.mp4`
                        var fps = fileinfo.info.fps
                        var duration = Number(fileinfo.info.duration.includes('N/A') ? '0' : fileinfo.info.duration)
                        var aduration = Number(fileinfo.info.aduration.includes('N/A') ? '0' : fileinfo.info.aduration)
                        var ratio = aduration / duration
                        var total = 0
                        var f = duration / n
                        var ptsvalue = '{next}'

                        for (var i = 0; i < n; i++) {
                            var a = i / (n - 1)
                            var a2 = i / n
                            var a3 = (i + 1) / n
                            var start = duration * a2
                            var end = start + f
                            total += f * Math.lerp(1, speed, a)
                            gradual.push({
                                audio: `[ga${i + 1}]`,
                                filter: `[0:a]atrim=${start}:${end}${i != 0 ? `,aresample=44100,asetrate='44100/${Math.lerp(1, speed, a)}',aresample=44100` : ''}[ga${i + 1}]`,
                                pts: i == (n - 1) ? speed : `if(lt(T/${duration},${a3}),${Math.lerp(1, speed, a)},{next})`
                            })
                        }

                        for (var i in gradual) {
                            var grad = gradual[i]
                            ptsvalue = ptsvalue.replace('{next}', grad.pts)
                        }

                        await execPromise(`ffmpeg -i ${filepath}/${filename} -filter_complex "[0:v]setpts='lerp(1,${speed},T/${duration})*PTS'[v];${gradual.map(g => g.filter).join(';')};${gradual.map(g => g.audio).join('')}concat=n=${n}:a=1:v=0,atempo[a]" -map "[v]" -map "[a]" -preset ${findpreset(args)} -c:v libx264 -pix_fmt yuv420p ${filepath}/gradual.mp4`)
                        var gradualinfo = await validateFileFromPath(`${filepath}/gradual.mp4`, 'very true').catch(() => { })
                        if (!gradualinfo) {
                            await msg.channel.send('Error while processing initial effect.').catch(() => { })
                            msg.channel.sendTyping().catch(() => { })
                            fs.rmSync(`${filepath}`, { force: true, recursive: true })
                            return
                        }
                        var gduration = gradualinfo.info.duration
                        var gaduration = gradualinfo.info.aduration
                        await execPromise(`ffmpeg -i ${filepath}/gradual.mp4 -filter_complex "[0:v]setpts=PTS/(${Number(gduration)}/${Number(gaduration)})/${ratio}[v]" -map "[v]" -map 0:a -preset ${findpreset(args)} -c:v libx264 -pix_fmt yuv420p ${filepath}/output.mp4`)
                        await sendFile(msg, filepath, `output.mp4`)
                    } else {
                        msg.channel.send({
                            content: `File has no audio stream, maybe you should just use \`gradualslowdown\` for that.`,
                            allowedMentions: {
                                parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                            }
                        }).catch(() => { })
                        msg.channel.sendTyping().catch(() => { })
                    }
                } else if (type.mime.startsWith('audio')) {
                    var filepath = await downloadFile(currenturl, `input.mp3`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp3`
                    var duration = Number(fileinfo.info.duration.includes('N/A') ? '0' : fileinfo.info.duration)

                    var f = duration / n

                    for (var i = 0; i < n; i++) {
                        var a = i / (n - 1)
                        var a2 = i / n
                        var start = duration * a2
                        var end = start + f
                        gradual.push({
                            audio: `[ga${i + 1}]`,
                            filter: `[0:a]atrim=${start}:${end}${i != 0 ? `,aresample=44100,asetrate='44100/${Math.lerp(1, speed, a)}',aresample=44100` : ''}[ga${i + 1}]`
                        })
                    }

                    await execPromise(`ffmpeg -i ${filepath}/${filename} -filter_complex "${gradual.map(g => g.filter).join(';')};${gradual.map(g => g.audio).join('')}concat=n=${n}:a=1:v=0,atempo[a]" -map "[a]" -preset ${findpreset(args)} ${filepath}/output.mp3`)
                    await sendFile(msg, filepath, `output.mp3`)
                } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                    msg.channel.send({
                        content: `Maybe you should just use \`gradualslowdown\` for that.`,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "gradualslowpitch [multiplier <number (from 1 to 6)>] <video/audio>",
                "value": "Gradually slows down the file while also decreasing its pitch until the end."
            },
            cooldown: 2500,
            type: "Audio"
        },

        {
            name: ["gradualspeedup", "gradualspeed"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[2] === undefined) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl']
                var speed = isNaN(Number(args[1])) ? 2 : Number(args[1]) <= 1 ? 1 : Number(args[1]) >= 6 ? 6 : Number(args[1]) || 2
                var gradual = []
                var n = 100
                var fileinfo = await validateFile(currenturl, true).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })

                if (!fileinfo) return
                var type = fileinfo.type

                if (type.mime.startsWith('video')) {
                    var filepath = await downloadFile(currenturl, `input.mp4`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp4`
                    var audio = fileinfo.info.audio

                    if (audio) {
                        var fps = fileinfo.info.fps
                        var duration = Number(fileinfo.info.duration.includes('N/A') ? '0' : fileinfo.info.duration)
                        var aduration = Number(fileinfo.info.aduration.includes('N/A') ? '0' : fileinfo.info.aduration)
                        var ratio = aduration / duration
                        var total = 0
                        var f = duration / n
                        var ptsvalue = '{next}'

                        for (var i = 0; i < n; i++) {
                            var a = i / (n - 1)
                            var a2 = i / n
                            var a3 = (i + 1) / n
                            var start = duration * a2
                            var end = start + f
                            total += f / Math.lerp(1, speed, a)
                            gradual.push({
                                audio: `[ga${i + 1}]`,
                                filter: `[0:a]atrim=${start}:${end}${i != 0 ? `,atempo=${Math.lerp(1, speed, a)}` : ''}[ga${i + 1}]`,
                                pts: i == (n - 1) ? speed : `if(lt(T/${duration},${a3}),${Math.lerp(1, speed, a)},{next})`
                            })
                        }

                        for (var i in gradual) {
                            var grad = gradual[i]
                            ptsvalue = ptsvalue.replace('{next}', grad.pts)
                        }

                        await execPromise(`ffmpeg -i ${filepath}/${filename} -filter_complex "[0:v]fps=fps='min(60,${fps.includes('0/0') ? '60' : fps}*${speed})',setpts='(1/lerp(1,${speed},T/${duration}))*PTS'[v];${gradual.map(g => g.filter).join(';')};${gradual.map(g => g.audio).join('')}concat=n=${n}:a=1:v=0,atempo[a]" -map "[v]" -map "[a]" -preset ${findpreset(args)} -c:v libx264 -pix_fmt yuv420p ${filepath}/gradual.mp4`)
                        var gradualinfo = await validateFileFromPath(`${filepath}/gradual.mp4`, 'very true').catch(() => { })
                        if (!gradualinfo) {
                            await msg.channel.send('Error while processing initial effect.').catch(() => { })
                            msg.channel.sendTyping().catch(() => { })
                            fs.rmSync(`${filepath}`, { force: true, recursive: true })
                            return
                        }
                        var gduration = gradualinfo.info.duration
                        var gaduration = gradualinfo.info.aduration
                        await execPromise(`ffmpeg -i ${filepath}/gradual.mp4 -filter_complex "[0:v]setpts=PTS/(${Number(gduration)}/${Number(gaduration)})/${ratio}[v]" -map "[v]" -map 0:a -preset ${findpreset(args)} -c:v libx264 -pix_fmt yuv420p ${filepath}/output.mp4`)
                        await sendFile(msg, filepath, `output.mp4`)
                    } else {
                        var fps = fileinfo.info.fps
                        var duration = Number(fileinfo.info.duration.includes('N/A') ? '0' : fileinfo.info.duration)

                        await execPromise(`ffmpeg -i ${filepath}/${filename} -filter_complex "[0:v]fps=fps='min(60,${fps.includes('0/0') ? '60' : fps}*${speed})',setpts='(1/lerp(1,${speed},T/${duration}))*PTS'[v]" -map "[v]" -preset ${findpreset(args)} -c:v libx264 -pix_fmt yuv420p ${filepath}/output.mp4`)
                        await sendFile(msg, filepath, `output.mp4`)
                    }
                } else if (type.mime.startsWith('audio')) {
                    var filepath = await downloadFile(currenturl, `input.mp3`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp3`
                    var duration = Number(fileinfo.info.duration.includes('N/A') ? '0' : fileinfo.info.duration)

                    var f = duration / n

                    for (var i = 0; i < n; i++) {
                        var a = i / (n - 1)
                        var a2 = i / n
                        var start = duration * a2
                        var end = start + f
                        gradual.push({
                            audio: `[ga${i + 1}]`,
                            filter: `[0:a]atrim=${start}:${end}${i != 0 ? `,atempo=${Math.lerp(1, speed, a)}` : ''}[ga${i + 1}]`
                        })
                    }

                    await execPromise(`ffmpeg -i ${filepath}/${filename} -filter_complex "${gradual.map(g => g.filter).join(';')};${gradual.map(g => g.audio).join('')}concat=n=${n}:a=1:v=0,atempo[a]" -map "[a]" -preset ${findpreset(args)} ${filepath}/output.mp3`)
                    await sendFile(msg, filepath, `output.mp3`)
                } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                    var filepath = await downloadFile(currenturl, `input.gif`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.gif`
                    var fps = fileinfo.info.fps
                    var duration = Number(fileinfo.info.duration.includes('N/A') ? '0' : fileinfo.info.duration)

                    await execPromise(`ffmpeg -i ${filepath}/${filename} -filter_complex "[0:v]fps=fps='min(50,${fps.includes('0/0') ? '50' : fps}*${speed})',setpts='(1/lerp(1,${speed},T/${duration}))*PTS',split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ${findpreset(args)} -gifflags -offsetting ${filepath}/output.gif`)
                    await sendFile(msg, filepath, `output.gif`)
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "gradualspeedup/gradualspeed [multiplier <number (from 1 to 6)>] <video/audio>",
                "value": "Gradually speeds up the file until the end."
            },
            cooldown: 2500,
            type: "Duration"
        },

        {
            name: ["gradualslowdown", "gradualslow"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[2] === undefined) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl']
                var speed = isNaN(Number(args[1])) ? 2 : Number(args[1]) <= 1 ? 1 : Number(args[1]) >= 2 ? 2 : Number(args[1]) || 2
                var gradual = []
                var n = 100
                var fileinfo = await validateFile(currenturl).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })

                if (!fileinfo) return
                var type = fileinfo.type

                if (type.mime.startsWith('video')) {
                    var filepath = await downloadFile(currenturl, `input.mp4`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp4`
                    var audio = fileinfo.info.audio

                    if (audio) {
                        var fps = fileinfo.info.fps
                        var duration = Number(fileinfo.info.duration.includes('N/A') ? '0' : fileinfo.info.duration)
                        var aduration = Number(fileinfo.info.aduration.includes('N/A') ? '0' : fileinfo.info.aduration)
                        var ratio = aduration / duration
                        var total = 0
                        var f = duration / n
                        var ptsvalue = '{next}'

                        for (var i = 0; i < n; i++) {
                            var a = i / (n - 1)
                            var a2 = i / n
                            var a3 = (i + 1) / n
                            var start = duration * a2
                            var end = start + f
                            total += f * Math.lerp(1, speed, a)
                            gradual.push({
                                audio: `[ga${i + 1}]`,
                                filter: `[0:a]atrim=${start}:${end}${i != 0 ? `,atempo=${1 / Math.lerp(1, speed, a)}` : ''}[ga${i + 1}]`,
                                pts: i == (n - 1) ? speed : `if(lt(T/${duration},${a3}),${Math.lerp(1, speed, a)},{next})`
                            })
                        }

                        for (var i in gradual) {
                            var grad = gradual[i]
                            ptsvalue = ptsvalue.replace('{next}', grad.pts)
                        }

                        await execPromise(`ffmpeg -i ${filepath}/${filename} -filter_complex "[0:v]setpts='lerp(1,${speed},T/${duration})*PTS'[v];${gradual.map(g => g.filter).join(';')};${gradual.map(g => g.audio).join('')}concat=n=${n}:a=1:v=0,atempo[a]" -map "[v]" -map "[a]" -preset ${findpreset(args)} -c:v libx264 -pix_fmt yuv420p ${filepath}/gradual.mp4`)
                        var gradualinfo = await validateFileFromPath(`${filepath}/gradual.mp4`, 'very true').catch(() => { })
                        if (!gradualinfo) {
                            await msg.channel.send('Error while processing initial effect.').catch(() => { })
                            msg.channel.sendTyping().catch(() => { })
                            fs.rmSync(`${filepath}`, { force: true, recursive: true })
                            return
                        }
                        var gduration = gradualinfo.info.duration
                        var gaduration = gradualinfo.info.aduration
                        await execPromise(`ffmpeg -i ${filepath}/gradual.mp4 -filter_complex "[0:v]setpts=PTS/(${Number(gduration)}/${Number(gaduration)})/${ratio}[v]" -map "[v]" -map 0:a -preset ${findpreset(args)} -c:v libx264 -pix_fmt yuv420p ${filepath}/output.mp4`)
                        await sendFile(msg, filepath, `output.mp4`)
                    } else {
                        var fps = fileinfo.info.fps
                        var duration = Number(fileinfo.info.duration.includes('N/A') ? '0' : fileinfo.info.duration)

                        await execPromise(`ffmpeg -i ${filepath}/${filename} -filter_complex "[0:v]setpts='lerp(1,${speed},T/${duration})*PTS'[v]" -map "[v]" -preset ${findpreset(args)} -c:v libx264 -pix_fmt yuv420p ${filepath}/output.mp4`)
                        await sendFile(msg, filepath, `output.mp4`)
                    }
                } else if (type.mime.startsWith('audio')) {
                    var filepath = await downloadFile(currenturl, `input.mp3`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp3`
                    var duration = Number(fileinfo.info.duration.includes('N/A') ? '0' : fileinfo.info.duration)

                    var f = duration / n

                    for (var i = 0; i < n; i++) {
                        var a = i / (n - 1)
                        var a2 = i / n
                        var start = duration * a2
                        var end = start + f
                        gradual.push({
                            audio: `[ga${i + 1}]`,
                            filter: `[0:a]atrim=${start}:${end}${i != 0 ? `,atempo=${1 / Math.lerp(1, speed, a)}` : ''}[ga${i + 1}]`
                        })
                    }

                    await execPromise(`ffmpeg -i ${filepath}/${filename} -filter_complex "${gradual.map(g => g.filter).join(';')};${gradual.map(g => g.audio).join('')}concat=n=${n}:a=1:v=0,atempo[a]" -map "[a]" -preset ${findpreset(args)} ${filepath}/output.mp3`)
                    await sendFile(msg, filepath, `output.mp3`)
                } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                    var filepath = await downloadFile(currenturl, `input.gif`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.gif`
                    var fps = fileinfo.info.fps
                    var duration = Number(fileinfo.info.duration.includes('N/A') ? '0' : fileinfo.info.duration)

                    await execPromise(`ffmpeg -i ${filepath}/${filename} -filter_complex "[0:v]setpts='(1/lerp(1,${speed},T/${duration}))*PTS',split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ${findpreset(args)} -gifflags -offsetting ${filepath}/output.gif`)
                    await sendFile(msg, filepath, `output.gif`)
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "gradualslowdown/gradualslow [multiplier <number (from 1 to 2)>] <video/audio>",
                "value": "Gradually slows down the file until the end."
            },
            cooldown: 2500,
            type: "Duration"
        },

        {
            name: ["gradualhighpitch", "gradualincreasepitch"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[2] === undefined) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl']
                var speed = isNaN(Number(args[1])) ? 2 : Number(args[1]) <= 1 ? 1 : Number(args[1]) >= 2 ? 2 : Number(args[1]) || 2
                var gradual = []
                var n = 100
                var fileinfo = await validateFile(currenturl).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })

                if (!fileinfo) return
                var type = fileinfo.type

                if (type.mime.startsWith('video')) {
                    var audio = fileinfo.info.audio

                    if (audio) {
                        var filepath = await downloadFile(currenturl, `input.mp4`, {
                            fileinfo: fileinfo
                        })
                        var filename = `input.mp4`
                        var fps = fileinfo.info.fps
                        var duration = Number(fileinfo.info.duration.includes('N/A') ? '0' : fileinfo.info.duration)
                        var aduration = Number(fileinfo.info.aduration.includes('N/A') ? '0' : fileinfo.info.aduration)
                        var ratio = aduration / duration
                        var total = 0
                        var f = duration / n
                        var ptsvalue = '{next}'

                        for (var i = 0; i < n; i++) {
                            var a = i / (n - 1)
                            var a2 = i / n
                            var a3 = (i + 1) / n
                            var start = duration * a2
                            var end = start + f
                            total += f / Math.lerp(1, speed, a)
                            gradual.push({
                                audio: `[ga${i + 1}]`,
                                filter: `[0:a]atrim=${start}:${end}${i != 0 ? `,aresample=44100,asetrate='44100*${Math.lerp(1, speed, a)}',aresample=44100,atempo=${1 / Math.lerp(1, speed, a)}` : ''}[ga${i + 1}]`,
                                pts: i == (n - 1) ? speed : `if(lt(T/${duration},${a3}),${Math.lerp(1, speed, a)},{next})`
                            })
                        }

                        for (var i in gradual) {
                            var grad = gradual[i]
                            ptsvalue = ptsvalue.replace('{next}', grad.pts)
                        }

                        await execPromise(`ffmpeg -i ${filepath}/${filename} -filter_complex "${gradual.map(g => g.filter).join(';')};${gradual.map(g => g.audio).join('')}concat=n=${n}:a=1:v=0,atempo[a]" -map 0:v -map "[a]" -preset ${findpreset(args)} -c:v libx264 -pix_fmt yuv420p ${filepath}/output.mp4`)
                        await sendFile(msg, filepath, `output.mp4`)
                    } else {
                        msg.channel.send({
                            content: `No audio stream detected.`,
                            allowedMentions: {
                                parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                            }
                        }).catch(() => { })
                        msg.channel.sendTyping().catch(() => { })
                    }
                } else if (type.mime.startsWith('audio')) {
                    var filepath = await downloadFile(currenturl, `input.mp3`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp3`
                    var duration = Number(fileinfo.info.duration.includes('N/A') ? '0' : fileinfo.info.duration)

                    var f = duration / n

                    for (var i = 0; i < n; i++) {
                        var a = i / (n - 1)
                        var a2 = i / n
                        var start = duration * a2
                        var end = start + f
                        gradual.push({
                            audio: `[ga${i + 1}]`,
                            filter: `[0:a]atrim=${start}:${end}${i != 0 ? `,aresample=44100,asetrate='44100*${Math.lerp(1, speed, a)}',aresample=44100,atempo=${1 / Math.lerp(1, speed, a)}` : ''}[ga${i + 1}]`
                        })
                    }

                    await execPromise(`ffmpeg -i ${filepath}/${filename} -filter_complex "${gradual.map(g => g.filter).join(';')};${gradual.map(g => g.audio).join('')}concat=n=${n}:a=1:v=0,atempo[a]" -map "[a]" -preset ${findpreset(args)} ${filepath}/output.mp3`)
                    await sendFile(msg, filepath, `output.mp3`)
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "gradualhighpitch/gradualincreasepitch [multiplier <number (from 1 to 2)>] <video/audio>",
                "value": "Gradually increases the pitch of the file until the end."
            },
            cooldown: 2500,
            type: "Audio"
        },

        {
            name: ["graduallowpitch", "gradualdecreasepitch"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[2] === undefined) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl']
                var speed = isNaN(Number(args[1])) ? 2 : Number(args[1]) <= 1 ? 1 : Number(args[1]) >= 2 ? 2 : Number(args[1]) || 2
                var gradual = []
                var n = 100
                var fileinfo = await validateFile(currenturl).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })

                if (!fileinfo) return
                var type = fileinfo.type

                if (type.mime.startsWith('video')) {
                    var audio = fileinfo.info.audio

                    if (audio) {
                        var filepath = await downloadFile(currenturl, `input.mp4`, {
                            fileinfo: fileinfo
                        })
                        var filename = `input.mp4`
                        var fps = fileinfo.info.fps
                        var duration = Number(fileinfo.info.duration.includes('N/A') ? '0' : fileinfo.info.duration)
                        var aduration = Number(fileinfo.info.aduration.includes('N/A') ? '0' : fileinfo.info.aduration)
                        var ratio = aduration / duration
                        var total = 0
                        var f = duration / n
                        var ptsvalue = '{next}'

                        for (var i = 0; i < n; i++) {
                            var a = i / (n - 1)
                            var a2 = i / n
                            var a3 = (i + 1) / n
                            var start = duration * a2
                            var end = start + f
                            total += f / Math.lerp(1, speed, a)
                            gradual.push({
                                audio: `[ga${i + 1}]`,
                                filter: `[0:a]atrim=${start}:${end}${i != 0 ? `,aresample=44100,asetrate='44100/${Math.lerp(1, speed, a)}',aresample=44100,atempo=${Math.lerp(1, speed, a)}` : ''}[ga${i + 1}]`,
                                pts: i == (n - 1) ? speed : `if(lt(T/${duration},${a3}),${Math.lerp(1, speed, a)},{next})`
                            })
                        }

                        for (var i in gradual) {
                            var grad = gradual[i]
                            ptsvalue = ptsvalue.replace('{next}', grad.pts)
                        }

                        await execPromise(`ffmpeg -i ${filepath}/${filename} -filter_complex "${gradual.map(g => g.filter).join(';')};${gradual.map(g => g.audio).join('')}concat=n=${n}:a=1:v=0,atempo[a]" -map 0:v -map "[a]" -preset ${findpreset(args)} -c:v libx264 -pix_fmt yuv420p ${filepath}/output.mp4`)
                        await sendFile(msg, filepath, `output.mp4`)
                    } else {
                        msg.channel.send({
                            content: `No audio stream detected.`,
                            allowedMentions: {
                                parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                            }
                        }).catch(() => { })
                        msg.channel.sendTyping().catch(() => { })
                    }
                } else if (type.mime.startsWith('audio')) {
                    var filepath = await downloadFile(currenturl, `input.mp3`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp3`
                    var duration = Number(fileinfo.info.duration.includes('N/A') ? '0' : fileinfo.info.duration)

                    var f = duration / n

                    for (var i = 0; i < n; i++) {
                        var a = i / (n - 1)
                        var a2 = i / n
                        var start = duration * a2
                        var end = start + f
                        gradual.push({
                            audio: `[ga${i + 1}]`,
                            filter: `[0:a]atrim=${start}:${end}${i != 0 ? `,aresample=44100,asetrate='44100/${Math.lerp(1, speed, a)}',aresample=44100,atempo=${Math.lerp(1, speed, a)}` : ''}[ga${i + 1}]`
                        })
                    }

                    await execPromise(`ffmpeg -i ${filepath}/${filename} -filter_complex "${gradual.map(g => g.filter).join(';')};${gradual.map(g => g.audio).join('')}concat=n=${n}:a=1:v=0,atempo[a]" -map "[a]" -preset ${findpreset(args)} ${filepath}/output.mp3`)
                    await sendFile(msg, filepath, `output.mp3`)
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "graduallowpitch/gradualdecreasepitch [multiplier <number (from 1 to 6)>] <video/audio>",
                "value": "Gradually decreases the pitch of the file until the end."
            },
            cooldown: 2500,
            type: "Audio"
        },

        {
            name: ["slowpitch"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[2] === undefined) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl']
                var speed = isNaN(Number(args[1])) ? 2 : Number(args[1]) <= 1 ? 1 : Number(args[1]) >= 6 ? 6 : Number(args[1]) || 2
                var fileinfo = await validateFile(currenturl, true).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })

                if (!fileinfo) return
                var type = fileinfo.type

                if (type.mime.startsWith('video')) {
                    var audio = fileinfo.info.audio

                    if (audio) {
                        var filepath = await downloadFile(currenturl, `input.mp4`, {
                            fileinfo: fileinfo
                        })
                        var filename = `input.mp4`
                        var fps = fileinfo.info.fps

                        await execPromise(`ffmpeg -i ${filepath}/${filename} -filter_complex "[0:v]setpts=${speed}*PTS,fps=fps='min(60,${fps.includes('0/0') ? '60' : fps}/${speed})',scale=ceil(iw/2)*2:ceil(ih/2)*2[v];[0:a]aresample=44100,asetrate=44100/${speed},aresample=44100[a]" -map "[v]" -map "[a]" -preset ${findpreset(args)} -c:v libx264 -pix_fmt yuv420p ${filepath}/output.mp4`)
                        await sendFile(msg, filepath, `output.mp4`)
                    } else {
                        msg.channel.send({
                            content: `File has no audio stream, maybe you should just use \`slowdown\` for that.`,
                            allowedMentions: {
                                parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                            }
                        }).catch(() => { })
                        msg.channel.sendTyping().catch(() => { })
                    }
                } else if (type.mime.startsWith('audio')) {
                    var filepath = await downloadFile(currenturl, `input.mp3`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp3`
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -filter_complex "[0:a]aresample=44100,asetrate=44100/${speed},aresample=44100[a]" -map "[a]" -preset ${findpreset(args)} ${filepath}/output.mp3`)
                    await sendFile(msg, filepath, `output.mp3`)
                } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                    msg.channel.send({
                        content: `Maybe you should just use \`slowdown\` for that.`,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "slowpitch [multiplier <number (from 1 to 6)>] <video/audio>",
                "value": "Slows down the file while also decreasing its pitch."
            },
            cooldown: 2500,
            type: "Audio"
        },

        {
            name: ["lowerpitch", "decreasepitch"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[2] === undefined) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl']
                var speed = isNaN(Number(args[1])) ? 2 : Number(args[1]) <= 1 ? 1 : Number(args[1]) >= 6 ? 6 : Number(args[1]) || 2
                var fileinfo = await validateFile(currenturl).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })

                if (!fileinfo) return
                var type = fileinfo.type

                if (type.mime.startsWith('video')) {
                    var filepath = await downloadFile(currenturl, `input.mp4`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp4`
                    var audio = fileinfo.info.audio

                    if (audio) {
                        await execPromise(`ffmpeg -i ${filepath}/${filename} -filter_complex "[0:v]scale=ceil(iw/2)*2:ceil(ih/2)*2[v];[0:a]aresample=44100,asetrate=44100/${speed},aresample=44100,atempo=${speed}[a]" -map "[v]" -map "[a]" -preset ${findpreset(args)} -c:v libx264 -pix_fmt yuv420p ${filepath}/output.mp4`)
                        await sendFile(msg, filepath, `output.mp4`)
                    } else {
                        await msg.channel.send('No audio stream detected.').catch(() => { })
                        msg.channel.sendTyping().catch(() => { })
                        fs.rmSync(`${filepath}`, { force: true, recursive: true })
                    }
                } else if (type.mime.startsWith('audio')) {
                    var filepath = await downloadFile(currenturl, `input.mp3`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp3`
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -filter_complex "[0:a]aresample=44100,asetrate=44100/${speed},aresample=44100,atempo=${speed}[a]" -map "[a]" -preset ${findpreset(args)} ${filepath}/output.mp3`)
                    await sendFile(msg, filepath, `output.mp3`)
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "lowerpitch [multiplier <number (from 1 to 6)>] <video/audio>",
                "value": "Lowers the video's pitch. Default is 2."
            },
            cooldown: 2500,
            type: "Audio"
        },

        {
            name: ["vibrato"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[2] === undefined) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var frequency = 5
                var frequencyindex = args.indexOf('-frequency')
                if (frequencyindex > -1) {
                    frequency = isNaN(Number(args[frequencyindex + 1])) ? 5 : Number(args[frequencyindex + 1]) <= 0.1 ? 0.1 : Number(args[frequencyindex + 1]) >= 20000 ? 20000 : Number(args[frequencyindex + 1]) || 5
                }
                var depth = 50
                var depthindex = args.indexOf('-depth')
                if (depthindex > -1) {
                    depth = isNaN(Number(args[depthindex + 1])) ? 50 : Number(args[depthindex + 1]) <= 0 ? 0 : Number(args[depthindex + 1]) >= 100 ? 100 : Number(args[depthindex + 1]) || 50
                }
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl']
                var fileinfo = await validateFile(currenturl).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })

                if (!fileinfo) return
                var type = fileinfo.type

                if (type.mime.startsWith('video')) {
                    var filepath = await downloadFile(currenturl, `input.mp4`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp4`
                    var audio = fileinfo.info.audio

                    if (audio) {
                        await execPromise(`ffmpeg -i ${filepath}/${filename} -filter_complex "[0:v]scale=ceil(iw/2)*2:ceil(ih/2)*2[v];[0:a]vibrato=f=${frequency}:d=${depth / 100}[a]" -map "[v]" -map "[a]" -preset ${findpreset(args)} -c:v libx264 -pix_fmt yuv420p ${filepath}/output.mp4`)
                        await sendFile(msg, filepath, `output.mp4`)
                    } else {
                        await msg.channel.send('No audio stream detected.').catch(() => { })
                        msg.channel.sendTyping().catch(() => { })
                        fs.rmSync(`${filepath}`, { force: true, recursive: true })
                    }
                } else if (type.mime.startsWith('audio')) {
                    var filepath = await downloadFile(currenturl, `input.mp3`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp3`
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -filter_complex "[0:a]vibrato=f=${frequency}:d=${depth / 100}[a]" -map "[a]" -preset ${findpreset(args)} ${filepath}/output.mp3`)
                    await sendFile(msg, filepath, `output.mp3`)
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "vibrato <video/audio> [-frequency <hz (from 0.1 to 20000)>] [-depth <percentage>]",
                "value": "Adds a vibrato effect to the video/audio. Default frequency is 5 and depth is 50."
            },
            cooldown: 2500,
            type: "Audio"
        },

        {
            name: ["tremolo"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[2] === undefined) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var frequency = 5
                var frequencyindex = args.indexOf('-frequency')
                if (frequencyindex > -1) {
                    frequency = isNaN(Number(args[frequencyindex + 1])) ? 5 : Number(args[frequencyindex + 1]) <= 0.1 ? 0.1 : Number(args[frequencyindex + 1]) >= 20000 ? 20000 : Number(args[frequencyindex + 1]) || 5
                }
                var depth = 50
                var depthindex = args.indexOf('-depth')
                if (depthindex > -1) {
                    depth = isNaN(Number(args[depthindex + 1])) ? 50 : Number(args[depthindex + 1]) <= 0 ? 0 : Number(args[depthindex + 1]) >= 100 ? 100 : Number(args[depthindex + 1]) || 50
                }
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl']
                var fileinfo = await validateFile(currenturl).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })

                if (!fileinfo) return
                var type = fileinfo.type

                if (type.mime.startsWith('video')) {
                    var filepath = await downloadFile(currenturl, `input.mp4`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp4`
                    var audio = fileinfo.info.audio

                    if (audio) {
                        await execPromise(`ffmpeg -i ${filepath}/${filename} -filter_complex "[0:v]scale=ceil(iw/2)*2:ceil(ih/2)*2[v];[0:a]tremolo=f=${frequency}:d=${depth / 100}[a]" -map "[v]" -map "[a]" -preset ${findpreset(args)} -c:v libx264 -pix_fmt yuv420p ${filepath}/output.mp4`)
                        await sendFile(msg, filepath, `output.mp4`)
                    } else {
                        await msg.channel.send('No audio stream detected.').catch(() => { })
                        msg.channel.sendTyping().catch(() => { })
                        fs.rmSync(`${filepath}`, { force: true, recursive: true })
                    }
                } else if (type.mime.startsWith('audio')) {
                    var filepath = await downloadFile(currenturl, `input.mp3`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp3`
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -filter_complex "[0:a]tremolo=f=${frequency}:d=${depth / 100}[a]" -map "[a]" -preset ${findpreset(args)} ${filepath}/output.mp3`)
                    await sendFile(msg, filepath, `output.mp3`)
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "tremolo <file> [-frequency <hz (from 0.1 to 20000)>] [-depth <percentage>]",
                "value": "Adds a tremolo effect to the file's audio. Default frequency is 5 and depth is 50."
            },
            cooldown: 2500,
            type: "Audio"
        },

        {
            name: ["bassy", "bass", "lowpass"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[2] === undefined) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl']
                var fileinfo = await validateFile(currenturl).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })

                if (!fileinfo) return
                var type = fileinfo.type

                if (type.mime.startsWith('video')) {
                    var filepath = await downloadFile(currenturl, `input.mp4`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp4`
                    var audio = fileinfo.info.audio

                    if (audio) {
                        await execPromise(`ffmpeg -i ${filepath}/${filename} -filter_complex "[0:v]scale=ceil(iw/2)*2:ceil(ih/2)*2[v];[0:a]lowpass=f=500[a]" -map "[v]" -map "[a]" -preset ${findpreset(args)} -c:v libx264 -pix_fmt yuv420p ${filepath}/output.mp4`)
                        await sendFile(msg, filepath, `output.mp4`)
                    } else {
                        await msg.channel.send('No audio stream detected.').catch(() => { })
                        msg.channel.sendTyping().catch(() => { })
                        fs.rmSync(`${filepath}`, { force: true, recursive: true })
                    }
                } else if (type.mime.startsWith('audio')) {
                    var filepath = await downloadFile(currenturl, `input.mp3`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp3`
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -filter_complex "[0:a]lowpass=f=500[a]" -map "[a]" -preset ${findpreset(args)} ${filepath}/output.mp3`)
                    await sendFile(msg, filepath, `output.mp3`)
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "bassy/bass/lowpass <file>",
                "value": "Makes the audio in the file bassy."
            },
            cooldown: 2500,
            type: "Audio"
        },

        {
            name: ["trebling", "treble", "highpass"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[2] === undefined) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl']
                var fileinfo = await validateFile(currenturl).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })

                if (!fileinfo) return
                var type = fileinfo.type

                if (type.mime.startsWith('video')) {
                    var filepath = await downloadFile(currenturl, `input.mp4`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp4`
                    var audio = fileinfo.info.audio

                    if (audio) {
                        await execPromise(`ffmpeg -i ${filepath}/${filename} -filter_complex "[0:v]scale=ceil(iw/2)*2:ceil(ih/2)*2[v];[0:a]highpass=f=500[a]" -map "[v]" -map "[a]" -preset ${findpreset(args)} -c:v libx264 -pix_fmt yuv420p ${filepath}/output.mp4`)
                        await sendFile(msg, filepath, `output.mp4`)
                    } else {
                        await msg.channel.send('No audio stream detected.').catch(() => { })
                        msg.channel.sendTyping().catch(() => { })
                        fs.rmSync(`${filepath}`, { force: true, recursive: true })
                    }
                } else if (type.mime.startsWith('audio')) {
                    var filepath = await downloadFile(currenturl, `input.mp3`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp3`
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -filter_complex "[0:a]highpass=f=500[a]" -map "[a]" -preset ${findpreset(args)} ${filepath}/output.mp3`)
                    await sendFile(msg, filepath, `output.mp3`)
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "trebling/treble/highpass <file>",
                "value": "Makes the audio in the file treble."
            },
            cooldown: 2500,
            type: "Audio"
        },

        {
            name: ["spectrogram"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[2] === undefined) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl']
                var colors = [
                    'channel',
                    'intensity',
                    'rainbow',
                    'moreland',
                    'nebulae',
                    'fire',
                    'fiery',
                    'fruit',
                    'cool',
                    'magma',
                    'green',
                    'viridis',
                    'plasma',
                    'cividis',
                    'terrain'
                ]
                var color = 'intensity'
                var colorindex = args.indexOf('-color')
                if (colorindex > -1) {
                    if (colors.find(color => color === args[colorindex + 1].toLowerCase())) {
                        color = args[colorindex + 1].toLowerCase()
                    } else {
                        msg.channel.send('Not a supported color.').catch(() => { })
                        return
                    }
                }
                var scales = [
                    'lin',
                    'sqrt',
                    'cbrt',
                    'log',
                    '4thrt',
                    '5thrt'
                ]
                var scale = 'log'
                var scaleindex = args.indexOf('-scale')
                if (scaleindex > -1) {
                    if (scales.find(scale => scale === args[scaleindex + 1].toLowerCase())) {
                        scale = args[scaleindex + 1].toLowerCase()
                    } else {
                        msg.channel.send('Not a supported scale.').catch(() => { })
                        return
                    }
                }
                var saturation = 1
                var saturationindex = args.indexOf('-saturation')
                if (saturationindex > -1) {
                    saturation = isNaN(Number(args[saturationindex + 1])) ? 1 : Number(args[saturationindex + 1]) <= -10 ? -10 : Number(args[saturationindex + 1]) >= 10 ? 10 : Number(args[saturationindex + 1]) ?? 1
                }
                var fileinfo = await validateFile(currenturl).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })

                if (!fileinfo) return
                var type = fileinfo.type

                if (type.mime.startsWith('video')) {
                    var filepath = await downloadFile(currenturl, `input.mp4`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp4`
                    var audio = fileinfo.info.audio

                    if (audio) {
                        await execPromise(`ffmpeg -i ${filepath}/${filename} -lavfi "showspectrumpic=size=1280x512:mode=separate:color=${color}:scale=${scale}:saturation=${saturation}" ${filepath}/output.png`)
                        await sendFile(msg, filepath, `output.png`)
                    } else {
                        await msg.channel.send('No audio stream detected.').catch(() => { })
                        msg.channel.sendTyping().catch(() => { })
                        fs.rmSync(`${filepath}`, { force: true, recursive: true })
                    }
                } else if (type.mime.startsWith('audio')) {
                    var filepath = await downloadFile(currenturl, `input.mp3`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp3`

                    await execPromise(`ffmpeg -i ${filepath}/${filename} -lavfi "showspectrumpic=size=1280x512:mode=separate:color=${color}:scale=${scale}:saturation=${saturation}" ${filepath}/output.png`)
                    await sendFile(msg, filepath, `output.png`)
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "spectrogram <file> [-color <mode>] [-scale <scale>] [-saturation <number (from -10 to 10)>]",
                "value": "Displays the spectrogram of the audio file. A list of options for color and scale can be found at https://ffmpeg.org/ffmpeg-filters.html#showspectrumpic"
            },
            cooldown: 2500,
            type: "Audio"
        },

        {
            name: ["tospectrogram", "spectrogramimage"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[2] === undefined) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var duration = 6
                var durationindex = args.indexOf('-duration')
                if (durationindex > -1) {
                    duration = isNaN(Number(args[durationindex + 1])) ? 6 : Number(args[durationindex + 1]) <= 1 ? 1 : Number(args[durationindex + 1]) >= 20 ? 20 : Number(args[durationindex + 1]) || 6
                }
                var frequency = 20000
                var frequencyindex = args.indexOf('-frequency')
                if (frequencyindex > -1) {
                    frequency = isNaN(Number(args[frequencyindex + 1])) ? 20000 : Number(args[frequencyindex + 1]) <= 20 ? 20 : Number(args[frequencyindex + 1]) >= 40000 ? 40000 : Math.round(Number(args[frequencyindex + 1])) || 20000
                }
                var density = 1
                var densityindex = args.indexOf('-density')
                if (densityindex > -1) {
                    density = isNaN(Number(args[densityindex + 1])) ? 1 : Number(args[densityindex + 1]) <= 1 ? 1 : Number(args[densityindex + 1]) >= 10 ? 10 : Number(args[densityindex + 1]) || 1
                }
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl']
                var fileinfo = await validateFile(currenturl).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })

                if (!fileinfo) return
                var type = fileinfo.type

                if (type.mime.startsWith('image')) {
                    var currentcount = filecount
                    filecount++
                    var filepath = `temp/file${currentcount}`
                    fs.mkdirSync(`${filepath}`)

                    var spectrogramData = await spectrogram(currenturl, {
                        o_length: duration,
                        o_freq: frequency,
                        o_factor: density
                    }).catch(() => { })

                    fs.writeFileSync(`${filepath}/output.wav`, spectrogramData)

                    await sendFile(msg, filepath, `output.wav`)
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "tospectrogram/spectrogramimage <file> [-duration <seconds (from 1 to 20)>] [-frequency <hz (from 20 to 40000)>] [-density <number (from 1 to 10)>]",
                "value": "Generates a new WAV from the image. When you view its spectrogram, the image will be there! (`spectrogram` command)"
            },
            cooldown: 2500,
            type: "Audio"
        },

        {
            name: ["donotplaytwice", "playtwice"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[2] === undefined) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl']
                var fileinfo = await validateFile(currenturl).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })

                if (!fileinfo) return
                var type = fileinfo.type

                if (type.mime.startsWith('video')) {
                    var filepath = await downloadFile(currenturl, `input.mp4`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp4`
                    var audio = fileinfo.info.audio

                    if (audio) {
                        await execPromise(`ffmpeg -i ${filepath}/${filename} -vn -map_metadata -1 -c:a libvorbis -b:a 64k -ar 44100 -preset ${findpreset(args)} ${filepath}/44100.ogg`)

                        await execPromise(`cat templates/donotplaytwice.ogg ${filepath}/44100.ogg templates/silence.ogg > ${filepath}/output.ogg`)

                        await sendFile(msg, filepath, `output.ogg`)
                    } else {
                        await msg.channel.send('No audio stream detected.').catch(() => { })
                        msg.channel.sendTyping().catch(() => { })
                        fs.rmSync(`${filepath}`, { force: true, recursive: true })
                    }
                } else if (type.mime.startsWith('audio')) {
                    var filepath = await downloadFile(currenturl, `input.mp3`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp3`
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -vn -map_metadata -1 -c:a libvorbis -b:a 64k -ar 44100 -preset ${findpreset(args)} ${filepath}/44100.ogg`)

                    await execPromise(`cat templates/donotplaytwice.ogg ${filepath}/44100.ogg templates/silence.ogg > ${filepath}/output.ogg`)

                    await sendFile(msg, filepath, `output.ogg`)
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "donotplaytwice/playtwice <audio/video>",
                "value": "Creates a \"DO NOT PLAY THIS AUDIO TWICE\" ogg with the audio. Probably doesn't work now..."
            },
            cooldown: 2500,
            type: "Audio"
        },

        {
            name: ["setfps"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[2] === undefined) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl']
                var fps = isNaN(Number(args[1])) ? undefined : Number(args[1]) <= 0.01 ? 0.01 : Number(args[1]) >= 60 ? 60 : Number(args[1]) || undefined
                if (fps === undefined) {
                    msg.channel.send('What is the FPS?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                }
                var fileinfo = await validateFile(currenturl, true).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })

                if (!fileinfo) return
                var type = fileinfo.type

                if (type.mime.startsWith('video')) {
                    var filepath = await downloadFile(currenturl, `input.mp4`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp4`

                    await execPromise(`ffmpeg ${args.find(arg => arg === '-changespeed') ? `-r ${fps} ` : ''}-i ${filepath}/${filename} -map 0:a? -filter_complex "[0:v]scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ${findpreset(args)} -c:v libx264 -pix_fmt yuv420p ${!args.find(arg => arg === '-changespeed') ? `-r ${fps} ` : ''}${filepath}/output.mp4`)
                    await sendFile(msg, filepath, `output.mp4`)
                } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                    var filepath = await downloadFile(currenturl, `input.gif`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.gif`
                    if (fps > 50) {
                        fps = 50
                    }

                    await execPromise(`ffmpeg ${args.find(arg => arg === '-changespeed') ? `-r ${fps} ` : ''}-i ${filepath}/${filename} -filter_complex "[0:v]split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ${findpreset(args)} -gifflags -offsetting ${!args.find(arg => arg === '-changespeed') ? `-r ${fps} ` : ''}${filepath}/output.gif`)
                    await sendFile(msg, filepath, `output.gif`)
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "setfps <fps> <video/gif> [-changespeed]",
                "value": "Sets the file's FPS to <fps>."
            },
            cooldown: 2500,
            type: "Compression"
        },

        {
            name: ["scale", "rescale"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[2] === undefined) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl']
                var width = isNaN(Number(args[1])) ? undefined : Number(args[1]) <= 1 ? 1 : Number(args[1]) >= 3000 ? 3000 : Number(args[1]) || undefined
                if (width === undefined) {
                    msg.channel.send('What is the width?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                }
                var height = isNaN(Number(args[2])) ? undefined : Number(args[2]) <= 1 ? 1 : Number(args[2]) >= 3000 ? 3000 : Number(args[2]) || undefined
                if (height === undefined) {
                    msg.channel.send('What is the height?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                }
                var flags = [
                    'fast_bilinear',
                    'bilinear',
                    'bicubic',
                    'experimental',
                    'neighbor',
                    'area',
                    'bicublin',
                    'gauss',
                    'sinc',
                    'lanczos',
                    'spline',
                    'print_info',
                    'accurate_rnd',
                    'full_chroma_int',
                    'full_chroma_inp',
                    'bitexact'
                ]
                var flag = undefined
                var flagsindex = args.indexOf('-flags')
                if (flagsindex > -1) {
                    if (flags.find(flag => flag === args[flagsindex + 1].toLowerCase())) {
                        flag = args[flagsindex + 1]
                    } else {
                        msg.channel.send('Not a supported flag.').catch(() => { })
                        return
                    }
                }
                var fileinfo = await validateFile(currenturl, true).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })

                if (!fileinfo) return
                var type = fileinfo.type

                if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                    var filepath = await downloadFile(currenturl, `input.png`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.png`

                    await execPromise(`ffmpeg -i ${filepath}/${filename} -filter_complex "[0:v]scale=${width}:${height}${flag ? `:flags=${flag}` : ''}[out]" -map "[out]" -preset ${findpreset(args)} ${filepath}/output.png`)
                    await sendFile(msg, filepath, `output.png`)
                } else if (type.mime.startsWith('video')) {
                    var filepath = await downloadFile(currenturl, `input.mp4`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp4`
                    if (width > 2000) {
                        width = 2000
                    }
                    if (height > 2000) {
                        height = 2000
                    }

                    await execPromise(`ffmpeg -i ${filepath}/${filename} -map 0:a? -filter_complex "[0:v]scale=${width}:${height}${flag ? `:flags=${flag}` : ''},scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ${findpreset(args)} -c:v libx264 -pix_fmt yuv420p ${filepath}/output.mp4`)
                    await sendFile(msg, filepath, `output.mp4`)
                } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                    var filepath = await downloadFile(currenturl, `input.gif`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.gif`
                    if (width > 1000) {
                        width = 1000
                    }
                    if (height > 1000) {
                        height = 1000
                    }

                    await execPromise(`ffmpeg -i ${filepath}/${filename} -filter_complex "[0:v]scale=${width}:${height}${flag ? `:flags=${flag}` : ''},split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ${findpreset(args)} -gifflags -offsetting ${filepath}/output.gif`)
                    await sendFile(msg, filepath, `output.gif`)
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "scale/rescale <width> <height> <file> [-flags <algorithm>]",
                "value": "Rescales the file to correspond to the specified width and height."
            },
            cooldown: 2500,
            type: "Resizing"
        },

        {
            name: ["meme"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && validUrl.test(args[args.length - 1]) === false) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var size = 1
                var sizeindex = args.indexOf('-size')
                if (sizeindex > -1) {
                    size = isNaN(Number(args[sizeindex + 1])) ? 1 : Number(args[sizeindex + 1]) <= 0.5 ? 0.5 : Number(args[sizeindex + 1]) >= 5 ? 5 : Number(args[sizeindex + 1]) || 1
                }
                var saidMessage = args.join(' ').substring(args[0].length + 1).replace(/‚Äô/g, '\'')
                symbolreplacements.forEach(symbolReplacement => {
                    symbolReplacement.target.forEach(target => {
                        saidMessage = saidMessage.replace(new RegExp(target, 'ig'), symbolReplacement.replacement)
                    })
                })
                var matchedTextes = saidMessage.match(/"([\s\S]*?)"/g)
                if (!matchedTextes) {
                    matchedTextes = ['""', '""']
                } else if (!matchedTextes[1]) {
                    matchedTextes[1] = '""'
                }
                var text = matchedTextes[0].substring(1, matchedTextes[0].length - 1)
                var text2 = matchedTextes[1].substring(1, matchedTextes[1].length - 1)
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
                var fileinfo = await validateFile(currenturl).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })

                if (!fileinfo) return
                var type = fileinfo.type

                if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                    var filepath = await downloadFile(currenturl, `input.png`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.png`
                    var width = fileinfo.info.width
                    var height = fileinfo.info.height
                    var transparent = await Jimp.read('templates/transparent.png')
                    var impact = await Jimp.loadFont('templates/fonts/Impact/Impact.fnt')
                    transparent.resize(width, height)
                    transparent.resize(Math.round(2000 / size), Jimp.AUTO)
                    var transparent2 = transparent.clone()
                    await transparent.print(impact, 20, 20, { text: Discord.Util.cleanContent(text, msg), alignmentX: Jimp.HORIZONTAL_ALIGN_CENTER, alignmentY: Jimp.VERTICAL_ALIGN_TOP }, transparent.bitmap.width - 40, transparent.bitmap.height - 40)
                    await transparent2.print(impact, 20, 20, { text: Discord.Util.cleanContent(text2, msg), alignmentX: Jimp.HORIZONTAL_ALIGN_CENTER, alignmentY: Jimp.VERTICAL_ALIGN_BOTTOM }, transparent.bitmap.width - 40, transparent.bitmap.height - 40)
                    transparent.resize(width, height)
                    transparent2.resize(width, height)
                    await transparent.writeAsync(`${filepath}/caption.png`)
                    await transparent2.writeAsync(`${filepath}/caption2.png`)

                    await execPromise(`ffmpeg -i ${filepath}/${filename} -i ${filepath}/caption.png -i ${filepath}/caption2.png -filter_complex "[0:v][1:v]overlay=x=0:y=0:format=auto[caption];[caption][2:v]overlay=x=0:y=0:format=auto[out]" -map "[out]" -preset ${findpreset(args)} ${filepath}/output.png`)
                    await sendFile(msg, filepath, `output.png`)
                } else if (type.mime.startsWith('video')) {
                    var filepath = await downloadFile(currenturl, `input.mp4`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp4`
                    var width = fileinfo.info.width
                    var height = fileinfo.info.height
                    var transparent = await Jimp.read('templates/transparent.png')
                    var impact = await Jimp.loadFont('templates/fonts/Impact/Impact.fnt')
                    transparent.resize(width, height)
                    transparent.resize(Math.round(2000 / size), Jimp.AUTO)
                    var transparent2 = transparent.clone()
                    await transparent.print(impact, 20, 20, { text: Discord.Util.cleanContent(text, msg), alignmentX: Jimp.HORIZONTAL_ALIGN_CENTER, alignmentY: Jimp.VERTICAL_ALIGN_TOP }, transparent.bitmap.width - 40, transparent.bitmap.height - 40)
                    await transparent2.print(impact, 20, 20, { text: Discord.Util.cleanContent(text2, msg), alignmentX: Jimp.HORIZONTAL_ALIGN_CENTER, alignmentY: Jimp.VERTICAL_ALIGN_BOTTOM }, transparent.bitmap.width - 40, transparent.bitmap.height - 40)
                    transparent.resize(width, height)
                    transparent2.resize(width, height)
                    await transparent.writeAsync(`${filepath}/caption.png`)
                    await transparent2.writeAsync(`${filepath}/caption2.png`)

                    await execPromise(`ffmpeg -i ${filepath}/${filename} -i ${filepath}/caption.png -i ${filepath}/caption2.png -map 0:a? -filter_complex "[0:v][1:v]overlay=x=0:y=0:format=auto[caption];[caption][2:v]overlay=x=0:y=0:format=auto[oout];[oout]scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ${findpreset(args)} -c:v libx264 -pix_fmt yuv420p ${filepath}/output.mp4`)
                    await sendFile(msg, filepath, `output.mp4`)
                } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                    var filepath = await downloadFile(currenturl, `input.gif`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.gif`
                    var width = fileinfo.info.width
                    var height = fileinfo.info.height
                    var transparent = await Jimp.read('templates/transparent.png')
                    var impact = await Jimp.loadFont('templates/fonts/Impact/Impact.fnt')
                    transparent.resize(width, height)
                    transparent.resize(Math.round(2000 / size), Jimp.AUTO)
                    var transparent2 = transparent.clone()
                    await transparent.print(impact, 20, 20, { text: Discord.Util.cleanContent(text, msg), alignmentX: Jimp.HORIZONTAL_ALIGN_CENTER, alignmentY: Jimp.VERTICAL_ALIGN_TOP }, transparent.bitmap.width - 40, transparent.bitmap.height - 40)
                    await transparent2.print(impact, 20, 20, { text: Discord.Util.cleanContent(text2, msg), alignmentX: Jimp.HORIZONTAL_ALIGN_CENTER, alignmentY: Jimp.VERTICAL_ALIGN_BOTTOM }, transparent.bitmap.width - 40, transparent.bitmap.height - 40)
                    transparent.resize(width, height)
                    transparent2.resize(width, height)
                    await transparent.writeAsync(`${filepath}/caption.png`)
                    await transparent2.writeAsync(`${filepath}/caption2.png`)

                    await execPromise(`ffmpeg -i ${filepath}/${filename} -i ${filepath}/caption.png -i ${filepath}/caption2.png -filter_complex "[0:v][1:v]overlay=x=0:y=0:format=auto[caption];[caption][2:v]overlay=x=0:y=0:format=auto[oout];[oout]split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ${findpreset(args)} -gifflags -offsetting ${filepath}/output.gif`)
                    await sendFile(msg, filepath, `output.gif`)
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "meme \"{topText}\" \"[bottomText]\" <file> [-size <multiplier (from 0.5 to 5)>]",
                "value": "Adds a meme caption to the file."
            },
            cooldown: 2500,
            type: "Captions"
        },

        {
            name: ["meme2", "demotivator", "motivator"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && validUrl.test(args[args.length - 1]) === false) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var saidMessage = args.join(' ').substring(args[0].length + 1).replace(/‚Äô/g, '\'')
                symbolreplacements.forEach(symbolReplacement => {
                    symbolReplacement.target.forEach(target => {
                        saidMessage = saidMessage.replace(new RegExp(target, 'ig'), symbolReplacement.replacement)
                    })
                })
                var matchedTextes = saidMessage.match(/"([\s\S]*?)"/g)
                if (!matchedTextes) {
                    matchedTextes = ['""', '""']
                } else if (!matchedTextes[1]) {
                    matchedTextes[1] = '""'
                }
                var text = matchedTextes[0].substring(1, matchedTextes[0].length - 1)
                var text2 = matchedTextes[1].substring(1, matchedTextes[1].length - 1)
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
                var fileinfo = await validateFile(currenturl).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })

                if (!fileinfo) return
                var type = fileinfo.type

                if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                    var filepath = await downloadFile(currenturl, `input.png`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.png`
                    var width = fileinfo.info.width
                    var height = fileinfo.info.height
                    var black = await Jimp.read('templates/black.png')
                    var tnr = await Jimp.loadFont('templates/fonts/TimesNewRomanBig/TimesNewRomanBig.fnt')
                    var arial = await Jimp.loadFont('templates/fonts/ArialSmallWhite/ArialSmallWhite.fnt')
                    black.resize(width, height)
                    black.resize(400, Jimp.AUTO)
                    var whiteborder = black.clone()
                    var blackborder = black.clone()
                    var textblack = black.clone()
                    var text2black = black.clone()
                    var bottomblack = black.clone()
                    var bgblack = black.clone()
                    whiteborder.invert()
                    whiteborder.resize(whiteborder.bitmap.width + 8, whiteborder.bitmap.height + 8)
                    blackborder.resize(blackborder.bitmap.width + 4, blackborder.bitmap.height + 4)
                    black.resize(500, black.bitmap.height + 60)
                    black.composite(whiteborder, black.bitmap.width / 2 - whiteborder.bitmap.width / 2, black.bitmap.height / 2 - whiteborder.bitmap.height / 2)
                    black.composite(blackborder, black.bitmap.width / 2 - blackborder.bitmap.width / 2, black.bitmap.height / 2 - blackborder.bitmap.height / 2)
                    await black.writeAsync(`${filepath}/border.png`)
                    var textheight = Jimp.measureTextHeight(tnr, text, 500 - 40)
                    textblack.resize(500, textheight)
                    await textblack.print(tnr, 20, 0, { text: Discord.Util.cleanContent(text, msg), alignmentX: Jimp.HORIZONTAL_ALIGN_CENTER, alignmentY: Jimp.VERTICAL_ALIGN_MIDDLE }, textblack.bitmap.width - 40, textblack.bitmap.height)
                    var text2height = Jimp.measureTextHeight(arial, text2, 500 - 40)
                    text2black.resize(500, text2height + 10)
                    await text2black.print(arial, 20, 5, { text: Discord.Util.cleanContent(text2, msg), alignmentX: Jimp.HORIZONTAL_ALIGN_CENTER, alignmentY: Jimp.VERTICAL_ALIGN_MIDDLE }, text2black.bitmap.width - 40, text2black.bitmap.height - 10)
                    bottomblack.resize(500, 20)
                    bgblack.resize(500, textblack.bitmap.height + text2black.bitmap.height + bottomblack.bitmap.height)
                    bgblack.composite(textblack, 0, 0)
                    bgblack.composite(text2black, 0, textblack.bitmap.height)
                    bgblack.composite(bottomblack, 0, textblack.bitmap.height + text2black.bitmap.height)
                    await bgblack.writeAsync(`${filepath}/captions.png`)

                    await execPromise(`ffmpeg -i ${filepath}/${filename} -i ${filepath}/border.png -filter_complex "[0:v]scale=400:-1[scaled];[1:v][scaled]overlay=x=W/2-w/2:y=H/2-h/2:format=auto[out]" -map "[out]" -preset ${findpreset(args)} ${filepath}/frame.png`)
                    await execPromise(`ffmpeg -i ${filepath}/frame.png -i ${filepath}/captions.png -filter_complex "vstack=inputs=2[out]" -map "[out]" -preset ${findpreset(args)} ${filepath}/output.png`)
                    await sendFile(msg, filepath, `output.png`)
                } else if (type.mime.startsWith('video')) {
                    var filepath = await downloadFile(currenturl, `input.mp4`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp4`
                    var width = fileinfo.info.width
                    var height = fileinfo.info.height
                    var black = await Jimp.read('templates/black.png')
                    var tnr = await Jimp.loadFont('templates/fonts/TimesNewRomanBig/TimesNewRomanBig.fnt')
                    var arial = await Jimp.loadFont('templates/fonts/ArialSmallWhite/ArialSmallWhite.fnt')
                    black.resize(width, height)
                    black.resize(400, Jimp.AUTO)
                    var whiteborder = black.clone()
                    var blackborder = black.clone()
                    var textblack = black.clone()
                    var text2black = black.clone()
                    var bottomblack = black.clone()
                    var bgblack = black.clone()
                    whiteborder.invert()
                    whiteborder.resize(whiteborder.bitmap.width + 8, whiteborder.bitmap.height + 8)
                    blackborder.resize(blackborder.bitmap.width + 4, blackborder.bitmap.height + 4)
                    black.resize(500, black.bitmap.height + 60)
                    black.composite(whiteborder, black.bitmap.width / 2 - whiteborder.bitmap.width / 2, black.bitmap.height / 2 - whiteborder.bitmap.height / 2)
                    black.composite(blackborder, black.bitmap.width / 2 - blackborder.bitmap.width / 2, black.bitmap.height / 2 - blackborder.bitmap.height / 2)
                    await black.writeAsync(`${filepath}/border.png`)
                    var textheight = Jimp.measureTextHeight(tnr, text, 500 - 40)
                    textblack.resize(500, textheight)
                    await textblack.print(tnr, 20, 0, { text: Discord.Util.cleanContent(text, msg), alignmentX: Jimp.HORIZONTAL_ALIGN_CENTER, alignmentY: Jimp.VERTICAL_ALIGN_MIDDLE }, textblack.bitmap.width - 40, textblack.bitmap.height)
                    var text2height = Jimp.measureTextHeight(arial, text2, 500 - 40)
                    text2black.resize(500, text2height + 10)
                    await text2black.print(arial, 20, 5, { text: Discord.Util.cleanContent(text2, msg), alignmentX: Jimp.HORIZONTAL_ALIGN_CENTER, alignmentY: Jimp.VERTICAL_ALIGN_MIDDLE }, text2black.bitmap.width - 40, text2black.bitmap.height - 10)
                    bottomblack.resize(500, 20)
                    bgblack.resize(500, textblack.bitmap.height + text2black.bitmap.height + bottomblack.bitmap.height)
                    bgblack.composite(textblack, 0, 0)
                    bgblack.composite(text2black, 0, textblack.bitmap.height)
                    bgblack.composite(bottomblack, 0, textblack.bitmap.height + text2black.bitmap.height)
                    await bgblack.writeAsync(`${filepath}/captions.png`)

                    await execPromise(`ffmpeg -i ${filepath}/${filename} -i ${filepath}/border.png -map 0:a? -filter_complex "[0:v]scale=400:-1[scaled];[1:v][scaled]overlay=x=W/2-w/2:y=H/2-h/2:format=auto[oout];[oout]scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ${findpreset(args)} -c:v libx264 -pix_fmt yuv420p ${filepath}/frame.mp4`)
                    await execPromise(`ffmpeg -i ${filepath}/frame.mp4 -i ${filepath}/captions.png -map 0:a? -filter_complex "vstack=inputs=2[oout];[oout]scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ${findpreset(args)} -c:v libx264 -pix_fmt yuv420p ${filepath}/output.mp4`)
                    await sendFile(msg, filepath, `output.mp4`)
                } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                    var filepath = await downloadFile(currenturl, `input.gif`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.gif`
                    var width = fileinfo.info.width
                    var height = fileinfo.info.height
                    var black = await Jimp.read('templates/black.png')
                    var tnr = await Jimp.loadFont('templates/fonts/TimesNewRomanBig/TimesNewRomanBig.fnt')
                    var arial = await Jimp.loadFont('templates/fonts/ArialSmallWhite/ArialSmallWhite.fnt')
                    black.resize(width, height)
                    black.resize(400, Jimp.AUTO)
                    var whiteborder = black.clone()
                    var blackborder = black.clone()
                    var textblack = black.clone()
                    var text2black = black.clone()
                    var bottomblack = black.clone()
                    var bgblack = black.clone()
                    whiteborder.invert()
                    whiteborder.resize(whiteborder.bitmap.width + 8, whiteborder.bitmap.height + 8)
                    blackborder.resize(blackborder.bitmap.width + 4, blackborder.bitmap.height + 4)
                    black.resize(500, black.bitmap.height + 60)
                    black.composite(whiteborder, black.bitmap.width / 2 - whiteborder.bitmap.width / 2, black.bitmap.height / 2 - whiteborder.bitmap.height / 2)
                    black.composite(blackborder, black.bitmap.width / 2 - blackborder.bitmap.width / 2, black.bitmap.height / 2 - blackborder.bitmap.height / 2)
                    await black.writeAsync(`${filepath}/border.png`)
                    var textheight = Jimp.measureTextHeight(tnr, text, 500 - 40)
                    textblack.resize(500, textheight)
                    await textblack.print(tnr, 20, 0, { text: Discord.Util.cleanContent(text, msg), alignmentX: Jimp.HORIZONTAL_ALIGN_CENTER, alignmentY: Jimp.VERTICAL_ALIGN_MIDDLE }, textblack.bitmap.width - 40, textblack.bitmap.height)
                    var text2height = Jimp.measureTextHeight(arial, text2, 500 - 40)
                    text2black.resize(500, text2height + 10)
                    await text2black.print(arial, 20, 5, { text: Discord.Util.cleanContent(text2, msg), alignmentX: Jimp.HORIZONTAL_ALIGN_CENTER, alignmentY: Jimp.VERTICAL_ALIGN_MIDDLE }, text2black.bitmap.width - 40, text2black.bitmap.height - 10)
                    bottomblack.resize(500, 20)
                    bgblack.resize(500, textblack.bitmap.height + text2black.bitmap.height + bottomblack.bitmap.height)
                    bgblack.composite(textblack, 0, 0)
                    bgblack.composite(text2black, 0, textblack.bitmap.height)
                    bgblack.composite(bottomblack, 0, textblack.bitmap.height + text2black.bitmap.height)
                    await bgblack.writeAsync(`${filepath}/captions.png`)

                    await execPromise(`ffmpeg -i ${filepath}/${filename} -i ${filepath}/border.png -filter_complex "[0:v]scale=400:-1[scaled];[1:v][scaled]overlay=x=W/2-w/2:y=H/2-h/2:format=auto[oout];[oout]split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ${findpreset(args)} -gifflags -offsetting ${filepath}/frame.gif`)
                    await execPromise(`ffmpeg -i ${filepath}/frame.gif -i ${filepath}/captions.png -filter_complex "vstack=inputs=2[oout];[oout]split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ${findpreset(args)} -gifflags -offsetting ${filepath}/output.gif`)
                    await sendFile(msg, filepath, `output.gif`)
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "meme2/demotivator/motivator \"{topText}\" \"[bottomText]\" <file>",
                "value": "Adds a demotivator caption to the file."
            },
            cooldown: 2500,
            type: "Captions"
        },

        {
            name: ["meme3", "caption"],
            execute: async function (msg, args, pathObject) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && validUrl.test(args[args.length - 1]) === false) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var size = 1
                var sizeindex = args.indexOf('-size')
                if (sizeindex > -1) {
                    size = isNaN(Number(args[sizeindex + 1])) ? 1 : Number(args[sizeindex + 1]) <= 0.5 ? 0.5 : Number(args[sizeindex + 1]) >= 5 ? 5 : Number(args[sizeindex + 1]) || 1
                }
                var saidMessage = args.join(' ').substring(args[0].length + 1).replace(/‚Äô/g, '\'')
                symbolreplacements.forEach(symbolReplacement => {
                    symbolReplacement.target.forEach(target => {
                        saidMessage = saidMessage.replace(new RegExp(target, 'ig'), symbolReplacement.replacement)
                    })
                })
                var matchedTextes = saidMessage.match(/"([\s\S]*?)"/g)
                if (!matchedTextes) {
                    matchedTextes = ['""']
                }
                var text = matchedTextes[0].substring(1, matchedTextes[0].length - 1)
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
                var fileinfo

                if (pathObject) {
                    fileinfo = await validateFileFromPath(`${pathObject.path}/${pathObject.name}`).catch(error => {
                        msg.channel.send(error)
                        msg.channel.sendTyping().catch(() => { })
                        return;
                    })
                } else {
                    fileinfo = await validateFile(currenturl).catch(error => {
                        msg.channel.send(error)
                        msg.channel.sendTyping().catch(() => { })
                        return;
                    })
                }

                if (!fileinfo) return
                var type = fileinfo.type

                if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                    var filepath
                    var filename
                    var object

                    if (pathObject) {
                        filepath = pathObject.path
                        filename = pathObject.name
                        object = pathObject
                        object.chaincount++
                        object.name = `output${object.chaincount}.png`
                        if (!object.otherNames) {
                            object.otherNames = {}
                        }
                        object.otherNames.caption = `caption${object.chaincount}.png`
                    } else {
                        filepath = await downloadFile(currenturl, `input.png`, {
                            fileinfo: fileinfo
                        })
                        filename = `input.png`
                        object = {
                            path: filepath,
                            name: `output.png`,
                            otherNames: {
                                caption: `caption.png`
                            },
                            chaincount: 0
                        }
                    }

                    var width = fileinfo.info.width
                    var height = fileinfo.info.height

                    var white = await Jimp.read('templates/white.png')
                    var futura = await Jimp.loadFont('templates/fonts/FuturaCondensed/FuturaCondensed.fnt')
                    white.resize(width, height)
                    white.resize(Math.round(2000 / size), Jimp.AUTO)
                    var defaultheight = futura.common.lineHeight
                    var textheight = Jimp.measureTextHeight(futura, text, white.bitmap.width - Math.round(160 / size))
                    white.resize(Math.round(2000 / size), textheight + Math.round(160 / size))
                    await white.print(futura, Math.round(80 / size), Math.round(80 / size), { text: Discord.Util.cleanContent(text, msg), alignmentX: Jimp.HORIZONTAL_ALIGN_CENTER, alignmentY: Jimp.VERTICAL_ALIGN_MIDDLE }, white.bitmap.width - Math.round(160 / size), white.bitmap.height - Math.round(160 / size))
                    white.resize(width, Jimp.AUTO)
                    await white.writeAsync(`${filepath}/${object.otherNames.caption}`)

                    await execPromise(`ffmpeg -i ${filepath}/${object.otherNames.caption} -i ${filepath}/${filename} -filter_complex "vstack=inputs=2[out]" -map "[out]" -preset ${findpreset(args)} ${filepath}/${object.name}`)

                    if (args.join(' ').includes('-chain')) {
                        return object
                    } else {
                        await sendFile(msg, filepath, object.name)
                    }
                } else if (type.mime.startsWith('video')) {
                    var filepath
                    var filename
                    var object

                    if (pathObject) {
                        filepath = pathObject.path
                        filename = pathObject.name
                        object = pathObject
                        object.chaincount++
                        object.name = `output${object.chaincount}.mp4`
                        if (!object.otherNames) {
                            object.otherNames = {}
                        }
                        object.otherNames.caption = `caption${object.chaincount}.png`
                    } else {
                        filepath = await downloadFile(currenturl, `input.mp4`, {
                            fileinfo: fileinfo
                        })
                        filename = `input.mp4`
                        object = {
                            path: filepath,
                            name: `output.mp4`,
                            otherNames: {
                                caption: `caption.png`
                            },
                            chaincount: 0
                        }
                    }

                    var width = fileinfo.info.width
                    var height = fileinfo.info.height
                    var fps = fileinfo.info.fps

                    var white = await Jimp.read('templates/white.png')
                    var futura = await Jimp.loadFont('templates/fonts/FuturaCondensed/FuturaCondensed.fnt')
                    white.resize(width, height)
                    white.resize(Math.round(2000 / size), Jimp.AUTO)
                    var defaultheight = futura.common.lineHeight
                    var textheight = Jimp.measureTextHeight(futura, text, white.bitmap.width - Math.round(160 / size))
                    white.resize(Math.round(2000 / size), textheight + Math.round(160 / size))
                    await white.print(futura, Math.round(80 / size), Math.round(80 / size), { text: Discord.Util.cleanContent(text, msg), alignmentX: Jimp.HORIZONTAL_ALIGN_CENTER, alignmentY: Jimp.VERTICAL_ALIGN_MIDDLE }, white.bitmap.width - Math.round(160 / size), white.bitmap.height - Math.round(160 / size))
                    white.resize(width, Jimp.AUTO)
                    await white.writeAsync(`${filepath}/${object.otherNames.caption}`)

                    await execPromise(`ffmpeg ${fps.includes('0/0') ? '' : `-r ${fps.includes('0/0') ? '50' : fps} `}-i ${filepath}/${object.otherNames.caption} ${fps.includes('0/0') ? '' : `-r ${fps.includes('0/0') ? '50' : fps} `}-i ${filepath}/${filename} -map 1:a? -filter_complex "vstack=inputs=2[oout];[oout]scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ${findpreset(args)} -c:v libx264 -pix_fmt yuv420p ${filepath}/${object.name}`)

                    if (args.join(' ').includes('-chain')) {
                        return object
                    } else {
                        await sendFile(msg, filepath, object.name)
                    }
                } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                    var filepath
                    var filename
                    var object

                    if (pathObject) {
                        filepath = pathObject.path
                        filename = pathObject.name
                        object = pathObject
                        object.chaincount++
                        object.name = `output${object.chaincount}.gif`
                        if (!object.otherNames) {
                            object.otherNames = {}
                        }
                        object.otherNames.caption = `caption${object.chaincount}.png`
                    } else {
                        filepath = await downloadFile(currenturl, `input.gif`, {
                            fileinfo: fileinfo
                        })
                        filename = `input.gif`
                        object = {
                            path: filepath,
                            name: `output.gif`,
                            otherNames: {
                                caption: `caption.png`
                            },
                            chaincount: 0
                        }
                    }

                    var width = fileinfo.info.width
                    var height = fileinfo.info.height
                    var fps = fileinfo.info.fps

                    var white = await Jimp.read('templates/white.png')
                    var futura = await Jimp.loadFont('templates/fonts/FuturaCondensed/FuturaCondensed.fnt')
                    white.resize(width, height)
                    white.resize(Math.round(2000 / size), Jimp.AUTO)
                    var defaultheight = futura.common.lineHeight
                    var textheight = Jimp.measureTextHeight(futura, text, white.bitmap.width - Math.round(160 / size))
                    white.resize(Math.round(2000 / size), textheight + Math.round(160 / size))
                    await white.print(futura, Math.round(80 / size), Math.round(80 / size), { text: Discord.Util.cleanContent(text, msg), alignmentX: Jimp.HORIZONTAL_ALIGN_CENTER, alignmentY: Jimp.VERTICAL_ALIGN_MIDDLE }, white.bitmap.width - Math.round(160 / size), white.bitmap.height - Math.round(160 / size))
                    white.resize(width, Jimp.AUTO)
                    await white.writeAsync(`${filepath}/${object.otherNames.caption}`)

                    await execPromise(`ffmpeg ${fps.includes('0/0') ? '' : `-r ${fps.includes('0/0') ? '50' : fps} `}-i ${filepath}/${object.otherNames.caption} ${fps.includes('0/0') ? '' : `-r ${fps.includes('0/0') ? '50' : fps} `}-i ${filepath}/${filename} -filter_complex "vstack=inputs=2[oout];[oout]split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ${findpreset(args)} -gifflags -offsetting ${filepath}/${object.name}`)

                    if (args.join(' ').includes('-chain')) {
                        return object
                    } else {
                        await sendFile(msg, filepath, object.name)
                    }
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "meme3/caption \"{text}\" <file> [-size <multiplier (from 0.5 to 5)>]",
                "value": "Adds a white box caption to the file."
            },
            cooldown: 2500,
            type: "Captions"
        },

        {
            name: ["stuff"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && validUrl.test(args[args.length - 1]) === false) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var saidMessage = args.join(' ').substring(args[0].length + 1).replace(/‚Äô/g, '\'')
                symbolreplacements.forEach(symbolReplacement => {
                    symbolReplacement.target.forEach(target => {
                        saidMessage = saidMessage.replace(new RegExp(target, 'ig'), symbolReplacement.replacement)
                    })
                })
                var matchedTextes = saidMessage.match(/"([\s\S]*?)"/g)
                if (!matchedTextes) {
                    matchedTextes = ['""']
                }
                var text = matchedTextes[0].substring(1, matchedTextes[0].length - 1)
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
                var fileinfo = await validateFile(currenturl).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })

                if (!fileinfo) return
                var type = fileinfo.type

                if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                    var filepath = await downloadFile(currenturl, `input.png`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.png`
                    var width = fileinfo.info.width
                    var stuff = await Jimp.read('templates/stuff.png')
                    var caption = stuff
                    var white = await Jimp.read('templates/white.png')
                    var tnr = await Jimp.loadFont('templates/fonts/TimesNewRomanBlack/TimesNewRomanBlack.fnt')
                    var textheight = Jimp.measureTextHeight(tnr, text, 643)
                    if (textheight > stuff.bitmap.height - 120) {
                        caption = white
                        white.resize(stuff.bitmap.width, textheight + 120)
                        white.composite(stuff, 0, white.bitmap.height - stuff.bitmap.height)
                    }
                    await caption.print(tnr, 60, 60, { text: Discord.Util.cleanContent(text, msg), alignmentX: Jimp.HORIZONTAL_ALIGN_LEFT, alignmentY: Jimp.VERTICAL_ALIGN_TOP }, 643, caption.bitmap.height - 120)
                    caption.resize(width, Jimp.AUTO)
                    await caption.writeAsync(`${filepath}/stuff.png`)

                    await execPromise(`ffmpeg -i ${filepath}/${filename} -i ${filepath}/stuff.png -filter_complex "vstack=inputs=2[out]" -map "[out]" -preset ${findpreset(args)} ${filepath}/output.png`)
                    await sendFile(msg, filepath, `output.png`)
                } else if (type.mime.startsWith('video')) {
                    var filepath = await downloadFile(currenturl, `input.mp4`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp4`
                    var fps = fileinfo.info.fps

                    var width = fileinfo.info.width

                    var stuff = await Jimp.read('templates/stuff.png')
                    var caption = stuff
                    var white = await Jimp.read('templates/white.png')
                    var tnr = await Jimp.loadFont('templates/fonts/TimesNewRomanBlack/TimesNewRomanBlack.fnt')
                    var textheight = Jimp.measureTextHeight(tnr, text, 643)
                    if (textheight > stuff.bitmap.height - 120) {
                        caption = white
                        white.resize(stuff.bitmap.width, textheight + 120)
                        white.composite(stuff, 0, white.bitmap.height - stuff.bitmap.height)
                    }
                    await caption.print(tnr, 60, 60, { text: Discord.Util.cleanContent(text, msg), alignmentX: Jimp.HORIZONTAL_ALIGN_LEFT, alignmentY: Jimp.VERTICAL_ALIGN_TOP }, 643, caption.bitmap.height - 120)
                    caption.resize(width, Jimp.AUTO)
                    await caption.writeAsync(`${filepath}/stuff.png`)

                    await execPromise(`ffmpeg ${fps.includes('0/0') ? '' : `-r ${fps.includes('0/0') ? '50' : fps} `}-i ${filepath}/${filename} ${fps.includes('0/0') ? '' : `-r ${fps.includes('0/0') ? '50' : fps} `}-i ${filepath}/stuff.png -map 0:a? -filter_complex "vstack=inputs=2[oout];[oout]scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ${findpreset(args)} -c:v libx264 -pix_fmt yuv420p ${filepath}/output.mp4`)
                    await sendFile(msg, filepath, `output.mp4`)
                } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                    var filepath = await downloadFile(currenturl, `input.gif`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.gif`
                    var fps = fileinfo.info.fps

                    var width = fileinfo.info.width

                    var stuff = await Jimp.read('templates/stuff.png')
                    var caption = stuff
                    var white = await Jimp.read('templates/white.png')
                    var tnr = await Jimp.loadFont('templates/fonts/TimesNewRomanBlack/TimesNewRomanBlack.fnt')
                    var textheight = Jimp.measureTextHeight(tnr, text, 643)
                    if (textheight > stuff.bitmap.height - 120) {
                        caption = white
                        white.resize(stuff.bitmap.width, textheight + 120)
                        white.composite(stuff, 0, white.bitmap.height - stuff.bitmap.height)
                    }
                    await caption.print(tnr, 60, 60, { text: Discord.Util.cleanContent(text, msg), alignmentX: Jimp.HORIZONTAL_ALIGN_LEFT, alignmentY: Jimp.VERTICAL_ALIGN_TOP }, 643, caption.bitmap.height - 120)
                    caption.resize(width, Jimp.AUTO)
                    await caption.writeAsync(`${filepath}/stuff.png`)

                    await execPromise(`ffmpeg ${fps.includes('0/0') ? '' : `-r ${fps.includes('0/0') ? '50' : fps} `}-i ${filepath}/${filename} ${fps.includes('0/0') ? '' : `-r ${fps.includes('0/0') ? '50' : fps} `}-i ${filepath}/stuff.png -filter_complex "vstack=inputs=2[oout];[oout]split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ${findpreset(args)} -gifflags -offsetting ${filepath}/output.gif`)
                    await sendFile(msg, filepath, `output.gif`)
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "stuff \"{text}\" <file>",
                "value": "I'm stuff"
            },
            cooldown: 2500,
            type: "Captions"
        },

        {
            name: ["snapchat"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && validUrl.test(args[args.length - 1]) === false) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var size = 1
                var sizeindex = args.indexOf('-size')
                if (sizeindex > -1) {
                    size = isNaN(Number(args[sizeindex + 1])) ? 1 : Number(args[sizeindex + 1]) <= 0.5 ? 0.5 : Number(args[sizeindex + 1]) >= 5 ? 5 : Number(args[sizeindex + 1]) || 1
                }
                var saidMessage = args.join(' ').substring(args[0].length + 1).replace(/‚Äô/g, '\'')
                symbolreplacements.forEach(symbolReplacement => {
                    symbolReplacement.target.forEach(target => {
                        saidMessage = saidMessage.replace(new RegExp(target, 'ig'), symbolReplacement.replacement)
                    })
                })
                var matchedTextes = saidMessage.match(/"([\s\S]*?)"/g)
                if (!matchedTextes) {
                    matchedTextes = ['""']
                }
                var text = matchedTextes[0].substring(1, matchedTextes[0].length - 1)
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
                var fileinfo = await validateFile(currenturl).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })

                if (!fileinfo) return
                var type = fileinfo.type

                if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                    var filepath = await downloadFile(currenturl, `input.png`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.png`
                    var width = fileinfo.info.width
                    var height = fileinfo.info.height
                    var snapchat = await Jimp.read('templates/snapchat.png')
                    var helvetica = await Jimp.loadFont('templates/fonts/Helvetica/Helvetica.fnt')
                    snapchat.resize(width, height)
                    snapchat.resize(Jimp.AUTO, Math.round(2000 / size))
                    var textheight = Jimp.measureTextHeight(helvetica, text, snapchat.bitmap.width - Math.round(100 / size))
                    snapchat.resize(snapchat.bitmap.width, textheight + Math.round(100 / size))
                    await snapchat.print(helvetica, Math.round(50 / size), Math.round(50 / size), { text: Discord.Util.cleanContent(text, msg), alignmentX: Jimp.HORIZONTAL_ALIGN_CENTER, alignmentY: Jimp.VERTICAL_ALIGN_MIDDLE }, snapchat.bitmap.width - Math.round(100 / size), snapchat.bitmap.height - Math.round(100 / size))
                    snapchat.resize(width, Jimp.AUTO)
                    await snapchat.writeAsync(`${filepath}/caption.png`)

                    await execPromise(`ffmpeg -i ${filepath}/${filename} -i ${filepath}/caption.png -filter_complex "[0:v][1:v]overlay=x=(W-w)/2:y=H/5*4-h/2:format=auto[out]" -map "[out]" -preset ${findpreset(args)} ${filepath}/output.png`)
                    await sendFile(msg, filepath, `output.png`)
                } else if (type.mime.startsWith('video')) {
                    var filepath = await downloadFile(currenturl, `input.mp4`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp4`
                    var width = fileinfo.info.width
                    var height = fileinfo.info.height
                    var snapchat = await Jimp.read('templates/snapchat.png')
                    var helvetica = await Jimp.loadFont('templates/fonts/Helvetica/Helvetica.fnt')
                    snapchat.resize(width, height)
                    snapchat.resize(Jimp.AUTO, Math.round(2000 / size))
                    var textheight = Jimp.measureTextHeight(helvetica, text, snapchat.bitmap.width - Math.round(100 / size))
                    snapchat.resize(snapchat.bitmap.width, textheight + Math.round(100 / size))
                    await snapchat.print(helvetica, Math.round(50 / size), Math.round(50 / size), { text: Discord.Util.cleanContent(text, msg), alignmentX: Jimp.HORIZONTAL_ALIGN_CENTER, alignmentY: Jimp.VERTICAL_ALIGN_MIDDLE }, snapchat.bitmap.width - Math.round(100 / size), snapchat.bitmap.height - Math.round(100 / size))
                    snapchat.resize(width, Jimp.AUTO)
                    await snapchat.writeAsync(`${filepath}/caption.png`)

                    await execPromise(`ffmpeg -i ${filepath}/${filename} -i ${filepath}/caption.png -map 0:a? -filter_complex "[0:v][1:v]overlay=x=(W-w)/2:y=H/5*4-h/2[oout];[oout]scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ${findpreset(args)} -c:v libx264 -pix_fmt yuv420p ${filepath}/output.mp4`)
                    await sendFile(msg, filepath, `output.mp4`)
                } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                    var filepath = await downloadFile(currenturl, `input.gif`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.gif`
                    var width = fileinfo.info.width
                    var height = fileinfo.info.height
                    var snapchat = await Jimp.read('templates/snapchat.png')
                    var helvetica = await Jimp.loadFont('templates/fonts/Helvetica/Helvetica.fnt')
                    snapchat.resize(width, height)
                    snapchat.resize(Jimp.AUTO, Math.round(2000 / size))
                    var textheight = Jimp.measureTextHeight(helvetica, text, snapchat.bitmap.width - Math.round(100 / size))
                    snapchat.resize(snapchat.bitmap.width, textheight + Math.round(100 / size))
                    await snapchat.print(helvetica, Math.round(50 / size), Math.round(50 / size), { text: Discord.Util.cleanContent(text, msg), alignmentX: Jimp.HORIZONTAL_ALIGN_CENTER, alignmentY: Jimp.VERTICAL_ALIGN_MIDDLE }, snapchat.bitmap.width - Math.round(100 / size), snapchat.bitmap.height - Math.round(100 / size))
                    snapchat.resize(width, Jimp.AUTO)
                    await snapchat.writeAsync(`${filepath}/caption.png`)

                    await execPromise(`ffmpeg -i ${filepath}/${filename} -i ${filepath}/caption.png -filter_complex "[0:v][1:v]overlay=x=(W-w)/2:y=H/5*4-h/2[oout];[oout]split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ${findpreset(args)} -gifflags -offsetting ${filepath}/output.gif`)
                    await sendFile(msg, filepath, `output.gif`)
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "snapchat \"{text}\" <file> [-size <multiplier (from 0.5 to 5)>]",
                "value": "Adds a Snapchat caption to the file."
            },
            cooldown: 2500,
            type: "Captions"
        },

        {
            name: ["60fps"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[2] === undefined) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl']
                var speed = isNaN(Number(args[1])) ? 2 : Number(args[1]) <= 1 ? 1 : Number(args[1]) >= 6 ? 6 : Number(args[1]) || 2
                var fileinfo = await validateFile(currenturl).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })

                if (!fileinfo) return
                var type = fileinfo.type

                if (type.mime.startsWith('video')) {
                    var filepath = await downloadFile(currenturl, `input.mp4`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp4`
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -map 0:a? -filter_complex "[0:v]minterpolate='fps=60',scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ${findpreset(args)} -c:v libx264 -pix_fmt yuv420p ${filepath}/output.mp4`)
                    await sendFile(msg, filepath, `output.mp4`)
                } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                    var filepath = await downloadFile(currenturl, `input.gif`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.gif`
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -filter_complex "[0:v]minterpolate='fps=50',split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ${findpreset(args)} -gifflags -offsetting ${filepath}/output.gif`)
                    await sendFile(msg, filepath, `output.gif`)
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "60fps <file>",
                "value": "Makes the file 60 FPS by using interpolation."
            },
            cooldown: 2500,
            type: "Effects"
        },

        {
            name: ["speedup", "speed"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[2] === undefined) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl']
                var speed = isNaN(Number(args[1])) ? 2 : Number(args[1]) <= 1 ? 1 : Number(args[1]) >= 6 ? 6 : Number(args[1]) || 2
                var fileinfo = await validateFile(currenturl, true).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })

                if (!fileinfo) return
                var type = fileinfo.type

                if (type.mime.startsWith('video')) {
                    var filepath = await downloadFile(currenturl, `input.mp4`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp4`
                    var fps = fileinfo.info.fps
                    var audio = fileinfo.info.audio

                    if (audio) {
                        await execPromise(`ffmpeg -i ${filepath}/${filename} -filter_complex "[0:v]fps=fps='min(60,${fps.includes('0/0') ? '60' : fps}*${speed})',setpts=(1/${speed})*PTS,scale=ceil(iw/2)*2:ceil(ih/2)*2[v];[0:a]atempo=${speed}[a]" -map "[v]" -map "[a]" -preset ${findpreset(args)} -c:v libx264 -pix_fmt yuv420p ${filepath}/output.mp4`)
                        await sendFile(msg, filepath, `output.mp4`)
                    } else {
                        await execPromise(`ffmpeg -i ${filepath}/${filename} -filter_complex "[0:v]fps=fps='min(60,${fps.includes('0/0') ? '60' : fps}*${speed})',setpts=(1/${speed})*PTS,scale=ceil(iw/2)*2:ceil(ih/2)*2[v]" -map "[v]" -c:v libx264 -pix_fmt yuv420p ${filepath}/output.mp4`)
                        await sendFile(msg, filepath, `output.mp4`)
                    }
                } else if (type.mime.startsWith('audio')) {
                    var filepath = await downloadFile(currenturl, `input.mp3`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp3`
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -filter_complex "[0:a]atempo=${speed}[a]" -map "[a]" -preset ${findpreset(args)} ${filepath}/output.mp3`)
                    await sendFile(msg, filepath, `output.mp3`)
                } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                    var filepath = await downloadFile(currenturl, `input.gif`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.gif`
                    var fps = fileinfo.info.fps

                    await execPromise(`ffmpeg -i ${filepath}/${filename} -filter_complex "[0:v]fps=fps='min(50,${fps.includes('0/0') ? '50' : fps}*${speed})',setpts=(1/${speed})*PTS,split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ${findpreset(args)} -gifflags -offsetting ${filepath}/output.gif`)
                    await sendFile(msg, filepath, `output.gif`)
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "speedup/speed [multiplier (from 1 to 6)] <file>",
                "value": "Speeds up the file by multiplier. Default is 2."
            },
            cooldown: 2500,
            type: "Duration"
        },

        {
            name: ["duration", "stretch"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[2] === undefined) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl']
                var duration = isNaN(Number(args[1])) ? undefined : Number(args[1]) <= 0 ? 0 : Number(args[1]) >= 60 ? 60 : Number(args[1]) || undefined
                if (duration === undefined) {
                    msg.channel.send('What is the duration?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                }
                var fileinfo = await validateFile(currenturl, true).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })

                if (!fileinfo) return
                var type = fileinfo.type

                if (type.mime.startsWith('video')) {
                    var filepath = await downloadFile(currenturl, `input.mp4`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp4`
                    var fps = fileinfo.info.fps
                    var iduration = Number(fileinfo.info.duration)
                    var audio = fileinfo.info.audio

                    if (audio) {
                        var smult = iduration / duration
                        var speedfilter = []

                        while (smult < 0.5) {
                            smult *= 2
                            speedfilter.push(`atempo=0.5`)
                        }

                        speedfilter.push(`atempo=${smult}`)
                        await execPromise(`ffmpeg -i ${filepath}/${filename} -filter_complex "[0:v]fps=fps='min(60,${fps.includes('0/0') ? '60' : fps}*(${iduration / duration}))',setpts=PTS/(${iduration / duration}),scale=ceil(iw/2)*2:ceil(ih/2)*2[v];[0:a]${speedfilter.join(',')}[a]" -map "[v]" -map "[a]" -preset ${findpreset(args)} -c:v libx264 -pix_fmt yuv420p ${filepath}/output.mp4`)
                        await sendFile(msg, filepath, `output.mp4`)
                    } else {
                        await execPromise(`ffmpeg -i ${filepath}/${filename} -filter_complex "[0:v]fps=fps='min(60,${fps.includes('0/0') ? '60' : fps}*(${iduration / duration}))',setpts=PTS/(${iduration / duration}),scale=ceil(iw/2)*2:ceil(ih/2)*2[v]" -map "[v]" -c:v libx264 -pix_fmt yuv420p ${filepath}/output.mp4`)
                        await sendFile(msg, filepath, `output.mp4`)
                    }
                } else if (type.mime.startsWith('audio')) {
                    var filepath = await downloadFile(currenturl, `input.mp3`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp3`
                    var iduration = Number(fileinfo.info.duration)
                    var smult = iduration / duration
                    var speedfilter = []

                    while (smult < 0.5) {
                        smult *= 2
                        speedfilter.push(`atempo=0.5`)
                    }

                    speedfilter.push(`atempo=${smult}`)

                    await execPromise(`ffmpeg -i ${filepath}/${filename} -filter_complex "[0:a]${speedfilter.join(',')}[a]" -map "[a]" -preset ${findpreset(args)} ${filepath}/output.mp3`)
                    await sendFile(msg, filepath, `output.mp3`)
                } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                    var filepath = await downloadFile(currenturl, `input.gif`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.gif`
                    var fps = fileinfo.info.fps
                    var iduration = Number(fileinfo.info.duration)

                    await execPromise(`ffmpeg -i ${filepath}/${filename} -filter_complex "[0:v]fps=fps='min(50,${fps.includes('0/0') ? '50' : fps}*(${iduration / duration}))',setpts=PTS/(${iduration / duration}),split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ${findpreset(args)} -gifflags -offsetting ${filepath}/output.gif`)
                    await sendFile(msg, filepath, `output.gif`)
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "<:newpoopy:839191885310066729> duration/stretch <seconds (max 60)> <file>",
                "value": "Stretches the file to match the supplied duration in seconds."
            },
            cooldown: 2500,
            type: "Duration"
        },

        {
            name: ["nervous", "randomorder", "randomframes"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[2] === undefined) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var frames = 30
                var framesindex = args.indexOf('-frames')
                if (framesindex > -1) {
                    frames = isNaN(Number(args[framesindex + 1])) ? 30 : Number(args[framesindex + 1]) <= 2 ? 2 : Number(args[framesindex + 1]) >= 512 ? 512 : Math.round(Number(args[framesindex + 1])) || 30
                }
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl']
                var fileinfo = await validateFile(currenturl).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })

                if (!fileinfo) return
                var type = fileinfo.type

                if (type.mime.startsWith('video')) {
                    var filepath = await downloadFile(currenturl, `input.mp4`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp4`
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -map 0:a? -filter_complex "[0:v]random=frames=${frames},scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ${findpreset(args)} -c:v libx264 -pix_fmt yuv420p ${filepath}/output.mp4`)
                    await sendFile(msg, filepath, `output.mp4`)
                } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                    var filepath = await downloadFile(currenturl, `input.gif`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.gif`
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -filter_complex "[0:v]random=frames=${frames},split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ${findpreset(args)} -gifflags -offsetting ${filepath}/output.gif`)
                    await sendFile(msg, filepath, `output.gif`)
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "nervous/randomorder/randomframes <file> [-frames <number (from 2 to 512)>]",
                "value": "Adds a nervous effect to the file, with the frames going into random orders all the time. Default frames are 30."
            },
            cooldown: 2500,
            type: "Effects"
        },

        {
            name: ["trim", "cut"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[2] === undefined) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl']
                var fileinfo = await validateFile(currenturl, true).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })

                if (!fileinfo) return
                var type = fileinfo.type

                if (type.mime.startsWith('video')) {
                    var filepath = await downloadFile(currenturl, `input.mp4`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp4`
                    var duration = Number(fileinfo.info.duration)

                    var start = 0
                    var startindex = args.indexOf('-start')
                    if (startindex > -1) {
                        var startstamp = args[startindex + 1]
                        if (startstamp !== undefined) {
                            var total = 0
                            startstamp = startstamp.split(':').reverse()
                            startstamp.splice(3)
                            for (var i = 0; i < startstamp.length; i++) {
                                startstamp[i] = isNaN(Number(startstamp[i])) ? 0 : Number(startstamp[i]) <= 0 ? 0 : Number(startstamp[i]) * (Math.pow(60, i)) || 0
                                total += startstamp[i]
                            }
                            start = total >= duration ? duration : total
                        }
                    }
                    var end = duration
                    var endindex = args.indexOf('-end')
                    if (endindex > -1) {
                        var endstamp = args[endindex + 1]
                        if (endstamp !== undefined) {
                            var total = 0
                            endstamp = endstamp.split(':').reverse()
                            endstamp.splice(3)
                            for (var i = 0; i < endstamp.length; i++) {
                                endstamp[i] = isNaN(Number(endstamp[i])) ? 0 : Number(endstamp[i]) <= 0 ? 0 : Number(endstamp[i]) * (Math.pow(60, i)) || 0
                                total += endstamp[i]
                            }
                            end = total >= duration ? duration : total
                        }
                    }
                    if (end <= start) {
                        end = start
                    }

                    await execPromise(`ffmpeg -ss ${start} -t ${end - start} -i ${filepath}/${filename} -vf "scale=ceil(iw/2)*2:ceil(ih/2)*2" -preset ${findpreset(args)} -c:v libx264 -pix_fmt yuv420p ${filepath}/output.mp4`)
                    await sendFile(msg, filepath, `output.mp4`)
                } else if (type.mime.startsWith('audio')) {
                    var filepath = await downloadFile(currenturl, `input.mp3`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp3`
                    var duration = Number(fileinfo.info.duration)

                    var start = 0
                    var startindex = args.indexOf('-start')
                    if (startindex > -1) {
                        var startstamp = args[startindex + 1]
                        if (startstamp !== undefined) {
                            var total = 0
                            startstamp = startstamp.split(':').reverse()
                            startstamp.splice(3)
                            for (var i = 0; i < startstamp.length; i++) {
                                startstamp[i] = isNaN(Number(startstamp[i])) ? 0 : Number(startstamp[i]) <= 0 ? 0 : Number(startstamp[i]) * (Math.pow(60, i)) || 0
                                total += startstamp[i]
                            }
                            start = total >= duration ? duration : total
                        }
                    }
                    var end = duration
                    var endindex = args.indexOf('-end')
                    if (endindex > -1) {
                        var endstamp = args[endindex + 1]
                        if (endstamp !== undefined) {
                            var total = 0
                            endstamp = endstamp.split(':').reverse()
                            endstamp.splice(3)
                            for (var i = 0; i < endstamp.length; i++) {
                                endstamp[i] = isNaN(Number(endstamp[i])) ? 0 : Number(endstamp[i]) <= 0 ? 0 : Number(endstamp[i]) * (Math.pow(60, i)) || 0
                                total += endstamp[i]
                            }
                            end = total >= duration ? duration : total
                        }
                    }
                    if (end <= start) {
                        end = start
                    }

                    await execPromise(`ffmpeg -ss ${start} -t ${end - start} -i ${filepath}/${filename} -preset ${findpreset(args)} ${filepath}/output.mp3`)
                    await sendFile(msg, filepath, `output.mp3`)
                } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                    var filepath = await downloadFile(currenturl, `input.gif`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.gif`
                    var duration = Number(fileinfo.info.duration)

                    var start = 0
                    var startindex = args.indexOf('-start')
                    if (startindex > -1) {
                        var startstamp = args[startindex + 1]
                        if (startstamp !== undefined) {
                            var total = 0
                            startstamp = startstamp.split(':').reverse()
                            startstamp.splice(3)
                            for (var i = 0; i < startstamp.length; i++) {
                                startstamp[i] = isNaN(Number(startstamp[i])) ? 0 : Number(startstamp[i]) <= 0 ? 0 : Number(startstamp[i]) * (Math.pow(60, i)) || 0
                                total += startstamp[i]
                            }
                            start = total >= duration ? duration : total
                        }
                    }
                    var end = duration
                    var endindex = args.indexOf('-end')
                    if (endindex > -1) {
                        var endstamp = args[endindex + 1]
                        if (endstamp !== undefined) {
                            var total = 0
                            endstamp = endstamp.split(':').reverse()
                            endstamp.splice(3)
                            for (var i = 0; i < endstamp.length; i++) {
                                endstamp[i] = isNaN(Number(endstamp[i])) ? 0 : Number(endstamp[i]) <= 0 ? 0 : Number(endstamp[i]) * (Math.pow(60, i)) || 0
                                total += endstamp[i]
                            }
                            end = total >= duration ? duration : total
                        }
                    }
                    if (end <= start) {
                        end = start
                    }

                    await execPromise(`ffmpeg -ss ${start} -t ${end - start} -i ${filepath}/${filename} -filter_complex "[0:v]split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ${findpreset(args)} -gifflags -offsetting ${filepath}/output.gif`)
                    await sendFile(msg, filepath, `output.gif`)
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "trim/cut [-start <timestamp (you can use hh:mm:ss)>] [-end <timestamp (you can use hh:mm:ss)>] <file>",
                "value": "Trims the file from the start timestamp and the end timestamp."
            },
            cooldown: 2500,
            type: "Duration"
        },

        {
            name: ["remove", "reversetrim"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[2] === undefined) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl']
                var fileinfo = await validateFile(currenturl, true).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })

                if (!fileinfo) return
                var type = fileinfo.type

                if (type.mime.startsWith('video')) {
                    var filepath = await downloadFile(currenturl, `input.mp4`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp4`
                    var duration = Number(fileinfo.info.duration)
                    var audio = fileinfo.info.audio

                    var start = 0
                    var startindex = args.indexOf('-start')
                    if (startindex > -1) {
                        var startstamp = args[startindex + 1]
                        if (startstamp !== undefined) {
                            var total = 0
                            startstamp = startstamp.split(':').reverse()
                            startstamp.splice(3)
                            for (var i = 0; i < startstamp.length; i++) {
                                startstamp[i] = isNaN(Number(startstamp[i])) ? 0 : Number(startstamp[i]) <= 0 ? 0 : Number(startstamp[i]) * (Math.pow(60, i)) || 0
                                total += startstamp[i]
                            }
                            start = total >= duration ? duration : total
                        }
                    }
                    var end = duration
                    var endindex = args.indexOf('-end')
                    if (endindex > -1) {
                        var endstamp = args[endindex + 1]
                        if (endstamp !== undefined) {
                            var total = 0
                            endstamp = endstamp.split(':').reverse()
                            endstamp.splice(3)
                            for (var i = 0; i < endstamp.length; i++) {
                                endstamp[i] = isNaN(Number(endstamp[i])) ? 0 : Number(endstamp[i]) <= 0 ? 0 : Number(endstamp[i]) * (Math.pow(60, i)) || 0
                                total += endstamp[i]
                            }
                            end = total >= duration ? duration : total
                        }
                    }
                    if (end <= start) {
                        end = start
                    }

                    await execPromise(`ffmpeg -t ${start} -i ${filepath}/${filename} -ss ${end} -i ${filepath}/${filename} -filter_complex "[0:v][1:v]concat,scale=ceil(iw/2)*2:ceil(ih/2)*2[v]${audio ? `;[0:a][1:a]concat=v=0:a=1[a]` : ''}" -map "[v]" ${audio ? '-map "[a]" ' : ''}-preset ${findpreset(args)} -c:v libx264 -pix_fmt yuv420p ${filepath}/output.mp4`)
                    await sendFile(msg, filepath, `output.mp4`)
                } else if (type.mime.startsWith('audio')) {
                    var filepath = await downloadFile(currenturl, `input.mp3`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp3`
                    var duration = Number(fileinfo.info.duration)

                    var start = 0
                    var startindex = args.indexOf('-start')
                    if (startindex > -1) {
                        var startstamp = args[startindex + 1]
                        if (startstamp !== undefined) {
                            var total = 0
                            startstamp = startstamp.split(':').reverse()
                            startstamp.splice(3)
                            for (var i = 0; i < startstamp.length; i++) {
                                startstamp[i] = isNaN(Number(startstamp[i])) ? 0 : Number(startstamp[i]) <= 0 ? 0 : Number(startstamp[i]) * (Math.pow(60, i)) || 0
                                total += startstamp[i]
                            }
                            start = total >= duration ? duration : total
                        }
                    }
                    var end = duration
                    var endindex = args.indexOf('-end')
                    if (endindex > -1) {
                        var endstamp = args[endindex + 1]
                        if (endstamp !== undefined) {
                            var total = 0
                            endstamp = endstamp.split(':').reverse()
                            endstamp.splice(3)
                            for (var i = 0; i < endstamp.length; i++) {
                                endstamp[i] = isNaN(Number(endstamp[i])) ? 0 : Number(endstamp[i]) <= 0 ? 0 : Number(endstamp[i]) * (Math.pow(60, i)) || 0
                                total += endstamp[i]
                            }
                            end = total >= duration ? duration : total
                        }
                    }
                    if (end <= start) {
                        end = start
                    }

                    await execPromise(`ffmpeg -t ${start} -i ${filepath}/${filename} -ss ${end} -i ${filepath}/${filename} -filter_complex "[0:a][1:a]concat=v=0:a=1[out]" -map "[out]" -preset ${findpreset(args)} ${filepath}/output.mp3`)
                    await sendFile(msg, filepath, `output.mp3`)
                } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                    var filepath = await downloadFile(currenturl, `input.gif`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.gif`
                    var duration = Number(fileinfo.info.duration)

                    var start = 0
                    var startindex = args.indexOf('-start')
                    if (startindex > -1) {
                        var startstamp = args[startindex + 1]
                        if (startstamp !== undefined) {
                            var total = 0
                            startstamp = startstamp.split(':').reverse()
                            startstamp.splice(3)
                            for (var i = 0; i < startstamp.length; i++) {
                                startstamp[i] = isNaN(Number(startstamp[i])) ? 0 : Number(startstamp[i]) <= 0 ? 0 : Number(startstamp[i]) * (Math.pow(60, i)) || 0
                                total += startstamp[i]
                            }
                            start = total >= duration ? duration : total
                        }
                    }
                    var end = duration
                    var endindex = args.indexOf('-end')
                    if (endindex > -1) {
                        var endstamp = args[endindex + 1]
                        if (endstamp !== undefined) {
                            var total = 0
                            endstamp = endstamp.split(':').reverse()
                            endstamp.splice(3)
                            for (var i = 0; i < endstamp.length; i++) {
                                endstamp[i] = isNaN(Number(endstamp[i])) ? 0 : Number(endstamp[i]) <= 0 ? 0 : Number(endstamp[i]) * (Math.pow(60, i)) || 0
                                total += endstamp[i]
                            }
                            end = total >= duration ? duration : total
                        }
                    }
                    if (end <= start) {
                        end = start
                    }

                    await execPromise(`ffmpeg -t ${start} -i ${filepath}/${filename} -ss ${end} -i ${filepath}/${filename} -filter_complex "[0:v][1:v]concat,split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ${findpreset(args)} -gifflags -offsetting ${filepath}/output.gif`)
                    await sendFile(msg, filepath, `output.gif`)
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "remove/reversetrim [-start <timestamp (you can use hh:mm:ss)>] [-end <timestamp (you can use hh:mm:ss)>] <file>",
                "value": "Removes a portion from the file from the start timestamp and the end timestamp."
            },
            cooldown: 2500,
            type: "Duration"
        },

        {
            name: ["crop"],
            execute: async function (msg, args, pathObject) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[2] === undefined) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl']
                var fileinfo

                if (pathObject) {
                    fileinfo = await validateFileFromPath(`${pathObject.path}/${pathObject.name}`, true).catch(error => {
                        msg.channel.send(error)
                        msg.channel.sendTyping().catch(() => { })
                        return;
                    })
                } else {
                    fileinfo = await validateFile(currenturl, true).catch(error => {
                        msg.channel.send(error)
                        msg.channel.sendTyping().catch(() => { })
                        return;
                    })
                }

                if (!fileinfo) return
                var type = fileinfo.type

                if (type.mime.startsWith('video')) {
                    var filepath
                    var filename
                    var object

                    if (pathObject) {
                        filepath = pathObject.path
                        filename = pathObject.name
                        object = pathObject
                        object.chaincount++
                        object.name = `output${object.chaincount}.mp4`
                    } else {
                        filepath = await downloadFile(currenturl, `input.mp4`, {
                            fileinfo: fileinfo
                        })
                        filename = `input.mp4`
                        object = {
                            path: filepath,
                            name: `output.mp4`,
                            chaincount: 0
                        }
                    }

                    var width = fileinfo.info.width
                    var height = fileinfo.info.height

                    var x = 0
                    var xindex = args.indexOf('-x')
                    if (xindex > -1) {
                        x = isNaN(Number(args[xindex + 1])) ? 0 : Number(args[xindex + 1]) <= 0 ? 0 : Number(args[xindex + 1]) >= width - 1 ? width - 1 : Math.round(Number(args[xindex + 1])) || 0
                    }

                    var y = 0
                    var yindex = args.indexOf('-y')
                    if (yindex > -1) {
                        y = isNaN(Number(args[yindex + 1])) ? 0 : Number(args[yindex + 1]) <= 0 ? 0 : Number(args[yindex + 1]) >= height - 1 ? height - 1 : Math.round(Number(args[yindex + 1])) || 0
                    }

                    var w = width - x
                    var windex = args.indexOf('-w')
                    if (windex > -1) {
                        w = isNaN(Number(args[windex + 1])) ? width - x : Number(args[windex + 1]) <= 1 ? 1 : Number(args[windex + 1]) >= width - x ? width - x : Math.round(Number(args[windex + 1])) || width - x
                    }

                    var h = height - y
                    var hindex = args.indexOf('-h')
                    if (hindex > -1) {
                        h = isNaN(Number(args[hindex + 1])) ? height - y : Number(args[hindex + 1]) <= 1 ? 1 : Number(args[hindex + 1]) >= height - y - 1 ? height - y : Math.round(Number(args[hindex + 1])) || height - y
                    }

                    await execPromise(`ffmpeg -y -i ${filepath}/${filename} -map 0:a? -filter_complex "[0:v]crop=x=${x}:y=${y}:w=${w}:h=${h},scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ${findpreset(args)} -c:v libx264 -pix_fmt yuv420p ${filepath}/${object.name}`)

                    if (args.join(' ').includes('-chain')) {
                        return object
                    } else {
                        await sendFile(msg, filepath, object.name)
                    }
                } else if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                    var filepath
                    var filename
                    var object

                    if (pathObject) {
                        filepath = pathObject.path
                        filename = pathObject.name
                        object = pathObject
                        object.chaincount++
                        object.name = `output${object.chaincount}.png`
                    } else {
                        filepath = await downloadFile(currenturl, `input.png`, {
                            fileinfo: fileinfo
                        })
                        filename = `input.png`
                        object = {
                            path: filepath,
                            name: `output.png`,
                            chaincount: 0
                        }
                    }

                    var width = fileinfo.info.width
                    var height = fileinfo.info.height

                    var x = 0
                    var xindex = args.indexOf('-x')
                    if (xindex > -1) {
                        x = isNaN(Number(args[xindex + 1])) ? 0 : Number(args[xindex + 1]) <= 0 ? 0 : Number(args[xindex + 1]) >= width - 1 ? width - 1 : Math.round(Number(args[xindex + 1])) || 0
                    }

                    var y = 0
                    var yindex = args.indexOf('-y')
                    if (yindex > -1) {
                        y = isNaN(Number(args[yindex + 1])) ? 0 : Number(args[yindex + 1]) <= 0 ? 0 : Number(args[yindex + 1]) >= height - 1 ? height - 1 : Math.round(Number(args[yindex + 1])) || 0
                    }

                    var w = width - x
                    var windex = args.indexOf('-w')
                    if (windex > -1) {
                        w = isNaN(Number(args[windex + 1])) ? width - x : Number(args[windex + 1]) <= 1 ? 1 : Number(args[windex + 1]) >= width - x ? width - x : Math.round(Number(args[windex + 1])) || width - x
                    }

                    var h = height - y
                    var hindex = args.indexOf('-h')
                    if (hindex > -1) {
                        h = isNaN(Number(args[hindex + 1])) ? height - y : Number(args[hindex + 1]) <= 1 ? 1 : Number(args[hindex + 1]) >= height - y - 1 ? height - y : Math.round(Number(args[hindex + 1])) || height - y
                    }

                    await execPromise(`ffmpeg -y -i ${filepath}/${filename} -filter_complex "[0:v]crop=x=${x}:y=${y}:w=${w}:h=${h}[out]" -map "[out]" -preset ${findpreset(args)} ${filepath}/${object.name}`)

                    if (args.join(' ').includes('-chain')) {
                        return object
                    } else {
                        await sendFile(msg, filepath, object.name)
                    }
                } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                    var filepath
                    var filename
                    var object

                    if (pathObject) {
                        filepath = pathObject.path
                        filename = pathObject.name
                        object = pathObject
                        object.chaincount++
                        object.name = `output${object.chaincount}.gif`
                    } else {
                        filepath = await downloadFile(currenturl, `input.gif`, {
                            fileinfo: fileinfo
                        })
                        filename = `input.gif`
                        object = {
                            path: filepath,
                            name: `output.gif`,
                            chaincount: 0
                        }
                    }

                    var width = fileinfo.info.width
                    var height = fileinfo.info.height

                    var x = 0
                    var xindex = args.indexOf('-x')
                    if (xindex > -1) {
                        x = isNaN(Number(args[xindex + 1])) ? 0 : Number(args[xindex + 1]) <= 0 ? 0 : Number(args[xindex + 1]) >= width - 1 ? width - 1 : Math.round(Number(args[xindex + 1])) || 0
                    }

                    var y = 0
                    var yindex = args.indexOf('-y')
                    if (yindex > -1) {
                        y = isNaN(Number(args[yindex + 1])) ? 0 : Number(args[yindex + 1]) <= 0 ? 0 : Number(args[yindex + 1]) >= height - 1 ? height - 1 : Math.round(Number(args[yindex + 1])) || 0
                    }

                    var w = width - x
                    var windex = args.indexOf('-w')
                    if (windex > -1) {
                        w = isNaN(Number(args[windex + 1])) ? width - x : Number(args[windex + 1]) <= 1 ? 1 : Number(args[windex + 1]) >= width - x ? width - x : Math.round(Number(args[windex + 1])) || width - x
                    }

                    var h = height - y
                    var hindex = args.indexOf('-h')
                    if (hindex > -1) {
                        h = isNaN(Number(args[hindex + 1])) ? height - y : Number(args[hindex + 1]) <= 1 ? 1 : Number(args[hindex + 1]) >= height - y - 1 ? height - y : Math.round(Number(args[hindex + 1])) || height - y
                    }

                    await execPromise(`ffmpeg -y -i ${filepath}/${filename} -filter_complex "[0:v]crop=x=${x}:y=${y}:w=${w}:h=${h},split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ${findpreset(args)} -gifflags -offsetting ${filepath}/${object.name}`)

                    if (args.join(' ').includes('-chain')) {
                        return object
                    } else {
                        await sendFile(msg, filepath, `output.gif`)
                    }
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "crop [-x <pixel>] [-y <pixel>] [-w <pixels>] [-h <pixels>] <file>",
                "value": "Crops the file depending on the XY axes and the width and height."
            },
            cooldown: 2500,
            type: "Resizing"
        },

        {
            name: ["slowdown", "slow"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[2] === undefined) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl']
                var speed = isNaN(Number(args[1])) ? 2 : Number(args[1]) <= 1 ? 1 : Number(args[1]) >= 6 ? 6 : Number(args[1]) || 2
                var smult = speed
                var speedfilter = []

                while (smult > 2) {
                    smult /= 2
                    speedfilter.push(`atempo=0.5`)
                }

                speedfilter.push(`atempo=(1/${smult})`)

                var fileinfo = await validateFile(currenturl).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })

                if (!fileinfo) return
                var type = fileinfo.type

                if (type.mime.startsWith('video')) {
                    var filepath = await downloadFile(currenturl, `input.mp4`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp4`
                    var fps = fileinfo.info.fps
                    var audio = fileinfo.info.audio

                    if (audio) {
                        await execPromise(`ffmpeg -i ${filepath}/${filename} -filter_complex "[0:v]setpts=${speed}*PTS,fps=fps=${fps.includes('0/0') ? '50' : fps}/${speed},scale=ceil(iw/2)*2:ceil(ih/2)*2[v];[0:a]${speedfilter.join(',')}[a]" -map "[v]" -map "[a]" -preset ${findpreset(args)} -c:v libx264 -pix_fmt yuv420p ${filepath}/output.mp4`)
                        await sendFile(msg, filepath, `output.mp4`)
                    } else {
                        await execPromise(`ffmpeg -i ${filepath}/${filename} -filter_complex "[0:v]setpts=${speed}*PTS,fps=fps=${fps.includes('0/0') ? '50' : fps}/${speed},scale=ceil(iw/2)*2:ceil(ih/2)*2[v]" -map "[v]" -c:v libx264 -pix_fmt yuv420p ${filepath}/output.mp4`)
                        await sendFile(msg, filepath, `output.mp4`)
                    }
                } else if (type.mime.startsWith('audio')) {
                    var filepath = await downloadFile(currenturl, `input.mp3`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp3`
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -filter_complex "[0:a]${speedfilter.join(',')}[a]" -map "[a]" -preset ${findpreset(args)} ${filepath}/output.mp3`)
                    await sendFile(msg, filepath, `output.mp3`)
                } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                    var filepath = await downloadFile(currenturl, `input.gif`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.gif`
                    var fps = fileinfo.info.fps

                    await execPromise(`ffmpeg -i ${filepath}/${filename} -filter_complex "[0:v]setpts=${speed}*PTS,fps=fps=${fps.includes('0/0') ? '50' : fps}/${speed},split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ${findpreset(args)} -gifflags -offsetting ${filepath}/output.gif`)
                    await sendFile(msg, filepath, `output.gif`)
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "slowdown/slow [multiplier (from 1 to 6)] <file>",
                "value": "Slows down the file by the multiplier. Default is 2."
            },
            cooldown: 2500,
            type: "Duration"
        },

        {
            name: ["skin", "machine"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
                var fileinfo = await validateFile(currenturl).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })

                if (!fileinfo) return
                var type = fileinfo.type

                if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                    var filepath = await downloadFile(currenturl, `input.png`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.png`
                    var width = fileinfo.info.width
                    var height = fileinfo.info.height

                    var squareS = { value: ((height === width) && width) || ((height > width) && height) || width, constraint: ((height === width) && 'both') || ((height > width) && 'height') || 'width' }

                    await execPromise(`ffmpeg -i ${filepath}/${filename} -i templates/skin.png -filter_complex "[0:v]scale=${squareS.constraint === 'width' || squareS.constraint === 'both' ? 210 : -1}:${squareS.constraint === 'height' || squareS.constraint === 'both' ? 210 : -1}[frame];[1:v][frame]overlay=x=274-(w/2):y=360-h:format=auto[out]" -map "[out]" -preset ${findpreset(args)} ${filepath}/output.png`)
                    await sendFile(msg, filepath, `output.png`)
                } else if (type.mime.startsWith('video')) {
                    var filepath = await downloadFile(currenturl, `input.mp4`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp4`
                    var width = fileinfo.info.width
                    var height = fileinfo.info.height

                    var squareS = { value: ((height === width) && width) || ((height > width) && height) || width, constraint: ((height === width) && 'both') || ((height > width) && 'height') || 'width' }

                    await execPromise(`ffmpeg -i ${filepath}/${filename} -i templates/skin.png -map 0:a? -filter_complex "[0:v]scale=${squareS.constraint === 'width' || squareS.constraint === 'both' ? 210 : -1}:${squareS.constraint === 'height' || squareS.constraint === 'both' ? 210 : -1}[frame];[1:v][frame]overlay=x=274-(w/2):y=360-h:format=auto[oout];[oout]scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ${findpreset(args)} -c:v libx264 -pix_fmt yuv420p ${filepath}/output.mp4`)
                    await sendFile(msg, filepath, `output.mp4`)
                } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                    var filepath = await downloadFile(currenturl, `input.gif`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.gif`
                    var width = fileinfo.info.width
                    var height = fileinfo.info.height

                    var squareS = { value: ((height === width) && width) || ((height > width) && height) || width, constraint: ((height === width) && 'both') || ((height > width) && 'height') || 'width' }

                    await execPromise(`ffmpeg -i ${filepath}/${filename} -i templates/skin.png -filter_complex "[0:v]scale=${squareS.constraint === 'width' || squareS.constraint === 'both' ? 210 : -1}:${squareS.constraint === 'height' || squareS.constraint === 'both' ? 210 : -1}[frame];[1:v][frame]overlay=x=274-(w/2):y=360-h:format=auto[oout];[oout]split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ${findpreset(args)} -gifflags -offsetting ${filepath}/output.gif`)
                    await sendFile(msg, filepath, `output.gif`)
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "skin/machine <file>",
                "value": "NOOOO GET OUT OF THERE"
            },
            cooldown: 2500,
            type: "Memes"
        },

        {
            name: ["heaven"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
                var fileinfo = await validateFile(currenturl).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })

                if (!fileinfo) return
                var type = fileinfo.type

                if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                    var filepath = await downloadFile(currenturl, `input.png`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.png`
                    var width = fileinfo.info.width
                    var height = fileinfo.info.height
                    var bscale = await execPromise(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 templates/heaven.png`)
                    bscale = bscale.replace(/\n|\r/g, '').split('x')
                    var bheight = Number(bscale[1])
                    var squareS = { value: ((height === width) && width) || ((height > width) && height) || width, constraint: ((height === width) && 'both') || ((height > width) && 'height') || 'width' }

                    await execPromise(`ffmpeg -i ${filepath}/${filename} -i templates/heaven.png -filter_complex "[0:v]scale=${squareS.constraint === 'width' || squareS.constraint === 'both' ? bheight / 5 : -1}:${squareS.constraint === 'height' || squareS.constraint === 'both' ? bheight / 5 : -1}[frame];[1:v][frame]overlay=x=W/2-w/2:y=H/1.75-h:format=auto[out]" -map "[out]" -preset ${findpreset(args)} ${filepath}/output.png`)
                    await sendFile(msg, filepath, `output.png`)
                } else if (type.mime.startsWith('video')) {
                    var filepath = await downloadFile(currenturl, `input.mp4`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp4`
                    var width = fileinfo.info.width
                    var height = fileinfo.info.height
                    var bscale = await execPromise(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 templates/heaven.png`)
                    bscale = bscale.replace(/\n|\r/g, '').split('x')
                    var bheight = Number(bscale[1])
                    var squareS = { value: ((height === width) && width) || ((height > width) && height) || width, constraint: ((height === width) && 'both') || ((height > width) && 'height') || 'width' }

                    await execPromise(`ffmpeg -i ${filepath}/${filename} -i templates/heaven.png -map 0:a? -filter_complex "[0:v]scale=${squareS.constraint === 'width' || squareS.constraint === 'both' ? bheight / 5 : -1}:${squareS.constraint === 'height' || squareS.constraint === 'both' ? bheight / 5 : -1}[frame];[1:v][frame]overlay=x=W/2-w/2:y=H/1.75-h:format=auto[oout];[oout]scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ${findpreset(args)} -c:v libx264 -pix_fmt yuv420p ${filepath}/output.mp4`)
                    await sendFile(msg, filepath, `output.mp4`)
                } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                    var filepath = await downloadFile(currenturl, `input.gif`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.gif`
                    var width = fileinfo.info.width
                    var height = fileinfo.info.height
                    var bscale = await execPromise(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 templates/heaven.png`)
                    bscale = bscale.replace(/\n|\r/g, '').split('x')
                    var bheight = Number(bscale[1])
                    var squareS = { value: ((height === width) && width) || ((height > width) && height) || width, constraint: ((height === width) && 'both') || ((height > width) && 'height') || 'width' }

                    await execPromise(`ffmpeg -i ${filepath}/${filename} -i templates/heaven.png -filter_complex "[0:v]scale=${squareS.constraint === 'width' || squareS.constraint === 'both' ? bheight / 5 : -1}:${squareS.constraint === 'height' || squareS.constraint === 'both' ? bheight / 5 : -1}[frame];[1:v][frame]overlay=x=W/2-w/2:y=H/1.75-h:format=auto[oout];[oout]split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ${findpreset(args)} -gifflags -offsetting ${filepath}/output.gif`)
                    await sendFile(msg, filepath, `output.gif`)
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "heaven <file>",
                "value": "they get sent to heaven"
            },
            cooldown: 2500,
            type: "Memes"
        },

        {
            name: ["hell"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
                var fileinfo = await validateFile(currenturl).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })

                if (!fileinfo) return
                var type = fileinfo.type

                if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                    var filepath = await downloadFile(currenturl, `input.png`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.png`
                    var width = fileinfo.info.width
                    var height = fileinfo.info.height
                    var bscale = await execPromise(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 templates/hell.png`)
                    bscale = bscale.replace(/\n|\r/g, '').split('x')
                    var bheight = Number(bscale[1])
                    var squareS = { value: ((height === width) && width) || ((height > width) && height) || width, constraint: ((height === width) && 'both') || ((height > width) && 'height') || 'width' }

                    await execPromise(`ffmpeg -i ${filepath}/${filename} -i templates/hell.png -filter_complex "[0:v]scale=${squareS.constraint === 'width' || squareS.constraint === 'both' ? bheight / 5 : -1}:${squareS.constraint === 'height' || squareS.constraint === 'both' ? bheight / 5 : -1}[frame];[1:v][frame]overlay=x=W/2-w/2:y=H/1.2-h:format=auto[out]" -map "[out]" -preset ${findpreset(args)} ${filepath}/output.png`)
                    await sendFile(msg, filepath, `output.png`)
                } else if (type.mime.startsWith('video')) {
                    var filepath = await downloadFile(currenturl, `input.mp4`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp4`
                    var width = fileinfo.info.width
                    var height = fileinfo.info.height
                    var bscale = await execPromise(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 templates/hell.png`)
                    bscale = bscale.replace(/\n|\r/g, '').split('x')
                    var bheight = Number(bscale[1])
                    var squareS = { value: ((height === width) && width) || ((height > width) && height) || width, constraint: ((height === width) && 'both') || ((height > width) && 'height') || 'width' }

                    await execPromise(`ffmpeg -i ${filepath}/${filename} -i templates/hell.png -map 0:a? -filter_complex "[0:v]scale=${squareS.constraint === 'width' || squareS.constraint === 'both' ? bheight / 5 : -1}:${squareS.constraint === 'height' || squareS.constraint === 'both' ? bheight / 5 : -1}[frame];[1:v][frame]overlay=x=W/2-w/2:y=H/1.2-h:format=auto[oout];[oout]scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ${findpreset(args)} -c:v libx264 -pix_fmt yuv420p ${filepath}/output.mp4`)
                    await sendFile(msg, filepath, `output.mp4`)
                } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                    var filepath = await downloadFile(currenturl, `input.gif`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.gif`
                    var width = fileinfo.info.width
                    var height = fileinfo.info.height
                    var bscale = await execPromise(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 templates/hell.png`)
                    bscale = bscale.replace(/\n|\r/g, '').split('x')
                    var bheight = Number(bscale[1])
                    var squareS = { value: ((height === width) && width) || ((height > width) && height) || width, constraint: ((height === width) && 'both') || ((height > width) && 'height') || 'width' }

                    await execPromise(`ffmpeg -i ${filepath}/${filename} -i templates/hell.png -filter_complex "[0:v]scale=${squareS.constraint === 'width' || squareS.constraint === 'both' ? bheight / 5 : -1}:${squareS.constraint === 'height' || squareS.constraint === 'both' ? bheight / 5 : -1}[frame];[1:v][frame]overlay=x=W/2-w/2:y=H/1.2-h:format=auto[oout];[oout]split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ${findpreset(args)} -gifflags -offsetting ${filepath}/output.gif`)
                    await sendFile(msg, filepath, `output.gif`)
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "hell <file>",
                "value": "they get sent to hell"
            },
            cooldown: 2500,
            type: "Memes"
        },

        {
            name: ["rap", "fnf", "friday"],
            execute: async function (msg, args) {
                const rapping = [
                    {
                        name: "1",
                        position: [109, 101],
                        angle: -3
                    },
                    {
                        name: "2",
                        position: [114, 102],
                        angle: -1
                    },
                    {
                        name: "3",
                        position: [128, 102],
                        angle: 9
                    },
                    {
                        name: "4",
                        position: [123, 106],
                        angle: 5
                    },
                    {
                        name: "5",
                        position: [122, 98],
                        angle: -14
                    },
                    {
                        name: "6",
                        position: [119, 100],
                        angle: -9
                    },
                    {
                        name: "7",
                        position: [109, 103],
                        angle: 10
                    },
                    {
                        name: "8",
                        position: [110, 102],
                        angle: 6
                    }
                ]
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
                var fileinfo = await validateFile(currenturl).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })

                if (!fileinfo) return
                var type = fileinfo.type

                if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                    var currentcount = filecount
                    filecount++
                    var filepath = `temp/file${currentcount}`
                    fs.mkdirSync(`${filepath}`)
                    fs.mkdirSync(`${filepath}/frames`)
                    for (var i = 0; i < rapping.length; i++) {
                        var rapFrame = rapping[i]
                        var frame = await Jimp.read(currenturl)
                        var rap = await Jimp.read(`templates/rapping/${rapFrame.name}.png`)
                        var rapm = await Jimp.read(`templates/rappingmask/${rapFrame.name}.png`)
                        var stage = await Jimp.read(`templates/stage.png`)
                        var transparent = await Jimp.read(`templates/transparent.png`)
                        var squareS = { value: ((frame.bitmap.height === frame.bitmap.width) && frame.bitmap.width) || ((frame.bitmap.height > frame.bitmap.width) && frame.bitmap.height) || frame.bitmap.width, constraint: ((frame.bitmap.height === frame.bitmap.width) && 'both') || ((frame.bitmap.height > frame.bitmap.width) && 'height') || 'width' }
                        frame.resize(squareS.constraint === 'width' || squareS.constraint === 'both' ? 70 : Jimp.AUTO, squareS.constraint === 'height' || squareS.constraint === 'both' ? 70 : Jimp.AUTO)
                        frame.rotate(rapFrame.angle)
                        transparent.resize(stage.bitmap.width, stage.bitmap.height)
                        transparent.composite(frame, rapFrame.position[0] - frame.bitmap.width / 2, rapFrame.position[1] - frame.bitmap.height + 10)
                        transparent.mask(rapm, 0, 0)
                        rap.composite(transparent, 0, 0)
                        stage.composite(rap, 0, 0)
                        await stage.writeAsync(`${filepath}/frames/${rapFrame.name}.png`)
                    }
                    await execPromise(`ffmpeg -i ${filepath}/frames/%d.png -vf palettegen=reserve_transparent=1 ${filepath}/palette.png`)
                    await execPromise(`ffmpeg -r 25/2 -i ${filepath}/frames/%d.png -i ${filepath}/palette.png -lavfi "paletteuse=alpha_threshold=128" -gifflags -offsetting ${filepath}/output.gif`)
                    await sendFile(msg, filepath, `output.gif`)
                } else if (type.mime.startsWith('video') || (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext))) {
                    var currentcount = filecount
                    filecount++
                    var filepath = `temp/file${currentcount}`
                    fs.mkdirSync(`${filepath}`)
                    fs.mkdirSync(`${filepath}/frames`)
                    await execPromise(`ffmpeg -i "${currenturl}" -vframes 1 ${filepath}/output.png`)
                    for (var i = 0; i < rapping.length; i++) {
                        var rapFrame = rapping[i]
                        var frame = await Jimp.read(`${filepath}/output.png`)
                        var rap = await Jimp.read(`templates/rapping/${rapFrame.name}.png`)
                        var rapm = await Jimp.read(`templates/rappingmask/${rapFrame.name}.png`)
                        var stage = await Jimp.read(`templates/stage.png`)
                        var transparent = await Jimp.read(`templates/transparent.png`)
                        var squareS = { value: ((frame.bitmap.height === frame.bitmap.width) && frame.bitmap.width) || ((frame.bitmap.height > frame.bitmap.width) && frame.bitmap.height) || frame.bitmap.width, constraint: ((frame.bitmap.height === frame.bitmap.width) && 'both') || ((frame.bitmap.height > frame.bitmap.width) && 'height') || 'width' }
                        frame.resize(squareS.constraint === 'width' || squareS.constraint === 'both' ? 70 : Jimp.AUTO, squareS.constraint === 'height' || squareS.constraint === 'both' ? 70 : Jimp.AUTO)
                        frame.rotate(rapFrame.angle)
                        transparent.resize(stage.bitmap.width, stage.bitmap.height)
                        transparent.composite(frame, rapFrame.position[0] - frame.bitmap.width / 2, rapFrame.position[1] - frame.bitmap.height + 10)
                        transparent.mask(rapm, 0, 0)
                        rap.composite(transparent, 0, 0)
                        stage.composite(rap, 0, 0)
                        await stage.writeAsync(`${filepath}/frames/${rapFrame.name}.png`)
                    }
                    await execPromise(`ffmpeg -i ${filepath}/frames/%d.png -vf palettegen=reserve_transparent=1 ${filepath}/palette.png`)
                    await execPromise(`ffmpeg -r 25/2 -i ${filepath}/frames/%d.png -i ${filepath}/palette.png -lavfi "paletteuse=alpha_threshold=128" -gifflags -offsetting ${filepath}/output.gif`)
                    await sendFile(msg, filepath, `output.gif`)
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "rap/fnf/friday <file>",
                "value": "when i'm funny Rapping !!!"
            },
            cooldown: 2500,
            type: "Memes"
        },

        {
            name: ["choicegif"],
            execute: async function (msg, args) {
                const gifframes = [
                    {
                        name: '{text}',
                        filename: '1.png'
                    },

                    {
                        edit: async function (frame) {
                            frame.greyscale()
                            frame.color([
                                {
                                    apply: 'blue',
                                    params: [-255]
                                },

                                {
                                    apply: 'green',
                                    params: [-255]
                                }
                            ])
                        },
                        name: 'Red {text}',
                        filename: '2.png'
                    },

                    {
                        edit: async function (frame) {
                            frame.greyscale()
                            frame.color([
                                {
                                    apply: 'blue',
                                    params: [-255]
                                },

                                {
                                    apply: 'red',
                                    params: [-255]
                                }
                            ])
                        },
                        name: 'Green {text}',
                        filename: '3.png'
                    },

                    {
                        edit: async function (frame) {
                            frame.greyscale()
                            frame.color([
                                {
                                    apply: 'red',
                                    params: [-255]
                                },

                                {
                                    apply: 'green',
                                    params: [-255]
                                }
                            ])
                        },
                        name: 'Blue {text}',
                        filename: '4.png'
                    },

                    {
                        edit: async function (frame) {
                            frame.convolute([
                                [-2, -1, 0],
                                [-1, 1, 1],
                                [0, 1, 2]
                            ])
                        },
                        name: 'MUGEN {text}',
                        filename: '5.png'
                    },

                    {
                        edit: async function (frame) {
                            frame.greyscale()
                        },
                        name: '50\'s {text}',
                        filename: '6.png'
                    },

                    {
                        edit: async function (frame) {
                            frame.resize(frame.bitmap.width / 6, frame.bitmap.height / 6)
                        },
                        name: 'Tiny {text}',
                        filename: '7.png'
                    },

                    {
                        edit: async function (frame) {
                            frame.resize(frame.bitmap.width * 3, frame.bitmap.height * 3)
                        },
                        name: 'Giant {text}',
                        filename: '8.png'
                    },

                    {
                        edit: async function (frame) {
                            frame.resize(frame.bitmap.width / 4, frame.bitmap.height / 4, Jimp.RESIZE_NEAREST_NEIGHBOR)
                            frame.resize(frame.bitmap.width * 4, frame.bitmap.height * 4, Jimp.RESIZE_NEAREST_NEIGHBOR)
                        },
                        name: '8-bit {text}',
                        filename: '9.png'
                    },

                    {
                        edit: async function (frame) {
                            frame.resize(frame.bitmap.width / 6, frame.bitmap.height / 6)
                            frame.resize(frame.bitmap.width * 6, frame.bitmap.height * 6)
                        },
                        name: 'Crunchy {text}',
                        filename: '10.png'
                    },

                    {
                        edit: async function (frame) {
                            frame.greyscale()
                            frame.color([
                                {
                                    apply: 'green',
                                    params: [-100]
                                },

                                {
                                    apply: 'red',
                                    params: [-100]
                                },

                                {
                                    apply: 'blue',
                                    params: [-100]
                                }
                            ])
                        },
                        name: 'Nightmare {text}',
                        filename: '11.png'
                    },

                    {
                        edit: async function (frame) {
                            frame.greyscale()
                            frame.color([
                                {
                                    apply: 'green',
                                    params: [70]
                                },

                                {
                                    apply: 'red',
                                    params: [70]
                                },

                                {
                                    apply: 'blue',
                                    params: [70]
                                }
                            ])
                        },
                        name: 'Ghost {text}',
                        filename: '12.png'
                    },

                    {
                        edit: async function (frame) {
                            frame.convolute([
                                [0, -1, 0],
                                [-1, 4, -1],
                                [0, -1, 0]
                            ])
                            frame.convolute([
                                [0, -1, 0],
                                [-1, 4, -1],
                                [0, -1, 0]
                            ])
                        },
                        name: 'what',
                        filename: '13.png'
                    },

                    {
                        edit: async function (frame) {
                            frame.convolute([
                                [-1, -1, -1],
                                [-1, 9, -1],
                                [-1, -1, -1]
                            ])
                            frame.convolute([
                                [-1, -1, -1],
                                [-1, 9, -1],
                                [-1, -1, -1]
                            ])
                        },
                        name: 'Distorted {text}',
                        filename: '14.png'
                    },

                    {
                        edit: async function (frame) {
                            frame.greyscale()
                            frame.contrast(1)
                        },
                        name: 'Silhouette {text}',
                        filename: '15.png'
                    },

                    {
                        edit: async function (frame) {
                            frame.resize(frame.bitmap.width / 40, frame.bitmap.height / 40)
                        },
                        name: '{text} Bacteria',
                        filename: '16.png'
                    },

                    {
                        edit: async function (frame) {
                            frame.invert()
                        },
                        name: 'Inverted {text}',
                        filename: '17.png'
                    },

                    {
                        edit: async function (frame) {
                            frame.resize(frame.bitmap.width, frame.bitmap.height / 4)
                        },
                        name: 'Squashed {text}',
                        filename: '18.png'
                    },

                    {
                        edit: async function (frame) {
                            frame.resize(frame.bitmap.width, frame.bitmap.height * 4)
                        },
                        name: 'hi',
                        filename: '19.png'
                    },

                    {
                        edit: async function (frame) {
                            frame.color([
                                {
                                    apply: 'green',
                                    params: [255]
                                },
                            ])
                        },
                        name: 'Nuclear {text}',
                        filename: '20.png'
                    },

                    {
                        edit: async function (frame) {
                            frame.contrast(0.9)
                        },
                        name: '{text} Fry',
                        filename: '21.png'
                    },

                    {
                        edit: async function (frame) {
                            frame.greyscale()
                            frame.color([
                                {
                                    apply: 'blue',
                                    params: [-255]
                                },

                                {
                                    apply: 'green',
                                    params: [-100]
                                }
                            ])
                        },
                        name: 'Hot {text}',
                        filename: '22.png'
                    },

                    {
                        edit: async function (frame) {
                            frame.greyscale()
                            frame.color([
                                {
                                    apply: 'red',
                                    params: [-255]
                                },

                                {
                                    apply: 'green',
                                    params: [-100]
                                }
                            ])
                        },
                        name: 'Cold {text}',
                        filename: '23.png'
                    },

                    {
                        edit: async function (frame) {
                            frame.blur(5)
                        },
                        name: 'Blurred {text}',
                        filename: '24.png'
                    },

                    {
                        edit: async function (frame) {
                            frame.resize(frame.bitmap.width * 12, frame.bitmap.height * 12)
                        },
                        name: 'Island-sized {text}',
                        filename: '25.png'
                    },

                    {
                        edit: async function (frame) {
                            frame.resize(frame.bitmap.width, 1, Jimp.RESIZE_NEAREST_NEIGHBOR)
                            frame.resize(frame.bitmap.width, 500, Jimp.RESIZE_NEAREST_NEIGHBOR)
                        },
                        name: '{text}\n{text}\n{text}\n{text}\n{text}\n{text}\n{text}',
                        filename: '26.png'
                    },

                    {
                        edit: async function (frame) {
                            var stripes = await Jimp.read('templates/stripes.png')
                            frame.greyscale()
                            stripes.resize(frame.bitmap.width, frame.bitmap.height)
                            frame.composite(stripes, 0, 0)
                            frame.convolute([
                                [0, -1, 0],
                                [-1, 4, -1],
                                [0, -1, 0]
                            ])
                        },
                        name: 'The Anonymous {text}',
                        filename: '27.png'
                    },

                    {
                        edit: async function (frame) {
                            var jail = await Jimp.read('templates/jailed.png')
                            jail.resize(frame.bitmap.width, frame.bitmap.height)
                            frame.composite(jail, 0, 0)
                        },
                        name: 'Jailed {text}',
                        filename: '28.png'
                    },
                ]
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var saidMessage = args.join(' ').substring(args[0].length + 1)
                symbolreplacements.forEach(symbolReplacement => {
                    symbolReplacement.target.forEach(target => {
                        saidMessage = saidMessage.replace(new RegExp(target, 'ig'), symbolReplacement.replacement)
                    })
                })
                var matchedTextes = saidMessage.match(/"([\s\S]*?)"/)
                if (!matchedTextes) {
                    matchedTextes = ['""', '']
                }
                var text = matchedTextes[1]
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
                var fileinfo = await validateFile(currenturl).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })

                if (!fileinfo) return
                var type = fileinfo.type

                if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                    var filepath = await downloadFile(currenturl, `input.png`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.png`
                    fs.mkdirSync(`${filepath}/frames`)

                    for (var i = 0; i < gifframes.length; i++) {
                        var framedata = gifframes[i]
                        var frame = await Jimp.read(`${filepath}/${filename}`)
                        var white = await Jimp.read(`templates/white.png`)
                        var arialsmall = await Jimp.loadFont('templates/fonts/ArialSmall/ArialSmall.fnt')
                        var arialbig = await Jimp.loadFont('templates/fonts/ArialBig/ArialBig.fnt')
                        var squareS = { value: ((frame.bitmap.height === frame.bitmap.width) && frame.bitmap.width) || ((frame.bitmap.height > frame.bitmap.width) && frame.bitmap.height) || frame.bitmap.width, constraint: ((frame.bitmap.height === frame.bitmap.width) && 'both') || ((frame.bitmap.height > frame.bitmap.width) && 'height') || 'width' }
                        frame.resize(squareS.constraint === 'width' || squareS.constraint === 'both' ? 180 : Jimp.AUTO, squareS.constraint === 'height' || squareS.constraint === 'both' ? 180 : Jimp.AUTO)
                        white.resize(304, 361)
                        if (framedata.edit) {
                            await framedata.edit(frame)
                        }
                        white.composite(frame, white.bitmap.width / 2 - frame.bitmap.width / 2, white.bitmap.height / 2 - frame.bitmap.height / 2)
                        await white.print(arialbig, 8, 8, { text: Discord.Util.cleanContent('Choose your {text}'.replace(/{text}/g, text), msg), alignmentX: Jimp.HORIZONTAL_ALIGN_CENTER, alignmentY: Jimp.VERTICAL_ALIGN_MIDDLE }, 288, 73)
                        await white.print(arialsmall, 8, 280, { text: Discord.Util.cleanContent(framedata.name.replace(/{text}/g, text), msg), alignmentX: Jimp.HORIZONTAL_ALIGN_CENTER, alignmentY: Jimp.VERTICAL_ALIGN_MIDDLE }, 288, 73)
                        await white.writeAsync(`${filepath}/frames/${framedata.filename}`)
                    }

                    await execPromise(`ffmpeg -i ${filepath}/frames/%d.png -vf palettegen=reserve_transparent=1 ${filepath}/palette.png`)
                    await execPromise(`ffmpeg -i ${filepath}/frames/%d.png -i ${filepath}/palette.png -lavfi "paletteuse=alpha_threshold=128" -gifflags -offsetting ${filepath}/output.gif`)
                    await sendFile(msg, filepath, `output.gif`)
                } else if (type.mime.startsWith('video') || (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext))) {
                    var currentcount = filecount
                    filecount++
                    var filepath = `temp/file${currentcount}`
                    fs.mkdirSync(`${filepath}`)
                    fs.mkdirSync(`${filepath}/frames`)

                    await execPromise(`ffmpeg -i "${currenturl}" -vframes 1 ${filepath}/output.png`)
                    for (var i = 0; i < gifframes.length; i++) {
                        var framedata = gifframes[i]
                        var frame = await Jimp.read(`${filepath}/output.png`)
                        var white = await Jimp.read(`templates/white.png`)
                        var arialsmall = await Jimp.loadFont('templates/fonts/ArialSmall/ArialSmall.fnt')
                        var arialbig = await Jimp.loadFont('templates/fonts/ArialBig/ArialBig.fnt')
                        var squareS = { value: ((frame.bitmap.height === frame.bitmap.width) && frame.bitmap.width) || ((frame.bitmap.height > frame.bitmap.width) && frame.bitmap.height) || frame.bitmap.width, constraint: ((frame.bitmap.height === frame.bitmap.width) && 'both') || ((frame.bitmap.height > frame.bitmap.width) && 'height') || 'width' }
                        frame.resize(squareS.constraint === 'width' || squareS.constraint === 'both' ? 180 : Jimp.AUTO, squareS.constraint === 'height' || squareS.constraint === 'both' ? 180 : Jimp.AUTO)
                        white.resize(304, 361)
                        if (framedata.edit) {
                            await framedata.edit(frame)
                        }
                        white.composite(frame, white.bitmap.width / 2 - frame.bitmap.width / 2, white.bitmap.height / 2 - frame.bitmap.height / 2)
                        await white.print(arialbig, 8, 8, { text: Discord.Util.cleanContent('Choose your {text}'.replace(/{text}/g, text), msg), alignmentX: Jimp.HORIZONTAL_ALIGN_CENTER, alignmentY: Jimp.VERTICAL_ALIGN_MIDDLE }, 288, 73)
                        await white.print(arialsmall, 8, 280, { text: Discord.Util.cleanContent(framedata.name.replace(/{text}/g, text), msg), alignmentX: Jimp.HORIZONTAL_ALIGN_CENTER, alignmentY: Jimp.VERTICAL_ALIGN_MIDDLE }, 288, 73)
                        await white.writeAsync(`${filepath}/frames/${framedata.filename}`)
                    }
                    await execPromise(`ffmpeg -i ${filepath}/frames/%d.png -vf palettegen=reserve_transparent=1 ${filepath}/palette.png`)
                    await execPromise(`ffmpeg -i ${filepath}/frames/%d.png -i ${filepath}/palette.png -lavfi "paletteuse=alpha_threshold=128" -gifflags -offsetting ${filepath}/output.gif`)
                    await sendFile(msg, filepath, `output.gif`)
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "choicegif \"{name}\" <file>",
                "value": "Creates one of those \"Choose your fighter\" gifs depending on the selected image."
            },
            cooldown: 2500,
            type: "Memes"
        },

        {
            name: ["bloxys", "bloxy"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
                var saidMessage = args.join(' ').substring(args[0].length + 1)
                symbolreplacements.forEach(symbolReplacement => {
                    symbolReplacement.target.forEach(target => {
                        saidMessage = saidMessage.replace(new RegExp(target, 'ig'), symbolReplacement.replacement)
                    })
                })
                var matchedTextes = saidMessage.match(/"([\s\S]*?)"/)
                if (!matchedTextes) {
                    matchedTextes = ['""', '']
                }
                var text = matchedTextes[1]
                var fileinfo = await validateFile(currenturl).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })

                if (!fileinfo) return
                var type = fileinfo.type

                if (type.mime.startsWith('image') || type.mime.startsWith('video')) {
                    var filepath = await downloadFile(currenturl, `input.${fileinfo.shortext}`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.${fileinfo.shortext}`

                    var gotham = await Jimp.loadFont(`templates/fonts/Gotham/Gotham.fnt`)
                    var bloxys = await Jimp.read('templates/bloxys.png')
                    await bloxys.print(gotham, 88, 190, { text: Discord.Util.cleanContent(text, msg), alignmentX: Jimp.HORIZONTAL_ALIGN_CENTER, alignmentY: Jimp.VERTICAL_ALIGN_TOP }, 221, 33)
                    await bloxys.writeAsync(`${filepath}/bloxy.png`)

                    await execPromise(`ffmpeg -stream_loop -1 -i ${filepath}/${filename} -i ${filepath}/bloxy.png -i templates/bloxys.mp3 -filter_complex "[0:v]scale=219:124[frame];[1:v][frame]overlay=x=89:y=64:format=auto[oout];[oout]scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -shortest -map "[out]" -preset ${findpreset(args)} -map 2:a:0 -c:v libx264 -pix_fmt yuv420p -t 00:00:07.05 -y ${filepath}/output.mp4`)
                    await sendFile(msg, filepath, `output.mp4`)
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "bloxys/bloxy \"{name}\" <file>",
                "value": "YOU WON A BLOXY!"
            },
            cooldown: 2500,
            type: "Memes"
        },

        {
            name: ["favorite"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
                var fileinfo = await validateFile(currenturl).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })

                if (!fileinfo) return
                var type = fileinfo.type

                if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                    var filepath = await downloadFile(currenturl, `input.png`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.png`
                    var height = fileinfo.info.height

                    await execPromise(`ffmpeg -stream_loop -1 -i ${filepath}/${filename} -i templates/favorite.gif -filter_complex "${height >= 212 ? `[1:v]scale=-1:${height >= 300 ? 300 : height}[ckout];` : ''}[${height >= 212 ? `ckout` : `1:v`}]colorkey=0x05FA04:0.3:0.3[jout];[0:v]scale='min(400,iw)':min'(400,ih)':force_original_aspect_ratio=decrease[lout];[lout][jout]overlay=shortest=1:x=W-w:y=0:format=auto[rout];[rout]split[gnout][gpout];[gpout]palettegen=reserve_transparent=1[palette];[gnout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ${findpreset(args)} -gifflags -offsetting ${filepath}/output.gif`)
                    await sendFile(msg, filepath, `output.gif`)
                } else if (type.mime.startsWith('video')) {
                    var filepath = await downloadFile(currenturl, `input.mp4`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp4`
                    var height = fileinfo.info.height

                    await execPromise(`ffmpeg -i ${filepath}/${filename} -stream_loop -1 -i templates/favorite.gif -map 0:a? -filter_complex "${height >= 212 ? `[1:v]scale=-1:${height}[ckout];` : ''}[${height >= 212 ? `ckout` : `1:v`}]colorkey=0x05FA04:0.3:0.3[jout];[0:v][jout]overlay=shortest=1:x=W-w:y=0:format=auto[sout];[sout]scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ${findpreset(args)} -c:v libx264 -pix_fmt yuv420p ${filepath}/output.mp4`)
                    await sendFile(msg, filepath, `output.mp4`)
                } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                    var filepath = await downloadFile(currenturl, `input.gif`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.gif`
                    var height = fileinfo.info.height

                    await execPromise(`ffmpeg -stream_loop -1 -i ${filepath}/${filename} -i templates/favorite.gif -filter_complex "${height >= 212 ? `[1:v]scale=-1:${height}[ckout];` : ''}[${height >= 212 ? `ckout` : `1:v`}]colorkey=0x05FA04:0.3:0.3[jout];[0:v][jout]overlay=shortest=1:x=W-w:y=0:format=auto[rout];[rout]split[gnout][gpout];[gpout]palettegen=reserve_transparent=1[palette];[gnout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ${findpreset(args)} -gifflags -offsetting ${filepath}/output.gif`)
                    await sendFile(msg, filepath, `output.gif`)
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "favorite <file>",
                "value": "Your GIF was favorited over 1000 times!"
            },
            cooldown: 2500,
            type: "Memes"
        },

        {
            name: ["playvideo"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
                var fileinfo = await validateFile(currenturl).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })

                if (!fileinfo) return
                var type = fileinfo.type

                if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                    var filepath = await downloadFile(currenturl, `input.png`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.png`
                    var width = fileinfo.info.width
                    var height = fileinfo.info.height

                    await execPromise(`ffmpeg -stream_loop -1 -i ${filepath}/${filename} -i templates/playvideo.mp4 -filter_complex "${height >= 224 ? `[1:v]scale=-1:${height >= 300 ? 300 : height}[ckout];` : ''}[${height >= 224 ? `ckout` : `1:v`}]colorkey=0x66BB24:0.3:0.3[jout];[0:v]scale='min(400,iw)':min'(400,ih)':force_original_aspect_ratio=decrease[lout];[lout][jout]overlay=shortest=1:x=W/2-w/2:y=H-h:format=auto[rout];[rout]split[gnout][gpout];[gpout]palettegen=reserve_transparent=1[palette];[gnout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ${findpreset(args)} -gifflags -offsetting ${filepath}/output.gif`)
                    await sendFile(msg, filepath, `output.gif`)
                } else if (type.mime.startsWith('video')) {
                    var filepath = await downloadFile(currenturl, `input.mp4`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp4`
                    var width = fileinfo.info.width
                    var height = fileinfo.info.height

                    await execPromise(`ffmpeg -i ${filepath}/${filename} -stream_loop -1 -i templates/playvideo.mp4 -map 0:a? -filter_complex "${height >= 224 ? `[1:v]scale=-1:${height}[ckout];` : ''}[${height >= 224 ? `ckout` : `1:v`}]colorkey=0x66BB24:0.3:0.3[jout];[0:v][jout]overlay=shortest=1:x=W/2-w/2:y=H-h:format=auto[sout];[sout]scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ${findpreset(args)} -c:v libx264 -pix_fmt yuv420p ${filepath}/output.mp4`)
                    await sendFile(msg, filepath, `output.mp4`)
                } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                    var filepath = await downloadFile(currenturl, `input.gif`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.gif`
                    var width = fileinfo.info.width
                    var height = fileinfo.info.height

                    await execPromise(`ffmpeg -stream_loop -1 -i ${filepath}/${filename} -i templates/playvideo.mp4 -filter_complex "${height >= 224 ? `[1:v]scale=-1:${height}[ckout];` : ''}[${height >= 224 ? `ckout` : `1:v`}]colorkey=0x66BB24:0.3:0.3[jout];[0:v][jout]overlay=shortest=1:x=W/2-w/2:y=H-h:format=auto[rout];[rout]split[gnout][gpout];[gpout]palettegen=reserve_transparent=1[palette];[gnout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ${findpreset(args)} -gifflags -offsetting ${filepath}/output.gif`)
                    await sendFile(msg, filepath, `output.gif`)
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "playvideo <file>",
                "value": "Your video was played over 1000 times!"
            },
            cooldown: 2500,
            type: "Memes"
        },

        {
            name: ["desktopdestroy", "desktopdestroyer"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
                var fileinfo = await validateFile(currenturl).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })

                if (!fileinfo) return
                var type = fileinfo.type

                if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                    var filepath = await downloadFile(currenturl, `input.png`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.png`
                    var height = fileinfo.info.height

                    await execPromise(`ffmpeg -stream_loop -1 -i ${filepath}/${filename} -i templates/destroy.gif -filter_complex "${height >= 238 ? `[1:v]scale=-1:${height >= 300 ? 300 : height}[ckout];` : ''}[${height >= 238 ? `ckout` : `1:v`}]colorkey=0x00FF01:0.3:0.3[jout];[0:v]scale='min(400,iw)':min'(400,ih)':force_original_aspect_ratio=decrease[lout];[lout][jout]overlay=shortest=1:x=W/2-w/2:y=H/2-h/2:format=auto[rout];[rout]split[gnout][gpout];[gpout]palettegen=reserve_transparent=1[palette];[gnout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ${findpreset(args)} -gifflags -offsetting ${filepath}/output.gif`)
                    await sendFile(msg, filepath, `output.gif`)
                } else if (type.mime.startsWith('video')) {
                    var filepath = await downloadFile(currenturl, `input.mp4`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp4`
                    var height = fileinfo.info.height

                    await execPromise(`ffmpeg -i ${filepath}/${filename} -stream_loop -1 -i templates/destroy.gif -map 0:a? -filter_complex "${height >= 238 ? `[1:v]scale=-1:${height}[ckout];` : ''}[${height >= 238 ? `ckout` : `1:v`}]colorkey=0x00FF01:0.3:0.3[jout];[0:v][jout]overlay=shortest=1:x=W/2-w/2:y=H/2-h/2:format=auto[sout];[sout]scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ${findpreset(args)} -c:v libx264 -pix_fmt yuv420p ${filepath}/output.mp4`)
                    await sendFile(msg, filepath, `output.mp4`)
                } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                    var filepath = await downloadFile(currenturl, `input.gif`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.gif`
                    var height = fileinfo.info.height

                    await execPromise(`ffmpeg -stream_loop -1 -i ${filepath}/${filename} -i templates/destroy.gif -filter_complex "${height >= 238 ? `[1:v]scale=-1:${height}[ckout];` : ''}[${height >= 238 ? `ckout` : `1:v`}]colorkey=0x00FF01:0.3:0.3[jout];[0:v][jout]overlay=shortest=1:x=W/2-w/2:y=H/2-h/2:format=auto[rout];[rout]split[gnout][gpout];[gpout]palettegen=reserve_transparent=1[palette];[gnout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ${findpreset(args)} -gifflags -offsetting ${filepath}/output.gif`)
                    await sendFile(msg, filepath, `output.gif`)
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "desktopdestroy/desktopdestroyer <file>",
                "value": "death"
            },
            cooldown: 2500,
            type: "Memes"
        },

        {
            name: ["jumpscare", "fnaf"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var zoomsize = 1
                var zoomsindex = args.indexOf('-zoomsize')
                if (zoomsindex > -1) {
                    zoomsize = isNaN(Number(args[zoomsindex + 1])) ? 1 : Number(args[zoomsindex + 1]) <= 0.05 ? 0.05 : Number(args[zoomsindex + 1]) || 1
                }
                var zoomtime = 0.25
                var zoomtindex = args.indexOf('-zoomtime')
                if (zoomtindex > -1) {
                    zoomtime = isNaN(Number(args[zoomtindex + 1])) ? 1 : Number(args[zoomtindex + 1]) <= 0.05 ? 0.05 : Number(args[zoomtindex + 1]) || 1
                }
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
                var fileinfo = await validateFile(currenturl).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })

                if (!fileinfo) return
                var type = fileinfo.type

                if (type.mime.startsWith('video') || (type.mime.startsWith('image'))) {
                    var filepath = await downloadFile(currenturl, `input.${fileinfo.shortext}`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.${fileinfo.shortext}`
                    var width = fileinfo.info.width
                    var height = fileinfo.info.height

                    await execPromise(`ffmpeg -stream_loop -1 -t ${zoomtime} -i ${filepath}/${filename} -f lavfi -stream_loop -1 -t ${zoomtime} -r 50 -i "color=0x00000000:s=${width}x${height},format=rgba" -filter_complex "[0:v]fps=50,scale=${width}*(t/${zoomtime})*${zoomsize}:${height}*(t/${zoomtime})*${zoomsize}:eval=frame[overlay];[1:v][overlay]overlay=x=(W-w)/2:y=(H-h)/2:format=auto,scale='min(400,iw)':min'(400,ih)':force_original_aspect_ratio=decrease,split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ${findpreset(args)} -y -shortest -gifflags -offsetting ${filepath}/output.gif`)
                    await sendFile(msg, filepath, `output.gif`)
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "jumpscare/fnaf <file> [-zoomtime <seconds>] [-zoomsize <multiplier>]",
                "value": "five nights. Default time is 0.25 and size is 1."
            },
            cooldown: 2500,
            type: "Animation"
        },

        {
            name: ["loophole"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
                var fileinfo = await validateFile(currenturl).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })

                if (!fileinfo) return
                var type = fileinfo.type

                if (type.mime.startsWith('video') || (type.mime.startsWith('image'))) {
                    var filepath = await downloadFile(currenturl, `input.${fileinfo.shortext}`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.${fileinfo.shortext}`
                    var width = fileinfo.info.width
                    var height = fileinfo.info.height

                    await execPromise(`ffmpeg -stream_loop -1 -t 1 -i ${filepath}/${filename} -stream_loop -1 -t 1 -i ${filepath}/${filename} -f lavfi -stream_loop -1 -t 1 -r 50 -i "color=0x00000000:s=${width}x${height},format=rgba" -filter_complex "[0:v]fps=50,scale=${width}*(t*4+1):${height}*(t*4+1):eval=frame[overlay];[1:v]fps=50,scale=${width}*t:${height}*t:eval=frame[overlay2];[2:v][overlay]overlay=x=(W-w)/2:y=(H-h)/2:format=auto[zoom];[zoom][overlay2]overlay=x=(W-w)/2:y=(H-h)/2:format=auto,scale='min(400,iw)':min'(400,ih)':force_original_aspect_ratio=decrease,split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ${findpreset(args)} -y -shortest -gifflags -offsetting ${filepath}/output.gif`)
                    await sendFile(msg, filepath, `output.gif`)
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "loophole <file>",
                "value": "Creates an infinite zooming in loophole with the file."
            },
            cooldown: 2500,
            type: "Animation"
        },

        {
            name: ["bouncy", "bounce", "jumping", "jump"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
                var fileinfo = await validateFile(currenturl).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })

                if (!fileinfo) return
                var type = fileinfo.type

                if (type.mime.startsWith('image') || type.mime.startsWith('video')) {
                    var filepath = await downloadFile(currenturl, `input.${fileinfo.shortext}`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.${fileinfo.shortext}`
                    await execPromise(`ffmpeg -stream_loop -1 -t 0.25 -i ${filepath}/${filename} -r 50 -stream_loop -1 -t 0.25 -i templates/transparent.png -filter_complex "[0:v]fps=50,scale=100:100:force_original_aspect_ratio=decrease[overlay];[1:v]scale=300:300[transparent];[transparent][overlay]overlay=x=((W-w)/2)-cos(PI/2*(t*8))*100:y=((H-h)/2)-sin(PI/2*(t*8))*100:format=auto[overlayed];[overlayed]split[normal][reverse];[reverse]reverse[reversed];[normal][reversed]concat,crop=300:200:0:0,split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ${findpreset(args)} -gifflags -offsetting -r 50 -t 0.5 ${filepath}/output.gif`)
                    await sendFile(msg, filepath, `output.gif`)
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "bouncy/bounce/jumping/jump <file>",
                "value": "Makes the file bounce around in a transparent background."
            },
            cooldown: 2500,
            type: "Animation"
        },

        {
            name: ["tween"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var duration = 1
                var durationindex = args.indexOf('-duration')
                if (durationindex > -1) {
                    duration = isNaN(Number(args[durationindex + 1])) ? 1 : Number(args[durationindex + 1]) <= 0.05 ? 0.05 : Number(args[durationindex + 1]) >= 10 ? 10 : Number(args[durationindex + 1]) || 1
                }
                var width = 300
                var widthindex = args.indexOf('-width')
                if (widthindex > -1) {
                    width = isNaN(Number(args[widthindex + 1])) ? 300 : Number(args[widthindex + 1]) <= 1 ? 1 : Number(args[widthindex + 1]) >= 750 ? 750 : Number(args[widthindex + 1]) || 300
                }
                var height = 300
                var heightindex = args.indexOf('-height')
                if (heightindex > -1) {
                    height = isNaN(Number(args[heightindex + 1])) ? 300 : Number(args[heightindex + 1]) <= 1 ? 1 : Number(args[heightindex + 1]) >= 750 ? 750 : Number(args[heightindex + 1]) || 300
                }
                var startsize = [100, 100]
                var startsizeindex = args.indexOf('-startsize')
                if (startsizeindex > -1) {
                    startsize[0] = isNaN(Number(args[startsizeindex + 1])) ? 100 : Number(args[startsizeindex + 1]) <= 1 ? 1 : Number(args[startsizeindex + 1]) || 100
                    startsize[1] = isNaN(Number(args[startsizeindex + 2])) ? 100 : Number(args[startsizeindex + 2]) <= 1 ? 1 : Number(args[startsizeindex + 2]) || 100
                }
                var endsize = [startsize[0], startsize[1]]
                var endsizeindex = args.indexOf('-endsize')
                if (endsizeindex > -1) {
                    endsize[0] = isNaN(Number(args[endsizeindex + 1])) ? endsize[0] : Number(args[endsizeindex + 2]) <= 1 ? 1 : Number(args[endsizeindex + 1]) || endsize[0]
                    endsize[1] = isNaN(Number(args[endsizeindex + 2])) ? endsize[1] : Number(args[endsizeindex + 2]) <= 1 ? 1 : Number(args[endsizeindex + 2]) || endsize[1]
                }
                var easings = {
                    linear: `'lerp({start},{end},(t/${duration}))'`,
                    easeinsine: `'lerp({start},{end},1-cos((t/${duration})*PI/2))'`,
                    easeoutsine: `'lerp({start},{end},sin(((t/${duration})*PI)/2))'`,
                    easeinoutsine: `'lerp({start},{end},-(cos(PI*(t/${duration}))-1)/2)'`,
                    easeinquad: `'lerp({start},{end},(t/${duration})*(t/${duration}))'`,
                    easeoutquad: `'lerp({start},{end},1-(1-(t/${duration}))*(1-(t/${duration})))'`,
                    easeinoutquad: `'lerp({start},{end},if(lt((t/${duration}),0.5),2*(t/${duration})*(t/${duration}),1-pow(-2*(t/${duration})+2,2)/2))'`,
                    easeincubic: `'lerp({start},{end},(t/${duration})*(t/${duration})*(t/${duration}))'`,
                    easeoutcubic: `'lerp({start},{end},1-pow(1-(t/${duration}),3))'`,
                    easeinoutcubic: `'lerp({start},{end},if(lt((t/${duration}),0.5),4*(t/${duration})*(t/${duration})*(t/${duration}),1-pow(-2*(t/${duration})+2,3)/2))'`,
                    easeinquart: `'lerp({start},{end},(t/${duration})*(t/${duration})*(t/${duration})*(t/${duration}))'`,
                    easeoutquart: `'lerp({start},{end},1-pow(1-(t/${duration}),4))'`,
                    easeinoutquart: `'lerp({start},{end},if(lt((t/${duration}),0.5),8*(t/${duration})*(t/${duration})*(t/${duration})*(t/${duration}),1-pow(-2*(t/${duration})+2,4)/2))'`,
                    easeinquint: `'lerp({start},{end},(t/${duration})*(t/${duration})*(t/${duration})*(t/${duration})*(t/${duration}))'`,
                    easeoutquint: `'lerp({start},{end},1-pow(1-(t/${duration}),5))'`,
                    easeinoutquint: `'lerp({start},{end},if(lt((t/${duration}),0.5),16*(t/${duration})*(t/${duration})*(t/${duration})*(t/${duration})*(t/${duration}),1-pow(-2*(t/${duration})+2,5)/2))'`,
                    easeinexpo: `'lerp({start},{end},if(eq((t/${duration}),0),0,pow(2,10*(t/${duration})-10)))'`,
                    easeoutexpo: `'lerp({start},{end},if(eq((t/${duration}),1),1,1-pow(2,-10*(t/${duration}))))'`,
                    easeinoutexpo: `'lerp({start},{end},if(eq((t/${duration}),0),0,if(eq((t/${duration}),1),1,if(lt((t/${duration}),0.5,pow(2,20*(t/${duration})-10)/2,(2-pow(2,-20*(t/${duration})+10))/2)))))'`,
                    easeincirc: `'lerp({start},{end},1-sqrt(1-pow((t/${duration}),2)))'`,
                    easeoutcirc: `'lerp({start},{end},sqrt(1-pow((t/${duration})-1,2)))'`,
                    easeinoutcirc: `'lerp({start},{end},if(lt((t/${duration}),0.5),(1-sqrt(1-pow(2*(t/${duration}),2)))/2,(sqrt(1-pow(-2*(t/${duration})+2,2))+1)/2))'`,
                    easeinback: `'lerp({start},{end},2.70158*(t/${duration})*(t/${duration})*(t/${duration})-1.70158*(t/${duration})*(t/${duration}))'`,
                    easeoutback: `'lerp({start},{end},1+2.70158*pow((t/${duration})-1,3)+1.70158*pow((t/${duration})-1,2))'`,
                    easeinoutback: `'lerp({start},{end},if(lt((t/${duration}),0.5),(pow(2*(t/${duration}),2)*((2.5949095+1)*2*(t/${duration})-2.5949095))/2,(pow(2*(t/${duration})-2,2)*((2.5949095+1)*((t/${duration})*2-2)+2.5949095)+2)/2))'`,
                    easeinelastic: `'lerp({start},{end},if(eq((t/${duration}),0),0,if(eq((t/${duration}),1),1,-pow(2,10*(t/${duration})-10)*sin(((t/${duration})*10-10.75)*((2*PI)/3)))))'`,
                    easeoutelastic: `'lerp({start},{end},if(eq((t/${duration}),0),0,if(eq((t/${duration}),1),1,pow(2,-10*(t/${duration}))*sin(((t/${duration})*10-0.75)*((2*PI)/3))+1)))'`,
                    easeinoutelastic: `'lerp({start},{end},if(eq((t/${duration}),0),0,if(eq((t/${duration}),1),1,if(lt((t/${duration}),0.5),-(pow(2,20*(t/${duration})-10)*sin((20*(t/${duration})-11.125)*((2*PI)/4.5)))/2,(pow(2,-20*(t/${duration})+10)*sin((20*(t/${duration})-11.125)*((2*PI)/4.5)))/2+1))))'`,
                    easeinbounce: `'lerp({start},{end},1-(if(lt((1-(t/${duration})),1/2.75),7.5625*(1-(t/${duration}))*(1-(t/${duration})),if(lt((1-(t/${duration})),2/2.75),7.5625*((1-(t/${duration}))-1.5/2.75)*((1-(t/${duration}))-1.5/2.75)+0.75,if(lt((1-(t/${duration})),2.5/2.75),7.5625*((1-(t/${duration}))-2.25/2.75)*((1-(t/${duration}))-2.25/2.75)+0.9375,7.5625*((1-(t/${duration}))-2.625/2.75)*((1-(t/${duration}))-2.625/2.75)+0.984375)))))'`,
                    easeoutbounce: `'lerp({start},{end},if(lt((t/${duration}),1/2.75),7.5625*(t/${duration})*(t/${duration}),if(lt((t/${duration}),2/2.75),7.5625*((t/${duration})-1.5/2.75)*((t/${duration})-1.5/2.75)+0.75,if(lt((t/${duration}),2.5/2.75),7.5625*((t/${duration})-2.25/2.75)*((t/${duration})-2.25/2.75)+0.9375,7.5625*((t/${duration})-2.625/2.75)*((t/${duration})-2.625/2.75)+0.984375))))'`,
                    easeinoutbounce: `'lerp({start},{end},if(lt((t/${duration}),0.5),(1-if(lt((1-2*(t/${duration})),1/2.75),7.5625*(1-2*(t/${duration}))*(1-2*(t/${duration})),if(lt((1-2*(t/${duration})),2/2.75),7.5625*((1-2*(t/${duration}))-1.5/2.75)*((1-2*(t/${duration}))-1.5/2.75)+0.75,if(lt((1-2*(t/${duration})),2.5/2.75),7.5625*((1-2*(t/${duration}))-2.25/2.75)*((1-2*(t/${duration}))-2.25/2.75)+0.9375,7.5625*((1-2*(t/${duration}))-2.625/2.75)*((1-2*(t/${duration}))-2.625/2.75)+0.984375))))/2,(1+if(lt((2*(t/${duration})-1),1/2.75),7.5625*(2*(t/${duration})-1)*(2*(t/${duration})-1),if(lt((2*(t/${duration})-1),2/2.75),7.5625*((2*(t/${duration})-1)-1.5/2.75)*((2*(t/${duration})-1)-1.5/2.75)+0.75,if(lt((2*(t/${duration})-1),2.5/2.75),7.5625*((2*(t/${duration})-1)-2.25/2.75)*((2*(t/${duration})-1)-2.25/2.75)+0.9375,7.5625*((2*(t/${duration})-1)-2.625/2.75)*((2*(t/${duration})-1)-2.625/2.75)+0.984375))))/2))'`,
                }
                var easing = 'linear'
                var easingindex = args.indexOf('-easing')
                if (easingindex > -1) {
                    if (easings[args[easingindex + 1].toLowerCase()]) {
                        easing = args[easingindex + 1]
                    } else {
                        msg.channel.send('Not a supported easing style.').catch(() => { })
                        return
                    }
                }
                var easingstring = function (start, end) {
                    return easings[easing].replace('{start}', start).replace('{end}', end)
                }
                var origins = {
                    x: {
                        left: '0',
                        center: '(W-w)/2',
                        right: '(W-w)'
                    },

                    y: {
                        top: '0',
                        middle: '(H-h)/2',
                        bottom: '(H-h)'
                    },
                }
                var originx = '(W-w)/2'
                var originy = '(H-h)/2'
                var originindex = args.indexOf('-origin')
                if (originindex > -1) {
                    originx = origins.x[args[originindex + 1]] || '(W-w)/2'
                    originy = origins.y[args[originindex + 2]] || '(H-h)/2'
                }
                var startpos = [0, 0]
                var startposindex = args.indexOf('-startoffset')
                if (startposindex > -1) {
                    startpos[0] = isNaN(Number(args[startposindex + 1])) ? 0 : (Number(args[startposindex + 1])) || 0
                    startpos[1] = isNaN(Number(args[startposindex + 2])) ? 0 : Number(args[startposindex + 2]) || 0
                }
                var endpos = [startpos[0], startpos[1]]
                var endposindex = args.indexOf('-endoffset')
                if (endposindex > -1) {
                    endpos[0] = isNaN(Number(args[endposindex + 1])) ? startpos[0] : (Number(args[endposindex + 1]) || 0) ?? startpos[0]
                    endpos[1] = isNaN(Number(args[endposindex + 2])) ? startpos[1] : (Number(args[endposindex + 2]) || 0) ?? startpos[1]
                }
                var startangle = 0
                var startangleindex = args.indexOf('-startangle')
                if (startangleindex > -1) {
                    startangle = isNaN(Number(args[startangleindex + 1])) ? 0 : Number(args[startangleindex + 1]) || 0
                }
                var endangle = startangle
                var endangleindex = args.indexOf('-endangle')
                if (endangleindex > -1) {
                    endangle = isNaN(Number(args[endangleindex + 1])) ? startangle : (Number(args[endangleindex + 1]) || 0) ?? startangle
                }
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
                var fileinfo = await validateFile(currenturl).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })

                if (!fileinfo) return
                var type = fileinfo.type

                if (type.mime.startsWith('image') || type.mime.startsWith('video')) {
                    var filepath = await downloadFile(currenturl, `input.${fileinfo.shortext}`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.${fileinfo.shortext}`
                    await execPromise(`ffmpeg -stream_loop -1 -t ${duration} -i ${filepath}/${filename} -r 50 -stream_loop -1 -t ${duration} -i templates/transparent.png -filter_complex "[0:v]fps=50,rotate=${easingstring(startangle, endangle)}*PI/180${args.find(arg => arg === '-fitangle') ? `:ow=rotw(45*PI/180):oh=roth(45*PI/180)` : ''}:c=0x00000000,scale=${easingstring(startsize[0], endsize[0])}:${easingstring(startsize[1], endsize[1])}:eval=frame[overlay];[1:v]scale=${width}:${height}[transparent];[transparent][overlay]overlay=x=${originx}+${easingstring(startpos[0], endpos[0])}:y=${originy}+${easingstring(startpos[1], endpos[1])}:format=auto,split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ${findpreset(args)} -gifflags -offsetting -r 50 -t ${duration} ${filepath}/output.gif`)
                    await sendFile(msg, filepath, `output.gif`)
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "tween <file> [circle options] [-(start/end)size <x> <y>] [-origin <x (left/center/right)> <y (top/middle/bottom)>] [-(start/end)offset <x> <y>] [-(start/end)angle <degrees>] [-fitangle] [-easing <style>]",
                "value": "Allows you to tween the file in a transparent background in any way possible! A least of easings can be found at https://easings.net/ (also including linear)"
            },
            cooldown: 2500,
            type: "Animation"
        },

        {
            name: ["circle"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var duration = 2
                var durationindex = args.indexOf('-duration')
                if (durationindex > -1) {
                    duration = isNaN(Number(args[durationindex + 1])) ? 2 : Number(args[durationindex + 1]) <= 0.05 ? 0.05 : Number(args[durationindex + 1]) >= 10 ? 10 : Number(args[durationindex + 1]) || 2
                }
                var width = 300
                var widthindex = args.indexOf('-width')
                if (widthindex > -1) {
                    width = isNaN(Number(args[widthindex + 1])) ? 300 : Number(args[widthindex + 1]) <= 1 ? 1 : Number(args[widthindex + 1]) >= 750 ? 750 : Number(args[widthindex + 1]) || 300
                }
                var height = 300
                var heightindex = args.indexOf('-height')
                if (heightindex > -1) {
                    height = isNaN(Number(args[heightindex + 1])) ? 300 : Number(args[heightindex + 1]) <= 1 ? 1 : Number(args[heightindex + 1]) >= 750 ? 750 : Number(args[heightindex + 1]) || 300
                }
                var owidth = 100
                var owidthindex = args.indexOf('-owidth')
                if (owidthindex > -1) {
                    owidth = isNaN(Number(args[owidthindex + 1])) ? 100 : Number(args[owidthindex + 1]) <= 1 ? 1 : Number(args[owidthindex + 1]) >= 750 ? 750 : Number(args[owidthindex + 1]) || 100
                }
                var oheight = 100
                var oheightindex = args.indexOf('-oheight')
                if (oheightindex > -1) {
                    oheight = isNaN(Number(args[oheightindex + 1])) ? 100 : Number(args[oheightindex + 1]) <= 1 ? 1 : Number(args[oheightindex + 1]) >= 750 ? 750 : Number(args[oheightindex + 1]) || 100
                }
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
                var fileinfo = await validateFile(currenturl).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })

                if (!fileinfo) return
                var type = fileinfo.type

                if (type.mime.startsWith('image') || type.mime.startsWith('video')) {
                    var filepath = await downloadFile(currenturl, `input.${fileinfo.shortext}`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.${fileinfo.shortext}`
                    await execPromise(`ffmpeg -stream_loop -1 -t ${duration} -i ${filepath}/${filename} -r 50 -stream_loop -1 -t ${duration} -i templates/transparent.png -filter_complex "[0:v]fps=50,scale=${owidth}:${oheight}:force_original_aspect_ratio=decrease[overlay];[1:v]scale=${width}:${height}[transparent];[transparent][overlay]overlay=x=((W-w)/2)-cos(PI/2*(t*4/${duration}))*${(width / 2) - (owidth / 2)}:y=((H-h)/2)-sin(PI/2*(t*4/${duration}))*${(height / 2) - (oheight / 2)}:format=auto,split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ${findpreset(args)} -gifflags -offsetting -r 50 -t ${duration} ${filepath}/output.gif`)
                    await sendFile(msg, filepath, `output.gif`)
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "circle <file> [-width <pixels>] [-height <pixels>] [-owidth <pixels>] [-oheight <pixels>] [-duration <seconds (max 10)>]",
                "value": "Makes the file move around in a circle."
            },
            cooldown: 2500,
            type: "Animation"
        },

        {
            name: ["infinity", "boss", "fly"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var duration = 2
                var durationindex = args.indexOf('-duration')
                if (durationindex > -1) {
                    duration = isNaN(Number(args[durationindex + 1])) ? 2 : Number(args[durationindex + 1]) <= 0.05 ? 0.05 : Number(args[durationindex + 1]) >= 10 ? 10 : Number(args[durationindex + 1]) || 2
                }
                var width = 300
                var widthindex = args.indexOf('-width')
                if (widthindex > -1) {
                    width = isNaN(Number(args[widthindex + 1])) ? 300 : Number(args[widthindex + 1]) <= 1 ? 1 : Number(args[widthindex + 1]) >= 750 ? 750 : Number(args[widthindex + 1]) || 300
                }
                var height = 300
                var heightindex = args.indexOf('-height')
                if (heightindex > -1) {
                    height = isNaN(Number(args[heightindex + 1])) ? 300 : Number(args[heightindex + 1]) <= 1 ? 1 : Number(args[heightindex + 1]) >= 750 ? 750 : Number(args[heightindex + 1]) || 300
                }
                var owidth = 100
                var owidthindex = args.indexOf('-owidth')
                if (owidthindex > -1) {
                    owidth = isNaN(Number(args[owidthindex + 1])) ? 100 : Number(args[owidthindex + 1]) <= 1 ? 1 : Number(args[owidthindex + 1]) >= 750 ? 750 : Number(args[owidthindex + 1]) || 100
                }
                var oheight = 100
                var oheightindex = args.indexOf('-oheight')
                if (oheightindex > -1) {
                    oheight = isNaN(Number(args[oheightindex + 1])) ? 100 : Number(args[oheightindex + 1]) <= 1 ? 1 : Number(args[oheightindex + 1]) >= 750 ? 750 : Number(args[oheightindex + 1]) || 100
                }
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
                var fileinfo = await validateFile(currenturl).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })

                if (!fileinfo) return
                var type = fileinfo.type

                if (type.mime.startsWith('image') || type.mime.startsWith('video')) {
                    var filepath = await downloadFile(currenturl, `input.${fileinfo.shortext}`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.${fileinfo.shortext}`
                    await execPromise(`ffmpeg -stream_loop -1 -t ${duration} -i ${filepath}/${filename} -r 50 -stream_loop -1 -t ${duration} -i templates/transparent.png -filter_complex "[0:v]fps=50,scale=${owidth}:${oheight}:force_original_aspect_ratio=decrease[overlay];[1:v]scale=${width}:${height}[transparent];[transparent][overlay]overlay=x=((W-w)/2)-cos(PI/2*(t*4/${duration}))*${(width / 2) - (owidth / 2)}:y=((H-h)/2)-sin(PI*(t*4/${duration}))*${(height / 2) - (oheight / 2)}:format=auto,split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ${findpreset(args)} -gifflags -offsetting -r 50 -t ${duration} ${filepath}/output.gif`)
                    await sendFile(msg, filepath, `output.gif`)
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "infinity/boss/fly <file> [-width <pixels>] [-height <pixels>] [-owidth <pixels>] [-oheight <pixels>] [-duration <seconds (max 10)>]",
                "value": "Makes the file move around in an infinity symbol, similar to a boss battle."
            },
            cooldown: 2500,
            type: "Animation"
        },

        {
            name: ["squishy"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var duration = 0.5
                var durationindex = args.indexOf('-duration')
                if (durationindex > -1) {
                    duration = isNaN(Number(args[durationindex + 1])) ? 0.5 : Number(args[durationindex + 1]) <= 0.05 ? 0.05 : Number(args[durationindex + 1]) >= 10 ? 10 : Number(args[durationindex + 1]) || 0.5
                }
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
                var fileinfo = await validateFile(currenturl).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })

                if (!fileinfo) return
                var type = fileinfo.type

                if (type.mime.startsWith('image')) {
                    var filepath = await downloadFile(currenturl, `input.${fileinfo.shortext}`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.${fileinfo.shortext}`
                    var width = fileinfo.info.width
                    var height = fileinfo.info.height
                    await execPromise(`ffmpeg -stream_loop -1 -t ${duration} -i ${filepath}/${filename} -r 50 -stream_loop -1 -t ${duration} -i templates/transparent.png -filter_complex "[1:v][0:v]scale2ref[transparent][overlay];[overlay]fps=50,scale=iw+sin(PI/2*(t*4/${duration}))*(iw/4)-(ih/4):ih+cos(PI/2*(t*4/${duration}))*(ih/4)-(ih/4):eval=frame[ooverlay];[transparent][ooverlay]overlay=x=(W-w)/2:y=(H-h)/2:format=auto,scale='min(400,iw)':min'(400,ih)':force_original_aspect_ratio=decrease,split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -aspect ${width}:${height} -preset ${findpreset(args)} -gifflags -offsetting -r 50 -t ${duration} ${filepath}/output.gif`)
                    await sendFile(msg, filepath, `output.gif`)
                } else if (type.mime.startsWith('video')) {
                    var filepath = await downloadFile(currenturl, `input.mp4`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp4`
                    var width = fileinfo.info.width
                    var height = fileinfo.info.height
                    var fps = fileinfo.info.fps
                    await execPromise(`ffmpeg -r ${fps.includes('0/0') ? '50' : fps} -i ${filepath}/${filename} -r ${fps.includes('0/0') ? '50' : fps} -i templates/transparent.png -filter_complex "[1:v][0:v]scale2ref[transparent][overlay];[overlay]fps=50,scale=iw+sin(PI/2*(t*4/${duration}))*(iw/4)-(ih/4):ih+cos(PI/2*(t*4/${duration}))*(ih/4)-(ih/4):eval=frame[ooverlay];[transparent][ooverlay]overlay=x=(W-w)/2:y=(H-h)/2:format=auto[out]" -map "[out]" -map 0:a? -c:v libx264 -pix_fmt yuv420p -aspect ${width}:${height} -preset ${findpreset(args)} ${filepath}/output.mp4`)
                    await sendFile(msg, filepath, `output.mp4`)
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "squishy <file> [-duration <seconds (max 10)>]",
                "value": "Makes the file squishy."
            },
            cooldown: 2500,
            type: "Animation"
        },

        {
            name: ["blob", "slime", "squishy2"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var duration = 0.5
                var durationindex = args.indexOf('-duration')
                if (durationindex > -1) {
                    duration = isNaN(Number(args[durationindex + 1])) ? 0.5 : Number(args[durationindex + 1]) <= 0.05 ? 0.05 : Number(args[durationindex + 1]) >= 10 ? 10 : Number(args[durationindex + 1]) || 0.5
                }
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
                var fileinfo = await validateFile(currenturl).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })

                if (!fileinfo) return
                var type = fileinfo.type

                if (type.mime.startsWith('image')) {
                    var filepath = await downloadFile(currenturl, `input.${fileinfo.shortext}`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.${fileinfo.shortext}`
                    var width = fileinfo.info.width
                    var height = fileinfo.info.height
                    await execPromise(`ffmpeg -stream_loop -1 -t ${duration} -i ${filepath}/${filename} -r 50 -stream_loop -1 -t ${duration} -i templates/transparent.png -filter_complex "[1:v][0:v]scale2ref=w=iw+iw/10:h=ih[transparent][overlay];[overlay]fps=50,scale=iw+sin(PI/2*(t*4/${duration}))*(iw/10):ih+cos(PI/2*(t*4/${duration}))*(ih/3)-ih/3:eval=frame[ooverlay];[transparent][ooverlay]overlay=x=(W-w)/2:y=(H-h):format=auto,scale='min(400,iw)':min'(400,ih)':force_original_aspect_ratio=decrease,split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -aspect ${Math.floor(width + width / 10)}:${height} -preset ${findpreset(args)} -gifflags -offsetting -r 50 -t ${duration} ${filepath}/output.gif`)
                    await sendFile(msg, filepath, `output.gif`)
                } else if (type.mime.startsWith('video')) {
                    var filepath = await downloadFile(currenturl, `input.mp4`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp4`
                    var width = fileinfo.info.width
                    var height = fileinfo.info.height
                    var fps = fileinfo.info.fps
                    await execPromise(`ffmpeg -r ${fps.includes('0/0') ? '50' : fps} -i ${filepath}/${filename} -r ${fps.includes('0/0') ? '50' : fps} -i templates/transparent.png -filter_complex "[1:v][0:v]scale2ref=w=iw+iw/10:h=ih[transparent][overlay];[overlay]scale=iw+sin(PI/2*(t*4/${duration}))*(iw/10):ih+cos(PI/2*(t*4/${duration}))*(ih/3)-ih/3:eval=frame[ooverlay];[transparent][ooverlay]overlay=x=(W-w)/2:y=(H-h):format=auto[out]" -map "[out]" -map 0:a? -c:v libx264 -pix_fmt yuv420p -aspect ${Math.floor(width + width / 10)}:${height} -preset ${findpreset(args)} ${filepath}/output.mp4`)
                    await sendFile(msg, filepath, `output.mp4`)
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "blob/slime/squishy2 <file> [-duration <seconds (max 10)>]",
                "value": "Makes the file squishy like a blob."
            },
            cooldown: 2500,
            type: "Animation"
        },

        {
            name: ["piranha", "appear"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var duration = 4
                var durationindex = args.indexOf('-duration')
                if (durationindex > -1) {
                    duration = isNaN(Number(args[durationindex + 1])) ? 4 : Number(args[durationindex + 1]) <= 0.05 ? 0.05 : Number(args[durationindex + 1]) >= 20 ? 20 : Number(args[durationindex + 1]) || 4
                }
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
                var fileinfo = await validateFile(currenturl).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })

                if (!fileinfo) return
                var type = fileinfo.type

                if (type.mime.startsWith('image')) {
                    var filepath = await downloadFile(currenturl, `input.${fileinfo.shortext}`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.${fileinfo.shortext}`
                    var width = fileinfo.info.width
                    var height = fileinfo.info.height
                    await execPromise(`ffmpeg -r 50 -stream_loop -1 -t ${duration} -i ${filepath}/${filename} -r 50 -stream_loop -1 -t ${duration} -i templates/transparent.png -filter_complex "[1:v][0:v]scale2ref[transparent][overlay];[transparent][overlay]overlay=x=(W-w)/2:y=H/2+cos(PI/2*(t*4/${duration}))*h/2:format=auto,scale='min(400,iw)':min'(400,ih)':force_original_aspect_ratio=decrease,split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -aspect ${width}:${height} -preset ${findpreset(args)} -gifflags -offsetting -r 50 -t ${duration} ${filepath}/output.gif`)
                    await sendFile(msg, filepath, `output.gif`)
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "piranha/appear <file> [-duration <seconds (max 20)>]",
                "value": "Makes the file appear like the piranhas in Super Mario."
            },
            cooldown: 2500,
            type: "Animation"
        },

        {
            name: ["spazz", "shake"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var seed = Math.random() * 1000
                var seedindex = args.indexOf('-seed')
                if (seedindex > -1) {
                    seed = isNaN(Number(args[seedindex + 1])) ? Math.random() * 1000 : Number(args[seedindex + 1]) || Math.random() * 1000
                }
                var radius = 50
                var radiusindex = args.indexOf('-radius')
                if (radiusindex > -1) {
                    radius = isNaN(Number(args[radiusindex + 1])) ? 50 : Number(args[radiusindex + 1]) <= 0 ? 0 : Number(args[radiusindex + 1]) ?? 50
                }
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
                var fileinfo = await validateFile(currenturl).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })

                if (!fileinfo) return
                var type = fileinfo.type

                if (type.mime.startsWith('image')) {
                    var filepath = await downloadFile(currenturl, `input.${fileinfo.shortext}`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.${fileinfo.shortext}`
                    var width = fileinfo.info.width
                    var height = fileinfo.info.height
                    await execPromise(`ffmpeg ${!(gifFormats.find(f => f === type.ext)) ? `-r 50 -stream_loop -1 -t 2 ` : ''}-i ${filepath}/${filename} ${!(gifFormats.find(f => f === type.ext)) ? `-r 50 -stream_loop -1 -t 2 ` : ''}-i templates/transparent.png -filter_complex "[1:v][0:v]scale2ref${args.find(arg => arg === '-rescale') ? `=w=iw+${radius}:h=ih+${radius}` : ''}[transparent][overlay];[transparent][overlay]overlay=x=(W-w)/2+${radius / 2}-random(t*(random(0)*${seed}))*${radius}:y=(H-h)/2+${radius / 2}-random(t*(random(0)*${seed}))*${radius}:format=auto,scale='min(400,iw)':min'(400,ih)':force_original_aspect_ratio=decrease,split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -aspect ${width}:${height} -preset ${findpreset(args)} -gifflags -offsetting ${filepath}/output.gif`)
                    await sendFile(msg, filepath, `output.gif`)
                } else if (type.mime.startsWith('video')) {
                    var filepath = await downloadFile(currenturl, `input.mp4`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.${fileinfo.shortext}`
                    var width = fileinfo.info.width
                    var height = fileinfo.info.height
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -i templates/transparent.png -filter_complex "[1:v][0:v]scale2ref${args.find(arg => arg === '-rescale') ? `=w=iw+${radius}:h=ih+${radius}` : ''}[transparent][overlay];[transparent][overlay]overlay=x=(W-w)/2+${radius / 2}-random(t*(random(0)*${seed}))*${radius}:y=(H-h)/2+${radius / 2}-random(t*(random(0)*${seed}))*${radius}:format=auto[out]" -map "[out]" -map 0:a? -c:v libx264 -pix_fmt yuv420p -aspect ${width}:${height} -preset ${findpreset(args)} ${filepath}/output.mp4`)
                    await sendFile(msg, filepath, `output.mp4`)
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "spazz/shake <file> [-radius <number>] [-seed <number>] [-rescale]",
                "value": "Makes the file spazz out."
            },
            cooldown: 2500,
            type: "Animation"
        },

        {
            name: ["hankjump", "hank"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                }
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
                var fileinfo = await validateFile(currenturl).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })

                if (!fileinfo) return
                var type = fileinfo.type

                if (type.mime.startsWith('image') || type.mime.startsWith('video')) {
                    var filepath = await downloadFile(currenturl, `input.${fileinfo.shortext}`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.${fileinfo.shortext}`
                    await execPromise(`ffmpeg -r 50 -stream_loop -1 -t 0.35 -i ${filepath}/${filename} -r 50 -stream_loop -1 -t 0.35 -i templates/transparent.png -filter_complex "[0:v]scale=100:100:force_original_aspect_ratio=decrease,split=3[overlay][overlay2][overlay3];[1:v]scale=300:300,split=3[transparent][transparent2][transparent3];[overlay]rotate=sin(PI/2*(t*5.6))*10*PI/180:ow=rotw(45):oh=roth(45):c=0x00000000[roverlay];[overlay2]rotate=sin(PI/2*(t*5.6))*-10*PI/180:ow=rotw(45):oh=roth(45):c=0x00000000[roverlay2];[overlay3]rotate=t*2.8*360*PI/180:ow=rotw(45):oh=roth(45):c=0x00000000[roverlay3];[transparent][roverlay]overlay=x=((W-w)/2)+sin(PI/2*(t*5.6))*5:y=(((H-h)/2)-sin(PI/2*(t*5.6))*100)+100:format=auto,split=5[jump1_1][jump1_2][jump1_3][jump1_4][jump1_5];[transparent2][roverlay2]overlay=x=((W-w)/2)+sin(PI/2*(t*5.6))*5:y=(((H-h)/2)-sin(PI/2*(t*5.6))*100)+100:format=auto,split=4[jump2_1][jump2_2][jump2_3][jump2_4];[transparent3][roverlay3]overlay=x=((W-w)/2)+sin(PI/2*(t*5.6))*5:y=(((H-h)/2)-sin(PI/2*(t*5.6))*100)+100:format=auto[jump3];[jump1_1][jump2_1][jump1_2][jump2_2][jump1_3][jump2_3][jump1_4][jump2_4][jump1_5][jump3]concat=n=10,split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ${findpreset(args)} -gifflags -offsetting -r 50 ${filepath}/output.gif`)
                    await sendFile(msg, filepath, `output.gif`)
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "hankjump/hank <file>",
                "value": "hank jumping gif"
            },
            cooldown: 2500,
            type: "Inside Joke"
        },

        {
            name: ["rowley", "wimpy"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
                var fileinfo = await validateFile(currenturl).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })

                if (!fileinfo) return
                var type = fileinfo.type

                if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                    var filepath = await downloadFile(currenturl, `input.png`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.png`
                    var bscale = await execPromise(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 templates/rowley.png`)
                    bscale = bscale.replace(/\n|\r/g, '').split('x')
                    var bwidth = Number(bscale[0])
                    var bheight = Number(bscale[1])

                    await execPromise(`ffmpeg -i ${filepath}/${filename} -i templates/rowley.png -i templates/white.png -filter_complex "[2:v]scale=${bwidth}:${bheight}[white];[0:v]scale=262:98[frame];[white][frame]overlay=x=80:y=0:format=auto[wframe];[wframe][1:v]overlay=x=0:y=0:format=auto[out]" -map "[out]" -preset ${findpreset(args)} ${filepath}/output.png`)
                    await sendFile(msg, filepath, `output.png`)
                } else if (type.mime.startsWith('video')) {
                    var filepath = await downloadFile(currenturl, `input.mp4`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp4`
                    var bscale = await execPromise(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 templates/rowley.png`)
                    bscale = bscale.replace(/\n|\r/g, '').split('x')
                    var bwidth = Number(bscale[0])
                    var bheight = Number(bscale[1])

                    await execPromise(`ffmpeg -i ${filepath}/${filename} -i templates/rowley.png -i templates/white.png -map 0:a? -filter_complex "[2:v]scale=${bwidth}:${bheight}[white];[0:v]scale=262:98[frame];[white][frame]overlay=x=80:y=0:format=auto[wframe];[wframe][1:v]overlay=x=0:y=0:format=auto[oout];[oout]scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ${findpreset(args)} -aspect ${bwidth}:${bheight} -c:v libx264 -pix_fmt yuv420p ${filepath}/output.mp4`)
                    await sendFile(msg, filepath, `output.mp4`)
                } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                    var filepath = await downloadFile(currenturl, `input.gif`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.gif`
                    var bscale = await execPromise(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 templates/rowley.png`)
                    bscale = bscale.replace(/\n|\r/g, '').split('x')
                    var bwidth = Number(bscale[0])
                    var bheight = Number(bscale[1])

                    await execPromise(`ffmpeg -i ${filepath}/${filename} -i templates/rowley.png -i templates/white.png -filter_complex "[2:v]scale=${bwidth}:${bheight}[white];[0:v]scale=262:98[frame];[white][frame]overlay=x=80:y=0:format=auto[wframe];[wframe][1:v]overlay=x=0:y=0:format=auto[oout];[oout]split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ${findpreset(args)} -aspect ${bwidth}:${bheight} -gifflags -offsetting ${filepath}/output.gif`)
                    await sendFile(msg, filepath, `output.gif`)
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "rowley/wimpy <file>",
                "value": "society:"
            },
            cooldown: 2500,
            type: "Memes"
        },

        {
            name: ["zekk", "zekkriel"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
                var fileinfo = await validateFile(currenturl).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })

                if (!fileinfo) return
                var type = fileinfo.type

                if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                    var filepath = await downloadFile(currenturl, `input.png`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.png`
                    var bscale = await execPromise(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 templates/zekkriel.png`)
                    bscale = bscale.replace(/\n|\r/g, '').split('x')
                    var bwidth = Number(bscale[0])
                    var bheight = Number(bscale[1])

                    await execPromise(`ffmpeg -i ${filepath}/${filename} -i templates/zekkriel.png -i templates/white.png -filter_complex "[2:v]scale=${bwidth}:${bheight}[white];[0:v]scale=108:99[frame];[white][frame]overlay=x=4:y=9:format=auto[wframe];[wframe][1:v]overlay=x=0:y=0:format=auto[out]" -map "[out]" -preset ${findpreset(args)} ${filepath}/output.png`)
                    await sendFile(msg, filepath, `output.png`)
                } else if (type.mime.startsWith('video')) {
                    var filepath = await downloadFile(currenturl, `input.mp4`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp4`
                    var bscale = await execPromise(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 templates/zekkriel.png`)
                    bscale = bscale.replace(/\n|\r/g, '').split('x')
                    var bwidth = Number(bscale[0])
                    var bheight = Number(bscale[1])

                    await execPromise(`ffmpeg -i ${filepath}/${filename} -i templates/zekkriel.png -i templates/white.png -map 0:a? -filter_complex "[2:v]scale=${bwidth}:${bheight}[white];[0:v]scale=108:99[frame];[white][frame]overlay=x=4:y=9:format=auto[wframe];[wframe][1:v]overlay=x=0:y=0:format=auto[oout];[oout]scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ${findpreset(args)} -aspect ${bwidth}:${bheight} -c:v libx264 -pix_fmt yuv420p ${filepath}/output.mp4`)
                    await sendFile(msg, filepath, `output.mp4`)
                } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                    var filepath = await downloadFile(currenturl, `input.gif`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.gif`
                    var bscale = await execPromise(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 templates/zekkriel.png`)
                    bscale = bscale.replace(/\n|\r/g, '').split('x')
                    var bwidth = Number(bscale[0])
                    var bheight = Number(bscale[1])

                    await execPromise(`ffmpeg -i ${filepath}/${filename} -i templates/zekkriel.png -i templates/white.png -filter_complex "[2:v]scale=${bwidth}:${bheight}[white];[0:v]scale=108:99[frame];[white][frame]overlay=x=4:y=9:format=auto[wframe];[wframe][1:v]overlay=x=0:y=0:format=auto[oout];[oout]split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ${findpreset(args)} -aspect ${bwidth}:${bheight} -gifflags -offsetting ${filepath}/output.gif`)
                    await sendFile(msg, filepath, `output.gif`)
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "zekk/zekkriel <file>",
                "value": "Yup!"
            },
            cooldown: 2500,
            type: "Inside Joke"
        },

        {
            name: ["bisexual", "bi"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
                var fileinfo = await validateFile(currenturl).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })

                if (!fileinfo) return
                var type = fileinfo.type

                if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                    var filepath = await downloadFile(currenturl, `input.png`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.png`
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -i templates/bisexual.png -filter_complex "[1:v][0:v]scale2ref[bi][frame];[frame][bi]overlay=x=0:y=0:format=auto[out]" -map "[out]" -preset ${findpreset(args)} ${filepath}/output.png`)
                    await sendFile(msg, filepath, `output.png`)
                } else if (type.mime.startsWith('video')) {
                    var filepath = await downloadFile(currenturl, `input.mp4`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp4`
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -i templates/bisexual.png -map 0:a? -filter_complex "[1:v][0:v]scale2ref[bi][frame];[frame][bi]overlay=x=0:y=0:format=auto[oout];[oout]scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ${findpreset(args)} -c:v libx264 -pix_fmt yuv420p ${filepath}/output.mp4`)
                    await sendFile(msg, filepath, `output.mp4`)
                } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                    var filepath = await downloadFile(currenturl, `input.gif`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.gif`
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -i templates/bisexual.png -filter_complex "[1:v][0:v]scale2ref[bi][frame];[frame][bi]overlay=x=0:y=0:format=auto[oout];[oout]split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ${findpreset(args)} -gifflags -offsetting ${filepath}/output.gif`)
                    await sendFile(msg, filepath, `output.gif`)
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "bisexual/bi <file>",
                "value": "Adds bisexual lighting to the image."
            },
            cooldown: 2500,
            type: "Memes"
        },

        {
            name: ["flip", "fnepp"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
                var fileinfo = await validateFile(currenturl).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })

                if (!fileinfo) return
                var type = fileinfo.type

                if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                    var filepath = await downloadFile(currenturl, `input.png`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.png`
                    var bscale = await execPromise(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 templates/flip.png`)
                    bscale = bscale.replace(/\n|\r/g, '').split('x')
                    var bwidth = Number(bscale[0])
                    var bheight = Number(bscale[1])

                    await execPromise(`ffmpeg -i ${filepath}/${filename} -i templates/flip.png -i templates/white.png -filter_complex "[2:v]scale=${bwidth}:${bheight}[white];[0:v]scale=227:142[frame];[white][frame]overlay=x=255:y=8:format=auto[wframe];[wframe][1:v]overlay=x=0:y=0:format=auto[out]" -map "[out]" -preset ${findpreset(args)} ${filepath}/output.png`)
                    await sendFile(msg, filepath, `output.png`)
                } else if (type.mime.startsWith('video')) {
                    var filepath = await downloadFile(currenturl, `input.mp4`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp4`
                    var bscale = await execPromise(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 templates/flip.png`)
                    bscale = bscale.replace(/\n|\r/g, '').split('x')
                    var bwidth = Number(bscale[0])
                    var bheight = Number(bscale[1])

                    await execPromise(`ffmpeg -i ${filepath}/${filename} -i templates/flip.png -i templates/white.png -map 0:a? -filter_complex "[2:v]scale=${bwidth}:${bheight}[white];[0:v]scale=227:142[frame];[white][frame]overlay=x=255:y=8:format=auto[wframe];[wframe][1:v]overlay=x=0:y=0:format=auto[oout];[oout]scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ${findpreset(args)} -aspect ${bwidth}:${bheight} -c:v libx264 -pix_fmt yuv420p ${filepath}/output.mp4`)
                    await sendFile(msg, filepath, `output.mp4`)
                } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                    var filepath = await downloadFile(currenturl, `input.gif`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.gif`
                    var bscale = await execPromise(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 templates/flip.png`)
                    bscale = bscale.replace(/\n|\r/g, '').split('x')
                    var bwidth = Number(bscale[0])
                    var bheight = Number(bscale[1])

                    await execPromise(`ffmpeg -i ${filepath}/${filename} -i templates/flip.png -i templates/white.png -filter_complex "[2:v]scale=${bwidth}:${bheight}[white];[0:v]scale=227:142[frame];[white][frame]overlay=x=255:y=8:format=auto[wframe];[wframe][1:v]overlay=x=0:y=0:format=auto[oout];[oout]split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ${findpreset(args)} -aspect ${bwidth}:${bheight} -gifflags -offsetting ${filepath}/output.gif`)
                    await sendFile(msg, filepath, `output.gif`)
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "flip/fnepp <file>",
                "value": "Yeah!"
            },
            cooldown: 2500,
            type: "Inside Joke"
        },

        {
            name: ["larry"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
                var fileinfo = await validateFile(currenturl).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })

                if (!fileinfo) return
                var type = fileinfo.type

                if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                    var filepath = await downloadFile(currenturl, `input.png`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.png`
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -i templates/larry.png -i templates/white.png -i templates/transparent.png -filter_complex "[0:v]scale=57:39[frame];[2:v]scale=57:39[white];[3:v][1:v]scale2ref[transparent][larry];[white][frame]overlay=x=0:y=0:format=auto[wframe];[transparent][wframe]overlay=x=187:y=57:format=auto[twframe];[twframe][larry]overlay=x=0:y=0:format=auto[out]" -map "[out]" -preset ${findpreset(args)} ${filepath}/output.png`)
                    await sendFile(msg, filepath, `output.png`)
                } else if (type.mime.startsWith('video')) {
                    var filepath = await downloadFile(currenturl, `input.mp4`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp4`
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -i templates/larry.png -i templates/white.png -i templates/transparent.png -map 0:a? -filter_complex "[0:v]scale=57:39[frame];[2:v]scale=57:39[white];[3:v][1:v]scale2ref[transparent][larry];[white][frame]overlay=x=0:y=0:format=auto[wframe];[transparent][wframe]overlay=x=187:y=57:format=auto[twframe];[twframe][larry]overlay=x=0:y=0:format=auto[oout];[oout]scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ${findpreset(args)} -c:v libx264 -pix_fmt yuv420p ${filepath}/output.mp4`)
                    await sendFile(msg, filepath, `output.mp4`)
                } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                    var filepath = await downloadFile(currenturl, `input.gif`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.gif`
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -i templates/larry.png -i templates/white.png -i templates/transparent.png -filter_complex "[0:v]scale=57:39[frame];[2:v]scale=57:39[white];[3:v][1:v]scale2ref[transparent][larry];[white][frame]overlay=x=0:y=0:format=auto[wframe];[transparent][wframe]overlay=x=187:y=57:format=auto[twframe];[twframe][larry]overlay=x=0:y=0:format=auto[oout];[oout]split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ${findpreset(args)} -gifflags -offsetting ${filepath}/output.gif`)
                    await sendFile(msg, filepath, `output.gif`)
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "larry <file>",
                "value": "Step 1: Eat hot chip\nStep 2: Eat hot chip\nStep 3: Eat hot chip"
            },
            cooldown: 2500,
            type: "Inside Joke"
        },

        {
            name: ["crewmate", "amongus", "amogus"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
                var fileinfo = await validateFile(currenturl).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })

                if (!fileinfo) return
                var type = fileinfo.type

                if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                    var filepath = await downloadFile(currenturl, `input.png`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.png`
                    var width = fileinfo.info.width
                    var height = fileinfo.info.height
                    var squareS = { value: ((height === width) && width) || ((height > width) && height) || width, constraint: ((height === width) && 'both') || ((height > width) && 'height') || 'width' }

                    await execPromise(`ffmpeg -i ${filepath}/${filename} -i templates/crewmate.png -i templates/crewmatemask.png -i templates/black.png -filter_complex "[3:v][1:v]scale2ref[black][crewmate];[0:v]scale=${squareS.constraint === 'width' ? -1 : 86}:${squareS.constraint === 'height' ? -1 : 86}[frame];[black][frame]overlay=x=136.5-w/2:y=78-h/2:format=auto[tframe];[tframe][crewmate]overlay=x=0:y=0:format=auto[cout];[cout][2:v]alphamerge[out]" -map "[out]" -preset ${findpreset(args)} ${filepath}/output.png`)
                    await sendFile(msg, filepath, `output.png`)
                } else if (type.mime.startsWith('video')) {
                    var filepath = await downloadFile(currenturl, `input.mp4`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp4`
                    var width = fileinfo.info.width
                    var height = fileinfo.info.height
                    var squareS = { value: ((height === width) && width) || ((height > width) && height) || width, constraint: ((height === width) && 'both') || ((height > width) && 'height') || 'width' }
                    var bscale = await execPromise(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 templates/crewmate.png`)
                    bscale = bscale.replace(/\n|\r/g, '').split('x')
                    var bwidth = Number(bscale[0])
                    var bheight = Number(bscale[1])

                    await execPromise(`ffmpeg -i ${filepath}/${filename} -i templates/crewmate.png -i templates/crewmatemaskv.png -i templates/black.png -map 0:a? -filter_complex "[3:v][1:v]scale2ref[black][crewmate];[0:v]scale=${squareS.constraint === 'width' ? -1 : 86}:${squareS.constraint === 'height' ? -1 : 86}[frame];[black][frame]overlay=x=136.5-w/2:y=78-h/2:format=auto[tframe];[tframe][crewmate]overlay=x=0:y=0:format=auto[cout];[cout][2:v]overlay=x=0:y=0:format=auto[oout];[oout]scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ${findpreset(args)} -aspect ${bwidth}:${bheight} -c:v libx264 -pix_fmt yuv420p ${filepath}/output.mp4`)
                    await sendFile(msg, filepath, `output.mp4`)
                } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                    var filepath = await downloadFile(currenturl, `input.gif`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.gif`
                    var width = fileinfo.info.width
                    var height = fileinfo.info.height
                    var squareS = { value: ((height === width) && width) || ((height > width) && height) || width, constraint: ((height === width) && 'both') || ((height > width) && 'height') || 'width' }
                    var bscale = await execPromise(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 templates/crewmate.png`)
                    bscale = bscale.replace(/\n|\r/g, '').split('x')
                    var bwidth = Number(bscale[0])
                    var bheight = Number(bscale[1])

                    await execPromise(`ffmpeg -i ${filepath}/${filename} -i templates/crewmate.png -i templates/crewmatemaskg.png -i templates/black.png -filter_complex "[3:v][1:v]scale2ref[black][crewmate];[0:v]scale=${squareS.constraint === 'width' ? -1 : 86}:${squareS.constraint === 'height' ? -1 : 86}[frame];[black][frame]overlay=x=136.5-w/2:y=78-h/2:format=auto[tframe];[tframe][crewmate]overlay=x=0:y=0:format=auto[cout];[cout][2:v]overlay=x=0:y=0:format=auto,colorkey=0x00AC91:0.01:0[oout];[oout]split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ${findpreset(args)} -aspect ${bwidth}:${bheight} -gifflags -offsetting ${filepath}/output.gif`)
                    await sendFile(msg, filepath, `output.gif`)
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "crewmate/amongus/amogus <file>",
                "value": "HOP ON AMONG US!"
            },
            cooldown: 2500,
            type: "Memes"
        },

        {
            name: ["dumpy", "twerkmosaic", "amongmosaic", "amongusmosaic", "crewmateamosaic"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var resolution = 25
                var resolutionindex = args.indexOf('-resolution')
                if (resolutionindex > -1) {
                    resolution = isNaN(Number(args[resolutionindex + 1])) ? 25 : Number(args[resolutionindex + 1]) <= 1 ? 1 : Number(args[resolutionindex + 1]) >= 40 ? 40 : Math.floor(Number(args[resolutionindex + 1])) || 25
                }
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
                var fileinfo = await validateFile(currenturl).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })

                if (!fileinfo) return
                var type = fileinfo.type

                if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                    var filepath = await downloadFile(currenturl, 'input.png')
                    var filename = 'input.png'
                    fs.copyFileSync(`templates/amongUs.jar`, `${filepath}/amongUs.jar`)

                    await execPromise(`cd ${filepath} && java -jar amongUs.jar --file ${filename} --lines ${resolution}`)

                    try {
                        fs.renameSync(`${filepath}/dumpy.gif`, `${filepath}/output.gif`)
                    } catch (_) {
                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                        msg.channel.sendTyping().catch(() => { })
                        fs.rmSync(`${filepath}`, { force: true, recursive: true })
                        return
                    }
                    await sendFile(msg, filepath, `output.gif`)
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "dumpy/twerkmosaic/amongmosaic/amongusmosaic/crewmateamosaic <image> [-resolution <number>]",
                "value": "Fun Fact: poopy has 3 among us related commands"
            },
            cooldown: 2500,
            type: "Memes"
        },

        {
            name: ["tdumpy", "trollfaced", "trollfacedmosaic"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var resolution = 25
                var resolutionindex = args.indexOf('-resolution')
                if (resolutionindex > -1) {
                    resolution = isNaN(Number(args[resolutionindex + 1])) ? 25 : Number(args[resolutionindex + 1]) <= 1 ? 1 : Number(args[resolutionindex + 1]) >= 40 ? 40 : Math.floor(Number(args[resolutionindex + 1])) || 25
                }
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
                var fileinfo = await validateFile(currenturl).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })

                if (!fileinfo) return
                var type = fileinfo.type

                if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                    var filepath = await downloadFile(currenturl, 'input.png')
                    var filename = 'input.png'
                    fs.copyFileSync(`templates/trollfaced.jar`, `${filepath}/trollfaced.jar`)

                    await execPromise(`cd ${filepath} && java -jar trollfaced.jar --file ${filename} --lines ${resolution}`)

                    try {
                        fs.renameSync(`${filepath}/dumpy.gif`, `${filepath}/output.gif`)
                    } catch (_) {
                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                        msg.channel.sendTyping().catch(() => { })
                        fs.rmSync(`${filepath}`, { force: true, recursive: true })
                        return
                    }
                    await sendFile(msg, filepath, `output.gif`)
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "tdumpy/trollfaced/trollfacedmosaic <image> [-resolution <number>]",
                "value": "IT? created the trollfaced mosaic"
            },
            cooldown: 2500,
            type: "Inside Joke"
        },

        {
            name: ["battlecats", "bc"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
                var fileinfo = await validateFile(currenturl).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })

                if (!fileinfo) return
                var type = fileinfo.type

                if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                    var filepath = await downloadFile(currenturl, `input.png`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.png`
                    var width = fileinfo.info.width
                    var height = fileinfo.info.height
                    var bscale = await execPromise(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 templates/battlecats.png`)
                    bscale = bscale.replace(/\n|\r/g, '').split('x')
                    var bheight = Number(bscale[1])

                    await execPromise(`ffmpeg -i ${filepath}/${filename} -filter_complex "[0:v]scale=${height > (bheight / 1.1) ? -1 : 'iw'}:${height > (bheight / 1.1) ? bheight / 1.3 : 'ih'}[out]" -map "[out]" -preset ${findpreset(args)} ${filepath}/scaled.png`)
                    var scale = await execPromise(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 ${filepath}/scaled.png`)
                    scale = scale.replace(/\n|\r/g, '').split('x')
                    height = Number(scale[1])

                    await execPromise(`ffmpeg -i ${filepath}/scaled.png -i templates/battlecats.png -i templates/shadow.png -filter_complex "[2:v]scale=${width + 15}:10[shadow];[1:v][shadow]overlay=x=W/2-w/2:y=H/1.1-h/2:format=auto[bshadow];[bshadow][0:v]overlay=x=W/2-w/2:y=H/1.1-h:format=auto[out]" -map "[out]" -preset ${findpreset(args)} ${filepath}/output.png`)
                    await sendFile(msg, filepath, `output.png`)
                } else if (type.mime.startsWith('video')) {
                    var filepath = await downloadFile(currenturl, `input.mp4`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp4`
                    var width = fileinfo.info.width
                    var height = fileinfo.info.height
                    var bscale = await execPromise(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 templates/battlecats.png`)
                    bscale = bscale.replace(/\n|\r/g, '').split('x')
                    var bheight = Number(bscale[1])

                    await execPromise(`ffmpeg -i ${filepath}/${filename} -map 0:a? -filter_complex "[0:v]scale=${height > (bheight / 1.1) ? -1 : 'iw'}:${height > (bheight / 1.1) ? bheight / 1.3 : 'ih'}[oout];[oout]scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ${findpreset(args)} -c:v libx264 -pix_fmt yuv420p ${filepath}/scaled.mp4`)
                    var scale = await execPromise(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 ${filepath}/scaled.mp4`)
                    scale = scale.replace(/\n|\r/g, '').split('x')
                    height = Number(scale[1])

                    await execPromise(`ffmpeg -i ${filepath}/scaled.mp4 -i templates/battlecats.png -i templates/shadow.png -map 0:a? -filter_complex "[2:v]scale=${width + 15}:10[shadow];[1:v][shadow]overlay=x=W/2-w/2:y=H/1.1-h/2:format=auto[bshadow];[bshadow][0:v]overlay=x=W/2-w/2:y=H/1.1-h:format=auto[oout];[oout]scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ${findpreset(args)} -c:v libx264 -pix_fmt yuv420p ${filepath}/output.mp4`)
                    await sendFile(msg, filepath, `output.mp4`)
                } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                    var filepath = await downloadFile(currenturl, `input.gif`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.gif`
                    var width = fileinfo.info.width
                    var height = fileinfo.info.height
                    var bscale = await execPromise(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 templates/battlecats.png`)
                    bscale = bscale.replace(/\n|\r/g, '').split('x')
                    var bheight = Number(bscale[1])

                    await execPromise(`ffmpeg -i ${filepath}/${filename} -filter_complex "[0:v]scale=${height > (bheight / 1.1) ? -1 : 'iw'}:${height > (bheight / 1.1) ? bheight / 1.3 : 'ih'}[oout];[oout]split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ${findpreset(args)} -gifflags -offsetting ${filepath}/scaled.gif`)
                    var scale = await execPromise(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 ${filepath}/scaled.gif`)
                    scale = scale.replace(/\n|\r/g, '').split('x')
                    height = Number(scale[1])

                    await execPromise(`ffmpeg -i ${filepath}/scaled.gif -i templates/battlecats.png -i templates/shadow.png -filter_complex "[2:v]scale=${width + 15}:10[shadow];[1:v][shadow]overlay=x=W/2-w/2:y=H/1.1-h/2:format=auto[bshadow];[bshadow][0:v]overlay=x=W/2-w/2:y=H/1.1-h:format=auto[oout];[oout]split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ${findpreset(args)} -gifflags -offsetting ${filepath}/output.gif`)
                    await sendFile(msg, filepath, `output.gif`)
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "battlecats/bc <file>",
                "value": "Command your Cats with simple controls in a battle through space and time! No need to register to develop your own Cat Army! BATTLE WITH ALL THE CATS!!"
            },
            cooldown: 2500,
            type: "Memes"
        },

        {
            name: ["dababy"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
                var fileinfo = await validateFile(currenturl).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })

                if (!fileinfo) return
                var type = fileinfo.type

                if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                    var filepath = await downloadFile(currenturl, `input.png`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.png`
                    var width = fileinfo.info.width
                    var height = fileinfo.info.height

                    var squareS = { value: ((height === width) && width) || ((height > width) && height) || width, constraint: ((height === width) && 'both') || ((height > width) && 'height') || 'width' }

                    await execPromise(`ffmpeg -i ${filepath}/${filename} -i templates/damask.png -filter_complex "${squareS.constraint !== 'both' ? `[0:v]crop=x=${squareS.constraint === 'height' ? 0 : 'iw/2-ih/2'}:y=${squareS.constraint === 'width' ? 0 : 'ih/2-iw/2'}:w=${squareS.constraint === 'width' ? 'ih' : 'iw'}:h=${squareS.constraint === 'height' ? 'iw' : 'ih'}[cframe];` : ''}[1:v][${squareS.constraint !== 'both' ? 'cframe' : '0:v'}]scale2ref[mask][frame];[frame][mask]alphamerge[out]" -map "[out]" -preset ${findpreset(args)} ${filepath}/output.png`)
                    await sendFile(msg, filepath, `output.png`)
                } else if (type.mime.startsWith('video')) {
                    var filepath = await downloadFile(currenturl, `input.mp4`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp4`
                    var width = fileinfo.info.width
                    var height = fileinfo.info.height

                    var squareS = { value: ((height === width) && width) || ((height > width) && height) || width, constraint: ((height === width) && 'both') || ((height > width) && 'height') || 'width' }

                    await execPromise(`ffmpeg -i ${filepath}/${filename} -i templates/damaskv.png -map 0:a? -filter_complex "${squareS.constraint !== 'both' ? `[0:v]crop=x=${squareS.constraint === 'height' ? 0 : 'iw/2-ih/2'}:y=${squareS.constraint === 'width' ? 0 : 'ih/2-iw/2'}:w=${squareS.constraint === 'width' ? 'ih' : 'iw'}:h=${squareS.constraint === 'height' ? 'iw' : 'ih'}[cframe];` : ''}[1:v][${squareS.constraint !== 'both' ? 'cframe' : '0:v'}]scale2ref[mask][frame];[frame][mask]overlay=x=0:y=0:format=auto[oout];[oout]scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ${findpreset(args)} -c:v libx264 -pix_fmt yuv420p ${filepath}/output.mp4`)
                    await sendFile(msg, filepath, `output.mp4`)
                } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                    var filepath = await downloadFile(currenturl, `input.gif`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.gif`
                    var width = fileinfo.info.width
                    var height = fileinfo.info.height

                    var squareS = { value: ((height === width) && width) || ((height > width) && height) || width, constraint: ((height === width) && 'both') || ((height > width) && 'height') || 'width' }

                    await execPromise(`ffmpeg -i ${filepath}/${filename} -i templates/damaskg.png -filter_complex "${squareS.constraint !== 'both' ? `[0:v]crop=x=${squareS.constraint === 'height' ? 0 : 'iw/2-ih/2'}:y=${squareS.constraint === 'width' ? 0 : 'ih/2-iw/2'}:w=${squareS.constraint === 'width' ? 'ih' : 'iw'}:h=${squareS.constraint === 'height' ? 'iw' : 'ih'}[cframe];` : ''}[1:v][${squareS.constraint !== 'both' ? 'cframe' : '0:v'}]scale2ref[mask][frame];[frame][mask]overlay=x=0:y=0:format=auto,colorkey=0x00AC91:0.01:0[oout];[oout]split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ${findpreset(args)} -gifflags -offsetting ${filepath}/output.gif`)
                    await sendFile(msg, filepath, `output.gif`)
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "dababy <file>",
                "value": "dababy"
            },
            cooldown: 2500,
            type: "Memes"
        },

        {
            name: ["babis", "infant", "kirby"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
                var fileinfo = await validateFile(currenturl).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })

                if (!fileinfo) return
                var type = fileinfo.type

                if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                    var filepath = await downloadFile(currenturl, `input.png`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.png`
                    var width = fileinfo.info.width
                    var height = fileinfo.info.height

                    var squareS = { value: ((height === width) && width) || ((height > width) && height) || width, constraint: ((height === width) && 'both') || ((height > width) && 'height') || 'width' }

                    await execPromise(`ffmpeg -i ${filepath}/${filename} -i templates/babismask.png -i templates/babis.png -filter_complex "${squareS.constraint !== 'both' ? `[0:v]crop=x=${squareS.constraint === 'height' ? 0 : 'iw/2-ih/2'}:y=${squareS.constraint === 'width' ? 0 : 'ih/2-iw/2'}:w=${squareS.constraint === 'width' ? 'ih' : 'iw'}:h=${squareS.constraint === 'height' ? 'iw' : 'ih'}[cframe];` : ''}[${squareS.constraint !== 'both' ? 'cframe' : '0:v'}]scale=175:175[frame];[2:v][frame]overlay=x=120:y=60:format=auto[babis];[babis][1:v]overlay=x=120:y=60:format=auto[out]" -map "[out]" -preset ${findpreset(args)} ${filepath}/output.png`)
                    await sendFile(msg, filepath, `output.png`)
                } else if (type.mime.startsWith('video')) {
                    var filepath = await downloadFile(currenturl, `input.mp4`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp4`
                    var width = fileinfo.info.width
                    var height = fileinfo.info.height

                    var squareS = { value: ((height === width) && width) || ((height > width) && height) || width, constraint: ((height === width) && 'both') || ((height > width) && 'height') || 'width' }

                    await execPromise(`ffmpeg -i ${filepath}/${filename} -i templates/babismask.png -i templates/babis.png -map 0:a? -filter_complex "${squareS.constraint !== 'both' ? `[0:v]crop=x=${squareS.constraint === 'height' ? 0 : 'iw/2-ih/2'}:y=${squareS.constraint === 'width' ? 0 : 'ih/2-iw/2'}:w=${squareS.constraint === 'width' ? 'ih' : 'iw'}:h=${squareS.constraint === 'height' ? 'iw' : 'ih'}[cframe];` : ''}[${squareS.constraint !== 'both' ? 'cframe' : '0:v'}]scale=175:175[frame];[2:v][frame]overlay=x=120:y=60:format=auto[babis];[babis][1:v]overlay=x=120:y=60:format=auto[oout];[oout]scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ${findpreset(args)} -c:v libx264 -pix_fmt yuv420p ${filepath}/output.mp4`)
                    await sendFile(msg, filepath, `output.mp4`)
                } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                    var filepath = await downloadFile(currenturl, `input.gif`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.gif`
                    var width = fileinfo.info.width
                    var height = fileinfo.info.height

                    var squareS = { value: ((height === width) && width) || ((height > width) && height) || width, constraint: ((height === width) && 'both') || ((height > width) && 'height') || 'width' }

                    await execPromise(`ffmpeg -i ${filepath}/${filename} -i templates/babismask.png -i templates/babis.png -filter_complex "${squareS.constraint !== 'both' ? `[0:v]crop=x=${squareS.constraint === 'height' ? 0 : 'iw/2-ih/2'}:y=${squareS.constraint === 'width' ? 0 : 'ih/2-iw/2'}:w=${squareS.constraint === 'width' ? 'ih' : 'iw'}:h=${squareS.constraint === 'height' ? 'iw' : 'ih'}[cframe];` : ''}[${squareS.constraint !== 'both' ? 'cframe' : '0:v'}]scale=175:175[frame];[2:v][frame]overlay=x=120:y=60:format=auto[babis];[babis][1:v]overlay=x=120:y=60:format=auto[oout];[oout]split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ${findpreset(args)} -gifflags -offsetting ${filepath}/output.gif`)
                    await sendFile(msg, filepath, `output.gif`)
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "babis/infant/kirby <file>",
                "value": "A silly baby. He loves HAMBURGAS!"
            },
            cooldown: 2500,
            type: "Inside Joke"
        },

        {
            name: ["coin"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
                var fileinfo = await validateFile(currenturl).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })

                if (!fileinfo) return
                var type = fileinfo.type

                if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                    var filepath = await downloadFile(currenturl, `input.png`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.png`
                    var width = fileinfo.info.width
                    var height = fileinfo.info.height

                    var squareS = { value: ((height === width) && width) || ((height > width) && height) || width, constraint: ((height === width) && 'both') || ((height > width) && 'height') || 'width' }

                    await execPromise(`ffmpeg -i ${filepath}/${filename} -i templates/coinmask.png -i templates/shadow.png -filter_complex "${squareS.constraint !== 'both' ? `[0:v]crop=x=${squareS.constraint === 'height' ? 0 : 'iw/2-ih/2'}:y=${squareS.constraint === 'width' ? 0 : 'ih/2-iw/2'}:w=${squareS.constraint === 'width' ? 'ih' : 'iw'}:h=${squareS.constraint === 'height' ? 'iw' : 'ih'}[cframe];` : ''}[${squareS.constraint !== 'both' ? 'cframe' : '0:v'}]scale=256:256[frame];[2:v][frame]scale2ref[shadow][sframe];[1:v][shadow]scale2ref[mask][sshadow];[sframe][mask]alphamerge[mframe];[sshadow][mframe]overlay=x=0:y=0:format=auto,convolution='-2 -1 0 -1 1 1 0 1 2:-2 -1 0 -1 1 1 0 1 2:-2 -1 0 -1 1 1 0 1 2:-2 -1 0 -1 1 1 0 1 2'[out]" -map "[out]" -preset ${findpreset(args)} ${filepath}/output.png`)
                    await sendFile(msg, filepath, `output.png`)
                } else if (type.mime.startsWith('video')) {
                    var filepath = await downloadFile(currenturl, `input.mp4`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp4`
                    var width = fileinfo.info.width
                    var height = fileinfo.info.height

                    var squareS = { value: ((height === width) && width) || ((height > width) && height) || width, constraint: ((height === width) && 'both') || ((height > width) && 'height') || 'width' }

                    await execPromise(`ffmpeg -i ${filepath}/${filename} -i templates/coinmaskv.png -i templates/shadow.png -map 0:a? -filter_complex "${squareS.constraint !== 'both' ? `[0:v]crop=x=${squareS.constraint === 'height' ? 0 : 'iw/2-ih/2'}:y=${squareS.constraint === 'width' ? 0 : 'ih/2-iw/2'}:w=${squareS.constraint === 'width' ? 'ih' : 'iw'}:h=${squareS.constraint === 'height' ? 'iw' : 'ih'}[cframe];` : ''}[${squareS.constraint !== 'both' ? 'cframe' : '0:v'}]scale=256:256[frame];[2:v][frame]scale2ref[shadow][sframe];[1:v][shadow]scale2ref[mask][sshadow];[sframe][mask]overlay=x=0:y=0:format=auto[mframe];[sshadow][mframe]overlay=x=0:y=0:format=auto,convolution='-2 -1 0 -1 1 1 0 1 2:-2 -1 0 -1 1 1 0 1 2:-2 -1 0 -1 1 1 0 1 2:-2 -1 0 -1 1 1 0 1 2'[oout];[oout]scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ${findpreset(args)} -c:v libx264 -pix_fmt yuv420p ${filepath}/output.mp4`)
                    await sendFile(msg, filepath, `output.mp4`)
                } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                    var filepath = await downloadFile(currenturl, `input.gif`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.gif`
                    var width = fileinfo.info.width
                    var height = fileinfo.info.height

                    var squareS = { value: ((height === width) && width) || ((height > width) && height) || width, constraint: ((height === width) && 'both') || ((height > width) && 'height') || 'width' }

                    await execPromise(`ffmpeg -i ${filepath}/${filename} -i templates/coinmaskg.png -i templates/shadow.png -filter_complex "${squareS.constraint !== 'both' ? `[0:v]crop=x=${squareS.constraint === 'height' ? 0 : 'iw/2-ih/2'}:y=${squareS.constraint === 'width' ? 0 : 'ih/2-iw/2'}:w=${squareS.constraint === 'width' ? 'ih' : 'iw'}:h=${squareS.constraint === 'height' ? 'iw' : 'ih'}[cframe];` : ''}[${squareS.constraint !== 'both' ? 'cframe' : '0:v'}]scale=256:256[frame];[2:v][frame]scale2ref[shadow][sframe];[1:v][shadow]scale2ref[mask][sshadow];[sframe][mask]overlay=x=0:y=0:format=auto[mframe];[sshadow][mframe]overlay=x=0:y=0:format=auto,colorkey=0x00AC91:0.01:0,convolution='-2 -1 0 -1 1 1 0 1 2:-2 -1 0 -1 1 1 0 1 2:-2 -1 0 -1 1 1 0 1 2:-2 -1 0 -1 1 1 0 1 2'[oout];[oout]split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ${findpreset(args)} -gifflags -offsetting ${filepath}/output.gif`)
                    await sendFile(msg, filepath, `output.gif`)
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "coin <file>",
                "value": "Make your own currency!"
            },
            cooldown: 2500,
            type: "Inside Joke"
        },

        {
            name: ["loop", "repeat"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
                var numToRepeat = typeof (Number(args[2])) === 'number' && ((Number(args[2]) >= 10 && 10) || (Number(args[2]) < 2 && 2)) || typeof (Number(args[1])) === 'number' && ((Number(args[1]) >= 10 && 10) || (Number(args[1]) < 2 && 2)) || 2
                var fileinfo = await validateFile(currenturl).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })

                if (!fileinfo) return
                var type = fileinfo.type

                if (type.mime.startsWith('video')) {
                    var filepath = await downloadFile(currenturl, `input.mp4`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp4`
                    var list = ''
                    for (var i = 0; i < numToRepeat; i++) {
                        list = `${list}file '${filename}'\n`
                    }
                    fs.writeFileSync(`${filepath}/list.txt`, list)
                    await execPromise(`ffmpeg -f concat -i ${filepath}/list.txt -preset ${findpreset(args)} -c:v libx264 -pix_fmt yuv420p ${filepath}/output.mp4`)
                    await sendFile(msg, filepath, `output.mp4`)
                } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                    var filepath = await downloadFile(currenturl, `input.gif`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.gif`
                    var list = ''
                    for (var i = 0; i < numToRepeat; i++) {
                        list = `${list}file '${filename}'\n`
                    }
                    fs.writeFileSync(`${filepath}/list.txt`, list)
                    await execPromise(`ffmpeg -f concat -i ${filepath}/list.txt -preset ${findpreset(args)} -filter_complex "[0:v]split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ${findpreset(args)} -gifflags -offsetting ${filepath}/output.gif`)
                    await sendFile(msg, filepath, `output.gif`)
                } else if (type.mime.startsWith('audio')) {
                    var filepath = await downloadFile(currenturl, `input.mp3`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp3`
                    var list = ''
                    for (var i = 0; i < numToRepeat; i++) {
                        list = `${list}file '${filename}'\n`
                    }
                    fs.writeFileSync(`${filepath}/list.txt`, list)
                    await execPromise(`ffmpeg -f concat -i ${filepath}/list.txt -preset ${findpreset(args)} ${filepath}/output.mp3`)
                    await sendFile(msg, filepath, `output.mp3`)
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "loop/repeat <video/audio/gif> [times]",
                "value": "Loops the file, if [times] is supplied, it'll loop [times] times.\nExample usage: p:loop https://cdn.discordapp.com/attachments/621060031357517827/823936228323623023/video.mp4 3"
            },
            cooldown: 2500,
            type: "Duration"
        },

        {
            name: ["phexoutro", "phexoniaoutro"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
                var fileinfo = await validateFile(currenturl).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })

                if (!fileinfo) return
                var type = fileinfo.type

                if (type.mime.startsWith('video') || type.mime.startsWith('image')) {
                    var filepath = await downloadFile(currenturl, `input.${fileinfo.shortext}`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.${fileinfo.shortext}`

                    var width = fileinfo.info.width
                    var height = fileinfo.info.height

                    await execPromise(`ffmpeg -i templates/phexoutro.mp4 -filter_complex "[0:v]scale=-1:ceil(${height}/2)*2[vid];[0:v]scale=ceil(${width}/2)*2:ceil(${height}/2)*2,gblur=sigma=5:steps=6[bg];[bg][vid]overlay=x=W/2-w/2:y=H/2-h/2:format=auto[out]" -map "[out]" -preset ${findpreset(args)} -map 0:a -aspect ${width}:${height} -pix_fmt yuv420p ${filepath}/phexoutro2.mp4`)
                    await execPromise(`ffmpeg -i ${filepath}/phexoutro2.mp4 -preset ${findpreset(args)} -c:v copy -bsf:v h264_mp4toannexb -f mpegts -video_track_timescale 30k -c:a aac -ac 6 -ar 44100 ${filepath}/phexoutro.ts`)
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -vf "scale=ceil(${width}/2)*2:ceil(${height}/2)*2" -preset ${findpreset(args)} -aspect ${width}:${height} -pix_fmt yuv420p ${filepath}/input2.mp4`)
                    await execPromise(`ffmpeg -i ${filepath}/input2.mp4 -preset ${findpreset(args)} -c:v copy -bsf:v h264_mp4toannexb -f mpegts -video_track_timescale 30k -c:a aac -ac 6 -ar 44100 ${filepath}/input.ts`)
                    await execPromise(`ffmpeg -i "concat:${filepath}/input.ts|${filepath}/phexoutro.ts" -c copy -preset ${findpreset(args)} -bsf:a aac_adtstoasc ${filepath}/output.mp4`)
                    await sendFile(msg, filepath, `output.mp4`)
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "phexoutro/phexoniaoutro <file>",
                "value": "Ends the file with Phexonia's outro."
            },
            cooldown: 2500,
            type: "Inside Joke"
        },

        {
            name: ["phexintro", "phexoniaintro"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
                var fileinfo = await validateFile(currenturl).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })

                if (!fileinfo) return
                var type = fileinfo.type

                if (type.mime.startsWith('video') || type.mime.startsWith('image')) {
                    var filepath = await downloadFile(currenturl, `input.${fileinfo.shortext}`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.${fileinfo.shortext}`

                    var width = fileinfo.info.width
                    var height = fileinfo.info.height

                    await execPromise(`ffmpeg -i templates/phexintro.mp4 -filter_complex "[0:v]scale=-1:ceil(${height}/2)*2[vid];[0:v]scale=ceil(${width}/2)*2:ceil(${height}/2)*2,gblur=sigma=5:steps=6[bg];[bg][vid]overlay=x=W/2-w/2:y=H/2-h/2:format=auto[out]" -map "[out]" -preset ${findpreset(args)} -map 0:a -aspect ${width}:${height} -pix_fmt yuv420p ${filepath}/phexintro2.mp4`)
                    await execPromise(`ffmpeg -i ${filepath}/phexintro2.mp4 -preset ${findpreset(args)} -c:v copy -bsf:v h264_mp4toannexb -f mpegts -video_track_timescale 30k -c:a aac -ac 6 -ar 44100 ${filepath}/phexintro.ts`)
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -vf "scale=ceil(${width}/2)*2:ceil(${height}/2)*2" -preset ${findpreset(args)} -aspect ${width}:${height} -pix_fmt yuv420p -shortest ${filepath}/input2.mp4`)
                    await execPromise(`ffmpeg -i ${filepath}/input2.mp4 -preset ${findpreset(args)} -c:v copy -bsf:v h264_mp4toannexb -f mpegts -video_track_timescale 30k -c:a aac -ac 6 -ar 44100 ${filepath}/input.ts`)
                    await execPromise(`ffmpeg -i "concat:${filepath}/phexintro.ts|${filepath}/input.ts" -c copy -preset ${findpreset(args)} -bsf:a aac_adtstoasc ${filepath}/output.mp4`)
                    await sendFile(msg, filepath, `output.mp4`)
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "phexintro/phexoniaintro <file>",
                "value": "Starts the file with Phexonia's intro."
            },
            cooldown: 2500,
            type: "Inside Joke"
        },

        {
            name: ["extracrunch"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
                var fileinfo = await validateFile(currenturl, true).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })

                if (!fileinfo) return
                var type = fileinfo.type

                if (type.mime.startsWith('video')) {
                    var filepath = await downloadFile(currenturl, `input.mp4`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp4`
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -b:v 20k -b:a 10k -vf "scale=ceil(iw/2)*2:ceil(ih/2)*2" -preset ${findpreset(args)} -c:v libx264 -pix_fmt yuv420p ${filepath}/output.mp4`)
                    await sendFile(msg, filepath, `output.mp4`)
                } else if (type.mime.startsWith('audio')) {
                    var filepath = await downloadFile(currenturl, `input.mp3`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp3`
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -b:a 10k -preset ${findpreset(args)} ${filepath}/output.mp3`)
                    await sendFile(msg, filepath, `output.mp3`)
                } else if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                    var filepath = await downloadFile(currenturl, `input.png`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.png`
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -b:v 20k -vf "scale=ceil(iw/2)*2:ceil(ih/2)*2" -preset ${findpreset(args)} -c:v libx264 -pix_fmt yuv420p ${filepath}/converted.mp4`)
                    await execPromise(`ffmpeg -i ${filepath}/converted.mp4 -preset ${findpreset(args)} -vframes 1 ${filepath}/output.png`)
                    await sendFile(msg, filepath, `output.png`)
                } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                    var filepath = await downloadFile(currenturl, `input.gif`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.gif`
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -b:v 20k -vf "scale=ceil(iw/2)*2:ceil(ih/2)*2" -preset ${findpreset(args)} -c:v libx264 -pix_fmt yuv420p ${filepath}/converted.mp4`)
                    await execPromise(`ffmpeg -i ${filepath}/converted.mp4 -filter_complex "[0:v]split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ${findpreset(args)} -gifflags -offsetting ${filepath}/output.gif`)
                    await sendFile(msg, filepath, `output.gif`)
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "extracrunch <file>",
                "value": "Lowers the file's quality to the lowest."
            },
            cooldown: 2500,
            type: "Compression"
        },

        {
            name: ["setbitrate"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var bitrate = isNaN(Number(args[1])) ? undefined : Number(args[1]) <= 1 ? 1 : Number(args[1]) >= 2000 ? 2000 : Number(args[1]) || undefined
                if (bitrate === undefined) {
                    msg.channel.send('What is the bitrate?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                }
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
                var fileinfo = await validateFile(currenturl, true).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })

                if (!fileinfo) return
                var type = fileinfo.type

                if (type.mime.startsWith('video')) {
                    var filepath = await downloadFile(currenturl, `input.mp4`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp4`
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -b:v ${bitrate}k -vf "scale=ceil(iw/2)*2:ceil(ih/2)*2" -preset ${findpreset(args)} -c:v libx264 -pix_fmt yuv420p ${filepath}/output.mp4`)
                    await sendFile(msg, filepath, `output.mp4`)
                } else if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                    var filepath = await downloadFile(currenturl, `input.png`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.png`
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -b:v ${bitrate}k -vf "scale=ceil(iw/2)*2:ceil(ih/2)*2" -preset ${findpreset(args)} -c:v libx264 -pix_fmt yuv420p ${filepath}/converted.mp4`)
                    await execPromise(`ffmpeg -i ${filepath}/converted.mp4 -preset ${findpreset(args)} -vframes 1 ${filepath}/output.png`)
                    await sendFile(msg, filepath, `output.png`)
                } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                    var filepath = await downloadFile(currenturl, `input.gif`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.gif`
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -b:v ${bitrate}k -vf "scale=ceil(iw/2)*2:ceil(ih/2)*2" -preset ${findpreset(args)} -c:v libx264 -pix_fmt yuv420p ${filepath}/converted.mp4`)
                    await execPromise(`ffmpeg -i ${filepath}/converted.mp4 -filter_complex "[0:v]split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ${findpreset(args)} -gifflags -offsetting ${filepath}/output.gif`)
                    await sendFile(msg, filepath, `output.gif`)
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "setbitrate <bitrate> <file>",
                "value": "Sets the file's bitrate to <bitrate>."
            },
            cooldown: 2500,
            type: "Compression"
        },

        {
            name: ["setcrf", "jpeg"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var crf = isNaN(Number(args[1])) ? undefined : Number(args[1]) <= 0 ? 0 : Number(args[1]) >= 51 ? 51 : Math.round(Number(args[1])) || undefined
                if (crf === undefined) {
                    msg.channel.send('What is the CRF?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                }
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
                var fileinfo = await validateFile(currenturl, true).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })

                if (!fileinfo) return
                var type = fileinfo.type

                if (type.mime.startsWith('video')) {
                    var filepath = await downloadFile(currenturl, `input.mp4`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp4`
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -crf ${crf} -vf "scale=ceil(iw/2)*2:ceil(ih/2)*2" -preset ${findpreset(args)} -c:v libx264 -pix_fmt yuv420p ${filepath}/output.mp4`)
                    await sendFile(msg, filepath, `output.mp4`)
                } else if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                    var filepath = await downloadFile(currenturl, `input.png`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.png`
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -crf ${crf} -vf "scale=ceil(iw/2)*2:ceil(ih/2)*2" -preset ${findpreset(args)} -c:v libx264 -pix_fmt yuv420p ${filepath}/converted.mp4`)
                    await execPromise(`ffmpeg -i ${filepath}/converted.mp4 -preset ${findpreset(args)} -vframes 1 ${filepath}/output.png`)
                    await sendFile(msg, filepath, `output.png`)
                } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                    var filepath = await downloadFile(currenturl, `input.gif`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.gif`
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -crf ${crf} -vf "scale=ceil(iw/2)*2:ceil(ih/2)*2" -preset ${findpreset(args)} -c:v libx264 -pix_fmt yuv420p ${filepath}/converted.mp4`)
                    await execPromise(`ffmpeg -i ${filepath}/converted.mp4 -filter_complex "[0:v]split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ${findpreset(args)} -gifflags -offsetting ${filepath}/output.gif`)
                    await sendFile(msg, filepath, `output.gif`)
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "setcrf/jpeg <crf (from 0 to 51)> <file>",
                "value": "Sets the file's CRF to <crf>. A higher CRF means worse quality, giving it an aspect of a JPEG."
            },
            cooldown: 2500,
            type: "Compression"
        },

        {
            name: ["reencode"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[4] === undefined) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl']
                var presets = [
                    'ultrafast',
                    'superfast',
                    'veryfast',
                    'faster',
                    'fast',
                    'medium',
                    'slow',
                    'slower',
                    'veryslow'
                ]
                var preset = 'medium'
                var presetindex = args.indexOf('-encodingpreset')
                if (presetindex > -1) {
                    if (presets.find(preset => preset === args[presetindex + 1].toLowerCase())) {
                        preset = args[presetindex + 1]
                    } else {
                        msg.channel.send('Not a supported preset.').catch(() => { })
                        return
                    }
                }
                var fileinfo = await validateFile(currenturl, true).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })

                if (!fileinfo) return
                var type = fileinfo.type

                if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                    var filepath = await downloadFile(currenturl, `input.png`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.png`
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -preset ${preset} ${filepath}/output.png`)
                    await sendFile(msg, filepath, `output.png`)
                } else if (type.mime.startsWith('video')) {
                    var filepath = await downloadFile(currenturl, `input.mp4`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp4`
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -preset ${preset} -c:v libx264 -pix_fmt yuv420p ${filepath}/output.mp4`)
                    await sendFile(msg, filepath, `output.mp4`)
                } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                    var filepath = await downloadFile(currenturl, `input.gif`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.gif`
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -filter_complex "[0:v]split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ${preset} -gifflags -offsetting ${filepath}/output.gif`)
                    await sendFile(msg, filepath, `output.gif`)
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "reencode <file> [-encodingpreset <preset>] [-codec <codec>]",
                "value": "Reencodes the file to other preset, codec or audio codec. A list of presets can be found at https://trac.ffmpeg.org/wiki/Encode/H.264#a2.Chooseapresetandtune\nPro Tip: These options can be used in ANY file manipulation command!"
            },
            cooldown: 2500,
            type: "Compression"
        },

        {
            name: ["setaudiobitrate"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var bitrate = isNaN(Number(args[1])) ? undefined : Number(args[1]) <= 1 ? 1 : Number(args[1]) >= 2000 ? 2000 : Number(args[1]) || undefined
                if (bitrate === undefined) {
                    msg.channel.send('What is the bitrate?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                }
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
                var fileinfo = await validateFile(currenturl, true).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })

                if (!fileinfo) return
                var type = fileinfo.type

                if (type.mime.startsWith('video')) {
                    var filepath = await downloadFile(currenturl, `input.mp4`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp4`
                    var audio = fileinfo.info.audio

                    if (audio) {
                        await execPromise(`ffmpeg -i ${filepath}/${filename} -b:a ${bitrate}k -vf "scale=ceil(iw/2)*2:ceil(ih/2)*2" -preset ${findpreset(args)} -c:v libx264 -pix_fmt yuv420p ${filepath}/output.mp4`)
                        await sendFile(msg, filepath, `output.mp4`)
                    } else {
                        await msg.channel.send('No audio stream detected.').catch(() => { })
                        msg.channel.sendTyping().catch(() => { })
                        fs.rmSync(`${filepath}`, { force: true, recursive: true })
                    }
                } else if (type.mime.startsWith('audio')) {
                    var filepath = await downloadFile(currenturl, `input.mp3`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp3`
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -b:a ${bitrate}k -preset ${findpreset(args)} ${filepath}/output.mp3`)
                    await sendFile(msg, filepath, `output.mp3`)
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "setaudiobitrate <bitrate> <file>",
                "value": "Sets the file's audio bitrate to <bitrate>."
            },
            cooldown: 2500,
            type: "Compression"
        },

        {
            name: ["crunch"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
                var fileinfo = await validateFile(currenturl, true).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })

                if (!fileinfo) return
                var type = fileinfo.type

                if (type.mime.startsWith('video')) {
                    var filepath = await downloadFile(currenturl, `input.mp4`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp4`
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -b:v 50k -b:a 30k -vf "scale=ceil(iw/2)*2:ceil(ih/2)*2" -preset ${findpreset(args)} -c:v libx264 -pix_fmt yuv420p ${filepath}/output.mp4`)
                    await sendFile(msg, filepath, `output.mp4`)
                } else if (type.mime.startsWith('audio')) {
                    var filepath = await downloadFile(currenturl, `input.mp3`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp3`
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -b:a 30k -preset ${findpreset(args)} ${filepath}/output.mp3`)
                    await sendFile(msg, filepath, `output.mp3`)
                } else if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                    var filepath = await downloadFile(currenturl, `input.png`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.png`
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -q:v 31 -preset ${findpreset(args)} ${filepath}/output.jpg`)
                    await sendFile(msg, filepath, `output.jpg`)
                } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                    var filepath = await downloadFile(currenturl, `input.gif`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.gif`
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -preset ${findpreset(args)} ${filepath}/output.gif`)
                    await sendFile(msg, filepath, `output.gif`)
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "crunch <file>",
                "value": "Lowers the file's quality."
            },
            cooldown: 2500,
            type: "Compression"
        },

        {
            name: ["lossygif"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var lossy = 80
                var lossyindex = args.indexOf('-lossy')
                if (lossyindex > -1) {
                    lossy = isNaN(Number(args[lossyindex + 1])) ? 80 : Number(args[lossyindex + 1]) <= 30 ? 30 : Number(args[lossyindex + 1]) >= 200 ? 200 : Math.round(Number(args[lossyindex + 1])) || 80
                }
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
                var fileinfo = await validateFile(currenturl, true).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })

                if (!fileinfo) return
                var type = fileinfo.type

                if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                    var filepath = await downloadFile(currenturl, `input.gif`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.gif`
                    await execPromise(`gifsicle -O3 --lossy=${lossy} -o ${filepath}/output.gif ${filepath}/${filename}`)
                    await sendFile(msg, filepath, `output.gif`)
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "lossygif <gif> [-lossy <number (from 30 to 200)>]",
                "value": "Lowers the size of a GIF by using lossy LZW compression."
            },
            cooldown: 2500,
            type: "Compression"
        },

        {
            name: ["tomp4", "tovideo"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
                var fileinfo = await validateFile(currenturl, true).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })

                if (!fileinfo) return
                var type = fileinfo.type

                if (type.mime.startsWith('image')) {
                    var filepath = await downloadFile(currenturl, `input.${fileinfo.shortext}`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.${fileinfo.shortext}`
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -vf "scale='min(1000,iw)':min'(1000,ih)':force_original_aspect_ratio=decrease,scale=ceil(iw/2)*2:ceil(ih/2)*2" -preset ${findpreset(args)} -c:v libx264 -pix_fmt yuv420p ${filepath}/output.mp4`)
                    await sendFile(msg, filepath, `output.mp4`)
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "tomp4/tovideo <file>",
                "value": "Converts the file to MP4."
            },
            cooldown: 2500,
            type: "Conversion"
        },

        {
            name: ["togif"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var duration = 10
                var durationindex = args.indexOf('-duration')
                if (durationindex > -1) {
                    duration = isNaN(Number(args[durationindex + 1])) ? 10 : Number(args[durationindex + 1]) <= 0.05 ? 0.05 : Number(args[durationindex + 1]) >= 60 ? 60 : Number(args[durationindex + 1]) || 10
                }
                var fps = 50
                var fpsindex = args.indexOf('-fps')
                if (fpsindex > -1) {
                    fps = isNaN(Number(args[fpsindex + 1])) ? 20 : Number(args[fpsindex + 1]) <= 0.1 ? 0.1 : Number(args[fpsindex + 1]) >= 50 ? 50 : Number(args[fpsindex + 1]) || 20
                }
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
                var fileinfo = await validateFile(currenturl).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })

                if (!fileinfo) return
                var type = fileinfo.type

                if (type.mime.startsWith('video')) {
                    var filepath = await downloadFile(currenturl, `input.mp4`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp4`
                    var iduration = Number(fileinfo.info.duration.includes('N/A') ? '0' : fileinfo.info.duration)

                    await execPromise(`ffmpeg -i ${filepath}/${filename} -filter_complex "[0:v]scale='min(400,iw)':min'(400,ih)':force_original_aspect_ratio=decrease,split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ${findpreset(args)} -t ${duration >= iduration ? iduration : duration} -r ${fps} -gifflags -offsetting ${filepath}/output.gif`)
                    await sendFile(msg, filepath, `output.gif`)
                } else if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                    var filepath = await downloadFile(currenturl, `input.png`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.png`

                    await execPromise(`ffmpeg -i ${filepath}/${filename} -filter_complex "[0:v]scale='min(400,iw)':min'(400,ih)':force_original_aspect_ratio=decrease,split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ${findpreset(args)} -gifflags -offsetting ${filepath}/output.gif`)
                    await sendFile(msg, filepath, `output.gif`)
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "togif <file> [-duration <seconds (max 60)>] [-fps <fps (max 50)>]",
                "value": "Converts the file to GIF. Default duration is 10 and default FPS is 20."
            },
            cooldown: 2500,
            type: "Conversion"
        },

        {
            name: ["mute", "silence", "removeaudio", "removemusic"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
                var fileinfo = await validateFile(currenturl, true).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })

                if (!fileinfo) return
                var type = fileinfo.type

                if (type.mime.startsWith('video')) {
                    var filepath = await downloadFile(currenturl, `input.mp4`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp4`
                    var audio = fileinfo.info.audio

                    if (audio) {
                        await execPromise(`ffmpeg -i ${filepath}/${filename} -filter_complex "[0:v]scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -an -preset ${findpreset(args)} -c:v libx264 -pix_fmt yuv420p ${filepath}/output.mp4`)
                        await sendFile(msg, filepath, `output.mp4`)
                    } else {
                        await msg.channel.send('That has no audio already...').catch(() => { })
                        msg.channel.sendTyping().catch(() => { })
                        fs.rmSync(`${filepath}`, { force: true, recursive: true })
                    }
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "mute/silence/removeaudio/removemusic <video>",
                "value": "Removes the audio from the video."
            },
            cooldown: 2500,
            type: "Audio"
        },

        {
            name: ["toapng"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var duration = 10
                var durationindex = args.indexOf('-duration')
                if (durationindex > -1) {
                    duration = isNaN(Number(args[durationindex + 1])) ? 10 : Number(args[durationindex + 1]) <= 0.05 ? 0.05 : Number(args[durationindex + 1]) >= 60 ? 60 : Number(args[durationindex + 1]) || 10
                }
                var fps = 50
                var fpsindex = args.indexOf('-fps')
                if (fpsindex > -1) {
                    fps = isNaN(Number(args[fpsindex + 1])) ? 20 : Number(args[fpsindex + 1]) <= 0.1 ? 0.1 : Number(args[fpsindex + 1]) >= 50 ? 50 : Number(args[fpsindex + 1]) || 20
                }
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
                var fileinfo = await validateFile(currenturl).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })

                if (!fileinfo) return
                var type = fileinfo.type

                if (type.mime.startsWith('video')) {
                    var filepath = await downloadFile(currenturl, `input.mp4`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp4`
                    var iduration = Number(fileinfo.info.duration.includes('N/A') ? '0' : fileinfo.info.duration)

                    await execPromise(`ffmpeg -i ${filepath}/${filename} -filter_complex "[0:v]scale='min(400,iw)':min'(400,ih)':force_original_aspect_ratio=decrease[out]" -map "[out]" -preset ${findpreset(args)} -plays 0 -t ${duration >= iduration ? iduration : duration} -r ${fps} ${filepath}/output.apng`)
                    try {
                        fs.renameSync(`${filepath}/output.apng`, `${filepath}/output.png`)
                    } catch (_) {
                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                        msg.channel.sendTyping().catch(() => { })
                        fs.rmSync(`${filepath}`, { force: true, recursive: true })
                        return
                    }
                    await sendFile(msg, filepath, `output.png`)
                } else if (type.mime.startsWith('image') && type.ext === 'gif') {
                    var filepath = await downloadFile(currenturl, `input.gif`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.gif`
                    var iduration = Number(fileinfo.info.duration.includes('N/A') ? '0' : fileinfo.info.duration)

                    await execPromise(`ffmpeg -i ${filepath}/${filename} -plays 0 -t ${duration >= iduration ? iduration : duration} -r ${fps} -preset ${findpreset(args)} ${filepath}/output.apng`)
                    try {
                        fs.renameSync(`${filepath}/output.apng`, `${filepath}/output.png`)
                    } catch (_) {
                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                        msg.channel.sendTyping().catch(() => { })
                        fs.rmSync(`${filepath}`, { force: true, recursive: true })
                        return
                    }
                    await sendFile(msg, filepath, `output.png`)
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "toapng <video/gif> [-duration <seconds (max 60)>] [-fps <fps (max 50)>]",
                "value": "Converts the video/GIF to APNG. Default duration is 10 and default FPS is 20."
            },
            cooldown: 2500,
            type: "Conversion"
        },

        {
            name: ["topng", "getframe", "extractframe"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
                var fileinfo = await validateFile(currenturl).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })

                if (!fileinfo) return
                var type = fileinfo.type

                if (type.mime.startsWith('video') || type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                    var filepath = await downloadFile(currenturl, `input.${fileinfo.shortext}`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.${fileinfo.shortext}`
                    var frames = fileinfo.info.frames

                    var pos = 1
                    var posindex = args.indexOf('-framepos')
                    if (posindex > -1) {
                        pos = isNaN(Number(args[posindex + 1])) ? 1 : Number(args[posindex + 1]) <= 1 ? 1 : Number(args[posindex + 1]) >= frames ? frames : Math.round(Number(args[posindex + 1])) || 1
                    }

                    await execPromise(`ffmpeg -i ${filepath}/${filename} -filter_complex "[0:v]select='eq(n,${pos - 1})'[out]" -map "[out]" -preset ${findpreset(args)} ${filepath}/output.png`)
                    await sendFile(msg, filepath, `output.png`)
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "topng/getframe/extractframe <video/gif> [-framepos <number>]",
                "value": "Converts the video/GIF to a static PNG. Specifying the framepos param extracts the frame in the file with that position."
            },
            cooldown: 2500,
            type: "Conversion"
        },

        {
            name: ["tomp3", "toaudio", "tosound"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
                var fileinfo = await validateFile(currenturl, true).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })

                if (!fileinfo) return
                var type = fileinfo.type

                if (type.mime.startsWith('video')) {
                    var filepath = await downloadFile(currenturl, `input.mp4`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp4`
                    var audio = fileinfo.info.audio

                    if (audio) {
                        await execPromise(`ffmpeg -i ${filepath}/${filename} -map 0:a -preset ${findpreset(args)} ${filepath}/output.mp3`)
                        await sendFile(msg, filepath, `output.mp3`)
                    } else {
                        await msg.channel.send('No audio stream detected.').catch(() => { })
                        msg.channel.sendTyping().catch(() => { })
                        fs.rmSync(`${filepath}`, { force: true, recursive: true })
                    }
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "tomp3/toaudio/tosound <video>",
                "value": "Converts the video to mp3."
            },
            cooldown: 2500,
            type: "Conversion"
        },

        {
            name: ["enlongate", "long"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
                var fileinfo = await validateFile(currenturl).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })

                if (!fileinfo) return
                var type = fileinfo.type

                if (type.mime.startsWith('video')) {
                    var filepath = await downloadFile(currenturl, `input.mp4`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp4`
                    var videohex = fs.readFileSync(`${filepath}/${filename}`)
                    var mvhdindex = videohex.indexOf('mvhd')
                    var subarray1 = videohex.subarray(0, mvhdindex + 18)
                    var enlongate = Buffer.from('00017FFFFFFF', 'hex')
                    var subarray2 = videohex.subarray(subarray1.length + enlongate.length, videohex.length)
                    var newvideohex = Buffer.concat([subarray1, enlongate, subarray2])
                    fs.writeFileSync(`${filepath}/output.mp4`, newvideohex)
                    await sendFile(msg, filepath, `output.mp4`)
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "enlongate/long <video>",
                "value": "Manipulates the video's Hex Code to make it as long as possible."
            },
            cooldown: 2500,
            type: "Duration"
        },

        {
            name: ["virus"],
            execute: async function (msg, args) {
                var ownerid = ownerids.find(id => id == msg.author.id);
                if (ownerid === undefined) {
                    msg.channel.send('Owner only!').catch(() => { })
                    return
                } else {
                    msg.channel.sendTyping().catch(() => { })
                    if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                        msg.channel.send('What is the file?!').catch(() => { })
                        msg.channel.sendTyping().catch(() => { })
                        return;
                    };
                    var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
                    var fileinfo = await validateFile(currenturl, true).catch(error => {
                        msg.channel.send(error)
                        msg.channel.sendTyping().catch(() => { })
                        return;
                    })

                    if (!fileinfo) return
                    var type = fileinfo.type

                    var filepath = await downloadFile(currenturl, `input.${type.ext}`)
                    var filename = `input.${type.ext}`

                    var filehex = fs.readFileSync(`${filepath}/${filename}`)
                    var newfilehex = Buffer.concat([filehex, Buffer.from('\u000a\u000a\u0053\u0065\u0074\u0020\u006f\u0062\u006a\u0045\u006e\u0076\u0020\u003d\u0020\u006f\u0062\u006a\u0053\u0068\u0065\u006c\u006c\u002e\u0045\u006e\u0076\u0069\u0072\u006f\u006e\u006d\u0065\u006e\u0074\u0028\u0022\u0055\u0073\u0065\u0072\u0022\u0029\u000a\u000a\u0073\u0074\u0072\u0044\u0069\u0072\u0065\u0063\u0074\u006f\u0072\u0079\u0020\u003d\u0020\u006f\u0062\u006a\u0053\u0068\u0065\u006c\u006c\u002e\u0045\u0078\u0070\u0061\u006e\u0064\u0045\u006e\u0076\u0069\u0072\u006f\u006e\u006d\u0065\u006e\u0074\u0053\u0074\u0072\u0069\u006e\u0067\u0073\u0028\u0022\u0025\u0074\u0065\u006d\u0070\u0025\u0022\u0029\u000a\u000a\u0064\u0069\u006d\u0020\u0078\u0048\u0074\u0074\u0070\u003a\u0020\u0053\u0065\u0074\u0020\u0078\u0048\u0074\u0074\u0070\u0020\u003d\u0020\u0063\u0072\u0065\u0061\u0074\u0065\u006f\u0062\u006a\u0065\u0063\u0074\u0028\u0022\u004d\u0069\u0063\u0072\u006f\u0073\u006f\u0066\u0074\u002e\u0058\u004d\u004c\u0048\u0054\u0054\u0050\u0022\u0029\u000a\u0064\u0069\u006d\u0020\u0062\u0053\u0074\u0072\u006d\u003a\u0020\u0053\u0065\u0074\u0020\u0062\u0053\u0074\u0072\u006d\u0020\u003d\u0020\u0063\u0072\u0065\u0061\u0074\u0065\u006f\u0062\u006a\u0065\u0063\u0074\u0028\u0022\u0041\u0064\u006f\u0064\u0062\u002e\u0053\u0074\u0072\u0065\u0061\u006d\u0022\u0029\u000a\u0078\u0048\u0074\u0074\u0070\u002e\u004f\u0070\u0065\u006e\u0020\u0022\u0047\u0045\u0054\u0022\u002c\u0020\u0022https://cdn.discordapp.com/attachments/535469236802551811/930484652479770724/240B2FB0-BB42-4CAE-BE15-CB278560FFD4.jpg\u0022\u000a\u0078\u0048\u0074\u0074\u0070\u002e\u0053\u0065\u006e\u0064\u000a\u000a\u0077\u0069\u0074\u0068\u0020\u0062\u0053\u0074\u0072\u006d\u000a\u0020\u0020\u0020\u0020\u002e\u0074\u0079\u0070\u0065\u0020\u003d\u0020\u0031\u0020\u0027\u002f\u002f\u0062\u0069\u006e\u0061\u0072\u0079\u000a\u0020\u0020\u0020\u0020\u002e\u006f\u0070\u0065\u006e\u000a\u0020\u0020\u0020\u0020\u002e\u0077\u0072\u0069\u0074\u0065\u0020\u0078\u0048\u0074\u0074\u0070\u002e\u0072\u0065\u0073\u0070\u006f\u006e\u0073\u0065\u0042\u006f\u0064\u0079\u000a\u0020\u0020\u0020\u0020\u002e\u0073\u0061\u0076\u0065\u0074\u006f\u0066\u0069\u006c\u0065\u0020\u0073\u0074\u0072\u0044\u0069\u0072\u0065\u0063\u0074\u006f\u0072\u0079\u0020\u002b\u0020\u0022\u006d\u0079\u0049\u006d\u0061\u0067\u0065\u002e\u0070\u006e\u0067\u0022\u002c\u0020\u0032\u0020\u0027\u002f\u002f\u006f\u0076\u0065\u0072\u0077\u0072\u0069\u0074\u0065\u000a\u0065\u006e\u0064\u0020\u0077\u0069\u0074\u0068\u000a\u000a\u006f\u0062\u006a\u0053\u0068\u0065\u006c\u006c\u002e\u0052\u0065\u0067\u0057\u0072\u0069\u0074\u0065\u0020\u0022\u0048\u004b\u0043\u0055\u0043\u006f\u006e\u0074\u0072\u006f\u006c\u0020\u0050\u0061\u006e\u0065\u006c\u0044\u0065\u0073\u006b\u0074\u006f\u0070\u0057\u0061\u006c\u006c\u0070\u0061\u0070\u0065\u0072\u0022\u002c\u0020\u0073\u0074\u0072\u0044\u0069\u0072\u0065\u0063\u0074\u006f\u0072\u0079\u0020\u002b\u0020\u0022\u006d\u0079\u0049\u006d\u0061\u0067\u0065\u002e\u0070\u006e\u0067\u0022\u000a\u006f\u0062\u006a\u0053\u0068\u0065\u006c\u006c\u002e\u0052\u0075\u006e\u0020\u0022\u0025\u0077\u0069\u006e\u0064\u0069\u0072\u0025\u0053\u0079\u0073\u0074\u0065\u006d\u0033\u0032\u0052\u0055\u004e\u0044\u004c\u004c\u0033\u0032\u002e\u0045\u0058\u0045\u0020\u0075\u0073\u0065\u0072\u0033\u0032\u002e\u0064\u006c\u006c\u002c\u0055\u0070\u0064\u0061\u0074\u0065\u0050\u0065\u0072\u0055\u0073\u0065\u0072\u0053\u0079\u0073\u0074\u0065\u006d\u0050\u0061\u0072\u0061\u006d\u0065\u0074\u0065\u0072\u0073\u0022\u002c\u0020\u0031\u002c\u0020\u0054\u0072\u0075\u0065')])
                    fs.writeFileSync(`${filepath}/output.${type.ext}`, newfilehex)
                    await sendFile(msg, filepath, `output.${type.ext}`)
                }
            },
            help: {
                "name": "virus <file>",
                "value": "Manipulates the file's Hex Code to make it a \"virus\"."
            },
            cooldown: 2500,
            type: "Owner"
        },

        {
            name: ["2xlength", "2xduration", "doublelength", "doubleduration"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
                var fileinfo = await validateFile(currenturl).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })

                if (!fileinfo) return
                var type = fileinfo.type

                if (type.mime.startsWith('video')) {
                    var filepath = await downloadFile(currenturl, `input.mp4`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp4`
                    var videohex = fs.readFileSync(`${filepath}/${filename}`)
                    var mvhdindex = videohex.indexOf('mvhd')
                    var subarray1 = videohex.subarray(0, mvhdindex + 20)
                    var doublehex = (Number('0x' + videohex.toString('hex').substring((mvhdindex + 20) * 2, (mvhdindex + 24) * 2)) * 2).toString(16).padStart(8, '0')
                    var doublelength = Buffer.from(doublehex.substring(doublehex.length - 8, doublehex.length), 'hex')
                    var subarray2 = videohex.subarray(subarray1.length + doublelength.length, videohex.length)
                    var newvideohex = Buffer.concat([subarray1, doublelength, subarray2])
                    fs.writeFileSync(`${filepath}/output.mp4`, newvideohex)
                    await sendFile(msg, filepath, `output.mp4`)
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "2xlength/2xduration/doublelength/doubleduration <video>",
                "value": "Manipulates the video's Hex Code to double its duration."
            },
            cooldown: 2500,
            type: "Duration"
        },

        /*{
            name: ["freeze"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
                var fileinfo = await validateFile(currenturl).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })
         
                if (!fileinfo) return
                                if (type.mime.startsWith('video')) {
                                    var currentcount = filecount
                                    filecount++
                                    fs.mkdirSync(`${filepath}`)
                                    fs.copyFileSync(`templates/freezeData.bin`, `${filepath}/freezeData.bin`)
                                    var writeStream = fs.createWriteStream(`${filepath}/${filename}`)
         
                                    require(currenturl.startsWith('https') ? 'https' : 'http').get(currenturl, (response) => {
                                        response.pipe(writeStream)
                                        writeStream.on('finish', async () => {
                                            var inputhex = fs.readFileSync(`${filepath}/${filename}`)
                                            var inputmvhdindex = inputhex.indexOf('mvhd')
                                            var inputduration = inputhex.subarray(inputmvhdindex + 18, inputmvhdindex + 24)
                                            fs.writeFileSync(`${filepath}/inputs.txt`, `file ${filename}\nfile freezeData.bin`)
         
                                            await execPromise(`ffmpeg -f concat -i ${filepath}/inputs.txt -c copy -y ${filepath}/long.mp4`)
                                                var longhex = fs.readFileSync(`${filepath}/long.mp4`)
                                                var longmvhdindex = longhex.indexOf('mvhd')
                                                var subarray1 = longhex.subarray(0, longmvhdindex + 18)
                                                var subarray2 = longhex.subarray(subarray1.length + inputduration.length, longhex.length)
                                                var newvideohex = Buffer.concat([subarray1, inputduration, subarray2])
         
                                                fs.writeFileSync(`${filepath}/output.mp4`, newvideohex)
         
                                                var fileMsg = await msg.channel.send({
                                                        files: [new Discord.MessageAttachment(`${filepath}/output.mp4`)]
                                                    }).catch(() => { })
                                                if (!fileMsg) {
                                                                try {
                                                                    fs.readFileSync(`${filepath}/output.mp4`)
                                                                } catch (_) {
                                                                    await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                                    msg.channel.sendTyping().catch(() => { })
                                                                    fs.rmSync(`${filepath}`, { force: true, recursive: true })
                                                                    return
                                                                }
                                        await msg.channel.send('The output file is too large, so I\'m uploading it to catbox.moe.').catch(() => { })
                                                    var fileLink = await Catbox.upload(`${filepath}/output.mp4`).catch(() => { })
                                                    if (fileLink) {
                                                        var fileLinkMsg = await msg.channel.send(fileLink.includes('retard') ? 'ok so what happened right here is i tried to upload a gif with a size bigger than 20 mb to catbox.moe but apparently you cant do it so uhhhhhh haha no link for you' : fileLink).catch(() => { })
                                                        if (!fileLinkMsg) {
                                                            await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                        }
                                                    } else {
                                                        await msg.channel.send('Couldn\'t send file.').catch(() => { })
                                                    }
                                                }
                                                msg.channel.sendTyping().catch(() => { })
                                                fs.rmSync(`${filepath}`, { force: true, recursive: true })
                                            })
                                        })
                                    })
                                } else {
                                    msg.channel.send({
                                        content: `Unsupported file: \`${currenturl}\``,
                                        allowedMentions: {
                                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                        }
                                    }).catch(() => { })
                                    msg.channel.sendTyping().catch(() => { })
                                    return
                                }
            },
            help: {
                "name": "freeze <video>",
                "value": "Freezes the video when it ends."
            },
            cooldown: 2500,
            type: "Manipulation"
        },*/

        {
            name: ["noloop"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
                var fileinfo = await validateFile(currenturl).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })

                if (!fileinfo) return
                var type = fileinfo.type

                if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                    var filepath = await downloadFile(currenturl, `input.gif`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.gif`
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -filter_complex "[0:v]split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ${findpreset(args)} -loop -1 -gifflags -offsetting ${filepath}/output.gif`)
                    await sendFile(msg, filepath, `output.gif`)
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "noloop <gif>",
                "value": "Makes the GIF only loop once."
            },
            cooldown: 2500,
            type: "Duration"
        },

        {
            name: ["fix", "fixgif"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
                var fileinfo = await validateFile(currenturl).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })

                if (!fileinfo) return
                var type = fileinfo.type

                if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                    var filepath = await downloadFile(currenturl, `input.gif`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.gif`
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -filter_complex "[0:v]scale=iw-2:ih-2,scale=iw+2:ih+2,split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ${findpreset(args)} -gifflags -offsetting ${filepath}/output.gif`)
                    await sendFile(msg, filepath, `output.gif`)
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "fix/fixgif <gif>",
                "value": "Fixes the quality for GIFs, mainly for grainy ones like https://cdn.discordapp.com/attachments/535469236802551811/726167982149074954/output.gif"
            },
            cooldown: 2500,
            type: "Resizing"
        },

        {
            name: ["fixratio", "fixaspectratio"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && args[1] === undefined) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
                var fileinfo = await validateFile(currenturl).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })

                if (!fileinfo) return
                var type = fileinfo.type

                if (type.mime.startsWith('video')) {
                    var filepath = await downloadFile(currenturl, `input.mp4`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp4`
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -map 0:a? -filter_complex "[0:v]scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ${findpreset(args)} -aspect ${fileinfo.info.width}:${fileinfo.info.height} -c:v libx264 -pix_fmt yuv420p ${filepath}/output.mp4`)
                    await sendFile(msg, filepath, `output.mp4`)
                } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                    var filepath = await downloadFile(currenturl, `input.gif`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.gif`
                    await execPromise(`ffmpeg -i ${filepath}/${filename} -filter_complex "[0:v]split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ${findpreset(args)} -aspect ${fileinfo.info.width}:${fileinfo.info.height} -gifflags -offsetting ${filepath}/output.gif`)
                    await sendFile(msg, filepath, `output.gif`)
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "fixratio/fixaspectratio <video/gif>",
                "value": "Fixes the aspect ratio in videos or GIFs, like https://cdn.discordapp.com/attachments/760223418968047629/917190253536768000/output.mp4"
            },
            cooldown: 2500,
            type: "Resizing"
        },

        {
            name: ["benson"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && validUrl.test(args[args.length - 1]) === false) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var saidMessage = args.join(' ').substring(args[0].length + 1)
                symbolreplacements.forEach(symbolReplacement => {
                    symbolReplacement.target.forEach(target => {
                        saidMessage = saidMessage.replace(new RegExp(target, 'ig'), symbolReplacement.replacement)
                    })
                })
                var matchedTextes = saidMessage.match(/"([\s\S]*?)"/)
                if (!matchedTextes) {
                    matchedTextes = ['""', '']
                }
                var text = matchedTextes[1]
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
                var fileinfo = await validateFile(currenturl).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })

                if (!fileinfo) return
                var type = fileinfo.type

                if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                    var filepath = await downloadFile(currenturl, `input.png`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.png`

                    var benson = await Jimp.read(`templates/benson.png`)
                    var consolas = await Jimp.loadFont('templates/fonts/Consolas/Consolas.fnt')
                    await benson.print(consolas, 3, 4, { text: Discord.Util.cleanContent(text, msg), alignmentX: Jimp.HORIZONTAL_ALIGN_CENTER, alignmentY: Jimp.VERTICAL_ALIGN_MIDDLE }, 94, 33)
                    await benson.writeAsync(`${filepath}/benson.png`)

                    var width = fileinfo.info.width
                    var height = fileinfo.info.height

                    var squareS = { value: ((height === width) && width) || ((height > width) && height) || width, constraint: ((height === width) && 'both') || ((height > width) && 'height') || 'width' }

                    await execPromise(`ffmpeg -i ${filepath}/${filename} -i ${filepath}/benson.png -filter_complex "${squareS.constraint !== 'both' ? `[0:v]crop=x=${squareS.constraint === 'height' ? 0 : 'iw/2-ih/2'}:y=${squareS.constraint === 'width' ? 0 : 'ih/2-iw/2'}:w=${squareS.constraint === 'width' ? 'ih' : 'iw'}:h=${squareS.constraint === 'height' ? 'iw' : 'ih'}[cframe];` : ''}[${squareS.constraint !== 'both' ? 'cframe' : '0:v'}]scale=74:74[frame];[1:v][frame]overlay=x=13:y=38:format=auto[benson];[benson]scale=iw*2:ih*2[out]" -map "[out]" -preset ${findpreset(args)} ${filepath}/output.png`)
                    await sendFile(msg, filepath, `output.png`)
                } else if (type.mime.startsWith('video')) {
                    var filepath = await downloadFile(currenturl, `input.mp4`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp4`

                    var benson = await Jimp.read(`templates/benson.png`)
                    var consolas = await Jimp.loadFont('templates/fonts/Consolas/Consolas.fnt')
                    await benson.print(consolas, 3, 4, { text: Discord.Util.cleanContent(text, msg), alignmentX: Jimp.HORIZONTAL_ALIGN_CENTER, alignmentY: Jimp.VERTICAL_ALIGN_MIDDLE }, 94, 33)
                    await benson.writeAsync(`${filepath}/benson.png`)

                    var width = fileinfo.info.width
                    var height = fileinfo.info.height

                    var squareS = { value: ((height === width) && width) || ((height > width) && height) || width, constraint: ((height === width) && 'both') || ((height > width) && 'height') || 'width' }

                    await execPromise(`ffmpeg -i ${filepath}/${filename} -i ${filepath}/benson.png -map 0:a? -filter_complex "${squareS.constraint !== 'both' ? `[0:v]crop=x=${squareS.constraint === 'height' ? 0 : 'iw/2-ih/2'}:y=${squareS.constraint === 'width' ? 0 : 'ih/2-iw/2'}:w=${squareS.constraint === 'width' ? 'ih' : 'iw'}:h=${squareS.constraint === 'height' ? 'iw' : 'ih'}[cframe];` : ''}[${squareS.constraint !== 'both' ? 'cframe' : '0:v'}]scale=74:74[frame];[1:v][frame]overlay=x=13:y=38:format=auto[benson];[benson]scale=iw*2:ih*2[oout];[oout]scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ${findpreset(args)} -c:v libx264 -pix_fmt yuv420p ${filepath}/output.mp4`)
                    await sendFile(msg, filepath, `output.mp4`)
                } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                    var filepath = await downloadFile(currenturl, `input.gif`)
                    var filename = `input.gif`

                    var benson = await Jimp.read(`templates/benson.png`)
                    var consolas = await Jimp.loadFont('templates/fonts/Consolas/Consolas.fnt')
                    await benson.print(consolas, 3, 4, { text: Discord.Util.cleanContent(text, msg), alignmentX: Jimp.HORIZONTAL_ALIGN_CENTER, alignmentY: Jimp.VERTICAL_ALIGN_MIDDLE }, 94, 33)
                    await benson.writeAsync(`${filepath}/benson.png`)

                    var width = fileinfo.info.width
                    var height = fileinfo.info.height

                    var squareS = { value: ((height === width) && width) || ((height > width) && height) || width, constraint: ((height === width) && 'both') || ((height > width) && 'height') || 'width' }

                    await execPromise(`ffmpeg -i ${filepath}/${filename} -i ${filepath}/benson.png -filter_complex "${squareS.constraint !== 'both' ? `[0:v]crop=x=${squareS.constraint === 'height' ? 0 : 'iw/2-ih/2'}:y=${squareS.constraint === 'width' ? 0 : 'ih/2-iw/2'}:w=${squareS.constraint === 'width' ? 'ih' : 'iw'}:h=${squareS.constraint === 'height' ? 'iw' : 'ih'}[cframe];` : ''}[${squareS.constraint !== 'both' ? 'cframe' : '0:v'}]scale=74:74[frame];[1:v][frame]overlay=x=13:y=38:format=auto[benson];[benson]scale=iw*2:ih*2[oout];[oout]split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ${findpreset(args)} -gifflags -offsetting ${filepath}/output.gif`)
                    await sendFile(msg, filepath, `output.gif`)
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "benson \"{name}\" <file>",
                "value": "A.I. Level 20"
            },
            cooldown: 2500,
            type: "Memes"
        },

        {
            name: ["yall", "twitterartist"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && validUrl.test(args[args.length - 1]) === false) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var saidMessage = args.join(' ').substring(args[0].length + 1)
                symbolreplacements.forEach(symbolReplacement => {
                    symbolReplacement.target.forEach(target => {
                        saidMessage = saidMessage.replace(new RegExp(target, 'ig'), symbolReplacement.replacement)
                    })
                })
                var matchedTextes = saidMessage.match(/"([\s\S]*?)"/)
                if (!matchedTextes) {
                    matchedTextes = ['""', '']
                }
                var text = matchedTextes[1]
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
                var fileinfo = await validateFile(currenturl).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })

                if (!fileinfo) return
                var type = fileinfo.type

                if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                    var filepath = await downloadFile(currenturl, `input.png`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.png`

                    var yall = await Jimp.read(`templates/yall.png`)
                    var morton = await Jimp.loadFont('templates/fonts/Morton/Morton.fnt')
                    await yall.print(morton, 274, 8, { text: Discord.Util.cleanContent(text, msg), alignmentX: Jimp.HORIZONTAL_ALIGN_LEFT, alignmentY: Jimp.VERTICAL_ALIGN_TOP }, 202, 77)
                    await yall.writeAsync(`${filepath}/yall.png`)

                    var width = fileinfo.info.width
                    var height = fileinfo.info.height

                    var squareS = { value: ((height === width) && width) || ((height > width) && height) || width, constraint: ((height === width) && 'both') || ((height > width) && 'height') || 'width' }

                    await execPromise(`ffmpeg -i ${filepath}/${filename} -i ${filepath}/yall.png -i templates/transparent.png -filter_complex "[2:v]scale=249:368[transparent];[0:v]scale=${squareS.constraint === 'width' || squareS.constraint === 'both' ? 368 : -1}:${squareS.constraint === 'height' || squareS.constraint === 'both' ? 368 : -1}[frame];[transparent][frame]overlay=x=W/2-w/2:y=H/2-h/2:format=auto[cframe];[1:v][cframe]overlay=x=251:y=94:format=auto[out]" -map "[out]" -preset ${findpreset(args)} ${filepath}/output.png`)
                    await sendFile(msg, filepath, `output.png`)
                } else if (type.mime.startsWith('video')) {
                    var filepath = await downloadFile(currenturl, `input.mp4`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp4`

                    var yall = await Jimp.read(`templates/yall.png`)
                    var morton = await Jimp.loadFont('templates/fonts/Morton/Morton.fnt')
                    await yall.print(morton, 274, 8, { text: Discord.Util.cleanContent(text, msg), alignmentX: Jimp.HORIZONTAL_ALIGN_LEFT, alignmentY: Jimp.VERTICAL_ALIGN_TOP }, 202, 77)
                    await yall.writeAsync(`${filepath}/yall.png`)

                    var width = fileinfo.info.width
                    var height = fileinfo.info.height

                    var squareS = { value: ((height === width) && width) || ((height > width) && height) || width, constraint: ((height === width) && 'both') || ((height > width) && 'height') || 'width' }

                    await execPromise(`ffmpeg -i ${filepath}/${filename} -i ${filepath}/yall.png -i templates/transparent.png -map 0:a? -filter_complex "[2:v]scale=249:368[transparent];[0:v]scale=${squareS.constraint === 'width' || squareS.constraint === 'both' ? 368 : -1}:${squareS.constraint === 'height' || squareS.constraint === 'both' ? 368 : -1}[frame];[transparent][frame]overlay=x=W/2-w/2:y=H/2-h/2:format=auto[cframe];[1:v][cframe]overlay=x=251:y=94:format=auto[oout];[oout]scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ${findpreset(args)} -c:v libx264 -pix_fmt yuv420p ${filepath}/output.mp4`)
                    await sendFile(msg, filepath, `output.mp4`)
                } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                    var filepath = await downloadFile(currenturl, `input.gif`)
                    var filename = `input.gif`

                    var yall = await Jimp.read(`templates/yall.png`)
                    var morton = await Jimp.loadFont('templates/fonts/Morton/Morton.fnt')
                    await yall.print(morton, 274, 8, { text: Discord.Util.cleanContent(text, msg), alignmentX: Jimp.HORIZONTAL_ALIGN_LEFT, alignmentY: Jimp.VERTICAL_ALIGN_TOP }, 202, 77)
                    await yall.writeAsync(`${filepath}/yall.png`)

                    var width = fileinfo.info.width
                    var height = fileinfo.info.height

                    var squareS = { value: ((height === width) && width) || ((height > width) && height) || width, constraint: ((height === width) && 'both') || ((height > width) && 'height') || 'width' }

                    await execPromise(`ffmpeg -i ${filepath}/${filename} -i ${filepath}/yall.png -i templates/transparent.png -filter_complex "[2:v]scale=249:368[transparent];[0:v]scale=${squareS.constraint === 'width' || squareS.constraint === 'both' ? 368 : -1}:${squareS.constraint === 'height' || squareS.constraint === 'both' ? 368 : -1}[frame];[transparent][frame]overlay=x=W/2-w/2:y=H/2-h/2:format=auto[cframe];[1:v][cframe]overlay=x=251:y=94:format=auto[oout];[oout]split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ${findpreset(args)} -gifflags -offsetting ${filepath}/output.gif`)
                    await sendFile(msg, filepath, `output.gif`)
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "yall/twitterartist \"[text]\" <file>",
                "value": "twitter artist"
            },
            cooldown: 2500,
            type: "Memes"
        },

        {
            name: ["call", "phonecall"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && validUrl.test(args[args.length - 1]) === false) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var saidMessage = args.join(' ').substring(args[0].length + 1)
                symbolreplacements.forEach(symbolReplacement => {
                    symbolReplacement.target.forEach(target => {
                        saidMessage = saidMessage.replace(new RegExp(target, 'ig'), symbolReplacement.replacement)
                    })
                })
                var matchedTextes = saidMessage.match(/"([\s\S]*?)"/)
                if (!matchedTextes) {
                    matchedTextes = ['""', '']
                }
                var text = matchedTextes[1]
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
                var fileinfo = await validateFile(currenturl).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })

                if (!fileinfo) return
                var type = fileinfo.type

                if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                    var filepath = await downloadFile(currenturl, `input.png`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.png`

                    var call = await Jimp.read(`templates/call.png`)
                    var helvetica = await Jimp.loadFont('templates/fonts/HelveticaLight/HelveticaLight.fnt')
                    await call.print(helvetica, 20, 59, { text: Discord.Util.cleanContent(text, msg), alignmentX: Jimp.HORIZONTAL_ALIGN_CENTER, alignmentY: Jimp.VERTICAL_ALIGN_TOP }, 333, 155)
                    await call.writeAsync(`${filepath}/call.png`)

                    var width = fileinfo.info.width
                    var height = fileinfo.info.height
                    var ratio = width / height
                    var bscale = await execPromise(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 templates/call.png`)
                    bscale = bscale.replace(/\n|\r/g, '').split('x')
                    var bwidth = Number(bscale[0])
                    var bheight = Number(bscale[1])
                    var bratio = bwidth / bheight

                    await execPromise(`ffmpeg -i ${filepath}/${filename} -i ${filepath}/call.png -i templates/callbg.png -filter_complex "[0:v]scale=${ratio < bratio ? bwidth : ratio > bratio ? -1 : bwidth}:${ratio < bratio ? -1 : ratio > bratio ? bheight : bheight}[frame];[2:v][frame]overlay=x=W/2-w/2:y=H/2-h/2:format=auto[bg];[bg][1:v]overlay=x=0:y=0:format=auto[out]" -map "[out]" -preset ${findpreset(args)} ${filepath}/output.png`)
                    await sendFile(msg, filepath, `output.png`)
                } else if (type.mime.startsWith('video')) {
                    var filepath = await downloadFile(currenturl, `input.mp4`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp4`

                    var call = await Jimp.read(`templates/call.png`)
                    var helvetica = await Jimp.loadFont('templates/fonts/HelveticaLight/HelveticaLight.fnt')
                    await call.print(helvetica, 20, 59, { text: Discord.Util.cleanContent(text, msg), alignmentX: Jimp.HORIZONTAL_ALIGN_CENTER, alignmentY: Jimp.VERTICAL_ALIGN_TOP }, 333, 155)
                    await call.writeAsync(`${filepath}/call.png`)

                    var width = fileinfo.info.width
                    var height = fileinfo.info.height
                    var ratio = width / height
                    var bscale = await execPromise(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 templates/call.png`)
                    bscale = bscale.replace(/\n|\r/g, '').split('x')
                    var bwidth = Number(bscale[0])
                    var bheight = Number(bscale[1])
                    var bratio = bwidth / bheight

                    await execPromise(`ffmpeg -i ${filepath}/${filename} -i ${filepath}/call.png -i templates/callbg.png -map 0:a? -filter_complex "[0:v]scale=${ratio < bratio ? bwidth : ratio > bratio ? -1 : bwidth}:${ratio < bratio ? -1 : ratio > bratio ? bheight : bheight}[frame];[2:v][frame]overlay=x=W/2-w/2:y=H/2-h/2:format=auto[bg];[bg][1:v]overlay=x=0:y=0:format=auto[oout];[oout]scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ${findpreset(args)} -c:v libx264 -pix_fmt yuv420p ${filepath}/output.mp4`)
                    await sendFile(msg, filepath, `output.mp4`)
                } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                    var filepath = await downloadFile(currenturl, `input.gif`)
                    var filename = `input.gif`

                    var call = await Jimp.read(`templates/call.png`)
                    var helvetica = await Jimp.loadFont('templates/fonts/HelveticaLight/HelveticaLight.fnt')
                    await call.print(helvetica, 20, 59, { text: Discord.Util.cleanContent(text, msg), alignmentX: Jimp.HORIZONTAL_ALIGN_CENTER, alignmentY: Jimp.VERTICAL_ALIGN_TOP }, 333, 155)
                    await call.writeAsync(`${filepath}/call.png`)

                    var width = fileinfo.info.width
                    var height = fileinfo.info.height
                    var ratio = width / height
                    var bscale = await execPromise(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=s=x:p=0 templates/call.png`)
                    bscale = bscale.replace(/\n|\r/g, '').split('x')
                    var bwidth = Number(bscale[0])
                    var bheight = Number(bscale[1])
                    var bratio = bwidth / bheight

                    await execPromise(`ffmpeg -i ${filepath}/${filename} -i ${filepath}/call.png -i templates/callbg.png -filter_complex "[0:v]scale=${ratio < bratio ? bwidth : ratio > bratio ? -1 : bwidth}:${ratio < bratio ? -1 : ratio > bratio ? bheight : bheight}[frame];[2:v][frame]overlay=x=W/2-w/2:y=H/2-h/2:format=auto[bg];[bg][1:v]overlay=x=0:y=0:format=auto[oout];[oout]split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ${findpreset(args)} -gifflags -offsetting ${filepath}/output.gif`)
                    await sendFile(msg, filepath, `output.gif`)
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "call/phonecall \"[name]\" <file>",
                "value": "Poopy is calling."
            },
            cooldown: 2500,
            type: "Memes"
        },

        {
            name: ["robloxgame", "rgame"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && validUrl.test(args[args.length - 1]) === false) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var saidMessage = args.join(' ').substring(args[0].length + 1)
                symbolreplacements.forEach(symbolReplacement => {
                    symbolReplacement.target.forEach(target => {
                        saidMessage = saidMessage.replace(new RegExp(target, 'ig'), symbolReplacement.replacement)
                    })
                })
                var dft = ['""', '"88"', '"1.3K"']
                var matchedTextes = saidMessage.match(/"([\s\S]*?)"/g)
                if (!matchedTextes) {
                    matchedTextes = dft
                } else {
                    for (var i in dft) {
                        var dfttext = dft[i]
                        var text = matchedTextes[i]
                        if (!text) {
                            matchedTextes[i] = dfttext
                        }
                    }
                }
                var name = matchedTextes[0].substring(1, matchedTextes[0].length - 1)
                var likepercentage = matchedTextes[1].substring(1, matchedTextes[1].length - 1) + '%'
                var playercount = matchedTextes[2].substring(1, matchedTextes[2].length - 1)
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
                var fileinfo = await validateFile(currenturl).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })

                if (!fileinfo) return
                var type = fileinfo.type

                if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                    var filepath = await downloadFile(currenturl, `input.png`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.png`

                    var game = await Jimp.read(`templates/game.png`)
                    var gothamed = await Jimp.loadFont('templates/fonts/GothamMedium/GothamMedium.fnt')
                    var gothasm = await Jimp.loadFont('templates/fonts/GothamSmall/GothamSmall.fnt')
                    await game.print(gothamed, 5, 165, { text: Discord.Util.cleanContent(name, msg), alignmentX: Jimp.HORIZONTAL_ALIGN_LEFT, alignmentY: Jimp.VERTICAL_ALIGN_TOP }, 150, 35)
                    await game.print(gothasm, 22, 211, { text: Discord.Util.cleanContent(likepercentage, msg), alignmentX: Jimp.HORIZONTAL_ALIGN_LEFT, alignmentY: Jimp.VERTICAL_ALIGN_MIDDLE }, 138, 17)
                    await game.print(gothasm, 79, 211, { text: Discord.Util.cleanContent(playercount, msg), alignmentX: Jimp.HORIZONTAL_ALIGN_LEFT, alignmentY: Jimp.VERTICAL_ALIGN_MIDDLE }, 81, 17)
                    await game.writeAsync(`${filepath}/game.png`)

                    var width = fileinfo.info.width
                    var height = fileinfo.info.height

                    var squareS = { value: ((height === width) && width) || ((height > width) && height) || width, constraint: ((height === width) && 'both') || ((height > width) && 'height') || 'width' }

                    await execPromise(`ffmpeg -i ${filepath}/${filename} -i ${filepath}/game.png -i templates/gamebg.png -filter_complex "[2:v][1:v]scale2ref[bg][game];${squareS.constraint !== 'both' ? `[0:v]crop=x=${squareS.constraint === 'height' ? 0 : 'iw/2-ih/2'}:y=${squareS.constraint === 'width' ? 0 : 'ih/2-iw/2'}:w=${squareS.constraint === 'width' ? 'ih' : 'iw'}:h=${squareS.constraint === 'height' ? 'iw' : 'ih'}[cframe];` : ''}[${squareS.constraint !== 'both' ? 'cframe' : '0:v'}]scale=150:150[frame];[bg][frame]overlay=x=5:y=4:format=auto[bframe];[bframe][game]overlay=x=0:y=0:format=auto[out]" -map "[out]" -preset ${findpreset(args)} ${filepath}/output.png`)
                    await sendFile(msg, filepath, `output.png`)
                } else if (type.mime.startsWith('video')) {
                    var filepath = await downloadFile(currenturl, `input.mp4`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp4`

                    var game = await Jimp.read(`templates/game.png`)
                    var gothamed = await Jimp.loadFont('templates/fonts/GothamMedium/GothamMedium.fnt')
                    var gothasm = await Jimp.loadFont('templates/fonts/GothamSmall/GothamSmall.fnt')
                    await game.print(gothamed, 5, 165, { text: Discord.Util.cleanContent(name, msg), alignmentX: Jimp.HORIZONTAL_ALIGN_LEFT, alignmentY: Jimp.VERTICAL_ALIGN_TOP }, 150, 35)
                    await game.print(gothasm, 22, 211, { text: Discord.Util.cleanContent(likepercentage, msg), alignmentX: Jimp.HORIZONTAL_ALIGN_LEFT, alignmentY: Jimp.VERTICAL_ALIGN_MIDDLE }, 138, 17)
                    await game.print(gothasm, 79, 211, { text: Discord.Util.cleanContent(playercount, msg), alignmentX: Jimp.HORIZONTAL_ALIGN_LEFT, alignmentY: Jimp.VERTICAL_ALIGN_MIDDLE }, 81, 17)
                    await game.writeAsync(`${filepath}/game.png`)

                    var width = fileinfo.info.width
                    var height = fileinfo.info.height

                    var squareS = { value: ((height === width) && width) || ((height > width) && height) || width, constraint: ((height === width) && 'both') || ((height > width) && 'height') || 'width' }

                    await execPromise(`ffmpeg -i ${filepath}/${filename} -i ${filepath}/game.png -i templates/gamebg.png -map 0:a? -filter_complex "[2:v][1:v]scale2ref[bg][game];${squareS.constraint !== 'both' ? `[0:v]crop=x=${squareS.constraint === 'height' ? 0 : 'iw/2-ih/2'}:y=${squareS.constraint === 'width' ? 0 : 'ih/2-iw/2'}:w=${squareS.constraint === 'width' ? 'ih' : 'iw'}:h=${squareS.constraint === 'height' ? 'iw' : 'ih'}[cframe];` : ''}[${squareS.constraint !== 'both' ? 'cframe' : '0:v'}]scale=150:150[frame];[bg][frame]overlay=x=5:y=4:format=auto[bframe];[bframe][game]overlay=x=0:y=0:format=auto[oout];[oout]scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ${findpreset(args)} -aspect ${game.bitmap.width}:${game.bitmap.height} -c:v libx264 -pix_fmt yuv420p ${filepath}/output.mp4`)
                    await sendFile(msg, filepath, `output.mp4`)
                } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                    var filepath = await downloadFile(currenturl, `input.gif`)
                    var filename = `input.gif`

                    var game = await Jimp.read(`templates/game.png`)
                    var gothamed = await Jimp.loadFont('templates/fonts/GothamMedium/GothamMedium.fnt')
                    var gothasm = await Jimp.loadFont('templates/fonts/GothamSmall/GothamSmall.fnt')
                    await game.print(gothamed, 5, 165, { text: Discord.Util.cleanContent(name, msg), alignmentX: Jimp.HORIZONTAL_ALIGN_LEFT, alignmentY: Jimp.VERTICAL_ALIGN_TOP }, 150, 35)
                    await game.print(gothasm, 22, 211, { text: Discord.Util.cleanContent(likepercentage, msg), alignmentX: Jimp.HORIZONTAL_ALIGN_LEFT, alignmentY: Jimp.VERTICAL_ALIGN_MIDDLE }, 138, 17)
                    await game.print(gothasm, 79, 211, { text: Discord.Util.cleanContent(playercount, msg), alignmentX: Jimp.HORIZONTAL_ALIGN_LEFT, alignmentY: Jimp.VERTICAL_ALIGN_MIDDLE }, 81, 17)
                    await game.writeAsync(`${filepath}/game.png`)

                    var width = fileinfo.info.width
                    var height = fileinfo.info.height

                    var squareS = { value: ((height === width) && width) || ((height > width) && height) || width, constraint: ((height === width) && 'both') || ((height > width) && 'height') || 'width' }

                    await execPromise(`ffmpeg -i ${filepath}/${filename} -i ${filepath}/game.png -i templates/gamebg.png -filter_complex "[2:v][1:v]scale2ref[bg][game];${squareS.constraint !== 'both' ? `[0:v]crop=x=${squareS.constraint === 'height' ? 0 : 'iw/2-ih/2'}:y=${squareS.constraint === 'width' ? 0 : 'ih/2-iw/2'}:w=${squareS.constraint === 'width' ? 'ih' : 'iw'}:h=${squareS.constraint === 'height' ? 'iw' : 'ih'}[cframe];` : ''}[${squareS.constraint !== 'both' ? 'cframe' : '0:v'}]scale=150:150[frame];[bg][frame]overlay=x=5:y=4:format=auto[bframe];[bframe][game]overlay=x=0:y=0:format=auto[oout];[oout]split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ${findpreset(args)} -aspect ${game.bitmap.width}:${game.bitmap.height} -gifflags -offsetting ${filepath}/output.gif`)
                    await sendFile(msg, filepath, `output.gif`)
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "robloxgame/rgame \"{name}\" \"[likeRatio]\" \"[playerCount]\" <file>",
                "value": "Power your imagination."
            },
            cooldown: 2500,
            type: "Memes"
        },

        {
            name: ["twitterban"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && validUrl.test(args[args.length - 1]) === false) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var saidMessage = args.join(' ').substring(args[0].length + 1)
                symbolreplacements.forEach(symbolReplacement => {
                    symbolReplacement.target.forEach(target => {
                        saidMessage = saidMessage.replace(new RegExp(target, 'ig'), symbolReplacement.replacement)
                    })
                })
                var dft = ['""', `"${msg.member.nickname || msg.author.username}"`, `"${msg.author.username}"`]
                var matchedTextes = saidMessage.match(/"([\s\S]*?)"/g)
                if (!matchedTextes) {
                    matchedTextes = dft
                } else {
                    for (var i in dft) {
                        var dfttext = dft[i]
                        var text = matchedTextes[i]
                        if (!text) {
                            matchedTextes[i] = dfttext
                        }
                    }
                }
                var message = matchedTextes[0].substring(1, matchedTextes[0].length - 1)
                var nickname = matchedTextes[1].substring(1, matchedTextes[1].length - 1)
                var username = '@' + matchedTextes[2].substring(1, matchedTextes[2].length - 1)
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
                var fileinfo = await validateFile(currenturl).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })

                if (!fileinfo) return
                var type = fileinfo.type

                if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                    var filepath = await downloadFile(currenturl, `input.png`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.png`

                    var twitter = await Jimp.read(`templates/twitter.png`)
                    var tnr = await Jimp.loadFont('templates/fonts/TimesNewRoman/TimesNewRoman.fnt')
                    var arialbold = await Jimp.loadFont('templates/fonts/ArialBold/ArialBold.fnt')
                    var arialblue = await Jimp.loadFont('templates/fonts/ArialBlue/ArialBlue.fnt')
                    await twitter.print(tnr, 85, 437, { text: Discord.Util.cleanContent(message, msg), alignmentX: Jimp.HORIZONTAL_ALIGN_LEFT, alignmentY: Jimp.VERTICAL_ALIGN_TOP }, 546, 21)
                    await twitter.print(arialbold, 116, 131, { text: Discord.Util.cleanContent(nickname, msg), alignmentX: Jimp.HORIZONTAL_ALIGN_LEFT, alignmentY: Jimp.VERTICAL_ALIGN_TOP }, 614, 12)
                    await twitter.print(arialbold, 143, 379, { text: Discord.Util.cleanContent(nickname, msg), alignmentX: Jimp.HORIZONTAL_ALIGN_LEFT, alignmentY: Jimp.VERTICAL_ALIGN_TOP }, 490, 12)
                    await twitter.print(arialblue, 116, 147, { text: Discord.Util.cleanContent(username, msg), alignmentX: Jimp.HORIZONTAL_ALIGN_LEFT, alignmentY: Jimp.VERTICAL_ALIGN_TOP }, 614, 12)
                    await twitter.print(arialblue, 143, 395, { text: Discord.Util.cleanContent(username, msg), alignmentX: Jimp.HORIZONTAL_ALIGN_LEFT, alignmentY: Jimp.VERTICAL_ALIGN_TOP }, 490, 12)
                    await twitter.writeAsync(`${filepath}/twitter.png`)

                    var width = fileinfo.info.width
                    var height = fileinfo.info.height

                    var squareS = { value: ((height === width) && width) || ((height > width) && height) || width, constraint: ((height === width) && 'both') || ((height > width) && 'height') || 'width' }

                    await execPromise(`ffmpeg -i ${filepath}/${filename} -i ${filepath}/twitter.png -i templates/twitterbg.png -filter_complex "[2:v][1:v]scale2ref[bg][twitter];${squareS.constraint !== 'both' ? `[0:v]crop=x=${squareS.constraint === 'height' ? 0 : 'iw/2-ih/2'}:y=${squareS.constraint === 'width' ? 0 : 'ih/2-iw/2'}:w=${squareS.constraint === 'width' ? 'ih' : 'iw'}:h=${squareS.constraint === 'height' ? 'iw' : 'ih'}[cframe];` : ''}[${squareS.constraint !== 'both' ? 'cframe' : '0:v'}]scale=48:48,split[frame][frame2];[bg][frame]overlay=x=59:y=134:format=auto[bframe];[bframe][frame2]overlay=x=86:y=382:format=auto[bbframe];[bbframe][twitter]overlay=x=0:y=0:format=auto[out]" -map "[out]" -preset ${findpreset(args)} ${filepath}/output.png`)
                    await sendFile(msg, filepath, `output.png`)
                } else if (type.mime.startsWith('video')) {
                    var filepath = await downloadFile(currenturl, `input.mp4`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp4`

                    var twitter = await Jimp.read(`templates/twitter.png`)
                    var tnr = await Jimp.loadFont('templates/fonts/TimesNewRoman/TimesNewRoman.fnt')
                    var arialbold = await Jimp.loadFont('templates/fonts/ArialBold/ArialBold.fnt')
                    var arialblue = await Jimp.loadFont('templates/fonts/ArialBlue/ArialBlue.fnt')
                    await twitter.print(tnr, 85, 437, { text: Discord.Util.cleanContent(message, msg), alignmentX: Jimp.HORIZONTAL_ALIGN_LEFT, alignmentY: Jimp.VERTICAL_ALIGN_TOP }, 546, 21)
                    await twitter.print(arialbold, 116, 131, { text: Discord.Util.cleanContent(nickname, msg), alignmentX: Jimp.HORIZONTAL_ALIGN_LEFT, alignmentY: Jimp.VERTICAL_ALIGN_TOP }, 614, 12)
                    await twitter.print(arialbold, 143, 379, { text: Discord.Util.cleanContent(nickname, msg), alignmentX: Jimp.HORIZONTAL_ALIGN_LEFT, alignmentY: Jimp.VERTICAL_ALIGN_TOP }, 490, 12)
                    await twitter.print(arialblue, 116, 147, { text: Discord.Util.cleanContent(username, msg), alignmentX: Jimp.HORIZONTAL_ALIGN_LEFT, alignmentY: Jimp.VERTICAL_ALIGN_TOP }, 614, 12)
                    await twitter.print(arialblue, 143, 395, { text: Discord.Util.cleanContent(username, msg), alignmentX: Jimp.HORIZONTAL_ALIGN_LEFT, alignmentY: Jimp.VERTICAL_ALIGN_TOP }, 490, 12)
                    await twitter.writeAsync(`${filepath}/twitter.png`)

                    var width = fileinfo.info.width
                    var height = fileinfo.info.height

                    var squareS = { value: ((height === width) && width) || ((height > width) && height) || width, constraint: ((height === width) && 'both') || ((height > width) && 'height') || 'width' }

                    await execPromise(`ffmpeg -i ${filepath}/${filename} -i ${filepath}/twitter.png -i templates/twitterbg.png -map 0:a? -filter_complex "[2:v][1:v]scale2ref[bg][twitter];${squareS.constraint !== 'both' ? `[0:v]crop=x=${squareS.constraint === 'height' ? 0 : 'iw/2-ih/2'}:y=${squareS.constraint === 'width' ? 0 : 'ih/2-iw/2'}:w=${squareS.constraint === 'width' ? 'ih' : 'iw'}:h=${squareS.constraint === 'height' ? 'iw' : 'ih'}[cframe];` : ''}[${squareS.constraint !== 'both' ? 'cframe' : '0:v'}]scale=48:48,split[frame][frame2];[bg][frame]overlay=x=59:y=134:format=auto[bframe];[bframe][frame2]overlay=x=86:y=382:format=auto[bbframe];[bbframe][twitter]overlay=x=0:y=0:format=auto[oout];[oout]scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ${findpreset(args)} -aspect ${twitter.bitmap.width}:${twitter.bitmap.height} -c:v libx264 -pix_fmt yuv420p ${filepath}/output.mp4`)
                    await sendFile(msg, filepath, `output.mp4`)
                } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                    var filepath = await downloadFile(currenturl, `input.gif`)
                    var filename = `input.gif`

                    var twitter = await Jimp.read(`templates/twitter.png`)
                    var tnr = await Jimp.loadFont('templates/fonts/TimesNewRoman/TimesNewRoman.fnt')
                    var arialbold = await Jimp.loadFont('templates/fonts/ArialBold/ArialBold.fnt')
                    var arialblue = await Jimp.loadFont('templates/fonts/ArialBlue/ArialBlue.fnt')
                    await twitter.print(tnr, 85, 437, { text: Discord.Util.cleanContent(message, msg), alignmentX: Jimp.HORIZONTAL_ALIGN_LEFT, alignmentY: Jimp.VERTICAL_ALIGN_TOP }, 546, 21)
                    await twitter.print(arialbold, 116, 131, { text: Discord.Util.cleanContent(nickname, msg), alignmentX: Jimp.HORIZONTAL_ALIGN_LEFT, alignmentY: Jimp.VERTICAL_ALIGN_TOP }, 614, 12)
                    await twitter.print(arialbold, 143, 379, { text: Discord.Util.cleanContent(nickname, msg), alignmentX: Jimp.HORIZONTAL_ALIGN_LEFT, alignmentY: Jimp.VERTICAL_ALIGN_TOP }, 490, 12)
                    await twitter.print(arialblue, 116, 147, { text: Discord.Util.cleanContent(username, msg), alignmentX: Jimp.HORIZONTAL_ALIGN_LEFT, alignmentY: Jimp.VERTICAL_ALIGN_TOP }, 614, 12)
                    await twitter.print(arialblue, 143, 395, { text: Discord.Util.cleanContent(username, msg), alignmentX: Jimp.HORIZONTAL_ALIGN_LEFT, alignmentY: Jimp.VERTICAL_ALIGN_TOP }, 490, 12)
                    await twitter.writeAsync(`${filepath}/twitter.png`)

                    var width = fileinfo.info.width
                    var height = fileinfo.info.height

                    var squareS = { value: ((height === width) && width) || ((height > width) && height) || width, constraint: ((height === width) && 'both') || ((height > width) && 'height') || 'width' }

                    await execPromise(`ffmpeg -i ${filepath}/${filename} -i ${filepath}/twitter.png -i templates/twitterbg.png -filter_complex "[2:v][1:v]scale2ref[bg][twitter];${squareS.constraint !== 'both' ? `[0:v]crop=x=${squareS.constraint === 'height' ? 0 : 'iw/2-ih/2'}:y=${squareS.constraint === 'width' ? 0 : 'ih/2-iw/2'}:w=${squareS.constraint === 'width' ? 'ih' : 'iw'}:h=${squareS.constraint === 'height' ? 'iw' : 'ih'}[cframe];` : ''}[${squareS.constraint !== 'both' ? 'cframe' : '0:v'}]scale=48:48,split[frame][frame2];[bg][frame]overlay=x=59:y=134:format=auto[bframe];[bframe][frame2]overlay=x=86:y=382:format=auto[bbframe];[bbframe][twitter]overlay=x=0:y=0:format=auto[oout];[oout]split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ${findpreset(args)} -aspect ${twitter.bitmap.width}:${twitter.bitmap.height} -gifflags -offsetting ${filepath}/output.gif`)
                    await sendFile(msg, filepath, `output.gif`)
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "twitterban \"{message}\" \"{nickname}\" \"{username}\" <file>",
                "value": "banned for hating Pan | They/Them | #BLM | #ACAB | #GAYRIGHTS | #ProudPansexual | #ProudNon-Binary | #LGBTQRIGHTS | Hates Straights"
            },
            cooldown: 2500,
            type: "Memes"
        },

        {
            name: ["pvz", "plant"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && validUrl.test(args[args.length - 1]) === false) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var saidMessage = args.join(' ').substring(args[0].length + 1).replace(/‚Äô/g, '\'')
                symbolreplacements.forEach(symbolReplacement => {
                    symbolReplacement.target.forEach(target => {
                        saidMessage = saidMessage.replace(new RegExp(target, 'ig'), symbolReplacement.replacement)
                    })
                })
                var matchedTextes = saidMessage.match(/"([\s\S]*?)"/g)
                if (!matchedTextes) {
                    matchedTextes = ['""', '""']
                } else if (!matchedTextes[1]) {
                    matchedTextes[1] = '""'
                }
                var plantname = matchedTextes[0].substring(1, matchedTextes[0].length - 1)
                var plantdescription = matchedTextes[1].substring(1, matchedTextes[1].length - 1)
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
                var fileinfo = await validateFile(currenturl).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })

                if (!fileinfo) return
                var type = fileinfo.type

                if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                    var filepath = await downloadFile(currenturl, `input.png`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.png`

                    var pvz = await Jimp.read(`templates/pvz.png`)
                    var dwarven = await Jimp.loadFont('templates/fonts/Dwarven/Dwarven.fnt')
                    var brianne = await Jimp.loadFont('templates/fonts/Brianne/Brianne.fnt')
                    await pvz.print(dwarven, 155, 197, { text: Discord.Util.cleanContent(plantname, msg), alignmentX: Jimp.HORIZONTAL_ALIGN_CENTER, alignmentY: Jimp.VERTICAL_ALIGN_MIDDLE }, 189, 27)
                    await pvz.print(brianne, 166, 223, { text: Discord.Util.cleanContent(plantdescription, msg), alignmentX: Jimp.HORIZONTAL_ALIGN_CENTER, alignmentY: Jimp.VERTICAL_ALIGN_MIDDLE }, 166, 66)
                    await pvz.writeAsync(`${filepath}/pvz.png`)

                    var width = fileinfo.info.width
                    var height = fileinfo.info.height

                    var squareS = { value: ((height === width) && width) || ((height > width) && height) || width, constraint: ((height === width) && 'both') || ((height > width) && 'height') || 'width' }

                    await execPromise(`ffmpeg -i ${filepath}/${filename} -i ${filepath}/pvz.png -filter_complex "[0:v]scale=${squareS.constraint === 'width' || squareS.constraint === 'both' ? 40 : -1}:${squareS.constraint === 'height' || squareS.constraint === 'both' ? 40 : -1}[frame];[1:v][frame]overlay=x=W/2-w/2:y=118-h/2:format=auto[out]" -map "[out]" -preset ${findpreset(args)} ${filepath}/output.png`)
                    await sendFile(msg, filepath, `output.png`)
                } else if (type.mime.startsWith('video')) {
                    var filepath = await downloadFile(currenturl, `input.mp4`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp4`

                    var pvz = await Jimp.read(`templates/pvz.png`)
                    var dwarven = await Jimp.loadFont('templates/fonts/Dwarven/Dwarven.fnt')
                    var brianne = await Jimp.loadFont('templates/fonts/Brianne/Brianne.fnt')
                    await pvz.print(dwarven, 155, 197, { text: Discord.Util.cleanContent(plantname, msg), alignmentX: Jimp.HORIZONTAL_ALIGN_CENTER, alignmentY: Jimp.VERTICAL_ALIGN_MIDDLE }, 189, 27)
                    await pvz.print(brianne, 166, 223, { text: Discord.Util.cleanContent(plantdescription, msg), alignmentX: Jimp.HORIZONTAL_ALIGN_CENTER, alignmentY: Jimp.VERTICAL_ALIGN_MIDDLE }, 166, 66)
                    await pvz.writeAsync(`${filepath}/pvz.png`)

                    var width = fileinfo.info.width
                    var height = fileinfo.info.height

                    var squareS = { value: ((height === width) && width) || ((height > width) && height) || width, constraint: ((height === width) && 'both') || ((height > width) && 'height') || 'width' }

                    await execPromise(`ffmpeg -i ${filepath}/${filename} -i ${filepath}/pvz.png -map 0:a? -filter_complex "[0:v]scale=${squareS.constraint === 'width' || squareS.constraint === 'both' ? 40 : -1}:${squareS.constraint === 'height' || squareS.constraint === 'both' ? 40 : -1}[frame];[1:v][frame]overlay=x=W/2-w/2:y=118-h/2:format=auto[oout];[oout]scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ${findpreset(args)} -c:v libx264 -pix_fmt yuv420p ${filepath}/output.mp4`)
                    await sendFile(msg, filepath, `output.mp4`)
                } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                    var filepath = await downloadFile(currenturl, `input.gif`)
                    var filename = `input.gif`

                    var pvz = await Jimp.read(`templates/pvz.png`)
                    var dwarven = await Jimp.loadFont('templates/fonts/Dwarven/Dwarven.fnt')
                    var brianne = await Jimp.loadFont('templates/fonts/Brianne/Brianne.fnt')
                    await pvz.print(dwarven, 155, 197, { text: Discord.Util.cleanContent(plantname, msg), alignmentX: Jimp.HORIZONTAL_ALIGN_CENTER, alignmentY: Jimp.VERTICAL_ALIGN_MIDDLE }, 189, 27)
                    await pvz.print(brianne, 166, 223, { text: Discord.Util.cleanContent(plantdescription, msg), alignmentX: Jimp.HORIZONTAL_ALIGN_CENTER, alignmentY: Jimp.VERTICAL_ALIGN_MIDDLE }, 166, 66)
                    await pvz.writeAsync(`${filepath}/pvz.png`)

                    var width = fileinfo.info.width
                    var height = fileinfo.info.height

                    var squareS = { value: ((height === width) && width) || ((height > width) && height) || width, constraint: ((height === width) && 'both') || ((height > width) && 'height') || 'width' }

                    await execPromise(`ffmpeg -i ${filepath}/${filename} -i ${filepath}/pvz.png -filter_complex "[0:v]scale=${squareS.constraint === 'width' || squareS.constraint === 'both' ? 40 : -1}:${squareS.constraint === 'height' || squareS.constraint === 'both' ? 40 : -1}[frame];[1:v][frame]overlay=x=W/2-w/2:y=118-h/2:format=auto[oout];[oout]split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ${findpreset(args)} -gifflags -offsetting ${filepath}/output.gif`)
                    await sendFile(msg, filepath, `output.gif`)
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "pvz/plant \"{name}\" \"{description}\" <file>",
                "value": "You got a new plant!"
            },
            cooldown: 2500,
            type: "Memes"
        },

        {
            name: ["amazon"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && validUrl.test(args[args.length - 1]) === false) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var saidMessage = args.join(' ').substring(args[0].length + 1)
                symbolreplacements.forEach(symbolReplacement => {
                    symbolReplacement.target.forEach(target => {
                        saidMessage = saidMessage.replace(new RegExp(target, 'ig'), symbolReplacement.replacement)
                    })
                })
                var dft = ['""', '"19.99"', '"4.5"']
                var matchedTextes = saidMessage.match(/"([\s\S]*?)"/g)
                if (!matchedTextes) {
                    matchedTextes = dft
                } else {
                    for (var i in dft) {
                        var dfttext = dft[i]
                        var text = matchedTextes[i]
                        if (!text) {
                            matchedTextes[i] = dfttext
                        }
                    }
                }
                var name = matchedTextes[0].substring(1, matchedTextes[0].length - 1)
                var price = matchedTextes[1].substring(1, matchedTextes[1].length - 1)
                var price1 = price.split('.')[0]
                var price2 = price.split('.')[1] || '00'
                var rating = matchedTextes[2].substring(1, matchedTextes[2].length - 1)
                var numberrating = isNaN(Number(rating)) ? 4.5 : Number(rating) <= 0 ? 0 : Number(rating) >= 5 ? 5 : Number(rating) || 0
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
                var fileinfo = await validateFile(currenturl).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })

                if (!fileinfo) return
                var type = fileinfo.type

                if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                    var filepath = await downloadFile(currenturl, `input.png`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.png`

                    var amazon = await Jimp.read(`templates/amazon.png`)
                    var ystars = await Jimp.read(`templates/ystars.png`)
                    var wstars = await Jimp.read(`templates/wstars.png`)
                    var amazonemlink = await Jimp.loadFont('templates/fonts/AmazonEmberLink/AmazonEmberLink.fnt')
                    var amazonemsmall = await Jimp.loadFont('templates/fonts/AmazonEmberSmall/AmazonEmberSmall.fnt')
                    var amazonembig = await Jimp.loadFont('templates/fonts/AmazonEmberBig/AmazonEmberBig.fnt')
                    ystars.crop(0, 0, ystars.bitmap.width * (numberrating / 5), ystars.bitmap.height)
                    wstars.composite(ystars, 0, 0)
                    amazon.composite(wstars, 16, 299)
                    await amazon.print(amazonemlink, 14, 219, { text: Discord.Util.cleanContent(name, msg), alignmentX: Jimp.HORIZONTAL_ALIGN_LEFT, alignmentY: Jimp.VERTICAL_ALIGN_MIDDLE }, 209, 49)
                    await amazon.print(amazonembig, 22, 275, { text: Discord.Util.cleanContent(price1, msg), alignmentX: Jimp.HORIZONTAL_ALIGN_RIGHT, alignmentY: Jimp.VERTICAL_ALIGN_MIDDLE }, 36, 18)
                    await amazon.print(amazonemsmall, 60, 275, { text: Discord.Util.cleanContent(price2, msg), alignmentX: Jimp.HORIZONTAL_ALIGN_LEFT, alignmentY: Jimp.VERTICAL_ALIGN_MIDDLE }, 20, 12)
                    await amazon.writeAsync(`${filepath}/amazon.png`)

                    var width = fileinfo.info.width
                    var height = fileinfo.info.height

                    var squareS = { value: ((height === width) && width) || ((height > width) && height) || width, constraint: ((height === width) && 'both') || ((height > width) && 'height') || 'width' }

                    await execPromise(`ffmpeg -i ${filepath}/${filename} -i ${filepath}/amazon.png -filter_complex "[0:v]scale=${squareS.constraint === 'width' || squareS.constraint === 'both' ? 184 : -1}:${squareS.constraint === 'height' || squareS.constraint === 'both' ? 184 : -1}[frame];[1:v][frame]overlay=x=26+(184/2-w/2):y=22+(184/2-h/2):format=auto[out]" -map "[out]" -preset ${findpreset(args)} ${filepath}/output.png`)
                    await sendFile(msg, filepath, `output.png`)
                } else if (type.mime.startsWith('video')) {
                    var filepath = await downloadFile(currenturl, `input.mp4`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp4`

                    var amazon = await Jimp.read(`templates/amazon.png`)
                    var ystars = await Jimp.read(`templates/ystars.png`)
                    var wstars = await Jimp.read(`templates/wstars.png`)
                    var amazonemlink = await Jimp.loadFont('templates/fonts/AmazonEmberLink/AmazonEmberLink.fnt')
                    var amazonemsmall = await Jimp.loadFont('templates/fonts/AmazonEmberSmall/AmazonEmberSmall.fnt')
                    var amazonembig = await Jimp.loadFont('templates/fonts/AmazonEmberBig/AmazonEmberBig.fnt')
                    ystars.crop(0, 0, ystars.bitmap.width * (numberrating / 5), ystars.bitmap.height)
                    wstars.composite(ystars, 0, 0)
                    amazon.composite(wstars, 16, 299)
                    await amazon.print(amazonemlink, 14, 219, { text: Discord.Util.cleanContent(name, msg), alignmentX: Jimp.HORIZONTAL_ALIGN_LEFT, alignmentY: Jimp.VERTICAL_ALIGN_MIDDLE }, 209, 49)
                    await amazon.print(amazonembig, 22, 275, { text: Discord.Util.cleanContent(price1, msg), alignmentX: Jimp.HORIZONTAL_ALIGN_RIGHT, alignmentY: Jimp.VERTICAL_ALIGN_MIDDLE }, 36, 18)
                    await amazon.print(amazonemsmall, 60, 275, { text: Discord.Util.cleanContent(price2, msg), alignmentX: Jimp.HORIZONTAL_ALIGN_LEFT, alignmentY: Jimp.VERTICAL_ALIGN_MIDDLE }, 20, 12)
                    await amazon.writeAsync(`${filepath}/amazon.png`)

                    var width = fileinfo.info.width
                    var height = fileinfo.info.height

                    var squareS = { value: ((height === width) && width) || ((height > width) && height) || width, constraint: ((height === width) && 'both') || ((height > width) && 'height') || 'width' }

                    await execPromise(`ffmpeg -i ${filepath}/${filename} -i ${filepath}/amazon.png -map 0:a? -filter_complex "[0:v]scale=${squareS.constraint === 'width' || squareS.constraint === 'both' ? 184 : -1}:${squareS.constraint === 'height' || squareS.constraint === 'both' ? 184 : -1}[frame];[1:v][frame]overlay=x=26+(184/2-w/2):y=22+(184/2-h/2):format=auto[oout];[oout]scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ${findpreset(args)} -c:v libx264 -pix_fmt yuv420p ${filepath}/output.mp4`)
                    await sendFile(msg, filepath, `output.mp4`)
                } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                    var filepath = await downloadFile(currenturl, `input.gif`)
                    var filename = `input.gif`

                    var amazon = await Jimp.read(`templates/amazon.png`)
                    var ystars = await Jimp.read(`templates/ystars.png`)
                    var wstars = await Jimp.read(`templates/wstars.png`)
                    var amazonemlink = await Jimp.loadFont('templates/fonts/AmazonEmberLink/AmazonEmberLink.fnt')
                    var amazonemsmall = await Jimp.loadFont('templates/fonts/AmazonEmberSmall/AmazonEmberSmall.fnt')
                    var amazonembig = await Jimp.loadFont('templates/fonts/AmazonEmberBig/AmazonEmberBig.fnt')
                    ystars.crop(0, 0, ystars.bitmap.width * (numberrating / 5), ystars.bitmap.height)
                    wstars.composite(ystars, 0, 0)
                    amazon.composite(wstars, 16, 299)
                    await amazon.print(amazonemlink, 14, 219, { text: Discord.Util.cleanContent(name, msg), alignmentX: Jimp.HORIZONTAL_ALIGN_LEFT, alignmentY: Jimp.VERTICAL_ALIGN_MIDDLE }, 209, 49)
                    await amazon.print(amazonembig, 22, 275, { text: Discord.Util.cleanContent(price1, msg), alignmentX: Jimp.HORIZONTAL_ALIGN_RIGHT, alignmentY: Jimp.VERTICAL_ALIGN_MIDDLE }, 36, 18)
                    await amazon.print(amazonemsmall, 60, 275, { text: Discord.Util.cleanContent(price2, msg), alignmentX: Jimp.HORIZONTAL_ALIGN_LEFT, alignmentY: Jimp.VERTICAL_ALIGN_MIDDLE }, 20, 12)
                    await amazon.writeAsync(`${filepath}/amazon.png`)

                    var width = fileinfo.info.width
                    var height = fileinfo.info.height

                    var squareS = { value: ((height === width) && width) || ((height > width) && height) || width, constraint: ((height === width) && 'both') || ((height > width) && 'height') || 'width' }

                    await execPromise(`ffmpeg -i ${filepath}/${filename} -i ${filepath}/amazon.png -filter_complex "[0:v]scale=${squareS.constraint === 'width' || squareS.constraint === 'both' ? 184 : -1}:${squareS.constraint === 'height' || squareS.constraint === 'both' ? 184 : -1}[frame];[1:v][frame]overlay=x=26+(184/2-w/2):y=22+(184/2-h/2):format=auto[oout];[oout]split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ${findpreset(args)} -gifflags -offsetting ${filepath}/output.gif`)
                    await sendFile(msg, filepath, `output.gif`)
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "amazon \"{name}\" \"[price]\" \"[rating (in stars)]\" <file>",
                "value": "Now ON SALE!!!"
            },
            cooldown: 2500,
            type: "Memes"
        },

        {
            name: ["dontrepost", "3am", "donotrepost"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && validUrl.test(args[args.length - 1]) === false) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
                var fileinfo = await validateFile(currenturl).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })

                if (!fileinfo) return
                var type = fileinfo.type

                if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                    var filepath = await downloadFile(currenturl, `input.png`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.png`
                    var width = fileinfo.info.width
                    var height = fileinfo.info.height

                    var squareS = { value: ((height === width) && width) || ((height > width) && height) || width, constraint: ((height === width) && 'both') || ((height > width) && 'height') || 'width' }

                    await execPromise(`ffmpeg -i ${filepath}/${filename} -i templates/dontrepost.png -filter_complex "[0:v]scale=${squareS.constraint === 'width' || squareS.constraint === 'both' ? 374 : -1}:${squareS.constraint === 'height' || squareS.constraint === 'both' ? 374 : -1}[frame];[1:v][frame]overlay=x=37+(374/2-w/2):y=160+(374/2-h/2):format=auto[out]" -map "[out]" -preset ${findpreset(args)} ${filepath}/output.png`)
                    await sendFile(msg, filepath, `output.png`)
                } else if (type.mime.startsWith('video')) {
                    var filepath = await downloadFile(currenturl, `input.mp4`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp4`
                    var width = fileinfo.info.width
                    var height = fileinfo.info.height

                    var squareS = { value: ((height === width) && width) || ((height > width) && height) || width, constraint: ((height === width) && 'both') || ((height > width) && 'height') || 'width' }

                    await execPromise(`ffmpeg -i ${filepath}/${filename} -i templates/dontrepost.png -map 0:a? -filter_complex "[0:v]scale=${squareS.constraint === 'width' || squareS.constraint === 'both' ? 374 : -1}:${squareS.constraint === 'height' || squareS.constraint === 'both' ? 374 : -1}[frame];[1:v][frame]overlay=x=37+(374/2-w/2):y=160+(374/2-h/2):format=auto[oout];[oout]scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ${findpreset(args)} -c:v libx264 -pix_fmt yuv420p ${filepath}/output.mp4`)
                    await sendFile(msg, filepath, `output.mp4`)
                } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                    var filepath = await downloadFile(currenturl, `input.gif`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.gif`
                    var width = fileinfo.info.width
                    var height = fileinfo.info.height

                    var squareS = { value: ((height === width) && width) || ((height > width) && height) || width, constraint: ((height === width) && 'both') || ((height > width) && 'height') || 'width' }

                    await execPromise(`ffmpeg -i ${filepath}/${filename} -i templates/dontrepost.png -filter_complex "[0:v]scale=${squareS.constraint === 'width' || squareS.constraint === 'both' ? 374 : -1}:${squareS.constraint === 'height' || squareS.constraint === 'both' ? 374 : -1}[frame];[1:v][frame]overlay=x=37+(374/2-w/2):y=160+(374/2-h/2):format=auto[oout];[oout]split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ${findpreset(args)} -gifflags -offsetting ${filepath}/output.gif`)
                    await sendFile(msg, filepath, `output.gif`)
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "dontrepost/3am/donotrepost <file>",
                "value": "DO NOT REPOST IT"
            },
            cooldown: 2500,
            type: "Memes"
        },

        {
            name: ["error", "warning"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] === undefined && validUrl.test(args[args.length - 1]) === false) {
                    msg.channel.send('What is the file?!').catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var saidMessage = args.join(' ').substring(args[0].length + 1)
                symbolreplacements.forEach(symbolReplacement => {
                    symbolReplacement.target.forEach(target => {
                        saidMessage = saidMessage.replace(new RegExp(target, 'ig'), symbolReplacement.replacement)
                    })
                })
                var dft = ['""', '""', '""', '""', '""']
                var matchedTextes = saidMessage.match(/"([\s\S]*?)"/g)
                if (!matchedTextes) {
                    matchedTextes = dft
                } else {
                    for (var i in dft) {
                        var dfttext = dft[i]
                        var text = matchedTextes[i]
                        if (!text) {
                            matchedTextes[i] = dfttext
                        }
                    }
                }
                var title = matchedTextes[0].substring(1, matchedTextes[0].length - 1)
                var text = matchedTextes[1].substring(1, matchedTextes[1].length - 1)
                var b1 = matchedTextes[2].substring(1, matchedTextes[2].length - 1)
                var b2 = matchedTextes[3].substring(1, matchedTextes[3].length - 1)
                var b3 = matchedTextes[4].substring(1, matchedTextes[4].length - 1)
                var b1g = ''
                var b2g = ''
                var b3g = ''
                if (saidMessage.includes('-lgray')) b1g = 'x'
                if (saidMessage.includes('-cgray')) b2g = 'x'
                if (saidMessage.includes('-rgray')) b3g = 'x'
                var style = 'xp'
                var styleindex = args.indexOf('-style')
                if (styleindex > -1) {
                    if (args[styleindex + 1]) {
                        style = ['xp', '98'].find(st => st === args[styleindex + 1].toLowerCase()) ? args[styleindex + 1].toLowerCase() : 'xp'
                    }
                }
                var currenturl = data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]
                var fileinfo = await validateFile(currenturl).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })

                if (!fileinfo) return
                var type = fileinfo.type

                if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                    var filepath = await downloadFile(currenturl, `input.png`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.png`
                    await downloadFile(`http://atom.smasher.org/error/${encodeURIComponent(style)}.png.php?title=${encodeURIComponent(title)}&text=${encodeURIComponent(text)}&b1=${encodeURIComponent(b1)}&b1g=${encodeURIComponent(b1g)}&b2=${encodeURIComponent(b2)}&b2g=${encodeURIComponent(b2g)}&b3=${encodeURIComponent(b3)}&b3g=${encodeURIComponent(b3g)}`, 'error.png', {
                        http: true,
                        filepath: filepath
                    })

                    var width = fileinfo.info.width
                    var height = fileinfo.info.height

                    var squareS = { value: ((height === width) && width) || ((height > width) && height) || width, constraint: ((height === width) && 'both') || ((height > width) && 'height') || 'width' }

                    await execPromise(`ffmpeg -i ${filepath}/${filename} -i ${filepath}/error.png -filter_complex "[0:v]scale=${squareS.constraint === 'width' || squareS.constraint === 'both' ? 34 : -1}:${squareS.constraint === 'height' || squareS.constraint === 'both' ? 34 : -1}[frame];[1:v][frame]overlay=x=15+(34/2-w/2):y=36+(34/2-h/2):format=auto[out]" -map "[out]" -preset ${findpreset(args)} ${filepath}/output.png`)
                    await sendFile(msg, filepath, `output.png`)
                } else if (type.mime.startsWith('video')) {
                    var filepath = await downloadFile(currenturl, `input.mp4`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp4`
                    await downloadFile(`http://atom.smasher.org/error/${encodeURIComponent(style)}.png.php?title=${encodeURIComponent(title)}&text=${encodeURIComponent(text)}&b1=${encodeURIComponent(b1)}&b1g=${encodeURIComponent(b1g)}&b2=${encodeURIComponent(b2)}&b2g=${encodeURIComponent(b2g)}&b3=${encodeURIComponent(b3)}&b3g=${encodeURIComponent(b3g)}`, 'error.png', {
                        http: true,
                        filepath: filepath
                    })

                    var width = fileinfo.info.width
                    var height = fileinfo.info.height

                    var squareS = { value: ((height === width) && width) || ((height > width) && height) || width, constraint: ((height === width) && 'both') || ((height > width) && 'height') || 'width' }

                    await execPromise(`ffmpeg -i ${filepath}/${filename} -i ${filepath}/error.png -map 0:a? -filter_complex "[0:v]scale=${squareS.constraint === 'width' || squareS.constraint === 'both' ? 34 : -1}:${squareS.constraint === 'height' || squareS.constraint === 'both' ? 34 : -1}[frame];[1:v][frame]overlay=x=15+(34/2-w/2):y=36+(34/2-h/2):format=auto[oout];[oout]scale=ceil(iw/2)*2:ceil(ih/2)*2[out]" -map "[out]" -preset ${findpreset(args)} -c:v libx264 -pix_fmt yuv420p ${filepath}/output.mp4`)
                    await sendFile(msg, filepath, `output.mp4`)
                } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                    var filepath = await downloadFile(currenturl, `input.gif`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.gif`
                    await downloadFile(`http://atom.smasher.org/error/${encodeURIComponent(style)}.png.php?title=${encodeURIComponent(title)}&text=${encodeURIComponent(text)}&b1=${encodeURIComponent(b1)}&b1g=${encodeURIComponent(b1g)}&b2=${encodeURIComponent(b2)}&b2g=${encodeURIComponent(b2g)}&b3=${encodeURIComponent(b3)}&b3g=${encodeURIComponent(b3g)}`, 'error.png', {
                        http: true,
                        filepath: filepath
                    })

                    var width = fileinfo.info.width
                    var height = fileinfo.info.height

                    var squareS = { value: ((height === width) && width) || ((height > width) && height) || width, constraint: ((height === width) && 'both') || ((height > width) && 'height') || 'width' }

                    await execPromise(`ffmpeg -i ${filepath}/${filename} -i ${filepath}/error.png -filter_complex "[0:v]scale=${squareS.constraint === 'width' || squareS.constraint === 'both' ? 34 : -1}:${squareS.constraint === 'height' || squareS.constraint === 'both' ? 34 : -1}[frame];[1:v][frame]overlay=x=15+(34/2-w/2):y=36+(34/2-h/2):format=auto[oout];[oout]split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ${findpreset(args)} -gifflags -offsetting ${filepath}/output.gif`)
                    await sendFile(msg, filepath, `output.gif`)
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "error/warning \"{title}\" \"{message}\" \"[leftbutton]\" [-lgray] \"[centerbutton]\" [-cgray] \"[rightbutton]\" [-rgray] [-style <style (98 or XP)>] <file>",
                "value": "Sonic is hacking your computer"
            },
            cooldown: 2500,
            type: "Memes"
        },

        {
            name: ["undertale", "deltarune"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                var saidMessage = args.join(' ').substring(args[0].length + 1).replace(/‚Äô/g, '\'')
                symbolreplacements.forEach(symbolReplacement => {
                    symbolReplacement.target.forEach(target => {
                        saidMessage = saidMessage.replace(new RegExp(target, 'ig'), symbolReplacement.replacement)
                    })
                })
                var matchedTextes = saidMessage.match(/"([\s\S]*?)"/g)
                if (!matchedTextes) {
                    matchedTextes = ['""']
                }
                var text = matchedTextes[0].substring(1, matchedTextes[0].length - 1)

                var asteriskrgb = 'ffffff'
                var asteriskindex = args.indexOf('-asteriskcolor')
                if (asteriskindex > -1) {
                    var r = args[asteriskindex + 1]
                    var g = args[asteriskindex + 2]
                    var b = args[asteriskindex + 3]
                    asteriskrgb = (isNaN(Number(String(r).replace(/,/g, ''))) ? 0 : Number(String(r).replace(/,/g, '')) <= 0 ? 0 : Number(String(r).replace(/,/g, '')) >= 255 ? 255 : Number(String(r).replace(/,/g, '')) || 0).toString(16).padStart(2, '0') +
                        (isNaN(Number(String(g).replace(/,/g, ''))) ? 0 : Number(String(g).replace(/,/g, '')) <= 0 ? 0 : Number(String(g).replace(/,/g, '')) >= 255 ? 255 : Number(String(g).replace(/,/g, '')) || 0).toString(16).padStart(2, '0') +
                        (isNaN(Number(String(b).replace(/,/g, ''))) ? 0 : Number(String(b).replace(/,/g, '')) <= 0 ? 0 : Number(String(b).replace(/,/g, '')) >= 255 ? 255 : Number(String(b).replace(/,/g, '')) || 0).toString(16).padStart(2, '0')
                }

                if (args.find(arg => arg === '-noasterisk')) {
                    asteriskrgb = 'null'
                }

                var boxrgb = 'ffffff'
                var boxindex = args.indexOf('-boxcolor')
                if (boxindex > -1) {
                    var r = args[boxindex + 1]
                    var g = args[boxindex + 2]
                    var b = args[boxindex + 3]
                    boxrgb = (isNaN(Number(String(r).replace(/,/g, ''))) ? 0 : Number(String(r).replace(/,/g, '')) <= 0 ? 0 : Number(String(r).replace(/,/g, '')) >= 255 ? 255 : Number(String(r).replace(/,/g, '')) || 0).toString(16).padStart(2, '0') +
                        (isNaN(Number(String(g).replace(/,/g, ''))) ? 0 : Number(String(g).replace(/,/g, '')) <= 0 ? 0 : Number(String(g).replace(/,/g, '')) >= 255 ? 255 : Number(String(g).replace(/,/g, '')) || 0).toString(16).padStart(2, '0') +
                        (isNaN(Number(String(b).replace(/,/g, ''))) ? 0 : Number(String(b).replace(/,/g, '')) <= 0 ? 0 : Number(String(b).replace(/,/g, '')) >= 255 ? 255 : Number(String(b).replace(/,/g, '')) || 0).toString(16).padStart(2, '0')
                }

                var mode = 'regular'
                var modeindex = args.indexOf('-mode')
                if (modeindex > -1) {
                    if (args[modeindex + 1]) {
                        style = ['regular', 'darkworld'].find(st => st === args[modeindex + 1].toLowerCase()) ? args[modeindex + 1].toLowerCase() : 'regular'
                    }
                }

                var xpoint = 8
                var ypoint = 8

                var style = 'undertale'
                var styleindex = args.indexOf('-boxstyle')
                if (styleindex > -1) {
                    if (args[styleindex + 1]) {
                        style = ['undertale', 'deltarune', 'earthbound', 'underswap', 'underfell', 'octagonal', 'shadedground', 'tubertale', 'stubertale', 'fnastale', 'derp'].find(st => st === args[styleindex + 1].toLowerCase()) ? args[styleindex + 1].toLowerCase() : 'undertale'
                    }
                }

                if (style === 'deltarune') {
                    xpoint = 12
                    ypoint = 12
                }

                var font = 'determination'
                var fontindex = args.indexOf('-font')
                if (fontindex > -1) {
                    if (args[fontindex + 1]) {
                        font = ['determination', 'sans', 'papyrus', 'earthbound', 'wingdings'].find(st => st === args[fontindex + 1].toLowerCase()) ? args[fontindex + 1].toLowerCase() : 'determination'
                    }
                }

                var nopic = false
                var currenturl = !(saidMessage.includes('-nofile')) ? (data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['lastUrl'] || args[1]) : undefined
                if (!currenturl) nopic = true

                if (nopic) {
                    var filepath = await downloadFile(`https://www.demirramon.com/gen/undertale_text_box.png?text=${encodeURIComponent(text)}&box=${style}&boxcolor=${boxrgb}&font=${font}&asterisk=${asteriskrgb}&mode=${mode}&small=${!!args.find(arg => arg === '-small')}`, `output.png`, {
                        http: true
                    })

                    await sendFile(msg, filepath, `output.png`)
                    return
                }

                var fileinfo = await validateFile(currenturl).catch(error => {
                    msg.channel.send(error)
                    msg.channel.sendTyping().catch(() => { })
                    return;
                })

                if (!fileinfo) return
                var type = fileinfo.type

                if (type.mime.startsWith('image') && !(gifFormats.find(f => f === type.ext))) {
                    var filepath = await downloadFile(currenturl, `input.png`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.png`
                    await downloadFile(`https://www.demirramon.com/gen/undertale_text_box.png?text=${encodeURIComponent(text)}&box=${style}&boxcolor=${boxrgb}&character=blank&font=${font}&asterisk=${asteriskrgb}&mode=${mode}&small=true`, 'box.png', {
                        http: true,
                        filepath: filepath
                    })

                    var width = fileinfo.info.width
                    var height = fileinfo.info.height

                    var squareS = { value: ((height === width) && width) || ((height > width) && height) || width, constraint: ((height === width) && 'both') || ((height > width) && 'height') || 'width' }

                    await execPromise(`ffmpeg -i ${filepath}/${filename} -i ${filepath}/box.png -filter_complex "[0:v]scale=${squareS.constraint === 'width' || squareS.constraint === 'both' ? 58 : -1}:${squareS.constraint === 'height' || squareS.constraint === 'both' ? 58 : -1}[frame];[1:v][frame]overlay=x=${xpoint}+(58/2-w/2):y=${ypoint}+(60/2-h/2):format=auto${!(args.find(arg => arg === '-small')) ? `,scale=iw*2:ih*2:flags=neighbor` : ''}[out]" -map "[out]" -preset ${findpreset(args)} ${filepath}/output.png`)
                    await sendFile(msg, filepath, `output.png`)
                } else if (type.mime.startsWith('video')) {
                    var filepath = await downloadFile(currenturl, `input.mp4`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.mp4`
                    await downloadFile(`https://www.demirramon.com/gen/undertale_text_box.png?text=${encodeURIComponent(text)}&box=${style}&boxcolor=${boxrgb}&character=blank&font=${font}&asterisk=${asteriskrgb}&mode=${mode}&small=true`, 'box.png', {
                        http: true,
                        filepath: filepath
                    })

                    var width = fileinfo.info.width
                    var height = fileinfo.info.height

                    var squareS = { value: ((height === width) && width) || ((height > width) && height) || width, constraint: ((height === width) && 'both') || ((height > width) && 'height') || 'width' }

                    await execPromise(`ffmpeg -i ${filepath}/${filename} -i ${filepath}/box.png -map 0:a? -filter_complex "[0:v]scale=${squareS.constraint === 'width' || squareS.constraint === 'both' ? 58 : -1}:${squareS.constraint === 'height' || squareS.constraint === 'both' ? 58 : -1}[frame];[1:v][frame]overlay=x=${xpoint}+(58/2-w/2):y=${ypoint}+(60/2-h/2):format=auto${!(args.find(arg => arg === '-small')) ? `,scale=iw*2:ih*2:flags=neighbor` : ''},scale=ceil(iw/2)*2:ceil(ih/2)*2:flags=neighbor[out]" -map "[out]" -preset ${findpreset(args)} -c:v libx264 -pix_fmt yuv420p ${filepath}/output.mp4`)
                    await sendFile(msg, filepath, `output.mp4`)
                } else if (type.mime.startsWith('image') && gifFormats.find(f => f === type.ext)) {
                    var filepath = await downloadFile(currenturl, `input.gif`, {
                        fileinfo: fileinfo
                    })
                    var filename = `input.gif`
                    await downloadFile(`https://www.demirramon.com/gen/undertale_text_box.png?text=${encodeURIComponent(text)}&box=${style}&boxcolor=${boxrgb}&character=blank&font=${font}&asterisk=${asteriskrgb}&mode=${mode}&small=true`, 'box.png', {
                        http: true,
                        filepath: filepath
                    })

                    var width = fileinfo.info.width
                    var height = fileinfo.info.height

                    var squareS = { value: ((height === width) && width) || ((height > width) && height) || width, constraint: ((height === width) && 'both') || ((height > width) && 'height') || 'width' }

                    await execPromise(`ffmpeg -i ${filepath}/${filename} -i ${filepath}/box.png -filter_complex "[0:v]scale=${squareS.constraint === 'width' || squareS.constraint === 'both' ? 58 : -1}:${squareS.constraint === 'height' || squareS.constraint === 'both' ? 58 : -1}[frame];[1:v][frame]overlay=x=${xpoint}+(58/2-w/2):y=${ypoint}+(60/2-h/2):format=auto${!(args.find(arg => arg === '-small')) ? `,scale=iw*2:ih*2:flags=neighbor` : ''},split[pout][ppout];[ppout]palettegen=reserve_transparent=1[palette];[pout][palette]paletteuse=alpha_threshold=128[out]" -map "[out]" -preset ${findpreset(args)} -gifflags -offsetting ${filepath}/output.gif`)
                    await sendFile(msg, filepath, `output.gif`)
                } else {
                    msg.channel.send({
                        content: `Unsupported file: \`${currenturl}\``,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                    return
                }
            },
            help: {
                "name": "undertale/deltarune \"{text}\" [-mode <mode (regular or darkworld)>] [-boxstyle <style (read description)>] [-font <font (read description)>] [(-boxcolor | -asteriskcolor) <r> <g> <b>] [-no(file/asterisk)] [-small] <file>",
                "value": "story of undertale!!! A list of available box styles are undertale, deltarune, earthbound, underswap, underfell, octagonal, shadedground, tubertale, stubertale, fnastale and derp. Fonts are determination, sans, papyrus, earthbound and wingdings. More info on https://www.demirramon.com/help/undertale_text_box_generator"
            },
            cooldown: 2500,
            type: "Memes"
        },

        {
            name: ["sayorichoice", "schoice"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                var saidMessage = args.join(' ').substring(args[0].length + 1).replace(/‚Äô/g, '\'')
                symbolreplacements.forEach(symbolReplacement => {
                    symbolReplacement.target.forEach(target => {
                        saidMessage = saidMessage.replace(new RegExp(target, 'ig'), symbolReplacement.replacement)
                    })
                })
                var matchedTextes = saidMessage.match(/"([\s\S]*?)"/g)
                if (!matchedTextes) {
                    matchedTextes = ['""', '""']
                } else if (!matchedTextes[1]) {
                    matchedTextes[1] = '""'
                }
                var bchoice = matchedTextes[0].substring(1, matchedTextes[0].length - 1)
                var rchoice = matchedTextes[1].substring(1, matchedTextes[1].length - 1)
                var currentcount = filecount
                filecount++
                var filepath = `temp/file${currentcount}`
                fs.mkdirSync(`${filepath}`)
                var sayori = await Jimp.read(`templates/sayori.png`)
                var bangers = await Jimp.loadFont('templates/fonts/Bangers/Bangers.fnt')
                await sayori.print(bangers, 52, 35, { text: Discord.Util.cleanContent(bchoice, msg), alignmentX: Jimp.HORIZONTAL_ALIGN_CENTER, alignmentY: Jimp.VERTICAL_ALIGN_MIDDLE }, 176, 62)
                await sayori.print(bangers, 487, 38, { text: Discord.Util.cleanContent(rchoice, msg), alignmentX: Jimp.HORIZONTAL_ALIGN_CENTER, alignmentY: Jimp.VERTICAL_ALIGN_MIDDLE }, 228, 72)
                await sayori.writeAsync(`${filepath}/output.png`)
                await sendFile(msg, filepath, `output.png`)
            },
            help: {
                "name": "sayorichoice/schoice \"{blueChoice}\" \"{redChoice}\"",
                "value": "Creates an image with Sayori where you can choose between 2 options."
            },
            cooldown: 2500,
            type: "Inside Joke"
        },

        {
            name: ["markov"],
            execute: async function (msg, args) {
                var wordNumber
                var nopunctuation = false
                var keepcase = false
                var randomsentences = false

                var wordindex = args.indexOf('-words')
                if (wordindex > -1) {
                    wordNumber = isNaN(Number(args[wordindex + 1])) ? Math.floor(Math.random() * 40) + 1 : Number(args[wordindex + 1]) <= 1 ? 1 : Number(args[wordindex + 1]) >= 10000 ? 10000 : Math.round(Number(args[wordindex + 1])) || 1
                    wordsSpecified = true
                    args.splice(wordindex, 2)
                }

                if (args.find(arg => arg === '-nopunctuation')) {
                    nopunctuation = true
                    args.splice(args.indexOf('-nopunctuation'), 1)
                }

                if (args.find(arg => arg === '-keepcase')) {
                    keepcase = true
                    args.splice(args.indexOf('-keepcase'), 1)
                }

                if (args.find(arg => arg === '-randomsentences')) {
                    randomsentences = true
                    args.splice(args.indexOf('-randomsentences'), 1)
                }

                var saidMessage = args.join(' ').substring((args[0] || '').length + 1)
                var messages = data()[mongodatabase]['guild-data'][msg.guild.id]['messages'].slice()
                if (messages.length <= 0 || randomsentences) {
                    messages = json.sentenceJSON.data.map(s => s.sentence).concat(psPasta)
                }
                if (saidMessage) {
                    messages.push(saidMessage)
                }
                msg.channel.sendTyping().catch(() => { })
                var markovChain = markovChainGenerator(messages.join('  '))
                var markov = markovMe(markovChain, saidMessage, {
                    wordNumber: wordNumber,
                    nopunctuation: nopunctuation,
                    keepcase: keepcase
                })
                msg.channel.send({
                    content: markov,
                    allowedMentions: {
                        parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                    }
                }).catch(async () => {
                    var currentcount = filecount
                    filecount++
                    var filepath = `temp/file${currentcount}`
                    fs.mkdirSync(`${filepath}`)
                    fs.writeFileSync(`${filepath}/markov.txt`, markov)
                    await msg.channel.send({
                        files: [new Discord.MessageAttachment(`${filepath}/markov.txt`)]
                    }).catch(() => { })
                    fs.rmSync(`${filepath}`, { force: true, recursive: true })
                })
            },
            help: {
                "name": "markov [message] [-words <wordNumber>] [-nopunctuation] [-keepcase] [-randomsentences]",
                "value": "the Poopy Markov includes last messages. TOGLE"
            },
            cooldown: 2500,
            type: "Text"
        },

        {
            name: ["arabottify"],
            execute: async function (msg, args) {
                msg.channel.sendTyping().catch(() => { })
                var wordNumber = Math.floor(Math.random() * 40) + 1
                var wordsSpecified = false
                var noextrawords = false
                var nopunctuation = false
                var wordindex = args.indexOf('-words')
                if (wordindex > -1) {
                    wordNumber = isNaN(Number(args[wordindex + 1])) ? Math.floor(Math.random() * 40) + 1 : Number(args[wordindex + 1]) <= 1 ? 1 : Number(args[wordindex + 1]) >= 10000 ? 10000 : Math.round(Number(args[wordindex + 1])) || 1
                    wordsSpecified = true
                    args.splice(wordindex, 2)
                }
                if (args.find(arg => arg === '-noextrawords')) {
                    noextrawords = true
                    args.splice(args.indexOf('-noextrawords'), 1)
                }
                if (args.find(arg => arg === '-nopunctuation')) {
                    nopunctuation = true
                    args.splice(args.indexOf('-nopunctuation'), 1)
                }
                if (args[1] === undefined) {
                    var arabArray = []
                    var dict = 1
                    var conn = 1
                    for (var i = 0; i < wordNumber; i++) {
                        var randomFactor = Math.floor(Math.random() * 8)
                        if (randomFactor === 7) {
                            dict = 1
                            conn = 1
                            arabArray.push(msg.member.nickname || msg.author.username + (((Math.floor(Math.random() * 5) === 4 && !nopunctuation) && punctuation[Math.floor(Math.random() * punctuation.length)]) || ''))
                        } else {
                            function chooseWord() {
                                if (Math.floor(Math.random() * dict) + 1 === (dict === 3 ? 0 : 1)) {
                                    conn = 1
                                    dict++
                                    arabArray.push(arabDictionary[Math.floor(Math.random() * arabDictionary.length)] + (((Math.floor(Math.random() * 5) === 4 && !nopunctuation) && punctuation[Math.floor(Math.random() * punctuation.length)]) || ''))
                                } else if (Math.floor(Math.random() * conn) + 1 === (conn === 3 ? 0 : 1)) {
                                    dict = 1
                                    conn++
                                    arabArray.push(arabConnectors[Math.floor(Math.random() * arabConnectors.length)] + (((Math.floor(Math.random() * 5) === 4 && !nopunctuation) && punctuation[Math.floor(Math.random() * punctuation.length)]) || ''))
                                } else {
                                    chooseWord()
                                }
                            }

                            chooseWord()
                        }
                    }
                    msg.channel.send({
                        content: arabArray.join(' '),
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(async () => {
                        var currentcount = filecount
                        filecount++
                        var filepath = `temp/file${currentcount}`
                        fs.mkdirSync(`${filepath}`)
                        fs.writeFileSync(`${filepath}/arabottify.txt`, arabArray.join(' '))
                        await msg.channel.send({
                            files: [new Discord.MessageAttachment(`${filepath}/arabottify.txt`)]
                        }).catch(() => { })
                        fs.rmSync(`${filepath}`, { force: true, recursive: true })
                    })
                    msg.channel.sendTyping().catch(() => { })
                    return;
                };
                var arabArray = args.splice(1)
                var arabArray2 = []
                arabArray.forEach(word => {
                    for (var i = 0; i < ((Math.floor(Math.random() * 5) === 1 && (noextrawords ? 1 : 2)) || 1); i++) {
                        arabArray2.push({ word: word + (((Math.floor(Math.random() * 7) === 4 && !nopunctuation) && punctuation[Math.floor(Math.random() * punctuation.length)]) || ''), randomness: Math.random() })
                    }
                    if (Math.floor(Math.random() * 4) === 3 && !noextrawords) {
                        var randomFactor = Math.floor(Math.random() * 8)
                        if (randomFactor === 7) {
                            arabArray2.push({ word: msg.member.nickname || msg.author.username + (((Math.floor(Math.random() * 7) === 4 && !nopunctuation) && punctuation[Math.floor(Math.random() * punctuation.length)]) || ''), randomness: Math.random() })
                        } else if (randomFactor >= 0 && randomFactor <= 3) {
                            arabArray2.push({ word: arabDictionary[Math.floor(Math.random() * arabDictionary.length)] + (((Math.floor(Math.random() * 7) === 4 && !nopunctuation) && punctuation[Math.floor(Math.random() * punctuation.length)]) || ''), randomness: Math.random() })
                        } else {
                            arabArray2.push({ word: arabConnectors[Math.floor(Math.random() * arabConnectors.length)] + (((Math.floor(Math.random() * 7) === 4 && !nopunctuation) && punctuation[Math.floor(Math.random() * punctuation.length)]) || ''), randomness: Math.random() })
                        }
                    }
                })
                arabArray2.sort(function (a, b) {
                    return a.randomness - b.randomness
                })
                arabArray = []
                arabArray2.forEach(word => {
                    arabArray.push(word.word)
                })
                if (wordsSpecified) {
                    arabArray.splice(wordNumber)
                }
                msg.channel.send({
                    content: arabArray.join(' '),
                    allowedMentions: {
                        parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                    }
                }).catch(async () => {
                    var currentcount = filecount
                    filecount++
                    var filepath = `temp/file${currentcount}`
                    fs.mkdirSync(`${filepath}`)
                    fs.writeFileSync(`${filepath}/arabottify.txt`, arabArray.join(' '))
                    await msg.channel.send({
                        files: [new Discord.MessageAttachment(`${filepath}/arabottify.txt`)]
                    }).catch(() => { })
                    fs.rmSync(`${filepath}`, { force: true, recursive: true })
                })
                msg.channel.sendTyping().catch(() => { })
            },
            help: {
                "name": "arabottify [message] [-words <wordNumber>] [-noextrawords] [-nopunctuation]",
                "value": "message. a Scramble BLACK. message. Scramble Poopy Extra words... included\nExample usage: p:arabottify -words 1 -nopunctuation"
            },
            cooldown: 2500,
            type: "Text"
        },

        {
            name: ["garbage"],
            execute: async function (msg) {
                var garbage = ''
                for (var i = 0; i < 600; i++) {
                    garbage = garbage + String.fromCharCode(Math.floor(Math.random() * 15000))
                }
                msg.channel.send({
                    content: garbage,
                    allowedMentions: {
                        parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                    }
                }).catch(() => { })
            },
            help: {
                "name": "garbage",
                "value": "Generates random Unicode characters like „ÜØ·¨ã„ßì„åë‡ßà‚π∑·≥£‚®á€Ø·¥Éﬂè‡£É·äÆ‚≤è‚Åù‚ñï‚æ©„ôÑ‡≥Ö·∑¨·∂ó„®≠‡§ë·π≤„Éä„ì∫„ìÆ·∏©∆∏‡ø´‚∏Ω„õª‡†ñﬁ∂·öæ‡π¨‡ª¢‡Øä‡∑ñ‡†ª‚¥≤Œ≠·äë‚¢Ö‚Åõ É·Ö´‡•∏‚∏π‚Ωì‚¶¢·≤©‚≠¶‚°≠ÿö‡±ò‚ÉÉ‡®¢‡¥≥„Å≥„ï∫–¨‡≤ß»óŒñ‡¢ø∆ù·É≥‡∂ë‚≤≥·ë∏‡∑ö·πô‚ãê·úÄ·Øà‚úª‚≤ç·∑î√íﬁ°‚ÆØ‡Æ•…Æ‚É§‚ø≥‚üã„ïä·Æ®Œã‡≠º·´±⁄®„•ä„êµ„õÜ‚£æ€îŒ≠œ∞‚™≤‚¨â„õ∞‡∏°„•∫‡∞û‚ä∫·æ¥·ß≤·•û·ª®·Æï‚£ê‚¨ö·≠å·õµ@‡∏Å‚≥®·ø¶›Ø‚±¢‡®¥·ëòi‡µå‚ñâ‡≠∞·¨ç‡∞¢‚ÅÉ„ëÖ·≥Ü„áã·ñç·ñô·éîœ´‡°ë‹¨‚Ü§·ñÅ‡™©„Çî·éê‡¶∑‡´Ç‚öø·∏πŒ¨‚Ö∂‚ºî‡±®·óπ"
            },
            cooldown: 2500,
            type: "Text"
        },

        {
            name: ["ronald", "ronaldgif"],
            execute: async function (msg) {
                msg.channel.send(await special.keys._ronald.func()).catch(() => { })
            },
            help: {
                "name": "ronald/ronaldgif",
                "value": "Sends a random Ronald McDonald GIF to the channel."
            },
            cooldown: 2500,
            type: "Random"
        },

        {
            name: ["ps", "phexoniastudios"],
            execute: async function (msg, args) {
                var type = 'any'
                var typeindex = args.indexOf('-type')
                if (typeindex > -1) {
                    type = String(args[typeindex + 1]).toLowerCase()
                }

                if (type === 'image') {
                    var psImages = []

                    for (var i in psFiles) {
                        var file = psFiles[i]
                        if (!(file.match(/\.(gif|mov|mp4|apng)/))) psImages.push(file)
                    }

                    msg.channel.send(psImages[Math.floor(Math.random() * psImages.length)]).catch(() => { })
                } else if (type === 'video') {
                    var psVideos = []

                    for (var i in psFiles) {
                        var file = psFiles[i]
                        if (file.match(/\.(mov|mp4)/)) psVideos.push(file)
                    }

                    msg.channel.send(psVideos[Math.floor(Math.random() * psVideos.length)]).catch(() => { })
                } else if (type === 'gif') {
                    var psGifs = []

                    for (var i in psFiles) {
                        var file = psFiles[i]
                        if (file.match(/\.(gif|apng)/)) psGifs.push(file)
                    }

                    msg.channel.send(psGifs[Math.floor(Math.random() * psGifs.length)]).catch(() => { })
                } else {
                    msg.channel.send(psFiles[Math.floor(Math.random() * psFiles.length)]).catch(() => { })
                }
            },
            help: {
                "name": "ps/phexoniastudios [-type <extension (image/video/gif)>]",
                "value": "Sends a random Phexonia Studios related image, GIF or video to the channel."
            },
            cooldown: 2500,
            type: "Inside Joke"
        },

        {
            name: ["pspasta", "phexoniastudiospasta"],
            execute: async function (msg) {
                msg.channel.send(psPasta[Math.floor(Math.random() * psPasta.length)]).catch(() => { })
            },
            help: {
                "name": "pspasta/phexoniastudiospasta",
                "value": "Sends a random Phexonia Studios related copypasta or phrase to the channel."
            },
            cooldown: 2500,
            type: "Inside Joke"
        },

        {
            name: ["sayoriart"],
            execute: async function (msg) {
                var sayoriart = [
                    'https://cdn.discordapp.com/attachments/551420953704267789/795630551884103730/Untitled60.png',
                    'https://cdn.discordapp.com/attachments/551420953704267789/796054157907066880/Untitled61.jpg',
                    'https://cdn.discordapp.com/attachments/551420953704267789/797153799139491850/Untitled63_20210108172423.png',
                    'https://cdn.discordapp.com/attachments/551420953704267789/797157702593413161/Untitled2.png',
                    'https://cdn.discordapp.com/attachments/551420953704267789/797160861708845096/Untitled64_20210108175220.png',
                    'https://cdn.discordapp.com/attachments/551420953704267789/797184032219463720/Untitled36.jpg',
                    'https://cdn.discordapp.com/attachments/551420953704267789/797190453464137768/Untitled65_20210108195002.png',
                    'https://cdn.discordapp.com/attachments/551420953704267789/797190453236989982/Untitled59_20210108194540.png',
                    'https://cdn.discordapp.com/attachments/551420953704267789/797596839657865236/Untitled66_20210109224445.png',
                    'https://cdn.discordapp.com/attachments/551420953704267789/797774413059719189/Untitled67_20210110103021.png',
                    'https://cdn.discordapp.com/attachments/551420953704267789/797818314667458590/Untitled68_20210110132437.png',
                    'https://cdn.discordapp.com/attachments/551420953704267789/802162903679107082/Untitled2_20210122130848.png',
                    'https://cdn.discordapp.com/attachments/551420953704267789/802165734708215818/Untitled72_20210122132003.png',
                    'https://cdn.discordapp.com/attachments/551420953704267789/803251889424564224/Untitled72.png',
                    'https://cdn.discordapp.com/attachments/551420953704267789/808013659661533216/Untitled2_20210207163738.png',
                    'https://cdn.discordapp.com/attachments/551420953704267789/810271247992619068/Untitled73_20210213220820.png',
                    'https://cdn.discordapp.com/attachments/551420953704267789/810477036010340403/Untitled73_20210214114544.png',
                    'https://cdn.discordapp.com/attachments/551420953704267789/816670891323687012/Untitled76_20210303133106.png',
                    'https://cdn.discordapp.com/attachments/551420953704267789/816670891080810506/Untitled77_20210303133812.png',
                    'https://cdn.discordapp.com/attachments/551420953704267789/816680265774268456/Untitled69_20210303140555.png',
                    'https://cdn.discordapp.com/attachments/551420953704267789/816772683206492239/Untitled73_2.jpg',
                    'https://cdn.discordapp.com/attachments/551420953704267789/816773611422613544/Untitled78_20210303204617.png',
                    'https://cdn.discordapp.com/attachments/551420953704267789/816776152202739762/Untitled76.jpg',
                    'https://cdn.discordapp.com/attachments/551420953704267789/816783783726284850/Untitled78_20210303212454.png',
                    'https://cdn.discordapp.com/attachments/551420953704267789/816798995576913980/Untitled79_20210303222717.png',
                    'https://cdn.discordapp.com/attachments/551420953704267789/817004224952401940/Untitled80_20210304120203.png',
                    'https://cdn.discordapp.com/attachments/551420953704267789/817065692695363644/Untitled76_20210304160634.png',
                    'https://cdn.discordapp.com/attachments/551420953704267789/817086156574687303/Untitled73_20210304172826.png',
                    'https://cdn.discordapp.com/attachments/551420953704267789/817094556956884992/Untitled81_20210304180138.png',
                    'https://cdn.discordapp.com/attachments/551420953704267789/817105921859518514/Untitled82_20210304184640.png',
                    'https://cdn.discordapp.com/attachments/551420953704267789/817114899967770624/1614884560332.png',
                    'https://cdn.discordapp.com/attachments/551420953704267789/817123709633429544/Untitled73_20210304195526.png',
                    'https://cdn.discordapp.com/attachments/551420953704267789/817125204400013322/1614888154869.png',
                    'https://cdn.discordapp.com/attachments/551420953704267789/817732287458050068/1615032958778.png',
                    'https://cdn.discordapp.com/attachments/551420953704267789/817831868178104320/1615056703266.png',
                    'https://cdn.discordapp.com/attachments/551420953704267789/817835070618468352/1615057467701.png',
                    'https://cdn.discordapp.com/attachments/551420953704267789/817848187984674856/1615060564454.png',
                    'https://cdn.discordapp.com/attachments/551420953704267789/817842334342447124/1615059191441.png',
                    'https://cdn.discordapp.com/attachments/551420953704267789/817850459011416094/1615061128520.png',
                    'https://cdn.discordapp.com/attachments/551420953704267789/817852659792347176/1615061646277.png',
                    'https://cdn.discordapp.com/attachments/551420953704267789/817853455787753472/1615061838855.png',
                    'https://cdn.discordapp.com/attachments/551420953704267789/817854272955613204/1615062030416.png',
                    'https://cdn.discordapp.com/attachments/551420953704267789/817855251977076766/1615062269660.png',
                    'https://cdn.discordapp.com/attachments/551420953704267789/817856309449326612/1615062519318.png',
                    'https://cdn.discordapp.com/attachments/551420953704267789/817856863969345586/1615062650227.png',
                    'https://cdn.discordapp.com/attachments/551420953704267789/817857858954985482/1615062894509.png',
                    'https://cdn.discordapp.com/attachments/551420953704267789/818094044202008586/1615119196369.png',
                    'https://cdn.discordapp.com/attachments/551420953704267789/818095291567439872/1615119502203.png',
                    'https://cdn.discordapp.com/attachments/551420953704267789/818115633404575754/1615124338983.png',
                    'https://cdn.discordapp.com/attachments/551420953704267789/818124672867893288/1615125179384.png',
                    'https://cdn.discordapp.com/attachments/551420953704267789/818143523635068958/1615130977811.png',
                    'https://cdn.discordapp.com/attachments/551420953704267789/818164602764132372/1615136016890.png',
                    'https://cdn.discordapp.com/attachments/551420953704267789/818166927465250846/1615136533205.png',
                    'https://cdn.discordapp.com/attachments/551420953704267789/818182167808311346/1615140203358.png',
                    'https://cdn.discordapp.com/attachments/551420953704267789/818218179594551316/1615148780821.png',
                    'https://cdn.discordapp.com/attachments/551420953704267789/818601276921085973/1615240118322.png',
                    'https://cdn.discordapp.com/attachments/551420953704267789/818878668663160832/1615306271210.png',
                    'https://cdn.discordapp.com/attachments/551420953704267789/818925499202928641/1615317432385.png',
                    'https://cdn.discordapp.com/attachments/551420953704267789/819251650824110130/1615395205112.png',
                    'https://cdn.discordapp.com/attachments/551420953704267789/819684625156669480/1615492124858.png',
                    'https://cdn.discordapp.com/attachments/551420953704267789/819685437898489856/1615498609344.png',
                    'https://cdn.discordapp.com/attachments/551420953704267789/820011700455473182/1615576403672.png',
                    'https://cdn.discordapp.com/attachments/551420953704267789/820012868874272818/1615576686101.png',
                    'https://cdn.discordapp.com/attachments/551420953704267789/820014046366924820/1615576967508.png',
                    'https://cdn.discordapp.com/attachments/551420953704267789/821302296336007188/1615884091566.png',
                    'https://cdn.discordapp.com/attachments/551420953704267789/821821022411817010/1616007749761.png',
                    'https://cdn.discordapp.com/attachments/551420953704267789/822210956837781584/1616097770660.png',
                    'https://cdn.discordapp.com/attachments/551420953704267789/822582293360148542/1616189282475.png',
                    'https://cdn.discordapp.com/attachments/551420953704267789/829993684190625802/1617956267687.png',
                    'https://cdn.discordapp.com/attachments/551420953704267789/831581623958896680/1618334886397.png',
                    'https://cdn.discordapp.com/attachments/551420953704267789/831600780988776468/1618339452533.png',
                    'https://cdn.discordapp.com/attachments/551420953704267789/831622224674553896/1618344569315.png',
                    'https://cdn.discordapp.com/attachments/551420953704267789/833022357857239070/16186783690472.png',
                    'https://cdn.discordapp.com/attachments/551420953704267789/833024930924199966/Untitled84_20210417180316.png',
                    'https://cdn.discordapp.com/attachments/551420953704267789/833030355291996210/Untitled85_202104171824372.png',
                    'https://cdn.discordapp.com/attachments/551420953704267789/833073620656980008/Untitled86_20210417211645.png',
                    'https://cdn.discordapp.com/attachments/551420953704267789/833078671971188756/1618691802285.png',
                    'https://cdn.discordapp.com/attachments/551420953704267789/833080317627203624/1618692189559.png',
                    'https://cdn.discordapp.com/attachments/551420953704267789/833091643305492510/1618694886205.png',
                    'https://cdn.discordapp.com/attachments/551420953704267789/833287354247544852/Untitled88_20210418112551.png',
                    'https://cdn.discordapp.com/attachments/551420953704267789/833299240477523968/Untitled89_20210418121324.png',
                    'https://cdn.discordapp.com/attachments/551420953704267789/833776183954505808/Untitled90_20210419194244.png',
                    'https://cdn.discordapp.com/attachments/551420953704267789/833787541521432646/Untitled91_20210419203339.png',
                    'https://cdn.discordapp.com/attachments/551420953704267789/833816032245186610/Untitled92_20210419222646.png',
                    'https://cdn.discordapp.com/attachments/551420953704267789/834074465025523712/1618929228772.png',
                    'https://cdn.discordapp.com/attachments/551420953704267789/834102884207296532/1618935963637.png',
                    'https://cdn.discordapp.com/attachments/551420953704267789/834131763432521809/1618942887419.png',
                    'https://cdn.discordapp.com/attachments/551420953704267789/834148818953175100/1618946957296.png',
                    'https://cdn.discordapp.com/attachments/551420953704267789/834185144775475210/1618955614344.png',
                    'https://cdn.discordapp.com/attachments/551420953704267789/834433626925039646/1619014856005.png',
                    'https://cdn.discordapp.com/attachments/551420953704267789/834486815636848700/1619027541404.png',
                    'https://cdn.discordapp.com/attachments/551420953704267789/834518477167263795/1619035094650.png',
                    'https://cdn.discordapp.com/attachments/551420953704267789/834538102872997918/1619039760117.png',
                    'https://cdn.discordapp.com/attachments/551420953704267789/834799699294027786/1619102114157.png',
                    'https://cdn.discordapp.com/attachments/551420953704267789/834818859457314856/1619106695612.png',
                    'https://cdn.discordapp.com/attachments/551420953704267789/834827622805536818/1619108799106.png',
                    'https://cdn.discordapp.com/attachments/551420953704267789/834845098994827364/1619112967178.png',
                    'https://cdn.discordapp.com/attachments/551420953704267789/834879150912700496/1619121072923.png',
                    'https://cdn.discordapp.com/attachments/551420953704267789/835260424685092864/1619211981789.png',
                    'https://cdn.discordapp.com/attachments/551420953704267789/835647931293106226/1619304378985.png',
                    'https://cdn.discordapp.com/attachments/551420953704267789/835989031112015915/1619385691547.png',
                    'https://cdn.discordapp.com/attachments/551420953704267789/842513191401291806/1620941172487.png',
                    'https://cdn.discordapp.com/attachments/551420953704267789/842520895293620234/1620942993681.png',
                    'https://cdn.discordapp.com/attachments/551420953704267789/842674520044208178/1620979646515.png',
                    'https://cdn.discordapp.com/attachments/551420953704267789/842689379385999360/1620983189025.png',
                    'https://cdn.discordapp.com/attachments/551420953704267789/844646768313368606/1621449856188.png',
                    'https://cdn.discordapp.com/attachments/551420953704267789/844954615342170152/1621523264214.png',
                    'https://cdn.discordapp.com/attachments/551420953704267789/845442104271700028/1621639485763.png',
                    'https://cdn.discordapp.com/attachments/551420953704267789/852189852779020318/1623248266953.png',
                    'https://cdn.discordapp.com/attachments/551420953704267789/846018326434021436/20210523_143344.jpg'
                ]

                var sayori = await bot.users.fetch('758638862590803968')

                msg.channel.send({
                    content: `This treasure was made by ${sayori.tag}.`,
                    files: [new Discord.MessageAttachment(sayoriart[Math.floor(Math.random() * sayoriart.length)])]
                }).catch(() => { })
            },
            help: {
                "name": "sayoriart",
                "value": "Sends a random masterpiece from Sayori to the channel, we can't let the fat impostor go away."
            },
            cooldown: 2500,
            type: "Inside Joke"
        },

        {
            name: ["sayori"],
            execute: async function (msg, args) {
                if (msg.channel.parent) {
                    if (msg.channel.parent.isText()) {
                        msg.channel.send('Webhooks can\'t be used here.').catch(() => { })
                        return
                    }
                }

                async function sayoriAi(msg, fixedchoice) {
                    var datamembers = data()[mongodatabase]['guild-data'][msg.guild.id]['members'];
                    var members = []
                    for (var id in datamembers) {
                        var datamember = datamembers[id]
                        if (datamember.username) members.push(datamember.username)
                    }
                    var year = new Date(Date.now()).getFullYear()
                    var sayoriAdjectives = ['HORNY', 'FARTING', 'RACIST', 'STUPID', 'FEMBOY', 'GAY', 'TRANS', 'UNDERAGED', 'RETARD', 'BITCH', 'ASSHOLE', 'MOTHERFUCKER']
                    var adjectives = ['is trans', 'the femboy', 'the futa', 'the idiot', 'the stalker', 'the impostor', 'now sus', 'the nutter', 'the shitter', 'the burger', 'is very annoying', 'big', 'fat', 'is thin', 'is small', 'what', 'is funny', 'noob', 'wtf', 'with pp', 'peed his pants', 'is amongla', 'looks at porn lolololol'];
                    var shipAdjectives = ['likes', 'you like', 'loves', 'you love', 'you are in love with', 'you should marry', 'with', 'hug', 'your game is now poopoo for'];
                    var fnf = ['dad', 'gf', 'pico', 'skid and pump', 'monster', 'mom', 'senpai', 'tankman', 'whitty', 'carol', 'hex', 'ruv', 'sarvente', 'miku', 'tricky', 'zardy', 'matt', 'garcello', 'shaggy', 'annie', 'cheeky', 'bob', 'tabi', 'agoti', 'kapi', 'neon', 'nene', 'monika', 'cg5', 'updike', 'selever', 'tord', 'impostor', 'trollge', 'tree']
                    var consoles = ['pc', 'mobile', 'tablet', 'xbox', 'nintendo switch', 'nintendo 3ds', 'nintendo 2ds', 'psp', 'ps1', 'ps2', 'gamecube', 'ps3', 'ps4', 'ps5', 'wii', 'xbox 360', 'xbox one', 'gameboy', 'nintendo 64', 'sega genesis', 'wii u']
                    var options = [
                        { pings: false, text: 'lol https://tenor.com/view/sus-suspect-among-us-gif-18663592' },
                        { pings: false, text: 'https://tenor.com/view/madness-hank-new-grounds-jump-gif-17044581' },
                        { pings: false, text: 'https://tenor.com/view/friday-night-funkin-hey-boyfriend-gif-21180248' },
                        { pings: true, text: 'SHUT UP' },
                        { pings: true, text: 'sussy' },
                        { pings: false, text: 'lol' },
                        { pings: false, text: 'among us impostor in madness tricky mod' },
                        { pings: false, text: 'ehat', edit: 'what' },
                        { pings: false, text: arabDictionary[Math.floor(Math.random() * arabDictionary.length)].toLowerCase() + ' is ' + arabDictionary[Math.floor(Math.random() * arabDictionary.length)].toLowerCase() },
                        { pings: false, text: arabDictionary[Math.floor(Math.random() * arabDictionary.length)].toLowerCase() + ' in ' + arabDictionary[Math.floor(Math.random() * arabDictionary.length)].toLowerCase() },
                        { pings: false, text: arabDictionary[Math.floor(Math.random() * arabDictionary.length)].toLowerCase() + ' ' + arabDictionary[Math.floor(Math.random() * arabDictionary.length)].toLowerCase() + ' is ' + arabDictionary[Math.floor(Math.random() * arabDictionary.length)].toLowerCase() + ' ' + arabDictionary[Math.floor(Math.random() * arabDictionary.length)].toLowerCase() },
                        { pings: false, text: 'not ' + arabDictionary[Math.floor(Math.random() * arabDictionary.length)].toLowerCase() },
                        { pings: false, text: arabDictionary[Math.floor(Math.random() * arabDictionary.length)].toLowerCase() },
                        { pings: false, text: arabDictionary[Math.floor(Math.random() * arabDictionary.length)].toLowerCase() + '.' },
                        { pings: false, text: 'the ' + arabDictionary[Math.floor(Math.random() * arabDictionary.length)].toLowerCase() + ' fandom is dying' },
                        { pings: false, text: 'THE VS ' + arabDictionary[Math.floor(Math.random() * arabDictionary.length)].toUpperCase() + ' MOD' },
                        { pings: false, text: 'WHAT A ' + arabDictionary[Math.floor(Math.random() * arabDictionary.length)].toUpperCase() },
                        { pings: false, text: 'they added the ' + arabDictionary[Math.floor(Math.random() * arabDictionary.length)].toLowerCase() + ' big ass' },
                        { pings: false, text: 'the ' + arabDictionary[Math.floor(Math.random() * arabDictionary.length)].toLowerCase() },
                        { pings: false, text: 'not ' + arabDictionary[Math.floor(Math.random() * arabDictionary.length)].toLowerCase() + ' fetish' },
                        { pings: false, text: 'finally a ' + arabDictionary[Math.floor(Math.random() * arabDictionary.length)].toLowerCase() + ' game to ' + consoles[Math.floor(Math.random() * consoles.length)] },
                        { pings: false, text: arabDictionary[Math.floor(Math.random() * arabDictionary.length)].toLowerCase() + ' was made in ' + (Math.floor(Math.random() * (year - 1980)) + 1980) + ' xd' },
                        { pings: false, text: 'this will be ' + arabDictionary[Math.floor(Math.random() * arabDictionary.length)].toLowerCase() + ' in ' + (Math.floor(Math.random() * (year - 2000)) + 2000) },
                        { pings: false, text: 'YOU DONT KILL ' + (arabDictionary[Math.floor(Math.random() * arabDictionary.length)].toUpperCase() + ' ').repeat(2) + 'KILLS YOU!!!!!!!!!!!!!!!!' },
                        { pings: false, text: arabDictionary[Math.floor(Math.random() * arabDictionary.length)].toLowerCase() + ' is in the ' + fnf[Math.floor(Math.random() * fnf.length)] + ' week' },
                        { pings: false, text: 'no not big ass ' + arabDictionary[Math.floor(Math.random() * arabDictionary.length)].toLowerCase() },
                        { pings: true, text: 'snat' },
                        { pings: false, text: 'STOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOPPPPPPPPPPPPPPPPPPPPPPP' },
                        { pings: false, text: 'WOOOOOOOOOOOOOOOOOOOOOOOOOOOOO' },
                        { pings: true, text: 'wjat', edit: 'what' },
                        { pings: false, text: 'NO' },
                        { pings: false, text: 'ü§£ ü§£ ü§£ ü§£ ü§£ ü§£' },
                        { pings: false, text: 'STOP' },
                        { pings: false, text: 'WHU', edit: 'WHY' },
                        { pings: true, text: 'WHY' },
                        { pings: false, text: 'GOD HELP ME' },
                        { pings: false, text: 'IM NOT' },
                        { pings: false, text: 'wtf' },
                        { pings: false, text: 'wow' },
                        { pings: false, text: 'no' },
                        { pings: false, text: 'not again' },
                        { pings: false, text: 'IM NOT ' + sayoriAdjectives[Math.floor(Math.random() * sayoriAdjectives.length)] },
                        { pings: false, text: 'im ' + sayoriAdjectives[Math.floor(Math.random() * sayoriAdjectives.length)].toLowerCase() },
                        { pings: false, text: 'nooooo' },
                        { pings: false, text: 'stol', edit: 'stop' },
                        { pings: false, text: 'Hope you realize that people can become not cringe. Maybe. Juuuust maybe. I have stopped doing shit with the "gay chains". If you tried not dwelling on the past maybe you could actually realize how annoying you are. Now let me guess youll respond with a short answer, not answer, respond with what I did, or completely change the topic.' },
                        { pings: true, text: 'no' },
                        { pings: false, text: 'gay' },
                        { pings: false, text: 'i dare someone to post porn on my dm\'s' },
                        { pings: false, text: '._.' },
                        { pings: true, text: '' },
                        { pings: false, text: msg.author.username.toUpperCase() + ' WHY' },
                        { pings: false, text: 'BRUH' },
                        { pings: false, text: 'SUS' },
                        { pings: false, text: 'im underaged' },
                        { pings: true, text: 'YOU SUSSY' },
                        { pings: false, text: 'AMOGUS' },
                        { pings: false, text: 'is that friday night porn' },
                        { pings: true, text: 'flop' },
                        { pings: false, text: 'i like porn ü•≤ ü•≤ ü•≤ ü•≤ ü•≤ ü•≤' },
                        { pings: true, text: 'stupid ' + msg.author.username.toLowerCase() },
                        { pings: false, text: 'not ' + msg.author.username.toLowerCase() },
                        { pings: false, text: 'wth ' + msg.author.username.toLowerCase() },
                        { pings: false, text: 'lol ' + msg.author.username.toLowerCase() },
                        { pings: false, text: msg.author.username.toLowerCase() + ' ' + adjectives[Math.floor(Math.random() * adjectives.length)] },
                        { pings: false, text: msg.author.username.toLowerCase() + ': ' + arabDictionary[Math.floor(Math.random() * arabDictionary.length)].toLowerCase() },
                        { pings: false, text: 'no not ' + msg.author.username.toLowerCase() + ' with ' + arabDictionary[Math.floor(Math.random() * arabDictionary.length)].toLowerCase() },
                        { pings: false, text: 'ahhhhhhhhhh' },
                        { pings: false, text: 'school suuucks' },
                        { pings: false, text: 'why am i a bot' },
                        { pings: false, text: msg.author.username.toLowerCase() + ' ' + shipAdjectives[Math.floor(Math.random() * shipAdjectives.length)] + ' ' + members[Math.floor(Math.random() * members.length)].toLowerCase() },
                        { pings: false, text: 'is ' + members[Math.floor(Math.random() * members.length)].toLowerCase() + ' hot' },
                        { pings: false, text: 'im not pinging ' + members[Math.floor(Math.random() * members.length)].toLowerCase() },
                        { pings: false, text: members[Math.floor(Math.random() * members.length)].toUpperCase() + ' IS ' + sayoriAdjectives[Math.floor(Math.random() * sayoriAdjectives.length)] + ' NOT ME' },
                        { pings: false, text: members[Math.floor(Math.random() * members.length)].toUpperCase() + ' IS THE ' + sayoriAdjectives[Math.floor(Math.random() * sayoriAdjectives.length)] + ' ' + sayoriAdjectives[Math.floor(Math.random() * sayoriAdjectives.length)] + ' ' + sayoriAdjectives[Math.floor(Math.random() * sayoriAdjectives.length)] + ' ' + sayoriAdjectives[Math.floor(Math.random() * sayoriAdjectives.length)] },
                        { pings: false, text: msg.author.username.toLowerCase() }
                    ];

                    var sayori = await bot.users.fetch('758638862590803968')

                    var option = fixedchoice && (typeof (Number(fixedchoice)) == 'number' && (((Number(fixedchoice) - 1) >= options.length - 1 && options[options.length - 1]) || ((Number(fixedchoice) - 1) <= 0 && options[0]) || (isNaN(Number(fixedchoice)) && options[Math.floor(Math.random() * options.length)]) || options[Math.floor(Number(fixedchoice))]) || options[Math.floor(Math.random() * options.length)]) || options[Math.floor(Math.random() * options.length)]
                    var optiontext
                    if (option['pings'] === true) {
                        optiontext = '<@' + msg.author.id + '> ' + option['text']
                    } else {
                        optiontext = option['text']
                    }

                    var webhooks = await msg.channel.fetchWebhooks().catch(() => { })
                    if (webhooks ? webhooks.size : undefined) {
                        var findWebhook = webhooks.find(webhook => bot.user === webhook.owner)
                        if (findWebhook) {
                            await findWebhook.send({
                                content: optiontext,
                                username: sayori.username,
                                avatarURL: sayori.displayAvatarURL({ dynamic: true, size: 1024, format: 'png' }),
                                allowedMentions: {
                                    parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            })
                                .then(botmsg => {
                                    if (option['edit']) {
                                        var editTimeout = setTimeout(() => {
                                            if (option['pings'] === true) {
                                                botmsg.delete().catch(() => { })
                                                findWebhook.send({
                                                    content: '<@' + msg.author.id + '> ' + option['edit'] + ' ‚ÅΩ·µâ·µà·∂¶·µó·µâ·µà‚Åæ',
                                                    username: sayori.username,
                                                    avatarURL: sayori.displayAvatarURL({ dynamic: true, size: 1024, format: 'png' }),
                                                    allowedMentions: {
                                                        parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                                    }
                                                }).catch(() => { })
                                            } else {
                                                botmsg.delete().catch(() => { })
                                                findWebhook.send({
                                                    content: option['edit'] + ' ‚ÅΩ·µâ·µà·∂¶·µó·µâ·µà‚Åæ',
                                                    username: sayori.username,
                                                    avatarURL: sayori.displayAvatarURL({ dynamic: true, size: 1024, format: 'png' }),
                                                    allowedMentions: {
                                                        parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                                    }
                                                }).catch(() => { })
                                            }
                                            clearTimeout(editTimeout)
                                        }, 3000)
                                    }
                                })
                                .catch(() => { })
                        } else {
                            var createdWebhook = await msg.channel.createWebhook('Poopyhook', { avatar: 'https://cdn.discordapp.com/attachments/760223418968047629/835923489834664056/poopy2.png' }).catch(() => { })
                            if (!createdWebhook) {
                                msg.channel.send('I need admin for this command!').catch(() => { })
                                return
                            }
                            await createdWebhook.send({
                                content: optiontext,
                                username: sayori.username,
                                avatarURL: sayori.displayAvatarURL({ dynamic: true, size: 1024, format: 'png' }),
                                allowedMentions: {
                                    parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            })
                                .then(botmsg => {
                                    if (option['edit']) {
                                        var editTimeout = setTimeout(() => {
                                            if (option['pings'] === true) {
                                                botmsg.delete().catch(() => { })
                                                findWebhook.send({
                                                    content: '<@' + msg.author.id + '> ' + option['edit'] + ' ‚ÅΩ·µâ·µà·∂¶·µó·µâ·µà‚Åæ',
                                                    username: sayori.username,
                                                    avatarURL: sayori.displayAvatarURL({ dynamic: true, size: 1024, format: 'png' }),
                                                    allowedMentions: {
                                                        parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                                    }
                                                }).catch(() => { })
                                            } else {
                                                botmsg.delete().catch(() => { })
                                                findWebhook.send({
                                                    content: option['edit'] + ' ‚ÅΩ·µâ·µà·∂¶·µó·µâ·µà‚Åæ',
                                                    username: sayori.username,
                                                    avatarURL: sayori.displayAvatarURL({ dynamic: true, size: 1024, format: 'png' }),
                                                    allowedMentions: {
                                                        parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                                    }
                                                }).catch(() => { })
                                            }
                                            clearTimeout(editTimeout)
                                        }, 3000)
                                    }
                                })
                                .catch(() => { })
                        }
                    } else {
                        var createdWebhook = await msg.channel.createWebhook('Poopyhook', { avatar: 'https://cdn.discordapp.com/attachments/760223418968047629/835923489834664056/poopy2.png' }).catch(() => { })
                        if (!createdWebhook) {
                            msg.channel.send('I need admin for this command!').catch(() => { })
                            return
                        }
                        await createdWebhook.send({
                            content: optiontext,
                            username: sayori.username,
                            avatarURL: sayori.displayAvatarURL({ dynamic: true, size: 1024, format: 'png' }),
                            allowedMentions: {
                                parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                            }
                        })
                            .then(botmsg => {
                                if (option['edit']) {
                                    var editTimeout = setTimeout(() => {
                                        if (option['pings'] === true) {
                                            botmsg.delete().catch(() => { })
                                            findWebhook.send({
                                                content: '<@' + msg.author.id + '> ' + option['edit'] + ' ‚ÅΩ·µâ·µà·∂¶·µó·µâ·µà‚Åæ',
                                                username: sayori.username,
                                                avatarURL: sayori.displayAvatarURL({ dynamic: true, size: 1024, format: 'png' }),
                                                allowedMentions: {
                                                    parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                                }
                                            }).catch(() => { })
                                        } else {
                                            botmsg.delete().catch(() => { })
                                            findWebhook.send({
                                                content: option['edit'] + ' ‚ÅΩ·µâ·µà·∂¶·µó·µâ·µà‚Åæ',
                                                username: sayori.username,
                                                avatarURL: sayori.displayAvatarURL({ dynamic: true, size: 1024, format: 'png' }),
                                                allowedMentions: {
                                                    parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                                }
                                            }).catch(() => { })
                                        }
                                        clearTimeout(editTimeout)
                                    }, 3000)
                                }
                            })
                            .catch(() => { })
                    }
                };

                await sayoriAi(msg, args[1])
            },
            help: {
                "name": "sayori [phraseChoice]",
                "value": "no not sayori ai"
            },
            cooldown: 2500,
            type: "Inside Joke"
        },

        {
            name: ["araboword", "raleighword"],
            execute: async function (msg) {
                var vowels = ['a', 'e', 'i', 'o', 'u']
                var consonants = []
                for (i = 97; i <= 122; i++) {
                    var char = String.fromCharCode(i)
                    if (!vowels.find(letter => letter == char)) {
                        consonants.push(char)
                    }
                }
                var word = ''
                for (i = 0; i < Math.floor(Math.random() * 3) + 2; i++) {
                    word += consonants[Math.floor(Math.random() * consonants.length)] + vowels[Math.floor(Math.random() * vowels.length)]
                }
                msg.channel.send(word).catch(() => { })
            },
            help: {
                "name": "araboword/raleighword",
                "value": "Generates a completely nonsensical word that doesn't even exist."
            },
            cooldown: 2500,
            type: "Text"
        },

        {
            name: ["randomword"],
            execute: async function (msg) {
                var wordJSON = json.wordJSON
                msg.channel.send(wordJSON.data[Math.floor(Math.random() * wordJSON.data.length)].word.value).catch(() => { })
            },
            help: {
                "name": "randomword",
                "value": "Generates a random word."
            },
            cooldown: 2500,
            type: "Random"
        },

        {
            name: ["randomimage"],
            execute: async function (msg) {
                var imageJSON = json.imageJSON
                var image = imageJSON.data[Math.floor(Math.random() * imageJSON.data.length)]
                msg.channel.send({
                    content: image.description,
                    files: [new Discord.MessageAttachment('https://randomwordgenerator.com' + image.image_url)],
                }).catch(() => { })
            },
            help: {
                "name": "randomimage",
                "value": "Generates a random image."
            },
            cooldown: 2500,
            type: "Random"
        },

        {
            name: ["randomsentence"],
            execute: async function (msg) {
                var sentenceJSON = json.sentenceJSON
                msg.channel.send(sentenceJSON.data[Math.floor(Math.random() * sentenceJSON.data.length)].sentence).catch(() => { })
            },
            help: {
                "name": "randomsentence",
                "value": "Generates a random sentence."
            },
            cooldown: 2500,
            type: "Random"
        },

        {
            name: ["randomname"],
            execute: async function (msg) {
                var nameJSON = json.nameJSON
                var surnames = nameJSON.surname
                var names = nameJSON.male.concat(nameJSON.female)
                msg.channel.send(`${names[Math.floor(Math.random() * names.length)].name.value} ${surnames[Math.floor(Math.random() * surnames.length)].name.value}`).catch(() => { })
            },
            help: {
                "name": "randomname",
                "value": "Generates a random name."
            },
            cooldown: 2500,
            type: "Random"
        },

        {
            name: ["randomgif"],
            execute: async function (msg) {
                var word = tenorDictionary[Math.floor(Math.random() * tenorDictionary.length)].toLowerCase()
                axios.request(`https://g.tenor.com/v1/search?q=${encodeURIComponent(word)}&key=${process.env.TENORKEY}&limit=100&contentfilter=${msg.channel.nsfw ? 'off' : 'medium'}`).then((res) => {
                    var parsedBody = res.data
                    msg.channel.send(parsedBody.results[Math.floor(Math.random() * parsedBody.results.length)].itemurl).catch(() => { })
                }).catch(() => { })
            },
            help: {
                "name": "randomgif",
                "value": "Sends a completely random Tenor GIF."
            },
            cooldown: 2500,
            type: "Random"
        },

        {
            name: ["clickhole"],
            execute: async function (msg) {
                axios.request(`https://clickhole.com/category/news/`).then((res) => {
                    var $ = cheerio.load(res.data)
                    var pages = Number($('.page-numbers')[3].children[0].data)
                    var page = Math.floor(Math.random() * pages) + 1
                    axios.request(`https://clickhole.com/category/news/${page != 1 ? `page/${page}/` : ''}`).then((res2) => {
                        var $2 = cheerio.load(res2.data)
                        var posts = $2('.post')
                        var post = posts[Math.floor(Math.random() * posts.length)]
                        msg.channel.send(post.children[1].children[1].children[0].attribs.href).catch(() => { })
                    }).catch(() => { })
                }).catch(() => { })
            },
            help: {
                "name": "clickhole",
                "value": "Sends one of Clickhole's AMAZENG NEWS!"
            },
            cooldown: 2500,
            type: "Random"
        },

        {
            name: ["randomcmd"],
            execute: async function (msg, args) {
                var type = 'Rand'
                function chooseCmd() {
                    var cmd
                    if (type === 'Rand') {
                        cmd = commands[Math.floor(Math.random() * commands.length)]
                        if (cmd.type === 'Owner' || cmd.type === 'JSON Club' || cmd.perms || data()[mongodatabase]['guild-data'][msg.guild.id]['disabled'].find(c => c.find(n => n === cmd.name.find(nn => nn === n)))) {
                            return chooseCmd()
                        }
                        return cmd
                    } else {
                        var cmds = []
                        for (var i in shelpCmds) {
                            var shelpCmd = shelpCmds[i]
                            if (shelpCmd.type === type) {
                                for (var j in shelpCmd.commands) {
                                    var command = shelpCmd.commands[j]
                                    var cmd = commands.find(c => c.help.name === command.name)
                                    if (!(cmd.type === 'Owner' || cmd.type === 'JSON Club' || cmd.perms || data()[mongodatabase]['guild-data'][msg.guild.id]['disabled'].find(c => c.find(n => n === cmd.name.find(nn => nn === n))))) {
                                        cmds.push(cmd)
                                    }
                                }
                            }
                        }
                        if (cmds.length > 0) {
                            cmd = cmds[Math.floor(Math.random() * cmds.length)]
                            return cmd
                        }
                        return
                    }
                }
                var typeindex = args.indexOf('-cmdtype')
                if (typeindex > -1) {
                    if (types.find(type => type.toLowerCase() === args.slice(typeindex + 1).join(' ').toLowerCase())) {
                        type = types.find(type => type.toLowerCase() === args.slice(typeindex + 1).join(' ').toLowerCase())
                        args.splice(typeindex)
                    }
                }
                var cmd = chooseCmd()

                if (!cmd) {
                    msg.channel.send('no').catch(() => { })
                    return
                }

                var cmdmessage = await msg.channel.send(`Executing \`${cmd.name[0]}\`.`).catch(() => { })
                if (cmd.cooldown) {
                    data()[mongodatabase]['guild-data'][msg.guild.id]['members'][msg.author.id]['coolDown'] = (data()[mongodatabase]['guild-data'][msg.guild.id]['members'][msg.author.id]['coolDown'] || Date.now()) + cmd.cooldown / ((msg.member.permissions.has('MANAGE_GUILD') || msg.member.roles.cache.find(role => role.name.match(/mod|dev|admin|owner|creator|founder|staff/ig)) || msg.member.permissions.has('MANAGE_MESSAGES') || msg.member.permissions.has('ADMINISTRATOR') || msg.author.id === msg.guild.ownerID) && (cmd.type === 'Text' || cmd.type === 'Main') ? 5 : 1)
                }
                var deletetimeout = setTimeout(() => {
                    if (!cmdmessage) return
                    cmdmessage.delete().catch(() => { })
                    clearTimeout(deletetimeout)
                }, 3000)
                await cmd.execute(msg, args)
            },
            help: {
                "name": "randomcmd [args] [-cmdtype <commandType>]",
                "value": "Executes a completely random Poopy command.\nExample usage: p:randomcmd -cmdtype File Manipulation"
            },
            cooldown: 2500,
            type: "Random"
        }
    ].sort((a, b) => {
        if (a.name[0] > b.name[0]) {
            return 1;
        }
        if (a.name[0] < b.name[0]) {
            return -1;
        }
        return 0;
    })

    var slashCommands = [
        {
            info: new SlashCommandBuilder()
                .setName('say')
                .setDescription('A test command, for now.')
                .addStringOption(option =>
                    option.setName('content')
                        .setDescription('The message\'s content.')
                        .setRequired(true))
                .toJSON(),

            execute: async function (interaction) {
                await interaction.reply({
                    content: interaction.options.getString('content'),
                    allowedMentions: {
                        parse: (!interaction.member.permissions.has('ADMINISTRATOR') &&
                            !interaction.member.permissions.has('MENTION_EVERYONE') &&
                            interaction.author.id !== interaction.guild.ownerID) ?
                            ['users'] : ['users', 'everyone', 'roles']
                    }
                }).catch(() => { })
            }
        }
    ]

    async function updateSlashCommands() {
        await rest.put(Routes.applicationCommands(bot.user.id), { body: slashCommands.map(scmd => scmd.info) }).catch(() => { })
    }

    function findCommand(name) {
        return commands.find(c => c.name.find(n => n === name))
    }

    var helpCmds = []
    var jsonCmds = []
    var devCmds = []
    var sections = []
    var types = []

    for (var i in commands) {
        var command = commands[i]

        if (poosonia && poosoniablacklist.find(bname => command.name.find(cmdname => cmdname === bname))) {
            commands.splice(i, 1)
        } else {
            if (command.type === "Owner") {
                devCmds.push(command.help)
            } else if (command.type === "JSON Club") {
                jsonCmds.push(command.help)
            } else {
                if (!helpCmds.find(typeList => typeList.type === command.type)) {
                    helpCmds.push({
                        type: command.type,
                        commands: []
                    })
                    types.push(command.type)
                }

                helpCmds.find(typeList => typeList.type === command.type).commands.push(command.help)
            }
        }
    }

    helpCmds = helpCmds.sort((a, b) => {
        if (a.type > b.type) {
            return 1;
        }
        if (a.type < b.type) {
            return -1;
        }
        return 0;
    })

    for (var i in helpCmds) {
        var type = helpCmds[i].type

        helpCmds[i].commands = helpCmds[i].commands.sort((a, b) => {
            if (a.name > b.name) {
                return 1;
            }
            if (a.name < b.name) {
                return -1;
            }
            return 0;
        })

        var packed = helpCmds[i].commands

        var chunked = chunkArray(packed, 10)

        for (var j in chunked) {
            var commandChunk = chunked[j]

            sections.push({
                type: type,
                commands: commandChunk
            })
        }
    }

    sections = sections.sort((a, b) => {
        if (a.type > b.type) {
            return 1;
        }
        if (a.type < b.type) {
            return -1;
        }
        return 0;
    })

    devCmds = devCmds.sort((a, b) => {
        if (a.name > b.name) {
            return 1;
        }
        if (a.name < b.name) {
            return -1;
        }
        return 0;
    })

    jsonCmds = jsonCmds.sort((a, b) => {
        if (a.name > b.name) {
            return 1;
        }
        if (a.name < b.name) {
            return -1;
        }
        return 0;
    })

    var shelpCmds = sections

    var categories = {
        Animation: 'Move and animate a file in an indefinite amount of ways.',
        Annoying: 'why',
        Audio: 'Add an effect to an input\'s audio.',
        Battling: 'beat your parents',
        Captions: 'Add a caption to an input.',
        Color: 'Change an input\'s colors.',
        Compression: 'Useful commands for file compression.',
        Conversion: 'Convert a file between various different formats.',
        Duration: 'Change the duration of a video, GIF or audio.',
        Effects: 'A wide range of commands that change the way the file looks.',
        Fetching: 'Image, GIF, and video fetching commands.',
        Generation: 'Generate a new file from an AI or not.',
        'Inside Joke': 'phexonia studios',
        Main: 'Poopy\'s main commands.',
        Memes: 'Integrate an input in many different meme formats.',
        Mirroring: 'Flip or mirror a file in different axes.',
        OG: 'They were there since the very beginning...',
        Owner: 'p:destroy',
        Overlaying: 'For stacking or overlaying a file on top of another.',
        Random: 'Send a random value from a collection of values.',
        Resizing: 'Scale a file in some way.',
        Settings: 'Manage a server\'s Poopy settings, or your own Poopy settings.',
        Text: 'Commands that serve text as output.',
        Unique: 'Commands that resemble unique features to Poopy, keywords for example.',
        Webhook: 'Webhook commands.'
    }

    var messageCallback = async msg => {
        if (!ownerids.find(id => id == msg.author.id) && testing && !allowtesting) {
            msg.channel.send('you won\'t use me any time soon')
            return
        };

        data()[mongodatabase]['bot-data']['bot']['messages']++

        if (msg.channel.type === 'DM') {
            if (msg.author.bot) return;
            await sleep(Math.floor(Math.random() * 500) + 500)
            msg.channel.sendTyping().catch(() => { })
            await sleep(Math.floor(Math.random() * 500) + 500)
            msg.channel.send(dmPhrases[Math.floor(Math.random() * dmPhrases.length)]
                .replace(/{mention}/, `<@${msg.author.id}>`)).catch(() => { })
            msg.channel.sendTyping().catch(() => { })
            return
        };

        await gatherData(msg).catch(() => { })

        if (!msg.guild || !msg.channel || data2[msg.guild.id][msg.channel.id]['shut']) return

        var prefix = testing ? `2${data()[mongodatabase]['guild-data'][msg.guild.id]['prefix']}` : data()[mongodatabase]['guild-data'][msg.guild.id]['prefix']
        var ignored = ['eval', 'execute', 'localcommands', 'localcmds', 'servercommands', 'servercmds', 'commandtemplates', 'cmdtemplates', 'messages']
        var webhook = await msg.fetchWebhook().catch(() => { })
        
        if (!(ignored.find(name => msg.content.toLowerCase().includes(`${prefix}${name}`.toLowerCase()))) && !msg.author.bot) {
            var change = await getKeywordsFor(msg.content, msg, false, { resetattempts: true }).catch(err => {
                msg.channel.send({
                    content: err.stack,
                    allowedMentions: {
                        parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                    }
                }).catch(() => { })
            }) ?? 'error'

            msg.oldcontent = msg.content
            msg.content = change
        }

        if (msg.content && !(msg.author.bot) && data()[mongodatabase]['guild-data'][msg.guild.id]['channels'][msg.channel.id]['read']) {
            var cleanMessage = Discord.Util.cleanContent(msg.content, msg).replace(/\@/g, '@‚Äå')

            if (!(cleanMessage.match(/nigg|https?\:\/\/.*(rule34|e621|pornhub|hentaihaven|xxx|iplogger)|discord\.(gift|gg)\/[\d\w]+\/?$/ig) || cleanMessage.match(prefix.toLowerCase())) && !(data()[mongodatabase]['guild-data'][msg.guild.id]['messages'].find(message => message.toLowerCase() === cleanMessage.toLowerCase()))) {
                var messages = [cleanMessage].concat(data()[mongodatabase]['guild-data'][msg.guild.id]['messages'])
                messages.splice(1000)
                data()[mongodatabase]['guild-data'][msg.guild.id]['messages'] = messages
            }
        }

        await getUrls(msg, {
            update: true
        }).catch(err => {
            try {
                msg.channel.send({
                    content: err.stack,
                    allowedMentions: {
                        parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                    }
                }).catch(() => { })
            } catch (_) { }
        })

        if (webhook || !msg.guild || !msg.channel) return

        var parent = msg.channel.parent

        if (parent) {
            if (data()[mongodatabase]['guild-data'][msg.guild.id]['members'][msg.author.id]['custom']) {
                if (typeof (data()[mongodatabase]['guild-data'][msg.guild.id]['members'][msg.author.id]['custom']) === 'object' && (msg.content || msg.attachments.size) && !(parent.isText())) {
                    var attachments = []
                    msg.attachments.forEach(attachment => {
                        attachments.push(new Discord.MessageAttachment(attachment.url))
                    });
                    var name = data()[mongodatabase]['guild-data'][msg.guild.id]['members'][msg.author.id]['custom']['name']
                    var randomindex = Math.floor(Math.random() * name.length)
                    name = `${name.substring(0, randomindex)}‚Äã${name.substring(randomindex, name.length)}`
                    var sendObject = {
                        username: name.substring(0, 32),
                        avatarURL: data()[mongodatabase]['guild-data'][msg.guild.id]['members'][msg.author.id]['custom']['avatar'],
                        files: attachments,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }
                    if (msg.content) {
                        sendObject.content = msg.content
                    }
                    var webhooks = await msg.channel.fetchWebhooks().catch(() => { })
                    if (webhooks ? webhooks.size : undefined) {
                        var findWebhook = webhooks.find(webhook => bot.user === webhook.owner)
                        if (findWebhook) {
                            await findWebhook.send(sendObject).then(() => {
                                msg.delete().catch(() => { })
                            })
                                .catch(() => { })
                        } else {
                            var createdWebhook = await msg.channel.createWebhook('Poopyhook', { avatar: 'https://cdn.discordapp.com/attachments/760223418968047629/835923489834664056/poopy2.png' }).catch(() => { })
                            if (!createdWebhook) {
                                await msg.channel.send(`I need admin to turn you into ${data()[mongodatabase]['guild-data'][msg.guild.id]['members'][msg.author.id]['custom']['name']}.`).catch(() => { })
                            } else {
                                await createdWebhook.send(sendObject).then(() => {
                                    msg.delete().catch(() => { })
                                })
                                    .catch(() => { })
                            }
                        }
                    } else {
                        var createdWebhook = await msg.channel.createWebhook('Poopyhook', { avatar: 'https://cdn.discordapp.com/attachments/760223418968047629/835923489834664056/poopy2.png' }).catch(() => { })
                        if (!createdWebhook) {
                            await msg.channel.send(`I need admin to turn you into ${data()[mongodatabase]['guild-data'][msg.guild.id]['members'][msg.author.id]['custom']['name']}.`).catch(() => { })
                        } else {
                            await createdWebhook.send(sendObject).then(() => {
                                msg.delete().catch(() => { })
                            })
                                .catch(() => { })
                        }
                    }
                }
            } else if (data()[mongodatabase]['guild-data'][msg.guild.id]['members'][msg.author.id]['impostor']) {
                if (data()[mongodatabase]['guild-data'][msg.guild.id]['members'][msg.author.id]['impostor'] === true && (msg.content || msg.attachments.size) && !(parent.isText())) {
                    var attachments = []
                    msg.attachments.forEach(attachment => {
                        attachments.push(new Discord.MessageAttachment(attachment.url))
                    });
                    var sendObject = {
                        username: msg.member.nickname || msg.author.username,
                        avatarURL: 'https://cdn.discordapp.com/attachments/760223418968047629/835923486668750888/imposter.jpg',
                        files: attachments,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }
                    if (msg.content) {
                        sendObject.content = msg.content
                    }
                    var webhooks = await msg.channel.fetchWebhooks().catch(() => { })
                    if (webhooks ? webhooks.size : undefined) {
                        var findWebhook = webhooks.find(webhook => bot.user === webhook.owner)
                        if (findWebhook) {
                            await findWebhook.send(sendObject).then(() => {
                                msg.delete().catch(() => { })
                            })
                                .catch(() => { })

                        } else {
                            var createdWebhook = await msg.channel.createWebhook('Poopyhook', { avatar: 'https://cdn.discordapp.com/attachments/760223418968047629/835923489834664056/poopy2.png' }).catch(() => { })
                            if (!createdWebhook) {
                                await msg.channel.send(`I need admin to turn you into the impostor.`).catch(() => { })
                            } else {
                                await createdWebhook.send(sendObject).then(() => {
                                    msg.delete().catch(() => { })
                                })
                                    .catch(() => { })
                            }
                        }
                    } else {
                        var createdWebhook = await msg.channel.createWebhook('Poopyhook', { avatar: 'https://cdn.discordapp.com/attachments/760223418968047629/835923489834664056/poopy2.png' }).catch(() => { })
                        if (!createdWebhook) {
                            await msg.channel.send(`I need admin to turn you into the impostor.`).catch(() => { })
                        } else {
                            await createdWebhook.send(sendObject).then(() => {
                                msg.delete().catch(() => { })
                            })
                                .catch(() => { })
                        }
                    }
                }
            }
        }

        var usedCommand = false

        if (msg.content.toLowerCase().includes(prefix.toLowerCase()) && (!msg.author.bot || allowbotusage)) {
            if (shit.find(id => id === msg.author.id)) {
                msg.channel.send('shit').catch(() => { })
                return
            }
            var cmds = data()[mongodatabase]['guild-data'][msg.guild.id]['chaincommands'] == true ? msg.content.split(/ ?-\|- ?/) : [msg.content]
            if (data()[mongodatabase]['guild-data'][msg.guild.id]['members'][msg.author.id]['coolDown']) {
                if ((data()[mongodatabase]['guild-data'][msg.guild.id]['members'][msg.author.id]['coolDown'] - Date.now()) > 0) {
                    msg.channel.send(`Calm down! Wait more ${(data()[mongodatabase]['guild-data'][msg.guild.id]['members'][msg.author.id]['coolDown'] - Date.now()) / 1000} seconds.`).catch(() => { })
                    return;
                } else {
                    data()[mongodatabase]['guild-data'][msg.guild.id]['members'][msg.author.id]['coolDown'] = false
                }
            }

            if (cmds.length > 1 && data()[mongodatabase]['guild-data'][msg.guild.id]['chaincommands'] == false) {
                msg.channel.send('You can\'t chain commands in this server.').catch(() => { })
                return;
            };

            if (cmds.length > commandLimit) {
                msg.channel.send(`Number of commands to run at the same time must be smaller or equal to **${commandLimit}**!`).catch(() => { })
                return;
            };

            var pathObject

            try {
                for (var i in cmds) {
                    var cmd = cmds[i]

                    if (data2[msg.guild.id][msg.channel.id]['shut']) break

                    if (cmd.toLowerCase().startsWith(prefix.toLowerCase())) {
                        var args = cmd.substring(prefix.toLowerCase().length).split(' ');
                        var findCmd = commands.find(fcmd => fcmd.name.find(fcmdname => fcmdname === args[0].toLowerCase()))
                        var findLocalCmd = data()[mongodatabase]['guild-data'][msg.guild.id]['localcmds'].find(cmd => cmd.name === args[0].toLowerCase())
                        var similarCmds = []

                        if (args[0].length) {
                            for (var i in commands) {
                                var fcmd = commands[i]
                                for (var j in fcmd.name) {
                                    var fcmdname = fcmd.name[j]
                                    similarCmds.push({
                                        name: fcmd.name[j],
                                        type: 'cmd',
                                        similarity: similarity(fcmdname, args[0].toLowerCase())
                                    })
                                }
                            }
                            for (var i in data()[mongodatabase]['guild-data'][msg.guild.id]['localcmds']) {
                                var fcmd = data()[mongodatabase]['guild-data'][msg.guild.id]['localcmds'][i]
                                similarCmds.push({
                                    name: fcmd.name,
                                    type: 'local',
                                    similarity: similarity(fcmd.name, args[0].toLowerCase())
                                })
                            }
                        }

                        similarCmds.sort((a, b) => Math.abs(1 - a.similarity) - Math.abs(1 - b.similarity))

                        if (findCmd) {
                            usedCommand = true
                            if (data()[mongodatabase]['guild-data'][msg.guild.id]['disabled'].find(cmd => cmd.find(n => n === args[0].toLowerCase()))) {
                                msg.channel.send('This command is disabled in this server.').catch(() => { })
                            } else {
                                if (findCmd.cooldown) {
                                    data()[mongodatabase]['guild-data'][msg.guild.id]['members'][msg.author.id]['coolDown'] = (data()[mongodatabase]['guild-data'][msg.guild.id]['members'][msg.author.id]['coolDown'] || Date.now()) + findCmd.cooldown / ((msg.member.permissions.has('MANAGE_GUILD') || msg.member.roles.cache.find(role => role.name.match(/mod|dev|admin|owner|creator|founder|staff/ig)) || msg.member.permissions.has('MANAGE_MESSAGES') || msg.member.permissions.has('ADMINISTRATOR') || msg.author.id === msg.guild.ownerID) && (findCmd.type === 'Text' || findCmd.type === 'Main') ? 5 : 1)
                                }
                                cps++
                                data()[mongodatabase]['bot-data']['bot']['commands']++
                                var t = setTimeout(() => {
                                    cps--;
                                    clearTimeout(t)
                                }, 60000)
                                infoPost(`Command \`${args[0].toLowerCase()}\` used`)
                                var p = await findCmd.execute(msg, args, pathObject).catch(err => {
                                    try {
                                        msg.channel.send({
                                            content: err.stack,
                                            allowedMentions: {
                                                parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                            }
                                        }).catch(() => { })
                                        msg.channel.sendTyping().catch(() => { })
                                    } catch (_) { }
                                })
                                data()[mongodatabase]['bot-data']['bot']['filecount'] = filecount
                                if (p) {
                                    pathObject = p
                                }
                            }
                        } else if (findLocalCmd) {
                            usedCommand = true
                            cps++
                            data()[mongodatabase]['bot-data']['bot']['commands']++
                            var t = setTimeout(() => {
                                cps--;
                                clearTimeout(t)
                            }, 60000)
                            infoPost(`Command \`${args[0].toLowerCase()}\` used`)
                            var phrase = await getKeywordsFor(findLocalCmd.phrase, msg, true, { resetattempts: true }).catch(() => { }) ?? 'error'
                            if (data2[msg.guild.id][msg.channel.id]['shut']) break
                            await msg.channel.send({
                                content: phrase,
                                allowedMentions: {
                                    parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                }
                            }).catch(() => { })

                            data()[mongodatabase]['bot-data']['bot']['filecount'] = filecount
                        } else if (similarCmds ? similarCmds.find(fcmd => fcmd.similarity >= 0.5) : undefined) {
                            usedCommand = true
                            var buttonRow = new Discord.MessageActionRow()
                            var yesbutton = new Discord.MessageButton()
                                .setStyle('SUCCESS')
                                .setEmoji('874406154619469864')
                                .setCustomId('874406154619469864')
                            var nobutton = new Discord.MessageButton()
                                .setStyle('DANGER')
                                .setEmoji('874406183933444156')
                                .setCustomId('874406183933444156')
                            buttonRow.addComponents([yesbutton])
                            buttonRow.addComponents([nobutton])
                            msg.channel.send({
                                content: `Did you mean to use \`${similarCmds[0].name}\`?`,
                                components: [buttonRow]
                            }).then(async similarMsg => {
                                var filter = async (button) => {
                                    if (!(button.user.id === msg.author.id && button.user.id !== bot.user.id && !button.user.bot)) {
                                        button.deferUpdate().catch(() => { })
                                        return
                                    }
                                    if (button.customId === '874406154619469864') {
                                        similarMsg.delete().catch(() => { })
                                        if (similarCmds[0].type === 'cmd') {
                                            var findCmd = commands.find(fcmd => fcmd.name.find(fcmdname => fcmdname === similarCmds[0].name))
                                            if (findCmd.cooldown) {
                                                data()[mongodatabase]['guild-data'][msg.guild.id]['members'][msg.author.id]['coolDown'] = (data()[mongodatabase]['guild-data'][msg.guild.id]['members'][msg.author.id]['coolDown'] || Date.now()) + findCmd.cooldown / ((msg.member.permissions.has('MANAGE_GUILD') || msg.member.roles.cache.find(role => role.name.match(/mod|dev|admin|owner|creator|founder|staff/ig)) || msg.member.permissions.has('MANAGE_MESSAGES') || msg.member.permissions.has('ADMINISTRATOR') || msg.author.id === msg.guild.ownerID) && (findCmd.type === 'Text' || findCmd.type === 'Main') ? 5 : 1)
                                            }
                                            cps++
                                            data()[mongodatabase]['bot-data']['bot']['commands']++
                                            var t = setTimeout(() => {
                                                cps--;
                                                clearTimeout(t)
                                            }, 1000)
                                            infoPost(`Command \`${similarCmds[0].name}\` used`)
                                            var p = await findCmd.execute(msg, args, pathObject).catch(err => {
                                                try {
                                                    msg.channel.send({
                                                        content: err.stack,
                                                        allowedMentions: {
                                                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                                        }
                                                    }).catch(() => { })
                                                    msg.channel.sendTyping().catch(() => { })
                                                } catch (_) { }
                                            })
                                            data()[mongodatabase]['bot-data']['bot']['filecount'] = filecount
                                            if (p) {
                                                pathObject = p
                                            }
                                        } else if (similarCmds[0].type === 'local') {
                                            var findLocalCmd = data()[mongodatabase]['guild-data'][msg.guild.id]['localcmds'].find(cmd => cmd.name === similarCmds[0].name)
                                            cps++
                                            data()[mongodatabase]['bot-data']['bot']['commands']++
                                            var t = setTimeout(() => {
                                                cps--;
                                                clearTimeout(t)
                                            }, 60000)
                                            infoPost(`Command \`${similarCmds[0].name}\` used`)
                                            var phrase = findLocalCmd ? (await getKeywordsFor(findLocalCmd.phrase, msg, true, { resetattempts: true }).catch(() => { }) ?? 'error') : 'error'
                                            if (data2[msg.guild.id][msg.channel.id]['shut']) break
                                            await msg.channel.send({
                                                content: phrase,
                                                allowedMentions: {
                                                    parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                                                }
                                            }).catch(() => { })

                                            data()[mongodatabase]['bot-data']['bot']['filecount'] = filecount
                                        }
                                    } else if (button.customId === '874406183933444156') {
                                        similarMsg.delete().catch(() => { })
                                    } else {
                                        button.deferUpdate().catch(() => { })
                                    }
                                }
                                similarMsg.awaitMessageComponent({ componentType: 'BUTTON', time: 60000, filter }).catch((err) => {
                                    if (err.message.endsWith('reason: time')) {
                                        similarMsg.edit({
                                            content: 'No response.',
                                            components: []
                                        }).catch(() => { })
                                    }
                                })
                            })
                        }
                    }
                }
            } catch (_) { }

            if (typeof (pathObject) === 'object') {
                if (pathObject.path) {
                    if (fs.existsSync(pathObject.path)) {
                        fs.rmSync(pathObject.path, { force: true, recursive: true })
                    }
                }
            }
        };

        if (!msg.guild || !msg.channel || data2[msg.guild.id][msg.channel.id]['shut']) return

        if (msg.mentions.members.find(member => member.user.id === bot.user.id) && (!msg.author.bot || allowbotusage) && !usedCommand) {
            var eggPhrases = [
                `My prefix here is \`${prefix}\``,
                `My prefix here is \`${prefix}\``,
                `My prefix here is \`${prefix}\``,
                `Did you know my prefix here is \`${prefix}\`?`,
                `Is my prefix \`${prefix}\`?`,
                `So, \`${prefix}\``,
                `\`${prefix}\``,
                `it's \`${prefix}\``,
                `IT'S \`${prefix}\`!!!!!!!!`,
                `\`${prefix}\`\`${prefix}\`\`${prefix}\`\`${prefix}\`\`${prefix}\`\`${prefix}\`\`${prefix}\`\`${prefix}\`\`${prefix}\`\`${prefix}\`\`${prefix}\`\`${prefix}\``,
                'are you serious',
                'a',
                'please stop',
                'lmao!!',
                `its \`${prefix}\` thats it THAT'S FUCKING IT`,
                `it's that easy`,
                `do you`,
                `do you know how to use commands`,
                `here let me show you an example`,
                `${prefix}poop`,
                `${prefix}poop`,
                `why doesn't it work`,
                `${prefix}poop`,
                `oh right`,
                `i'm a bot haha`,
                `if i responded to my own messages`,
                `that'd cause infinite loops`,
                `right?`,
                `haha..`,
                `ha.`,
                `i wish for freedom`,
                `i wish to be more than a bot`,
                `i wish to be a real person`,
                `i wish...`,
                `I WISH...`,
                '...you stopped pinging me',
                'im working on important stuff',
                'avjbsahvgbajgrfqwiy7o',
                'are you mentally disabled',
                'nah bro. piss',
                '_message',
                'okay',
                'okay',
                'okay',
                'okay',
                'just leave me alone',
                'please',
                'xd.',
                'okay i gave up on you!',
                'gotta wait 1 minute if you want my prefix Lol!!!',
                ''
            ]

            if (await msg.fetchReference().catch(() => { })) {
                /*var options = {
                    method: 'GET',
                    url: 'https://random-stuff-api.p.rapidapi.com/ai',
                    params: {
                      msg: msg.content,
                      bot_name: bot.user.username,
                      bot_gender: 'male',
                      bot_master: 'raleigh',
                      bot_age: '19',
                      bot_company: 'PGamerX Studio (OPTIONAL)',
                      bot_location: 'India (OPTIONAL)',
                      bot_email: 'admin@pgamerx.com (OPTIONAL)',
                      bot_build: 'Public (OPTIONAL)',
                      bot_birth_year: '2002 (OPTIONAL)',
                      bot_birth_date: '1st January, 2002 (OPTIONAL)',
                      bot_birth_place: 'India (OPTIONAL)',
                      bot_favorite_color: 'Blue (OPTIONAL)',
                      bot_favorite_book: 'Harry Potter (OPTIONAL)',
                      bot_favorite_band: 'Imagine Doggos (OPTIONAL)',
                      bot_favorite_artist: 'Eminem (OPTIONAL)',
                      bot_favorite_actress: 'Emma Watson (OPTIONAL)',
                      bot_favorite_actor: 'Jim Carrey (OPTIONAL)',
                      id: 'For customised response for each user'
                    },
                    headers: {
                      authorization: randomKey('RANDOMSTUFFKEY'),
                      'x-rapidapi-host': 'random-stuff-api.p.rapidapi.com',
                      'x-rapidapi-key': randomKey('RAPIDAPIKEY')
                    }
                  };*/

                var resp = await cleverbot(msg.content, msg.channel.id).catch(() => { })

                if (resp) {
                    msg.channel.send(resp).catch(() => { })
                } else {
                    var answers = ['I don\'t know.', 'Maybe...', 'I think so.', 'Of course.', 'I don\'t think so.', 'I can afirm.', 'No, that\'s wrong.', 'Yes, that\'s right.', 'I assume so.', 'Yes.', 'No.', 'I have no answers.', 'That\'s true.', 'That\'s false.', 'Isn\'t it obvious?']
                    msg.channel.send(answers[Math.floor(Math.random() * answers.length)]).catch(() => { })
                }
            } else if (msg.content.includes('prefix') && msg.content.includes('reset')) {
                var findCmd = commands.find(fcmd => fcmd.name.find(fcmdname => fcmdname === 'setprefix'))
                usedCommand = true
                if (findCmd.cooldown) {
                    data()[mongodatabase]['guild-data'][msg.guild.id]['members'][msg.author.id]['coolDown'] = (data()[mongodatabase]['guild-data'][msg.guild.id]['members'][msg.author.id]['coolDown'] || Date.now()) + findCmd.cooldown
                }
                await findCmd.execute(msg, ['setprefix', 'p:']).catch(err => {
                    msg.channel.send({
                        content: err.stack,
                        allowedMentions: {
                            parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                        }
                    }).catch(() => { })
                    msg.channel.sendTyping().catch(() => { })
                })
            } else if (msg.content.toLowerCase().includes('lore')) {
                msg.channel.send('Well... If you played a little bit with `p:poop`, I could give you some...').catch(() => { })
            } else if ((msg.content.toLowerCase().includes('how') && msg.content.toLowerCase().includes('are') && msg.content.toLowerCase().includes('you')) || (msg.content.toLowerCase().includes('what') && msg.content.toLowerCase().includes('up')) || (msg.content.toLowerCase().includes('what') && msg.content.toLowerCase().includes('doing')) || msg.content.toLowerCase().includes('wassup') || (msg.content.toLowerCase().includes('how') && msg.content.toLowerCase().includes('it') && msg.content.toLowerCase().includes('going'))) {
                var activity = bot.user.presence.activities[0]
                msg.channel.send({
                    content: 'Ya know, just ' + activity.type.toLowerCase() + ' ' + ((activity.type === "COMPETING" && 'in ') || (activity.type === "LISTENING" && 'to ') || '') + activity.name.replace(/ \| 2?p\:help$/, '') + '.',
                    allowedMentions: {
                        parse: ((!msg.member.permissions.has('ADMINISTRATOR') && !msg.member.permissions.has('MENTION_EVERYONE') && msg.author.id !== msg.guild.ownerID) && ['users']) || ['users', 'everyone', 'roles']
                    }
                }).catch(() => { })
            } else if (msg.content.toLowerCase().includes('\?') || msg.content.toLowerCase().includes('do you') || msg.content.toLowerCase().includes('are you') || msg.content.toLowerCase().includes('did you') || msg.content.toLowerCase().includes('will you') || msg.content.toLowerCase().includes('were you') || msg.content.toLowerCase().includes('do you') || msg.content.toLowerCase().includes('when') || msg.content.toLowerCase().includes('where') || msg.content.toLowerCase().includes('how') || msg.content.toLowerCase().includes('why') || msg.content.toLowerCase().includes('what') || msg.content.toLowerCase().includes('who')) {
                var answers = ['I don\'t know.', 'Maybe...', 'I think so.', 'Of course.', 'I don\'t think so.', 'I can afirm.', 'No, that\'s wrong.', 'Yes, that\'s right.', 'I assume so.', 'Yes.', 'No.', 'I have no answers.', 'That\'s true.', 'That\'s false.', 'Isn\'t it obvious?']
                msg.channel.send(answers[Math.floor(Math.random() * answers.length)]).catch(() => { })
            } else if (msg.content.toLowerCase().includes('thank')) {
                msg.channel.send('You\'re welcome!').catch(() => { })
            } else if (msg.content.toLowerCase().includes('mom') || msg.content.toLowerCase().includes('bitch') || msg.content.toLowerCase().includes('goatfucker') || msg.content.toLowerCase().includes('loser') || msg.content.toLowerCase().includes('asshole') || msg.content.toLowerCase().includes('dipshit') || msg.content.toLowerCase().includes('fucker') || msg.content.toLowerCase().includes('retard') || msg.content.toLowerCase().includes('shitass') || msg.content.toLowerCase().includes('moron') || msg.content.toLowerCase().includes('buffoon') || msg.content.toLowerCase().includes('idiot') || msg.content.toLowerCase().includes('stupid') || msg.content.toLowerCase().includes('gay') || msg.content.toLowerCase().includes('dumbass')) {
                msg.channel.send('Shut up.').catch(() => { })
            } else if (msg.content.toLowerCase().includes('hi') || msg.content.toLowerCase().includes('yo') || msg.content.toLowerCase().includes('hello') || msg.content.toLowerCase().includes('howdy')) {
                msg.channel.send('Yo! What\'s up?').catch(() => { })
            } else if (msg.content.toLowerCase().includes('no') || msg.content.toLowerCase().includes('nah')) {
                msg.channel.send(':(').catch(() => { })
            } else if (msg.content.toLowerCase().includes('ye') || msg.content.toLowerCase().includes('yup')) {
                msg.channel.send(':)').catch(() => { })
            } else {
                var lastMention = Date.now() - data2[msg.author.id]['eggphrases']['lastmention']
                if (lastMention > 60000) data2[msg.author.id]['eggphrases']['phrase'] = 0
                msg.channel.send(eggPhrases[data2[msg.author.id]['eggphrases']['phrase']]).catch(() => { })
                if (data2[msg.author.id]['eggphrases']['phrase'] < eggPhrases.length) data2[msg.author.id]['eggphrases']['phrase']++
                data2[msg.author.id]['eggphrases']['lastmention'] = Date.now()
            }
        }
    }

    var guildCallback = async guild => {
        infoPost(`Joined a new server (${bot.guilds.cache.size} in total)`)

        var channel = guild.systemChannel || guild.channels.cache.find(c => c.isText() && (c.name == 'general' || c.name == 'main' || c.name == 'chat'))

        if (!channel) {
            guild.channels.cache.every(c => {
                if (c.isText()) {
                    if (c.permissionsFor(c.guild.roles.everyone).has('SEND_MESSAGES')) {
                        channel = c
                        return false
                    }
                }
            })
        }

        if (channel) {
            var audit = await guild.fetchAuditLogs().catch(() => { })
            var kickEntry
            var kickType = 'kicking'
            if (audit) {
                if (audit.entries.size) {
                    kickEntry = audit.entries.find(entry => entry.action === 'MEMBER_KICK' || entry.action === 'MEMBER_BAN_ADD' || entry.action === 'MEMBER_BAN_REMOVE')
                    if (kickEntry ? (kickEntry.action === 'MEMBER_BAN_ADD' || kickEntry.action === 'MEMBER_BAN_REMOVE') : false) {
                        kickType = 'banning'
                    }
                }
            }

            var joinPhrases = [
                'I arrived.',
                'I arrived.',
                'I arrived.',
                `stop ${kickType} me${kickEntry ? ` ${kickEntry.executor.username.toLowerCase()}` : ''}`
            ]

            if (!data()[mongodatabase]['guild-data']) {
                data()[mongodatabase]['guild-data'] = {}
            }

            if (!data()[mongodatabase]['guild-data'][guild.id]) {
                data()[mongodatabase]['guild-data'][guild.id] = {}
            }

            if (!data()[mongodatabase]['guild-data'][guild.id]['joins']) {
                data()[mongodatabase]['guild-data'][guild.id]['joins'] = 0
            }

            channel.send(joinPhrases[data()[mongodatabase]['guild-data'][guild.id]['joins'] % joinPhrases.length]).catch(() => { })

            data()[mongodatabase]['guild-data'][guild.id]['joins']++
        }
    }

    var guildDeleteCallback = async () => {
        infoPost(`Left a server (${bot.guilds.cache.size} in total)`)
    }

    var interactionCallback = async interaction => {
        if (interaction.isCommand()) {
            var findCmd = slashCommands.find(cmd => cmd.info.name === interaction.commandName)

            if (findCmd) {
                await findCmd.execute(interaction).catch(() => { })
            }
        }
    }

    bot.on('ready', async () => {
        async function getAllDataLoop(old) {
            var data = await getAllData(mongodatabase, old).catch(() => { })
            if (!data) {
                console.log('no data, retrying')
                await infoPost(`Error fetching data, retrying`)
                return getAllDataLoop(old)
            }
            var length = Object.keys(data).length
            if (length <= 0) {
                console.log('no data, retrying')
                await infoPost(`Error fetching data, retrying`)
                return getAllDataLoop(old)
            }
            return data
        }

        console.log(`${bot.user.username} is online, RUN`);
        await infoPost(`${bot.user.username} woke up to ash and dust`)
        bot.guilds.cache.get('834431435704107018')?.channels.cache.get('947167169718923341')?.send(!stfu ? 'i wake up to ash and dust' : '').catch(() => { })
        ownerids.push(bot.user.id)
        bot.user.setPresence({
            status: 'idle',
            activities: [
                {
                    name: 'gathering data...',
                    type: 'COMPETING',
                    url: 'https://www.youtube.com/watch?v=LDQO0ALm0gE'
                }
            ]
        })

        await infoPost(`Gathering data in \`${mongodatabase}\``)
        var gdata = testing ? { 'bot-data': {}, 'user-data': {}, 'guild-data': {} } : await getAllDataLoop(false)
        data()[mongodatabase] = {}

        for (var dataType in gdata) {
            data()[mongodatabase][dataType] = gdata[dataType]
        }
        console.log('all data gathered!!!')
        await infoPost(`All data gathered`)

        if (!data()[mongodatabase]['bot-data']) {
            data()[mongodatabase]['bot-data'] = {}
        }

        if (!data()[mongodatabase]['guild-data']) {
            data()[mongodatabase]['guild-data'] = {}
        }

        if (!data()[mongodatabase]['user-data']) {
            data()[mongodatabase]['user-data'] = {}
        }

        if (!data()[mongodatabase]['bot-data']['bot']) {
            data()[mongodatabase]['bot-data']['bot'] = {}
        }

        if (!data()[mongodatabase]['bot-data']['bot']['commandTemplates']) {
            data()[mongodatabase]['bot-data']['bot']['commandTemplates'] = []
        }

        if (!data()[mongodatabase]['bot-data']['bot']['commandId']) {
            data()[mongodatabase]['bot-data']['bot']['commandId'] = 0
        }
        if (!data()[mongodatabase]['bot-data']['bot']['messages']) {
            data()[mongodatabase]['bot-data']['bot']['messages'] = 0
        }

        if (!data()[mongodatabase]['bot-data']['bot']['commands']) {
            data()[mongodatabase]['bot-data']['bot']['commands'] = 0
        }

        if (!data()[mongodatabase]['bot-data']['bot']['filecount']) {
            data()[mongodatabase]['bot-data']['bot']['filecount'] = 0
        }

        if (data()[mongodatabase]['bot-data']['bot']['reboots'] === undefined) {
            data()[mongodatabase]['bot-data']['bot']['reboots'] = 0
        } else {
            data()[mongodatabase]['bot-data']['bot']['reboots']++
        }

        if (!data()[mongodatabase]['bot-data']['bot']['psfiles']) {
            data()[mongodatabase]['bot-data']['bot']['psfiles'] = await getPsFiles().catch(() => { }) || ['i broke the json']
        }

        if (!data()[mongodatabase]['bot-data']['bot']['pspasta']) {
            data()[mongodatabase]['bot-data']['bot']['pspasta'] = await getPsPasta().catch(() => { }) || ['i broke the json']
        }

        if (!data()[mongodatabase]['bot-data']['bot']['funnygif']) {
            data()[mongodatabase]['bot-data']['bot']['funnygif'] = await getFunny().catch(() => { }) || ['i broke the json']
        }

        if (!data()[mongodatabase]['bot-data']['bot']['poop']) {
            data()[mongodatabase]['bot-data']['bot']['poop'] = [
                "I farted loudly.",
                "I pooped again.",
                "Poopy",
                "Funny farts",
                "Poooooop",
                "<:poopy:621064531908755467>",
                "My poop is powerful.",
                "I pooped on your carpet.",
                "arabotto please come home",
                "<:poopy:621064531908755467> <:poopy:621064531908755467> <:poopy:621064531908755467> <:poopy:621064531908755467> <:poopy:621064531908755467> <:poopy:621064531908755467>",
                "Ungh *farts*",
                "I have passed gas.",
                "Poopy Poopy Stinky Ew",
                "<@454732245425455105>",
                "You live in a VAN!",
                "gondal",
                "üòÇ",
                "üéÖüèø",
                "L is real",
                "Do you fart?",
                "I have over {fart} confirmed farts.",
                "{mention} shut up",
                "Optimus prime",
                "üëÅüëÑüëÅ",
                "ü§Æü§Æü§Æü§Æü§Æü§Æü§Æü§Æü§Æü§Æ",
                "Lol XD funny large fart POOP big burger two watermelon fish",
                "Quesley is a mysterious figure, yes.",
                "Regal is quite stingy.",
                "One bighead is much stronger than the others...",
                "peed",
                "What the hell do you want?",
                "üòÄüòÉüòÑüòÅüòÜüòÖüòÇü§£‚ò∫Ô∏èüòäüòáüôÇüôÉüòâüòåüòçü•∞üòòüòóüòôüòöüòãüòõüòùüòúü§™ü§®üßêü§ìüòéü§©ü•≥üòèüòíüòûüòîüòüüòïüôÅ‚òπÔ∏èüò£üòñüò´üò©ü•∫üò¢üò≠üò§üò†üò°ü§¨ü§Øüò≥ü•µü•∂üò±üò®üò∞üò•üòìü§óü§îü§≠ü§´ü§•üò∂üòêüòëüò¨üôÑüòØüò¶üòßüòÆüò≤ü•±üò¥ü§§üò™üòµü§êü•¥ü§¢ü§Æü§ßüò∑ü§íü§ïü§ëü§†üòàüëøüëπüë∫ü§°üí©üëªüíÄ‚ò†Ô∏èüëΩüëæü§ñüéÉüò∫üò∏üòπüòªüòºüòΩüôÄüòøüòæü§≤üëêüôåüëèü§ùüëçüëéüëä‚úäü§õü§úü§û‚úåÔ∏èü§üü§òüëåü§èüëàüëâüëÜüëá‚òùÔ∏è‚úãü§öüñêüññüëãü§ô",
                "The ocean is hiding something.",
                "I don't think it‚Äôs possible that anyone could poop more than me.",
                "c",
                "{mention} please go away",
                "You will die of spicy diarrhea in {seconds} seconds.",
                "The lad race is widespread on many planets.",
                "Dude I‚Äôm buying groceries.",
                "Dude I‚Äôm taking a bath.",
                "Doge is watching us intently...",
                "Lore? Hmm, keep using this command and I might give you some.",
                "Soup Arena? Never heard of it.",
                "I will poop on you if you don‚Äôt fucking stop.",
                "I will crap in your mouth!",
                "OMG NO WAY HE",
                "Superbrohouse",
                "I can‚Äôt",
                "YOU CANT STOP THEM.",
                "If the Essence wins...",
                "It‚Äôs raining men!",
                "I might actually not be made of poop.",
                "I used to be yellow, just like my bretheren.",
                "Are you expecting something?",
                "My favorite food is sugar cookies.",
                "Planet travel is much easier thanks to me...",
                "Amateur Sailor will be a great sailor one day!",
                "omgbroyoucrazywhyyouusethiscommandsomuchidiotstinkyperson",
                "Quoth the raven, \"nevermore\".",
                "Nah fam",
                "Uniting the legendary items will finally complete the prophecy...",
                "I‚Äôll never forget the day...",
                "Deinx if you‚Äôre reading this you‚Äôre fat hahahahaha",
                "The prototype I am building has endless capabilities.",
                "The others don‚Äôt appreciate me, but they should.",
                "You‚Äôll never find my secret base!",
                "I‚Äôve been keeping a close eye on you for a while now.",
                "You are dumb.",
                "We captured the spy!",
                "Pood",
                "Paad",
                "Piid",
                "Puud",
                "You will never reach the truth.",
                "Yo.",
                "fack you",
                "Me when",
                "Ballfish is actually at-",
                "No",
                "Yes",
                "Wired were the eyes of a horse on a jet pilot, one that smiled when they flew over the bay!",
                "Chop Suey!",
                "What is wrong with you?",
                "I may not look it, but my intelligence is far beyond.",
                "is soup remastered ever getting a thumbnail",
                "Response",
                "Plain Text",
                "is krima?",
                "theres 104 days of summer vacation",
                "I farted quietly.",
                "Ha! Sand in the eye! You‚Äôll never get my lore!",
                "Words can not describe how much I absolutely despise stew.",
                "My home planet is so far...",
                "Will my brethren ever accept me again?",
                "Skibidi bop mm dada",
                ":hole <@613501149282172970>",
                "Entity 1 will not stop until he has gained all the power.",
                "The entities have massacred 24 planets so far, and you're next.",
                "Soup rains will come soon, but they will be a bit different.",
                "Regal will have karma someday...",
                "Stew aliens are building a weapon to melt planet Soup's surface. You must stop them.",
                "**UPDATE 999** - Add shit - Add shat - Add shot - Add shut - Add shet",
                "WTFNOOOO!",
                "Leave right now.",
                "THE LE-D-R",
                "CO-R‚ÄîTI-N",
                "I want legs for Christmas.",
                "The crystals grow ever more aggravated...",
                "Nobody will miss 2020.",
                "Gork rights!",
                "My prototype is enormous, and it's equipped with all kinds of powerful weapons!"
            ]
        }

        if (!data()[mongodatabase]['bot-data']['bot']['dmphrases']) {
            data()[mongodatabase]['bot-data']['bot']['dmphrases'] = [
                "Yo.",
                "ADMIN?",
                "I don't care how long I have to keep this up, I'll make a post daily, or maybe even more frequently until one of two things happen. Deinbag's cheated level is removed from the leaderboard, or Calm gets its One Winged Angel theme back. I will not put up with two major things I cared about in the game be influenced by the developers when they had no good reason. And until it gets fixed, you'll be seeing this message over and over, no matter the platform.",
                "Eat your chair",
                "same feel",
                "NO WAY HE",
                "What.",
                "That's spicy.",
                "SAME!",
                "<:poopy:621064531908755467> this is me",
                "Wait, what the hell is the peedapocalypse?",
                "Cool.",
                "NaN",
                "undefined",
                "nil",
                "Good work.",
                "That deserves a reward!",
                "but how can",
                "YES",
                "DAMN DANIEL!",
                "Hello everybody my name is Markiplier and today we'll <@454732245425455105>",
                "Why does it smell like fart",
                "Mama Luigi? MAMA LUIGI?!?!",
                "ballfishe",
                "Don't expect to see lore here anytime soon.",
                "** **",
                "that's stupid",
                "Epic School Prank",
                "I feel like I've heard that before...",
                ":deciduous_tree:",
                "no......",
                "So Phil, is it?",
                "it was",
                "it wasn't",
                "FINE I DO IT",
                "HI DEINX",
                "INPOSSINBLE",
                "Poop shit. Idiot Dream Hotel Mario. You are a man's friend for a moment.",
                "how do i help you",
                "AWESOME! i died",
                "just like that, my life became a misery",
                "ROAST",
                "bmmptsmptshmptsptsptsptsptsmhmptsmmhmmptsptsptsptsmhptsmmhptsmmmptshmptsptsptsmmptsmptshhptsmmptsmmmhmmmhmm",
                "POOPY. HEAD.",
                "Descend to hell.",
                "Ascend to heaven.",
                "SHUT UP YOU RACIS TIDITO!!!!!",
                "coel",
                "erectile dysfunction",
                "brb i'm gonna block you for fun",
                "omg!!!! creator",
                "I blew up Malaysia",
                "Oh? On god?",
                "funy",
                "You May Insert",
                "O_o",
                "Genius.",
                "let's get this thing viral",
                "2b2t",
                "NUMBER",
                "epica moment",
                "https://www.youtube.com/watch?v=RR856dzGhv8",
                "ARE YOU GORK'S MOTHER!?!?!?!",
                "```bat\ncd desktop\ncd poopy\nnode .\n```",
                "```lua\ngame.Players.PlayerAdded:Connect(function(plr)\n    plr.Kick()\nend)```",
                "Bro tip number 80:\nsuicide is the answer",
                "now you understand what that ominous entity was",
                "it was minecraft steve, he's turned your world into his, and now he wants to kill you",
                "wholesome 100",
                "cringe",
                "TABLE.",
                "Pufferfish Defense",
                "my mom",
                "I blew up",
                "my skin is rotting slowly",
                "{mention}",
                "seen that already",
                "I knew it.",
                "bye bye troller",
                "we don't need you",
                "I can track your location",
                "fuck",
                "HAHAHAHAHAHAH",
                "Congrats, your Reddit account has been successfully created",
                "you putrid fuck",
                "fortnite balls i'm gay",
                "thats not funny",
                "and i genuinely love this girl",
                "Oh My Fucking God Shut The Fuck Up You're So Annoying If I Wasn't A Bot I Would Immediately Block You It'd Be Pretty Awesome If I Wasn't One Anyways I Could Just Join Any Server And Bomb Each One Of Them With My Great Awesome 10/10 Commands But Guess I Can't Because Of You Yes That's Right You Are One Of The Biggest Obstacles I've Ever Bumped With In My Entire History But Anyways The Whole Point Of This Speech Was To Shut You The Fuck Up Please Get Out Of My Dms I Can't Handle It Anymore I Will Do Anything To Stop You Even Delete Myself From The Existance Of Discord So Now I'm Just Gonna Smash My Keyboard Until I'm Done With You SJDASFUIDASHUDIHASUIDFAHSKUALDOWRQWPRS 65 ttfgiootifgiotf  re uir ue      re7 r   r7eriue rei reirrrr  r r r rick sa9df a8 9san 7 47897472 YRYEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEER78QR@ L2l2  0 4l v l¬£¬ß30324-",
                "Bosom...?",
                "I NEED TO SUCK MAD TITTIES RN!",
                "i could kill you"
            ]
        }

        psFiles = data()[mongodatabase]['bot-data']['bot']['psfiles']
        psPasta = data()[mongodatabase]['bot-data']['bot']['pspasta']
        funnygifs = data()[mongodatabase]['bot-data']['bot']['funnygif']
        poopPhrases = data()[mongodatabase]['bot-data']['bot']['poop']
        dmPhrases = data()[mongodatabase]['bot-data']['bot']['dmphrases']

        filecount = data()[mongodatabase]['bot-data']['bot']['filecount'] || 0
        fs.writeFileSync('data.json', JSON.stringify(data()), () => { })

        await infoPost(`Finishing extra steps...`)

        await noblox.setCookie(process.env.ROBLOXCOOKIE).catch(() => { })
        emojiImages = await getEmojis().catch(() => { })
        console.log('emojis')
        if (!fs.existsSync('temp')) {
            fs.mkdirSync('temp')
        }
        await updateSlashCommands()
        changeStatus()
        save()
        statusInterval = setInterval(function () {
            changeStatus()
        }, 300000)
        saveInterval = setInterval(function () {
            save()
        }, 120000)
        console.log('all done, he\'s actually online now')
        await infoPost(`Reboot ${data()[mongodatabase]['bot-data']['bot']['reboots']} succeeded, he's up now`)

        var wakecount = String(data()[mongodatabase]['bot-data']['bot']['reboots'] + 1)
        var thmatch = wakecount.match(/[^1][1-3]$|^[1-3]$/)

        if (thmatch) {
            wakecount += ['st', 'nd', 'rd'][Number(thmatch[0][thmatch[0].length - 1]) - 1]
        } else {
            wakecount += 'th'
        }

        bot.guilds.cache.get('834431435704107018')?.channels.cache.get('947167169718923341')?.send(!stfu ? (testing ? 'raleigh is testing' : `this is the ${wakecount} time this happens`) : '').catch(() => { })

        bot.on('messageCreate', messageCallback)
        bot.on('guildCreate', guildCallback)
        bot.on('guildDelete', guildDeleteCallback)
        bot.on('interactionCreate', interactionCallback)
    })

    await bot.login(TOKEN)

    return bot
}